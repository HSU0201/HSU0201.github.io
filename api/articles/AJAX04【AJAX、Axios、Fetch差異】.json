{"title":"AJAX、Axios、Fetch差異","uid":"92da9106fb683f4d6b08c8fcca39f76e","slug":"AJAX04【AJAX、Axios、Fetch差異】","date":"2024-01-03T02:22:05.000Z","updated":"2024-02-04T04:44:55.265Z","comments":true,"path":"api/articles/AJAX04【AJAX、Axios、Fetch差異】.json","keywords":null,"cover":"https://raw.githubusercontent.com/HSU0201/images/16361bf98fcfc78c6e956fb9803010ed9a694dd0/ajax/W0xDTV4.png","content":"<h1 id=\"04【AJAX、Axios、Fetch差異】\"><a href=\"#04【AJAX、Axios、Fetch差異】\" class=\"headerlink\" title=\"04【AJAX、Axios、Fetch差異】\"></a>04【AJAX、Axios、Fetch差異】</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端開發中，與後端互動的重要途徑之一就是「請求」。<br>三種常見的網路請求方式：Ajax、Fetch、以及 axios。這些名詞都用來發送網路請求，但它們有不同的特點和使用方式。</p>\n<h2 id=\"1-Ajax-Asynchronous-JavaScript-And-XML\"><a href=\"#1-Ajax-Asynchronous-JavaScript-And-XML\" class=\"headerlink\" title=\"1. Ajax(Asynchronous JavaScript And XML)\"></a>1. Ajax(Asynchronous JavaScript And XML)</h2><p>AJAX (Asynchronous JavaScript and XML) 是一種在不重新加載整個網頁的情況下，通過後台發送 HTTP 請求和接收回應的技術。<br>特點:<br>實現局部刷新頁面，避免整個頁面的重新載入。</p>\n<p>XMLHttpRequest 是實作 Ajax 的一種方式，常被用來發送網路請求，目前較流行使用 json 的方式。</p>\n<p>利用 XMLHttpRequest 模組實作 Ajax。<br>若使用 JSON 要使用 <code>JSON.parse()</code> 將收到的 JSON 字串解析為 JavaScript 物件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">ajax</span>(<span class=\"params\">url</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> <span class=\"title class_\">XMLHttpRequest</span>();</span><br><span class=\"line\">  xhr.<span class=\"title function_\">open</span>(<span class=\"string\">&quot;get&quot;</span>, url, <span class=\"literal\">false</span>);</span><br><span class=\"line\">  xhr.<span class=\"property\">onreadystatechange</span> = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (xhr.<span class=\"property\">readyState</span> === <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (xhr.<span class=\"property\">status</span> === <span class=\"number\">200</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 1. 使用XMLHttpRequest 實作的方式■■■■■■■■■■■</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">info</span>(<span class=\"string\">&quot;響應結果&quot;</span>, xhr.<span class=\"property\">response</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 2. 使用JSON 實作的方式■■■■■■■■■■■■■■■■■■■■■</span></span><br><span class=\"line\">        <span class=\"comment\">// // 將收到的 JSON 字串解析為 JavaScript 物件</span></span><br><span class=\"line\">        <span class=\"comment\">// // responseText 是 XMLHttpRequest 物件的屬性之一，它用於獲取從伺服器返回的響應資料，以純文字字符串的形式表示。</span></span><br><span class=\"line\">        <span class=\"comment\">// const responseData = JSON.parse(xhr.responseText);</span></span><br><span class=\"line\">        <span class=\"comment\">// console.info(&quot;響應結果&quot;, responseData);</span></span><br><span class=\"line\">        <span class=\"comment\">// ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  xhr.<span class=\"title function_\">send</span>(<span class=\"literal\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">ajax</span>(<span class=\"string\">&quot;https://api.example.com/data&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果：</p>\n<p>這裡利用 XMLHttpRequest 模組實作了一個最簡單的 get 網路請求。<br>注意：我們使用這種方式實現網路請求時，如果請求內部又包含請求，以此循環，就會出現回調地獄，這也是一個詬病，後來才催生了更優雅的請求方式。</p>\n<h2 id=\"2-Axios\"><a href=\"#2-Axios\" class=\"headerlink\" title=\"2.Axios\"></a>2.Axios</h2><p>Axios: Vue 專案中廣泛應用的網路請求庫<br>Axios 是一個網路請求庫，隨著 Vue 框架的興起而在前端開發中廣泛應用。它並非一個思想或原生 API，而是一個封裝函式庫，專為處理網路請求而設計。以下是 Axios 的特點和使用情境：</p>\n<p><strong>特點：</strong></p>\n<ol>\n<li>基於 Promise 封裝：Axios 使用 Promise 對網路請求進行封裝，使得處理異步操作更加容易。</li>\n<li>跨環境支援：</li>\n</ol>\n<ul>\n<li>從瀏覽器中建立 XMLHttpRequests。</li>\n<li>從 Node.js 中建立 http 請求。</li>\n</ul>\n<ol start=\"3\">\n<li>Promise API 支援：使用 <strong>Promise 作為異步操作的標準</strong>，讓程式碼更具可讀性。</li>\n<li>攔截請求和回應：提供攔截器，可以在發送請求或接收回應時進行攔截處理。</li>\n<li>數據轉換：</li>\n</ol>\n<ul>\n<li><strong>轉換請求數據</strong>：自動將請求數據轉換為特定格式，例如 JSON。</li>\n<li><strong>轉換回應數據</strong>：自動將回應數據轉換為 JavaScript 對象。</li>\n</ul>\n<ol start=\"6\">\n<li><strong>取消請求</strong>：提供取消請求的機制，避免不必要的請求發送。</li>\n<li>自動轉換 JSON 數據：在發送和接收過程中自動處理 JSON 格式的數據。</li>\n<li>客戶端支援防禦 XSRF：提供機制防禦跨站請求偽造（XSRF）攻擊。</li>\n</ol>\n<p><strong>使用情境：</strong></p>\n<ul>\n<li>在 Vue 專案中，絕大多數的網路請求是透過 Axios 發起的。</li>\n<li>適用於各種網路請求場景，包括 GET、POST 等。</li>\n<li>由於提供了豐富的功能和良好的 API 設計，使得在處理複雜的網路請求時更加方便。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總的來說，Axios 不僅是 XMLHttpRequest（XHR）的二次封裝，也是 Ajax 思想的延伸。在實際應用中，Axios 為前端開發者提供了一個強大而便捷的工具，使得處理網路請求變得更加優雅和有效。</p></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">axios</span><br><span class=\"line\">  .<span class=\"title function_\">get</span>(<span class=\"string\">&quot;https://api.example.com/data&quot;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(response.<span class=\"property\">data</span>);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"keyword\">function</span> (<span class=\"params\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-Fetch\"><a href=\"#3-Fetch\" class=\"headerlink\" title=\"3.Fetch\"></a>3.Fetch</h2><p><strong>定義:</strong> Fetch 是 ES6 引入的 API，基於 Promise 物件，取代了 XMLHttpRequest，提供更簡潔的使用方式。</p>\n<p><strong>特點:</strong></p>\n<ul>\n<li><strong>支援 Promise</strong>，使得處理異步請求更加方便，不使用回呼函數。</li>\n<li><strong>模組化設計</strong>，如 Response、Request 等物件分散開來，更友善。</li>\n<li>透過資料流物件處理數據，提高網站效能。</li>\n</ul>\n<p><strong>缺點</strong><br>它不自動傳遞或接收 cookies，並且不能取消請求，這些功能需要額外的處理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;https://api.example.com/data&quot;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">response</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">data</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(data);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"keyword\">function</span> (<span class=\"params\">error</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>輸出結果：</p>\n<p>上段程式碼利用 Fetch 發送了一個最簡單的 get 請求，其中最重要的特點之一就是採用了.then 鏈式呼叫的方式處理結果，這樣不僅利於程式碼的可讀，而且也解決了回呼地獄的問題。</p>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><ul>\n<li>Ajax、Fetch、axios 三者之間的關係可以用一張圖來清楚的表示，如圖：</li>\n</ul>\n<p><img src=\"https://github.com/HSU0201/images/blob/main/ajax/%E8%9E%A2%E5%B9%95%E6%93%B7%E5%8F%96%E7%95%AB%E9%9D%A2%202024-01-23%20195619.png?raw=true\" alt=\"三者之間的關係\"></p>\n<table>\n<thead>\n<tr>\n<th>功能&#x2F;特性</th>\n<th>AJAX</th>\n<th>Axios</th>\n<th>Fetch</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>特點</td>\n<td>一種技術統稱，主要利用 XHR 實現網路請求</td>\n<td>一個封裝庫，基於 XHR 封裝</td>\n<td>具體 API，基於 Promise，實現網路請求</td>\n</tr>\n<tr>\n<td>Promise</td>\n<td>否</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>瀏覽器支援</td>\n<td>原生</td>\n<td>需要引入庫</td>\n<td>部分現代瀏覽器</td>\n</tr>\n<tr>\n<td>API 簡潔性</td>\n<td>較複雜</td>\n<td>簡潔且易於使用</td>\n<td>簡潔且易於使用</td>\n</tr>\n<tr>\n<td>攔截器</td>\n<td>不支援</td>\n<td>支援</td>\n<td>不支援</td>\n</tr>\n<tr>\n<td>請求取消</td>\n<td>不支援</td>\n<td>支援</td>\n<td>不支援</td>\n</tr>\n<tr>\n<td>跨域請求</td>\n<td>需要額外處理</td>\n<td>需要額外處理</td>\n<td>與瀏覽器的 CORS 機制整合</td>\n</tr>\n</tbody></table>\n","feature":null,"text":"04【AJAX、Axios、Fetch差異】前言在前端開發中，與後端互動的重要途徑之一就是「請求」。三種常見的網路請求方式：Ajax、Fetch、以及 axio...","permalink":"/post/AJAX04【AJAX、Axios、Fetch差異】","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"AJAX","slug":"AJAX","count":4,"path":"api/categories/AJAX.json"}],"tags":[{"name":"AJAX","slug":"AJAX","count":4,"path":"api/tags/AJAX.json"},{"name":"桃園資展筆記","slug":"桃園資展筆記","count":30,"path":"api/tags/桃園資展筆記.json"},{"name":"Axios","slug":"Axios","count":1,"path":"api/tags/Axios.json"},{"name":"Fetch","slug":"Fetch","count":1,"path":"api/tags/Fetch.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#04%E3%80%90AJAX%E3%80%81Axios%E3%80%81Fetch%E5%B7%AE%E7%95%B0%E3%80%91\"><span class=\"toc-text\">04【AJAX、Axios、Fetch差異】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Ajax-Asynchronous-JavaScript-And-XML\"><span class=\"toc-text\">1. Ajax(Asynchronous JavaScript And XML)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Axios\"><span class=\"toc-text\">2.Axios</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Fetch\"><span class=\"toc-text\">3.Fetch</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B8%BD%E7%B5%90\"><span class=\"toc-text\">總結</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"內建-緩衝區模組 ( Buffer )","uid":"b4f37f72e1016ef379212405ddab2ded","slug":"NODEJS05 【內建-緩衝區模組 ( Buffer )】","date":"2024-01-05T11:30:05.000Z","updated":"2024-02-13T04:56:26.504Z","comments":true,"path":"api/articles/NODEJS05 【內建-緩衝區模組 ( Buffer )】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/node.js/what-is-npm.png?raw=true","text":"05 【內建-緩衝區模組 ( Buffer )】概念 Buffer 是一個類似於陣列的 物件 ，用於表示固定長度的字節序列 Buffer 本質是一段記憶體空間，...","permalink":"/post/NODEJS05 【內建-緩衝區模組 ( Buffer )】","photos":[],"count_time":{"symbolsCount":"1.7k","symbolsTime":"2 mins."},"categories":[{"name":"node.js","slug":"node-js","count":6,"path":"api/categories/node-js.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":30,"path":"api/tags/桃園資展筆記.json"},{"name":"node.js","slug":"node-js","count":8,"path":"api/tags/node-js.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"AJAX 概述和基本使用","uid":"9a2aa4a955d2779579e86c05e126bfd4","slug":"AJAX01 【AJAX概述和基本使用】","date":"2024-01-02T01:52:05.000Z","updated":"2024-01-30T11:45:11.793Z","comments":true,"path":"api/articles/AJAX01 【AJAX概述和基本使用】.json","keywords":null,"cover":"https://raw.githubusercontent.com/HSU0201/images/16361bf98fcfc78c6e956fb9803010ed9a694dd0/ajax/W0xDTV4.png","text":"01 【AJAX 概述和基本使用】1.AJAX 簡介AJAX 全稱為 Asynchronous JavaScript And XML，是一種用於在網頁上以非同步...","permalink":"/post/AJAX01 【AJAX概述和基本使用】","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"AJAX","slug":"AJAX","count":4,"path":"api/categories/AJAX.json"}],"tags":[{"name":"AJAX","slug":"AJAX","count":4,"path":"api/tags/AJAX.json"},{"name":"jQuery","slug":"jQuery","count":3,"path":"api/tags/jQuery.json"},{"name":"桃園資展筆記","slug":"桃園資展筆記","count":30,"path":"api/tags/桃園資展筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}