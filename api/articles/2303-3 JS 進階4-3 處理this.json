{"title":"JavaScript 進階 - 第4天","uid":"956114e1932534f6adc2e3848138c40e","slug":"2303-3 JS 進階4-3 處理this","date":"2023-04-01T01:22:08.000Z","updated":"2023-04-13T09:15:36.220Z","comments":true,"path":"api/articles/2303-3 JS 進階4-3 處理this.json","keywords":null,"cover":null,"content":"<h1 id=\"處理this\"><a href=\"#處理this\" class=\"headerlink\" title=\"處理this\"></a>處理this</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>瞭解函數中 this 在不同場景下的預設值，知道動態指定函數 this 值的方法。</p></blockquote>\n<p><code>this</code> 是 JavaScript 最具“魅惑”的知識點，不同的應用場合 <code>this</code> 的取值可能會有意想不到的結果，在此我們對以往學習過的關於【 <code>this</code> 預設的取值】情況進行歸納和總結。</p>\n<h2 id=\"普通函數\"><a href=\"#普通函數\" class=\"headerlink\" title=\"普通函數\"></a>普通函數</h2><p><strong>普通函數</strong>的調用方式決定了 <code>this</code> 的值，即【誰調用 <code>this</code> 的值指向誰】，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this)  \n  &#125;\n  &#x2F;&#x2F; 函數運算式\n  const sayHello &#x3D; function () &#123;\n    console.log(this)\n  &#125;\n  &#x2F;&#x2F; 函數的調用方式決定了 this 的值\n  sayHi() &#x2F;&#x2F; window\n  window.sayHi()\n  \n\n&#x2F;&#x2F; 普通對象\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    walk: function () &#123;\n      console.log(this)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 動態為 user 添加方法\n  user.sayHi &#x3D; sayHi\n  uesr.sayHello &#x3D; sayHello\n  &#x2F;&#x2F; 函式呼叫方式，決定了 this 的值\n  user.sayHi()\n  user.sayHello()\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>注： 普通函數沒有明確調用者時 <code>this</code> 值為 <code>window</code>，嚴格模式下沒有調用者時 <code>this</code> 的值為 <code>undefined</code>。</p>\n<h2 id=\"箭頭函數\"><a href=\"#箭頭函數\" class=\"headerlink\" title=\"箭頭函數\"></a>箭頭函數</h2><p><strong>箭頭函數</strong>中的 <code>this</code> 與普通函數完全不同，也不受調用方式的影響，事實上箭頭函數中並不存在 <code>this</code> ！箭頭函數中訪問的 <code>this</code> 不過是箭頭函數所在作用域的 <code>this</code> 變數。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n    \n  console.log(this) &#x2F;&#x2F; 此處為 window\n  &#x2F;&#x2F; 箭頭函數\n  const sayHi &#x3D; function() &#123;\n    console.log(this) &#x2F;&#x2F; 該箭頭函數中的 this 為函式宣告環境中 this 一致\n  &#125;\n  &#x2F;&#x2F; 普通對象\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    &#x2F;&#x2F; 該箭頭函數中的 this 為函式宣告環境中 this 一致\n    walk: () &#x3D;&gt; &#123;\n      console.log(this)\n    &#125;,\n    \n    sleep: function () &#123;\n      let str &#x3D; &#39;hello&#39;\n      console.log(this)\n      let fn &#x3D; () &#x3D;&gt; &#123;\n        console.log(str)\n        console.log(this) &#x2F;&#x2F; 該箭頭函數中的 this 與 sleep 中的 this 一致\n      &#125;\n      &#x2F;&#x2F; 調用箭頭函數\n      fn();\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 動態添加方法\n  user.sayHi &#x3D; sayHi\n  \n  &#x2F;&#x2F; 函式呼叫\n  user.sayHi()\n  user.sleep()\n  user.walk()\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>在開發中【使用箭頭函數前需要考慮函數中 <code>this</code> 的值】，<strong>事件回呼函數</strong>使用箭頭函數時，<code>this</code> 為全域的 <code>window</code>，因此DOM事件回呼函數不推薦使用箭頭函數，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; DOM 節點\n  const btn &#x3D; document.querySelector(&#39;.btn&#39;)\n  &#x2F;&#x2F; 箭頭函數 此時 this 指向了 window\n  btn.addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;\n    console.log(this)\n  &#125;)\n  &#x2F;&#x2F; 普通函數 此時 this 指向了 DOM 對象\n  btn.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(this)\n  &#125;)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>同樣由於箭頭函數 <code>this</code> 的原因，<strong>基於原型的物件導向也不推薦採用箭頭函數</strong>，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n  &#125;\n  &#x2F;&#x2F; 原型對像上添加了箭頭函數\n  Person.prototype.walk &#x3D; () &#x3D;&gt; &#123;\n    console.log(&#39;人都要走路...&#39;)\n    console.log(this); &#x2F;&#x2F; window\n  &#125;\n  const p1 &#x3D; new Person()\n  p1.walk()\n&lt;&#x2F;script&gt;</code></pre>\n\n<h2 id=\"改變this指向\"><a href=\"#改變this指向\" class=\"headerlink\" title=\"改變this指向\"></a>改變this指向</h2><p>以上歸納了普通函數和箭頭函數中關於 <code>this</code> 預設值的情形，不僅如此 JavaScript 中還允許指定函數中 <code>this</code> 的指向，有 3 個方法可以動態指定普通函數中 <code>this</code> 的指向：</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call\"></a>call</h3><p>使用 <code>call</code> 方法調用函數，同時指定函數中 <code>this</code> 的值</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>語法<br>fun.call(thisArg, arg1, arg2, …)</p></blockquote>\n<ul>\n<li>thisArg ：在 fun 函數 運行時指定 的 this 值</li>\n<li>arg1 arg2 ：傳遞 的其他參數</li>\n<li>返回 值就是函數的返回值，因為它就是調用 函數</li>\n</ul>\n<p>使用方法如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this);\n  &#125;\n\n  let user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student &#x3D; &#123;\n    name: &#39;小紅&#39;,\n    age: 16\n  &#125;\n\n  &#x2F;&#x2F; 調用函數並指定 this 的值\n  sayHi.call(user); &#x2F;&#x2F; this 值為 user\n  sayHi.call(student); &#x2F;&#x2F; this 值為 student\n\n  &#x2F;&#x2F; 求和函數\n  function counter(x, y) &#123;\n    return x + y;\n  &#125;\n\n  &#x2F;&#x2F; 調用 counter 函數，並傳入參數\n  let result &#x3D; counter.call(null, 5, 10);\n  console.log(result);\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li><code>call</code> 方法能夠在調用函數的同時指定 <code>this</code> 的值</li>\n<li>使用 <code>call</code> 方法調用函數時，第1個參數為 <code>this</code> 指定的值</li>\n<li><code>call</code> 方法的其餘參數會依次自動傳入函數做為函數的參數</li>\n</ol>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><p>使用 <code>call</code> 方法<strong>調用函數</strong>，同時指定函數中 <code>this</code> 的值</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>語法<br>fun.apply(thisArg, [argsArray])</p></blockquote>\n<ul>\n<li>thisArg ：在 fun 函數運行時指定的 this 值</li>\n<li>argsArray ：傳遞的值，必須包含在 <strong>數組</strong> 裡面</li>\n<li>返回 值就是函數的返回值，因為它就是調用 函數</li>\n<li>因此 apply 主要跟數組有關係，比如使用 Math.max() 求數組的最大 值</li>\n</ul>\n<p>使用方法如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n\n  let user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student &#x3D; &#123;\n    name: &#39;小紅&#39;,\n    age: 16\n  &#125;\n\n  &#x2F;&#x2F; 調用函數並指定 this 的值\n  sayHi.apply(user) &#x2F;&#x2F; this 值為 user\n  sayHi.apply(student) &#x2F;&#x2F; this 值為 student\n\n  &#x2F;&#x2F; 求和函數\n  function counter(x, y) &#123;\n    return x + y\n  &#125;\n  &#x2F;&#x2F; 調用 counter 函數，並傳入參數\n  let result &#x3D; counter.apply(null, [5, 10])\n  console.log(result)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li><code>apply</code> 方法能夠在調用函數的同時指定 <code>this</code> 的值</li>\n<li>使用 <code>apply</code> 方法調用函數時，第1個參數為 <code>this</code> 指定的值</li>\n<li><code>apply</code> 方法第2個參數為陣列，陣列的單元值依次自動傳入函數做為函數的參數</li>\n</ol>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><p><code>bind</code> 方法並<strong>不會調用函數</strong>，而是創建一個指定了 <code>this</code> 值的新函數</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>語法<br>fun.bind(thisArg, arg1, arg2, …)</p></blockquote>\n<ul>\n<li>thisArg ：在 fun 函数运行时指定的 this 值</li>\n<li>arg1 arg2 ：传递的其他参数</li>\n<li>返回由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数</li>\n<li>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind 比如改变定时器内部的this 指向</li>\n</ul>\n<p>使用方法如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n  let user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n  &#x2F;&#x2F; 調用 bind 指定 this 的值\n  let sayHello &#x3D; sayHi.bind(user);\n  &#x2F;&#x2F; 調用使用 bind 創建的新函數\n  sayHello()\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>注：<code>bind</code> 方法創建新的函數，與原函數的唯一的變化是改變了 <code>this</code> 的值。</p>\n<h3 id=\"call-apply-bind-總結\"><a href=\"#call-apply-bind-總結\" class=\"headerlink\" title=\"call apply bind 總結\"></a>call apply bind 總結</h3><ul>\n<li><p>相同點 :</p>\n<ul>\n<li>都可以改變函數內部的 this 指向</li>\n</ul>\n</li>\n<li><p>區別點 :</p>\n<ul>\n<li>call 和 apply 會調用函數 , 並且改變函數內部 this 指向</li>\n<li>call 和 apply 傳遞的參數不一樣 , call 傳遞參數 aru1, aru2.. 形式 apply 必須數組形式 arg</li>\n<li><strong>bind 不會調用函數 , 可以改變函數內部 this 指向</strong></li>\n</ul>\n</li>\n<li><p>主要應用場景 :</p>\n<ul>\n<li>call 調用函數並且可以傳遞參數</li>\n<li>apply 經常跟數組有關係 . 比如借助於數學對象實現數組最大值最小值</li>\n<li><strong>bind 不調用函數 但是還想改變 this 指向 . 比如改變定時器內部的 this 指向</strong></li>\n</ul>\n</li>\n</ul>\n","feature":null,"text":"處理this 瞭解函數中 this 在不同場景下的預設值，知道動態指定函數 this 值的方法。 this 是 JavaScript 最具“魅惑”的知識點，不同的應用場合 this 的取值可能會有意想不到的結果，在此我們對以往學習過的關於【 this 預設的取值】情況進行歸納和總...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%95%E7%90%86this\"><span class=\"toc-text\">處理this</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">普通函數</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E9%A0%AD%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">箭頭函數</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%94%B9%E8%AE%8Athis%E6%8C%87%E5%90%91\"><span class=\"toc-text\">改變this指向</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call\"><span class=\"toc-text\">call</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#apply\"><span class=\"toc-text\">apply</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#bind\"><span class=\"toc-text\">bind</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#call-apply-bind-%E7%B8%BD%E7%B5%90\"><span class=\"toc-text\">call apply bind 總結</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaScript 進階 - 第4天","uid":"956114e1932534f6adc2e3848138c40e","slug":"2303-3 JS 進階4-2 異常處理","date":"2023-04-01T01:22:08.000Z","updated":"2023-04-13T09:16:22.204Z","comments":true,"path":"api/articles/2303-3 JS 進階4-2 異常處理.json","keywords":null,"cover":null,"text":"異常處理 瞭解 JavaScript 中程式異常處理的方法，提升代碼運行的健壯性。 throw異常處理是指預估代碼執行過程中可能發生的錯誤，然後最大程度的避免錯誤的發生導致整個程式無法繼續運行 總結： throw 拋出異常資訊，程式也會終止執行 throw 後面跟的是錯誤提示資訊...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"JavaScript 進階 - 第4天","uid":"956114e1932534f6adc2e3848138c40e","slug":"2303-3 JS 進階4-4 防抖節流","date":"2023-04-01T01:22:08.000Z","updated":"2024-01-28T04:26:03.749Z","comments":true,"path":"api/articles/2303-3 JS 進階4-4 防抖節流.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/46a3e3ddbdade37866e3aaf24a04bbe6.jpg?raw=true","text":"防抖節流節流 和防抖的區別是？ 防抖（debounce） 所謂防抖，就是指觸發事件後在 n 秒內函數只能執行一次(最後一次)，如果在 n 秒內又觸發了事件，則會重新計算函數執行時間 節流（throttle） 所謂節流，就是指連續觸發事件但是在 n 秒中只執行一次函數(不會被打斷)...","link":"","photos":[],"count_time":{"symbolsCount":266,"symbolsTime":"1 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}