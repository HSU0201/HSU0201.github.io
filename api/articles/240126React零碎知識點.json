{"title":"240126React零碎知識點","uid":"226913a9ccc4a580478e5d60de981fd1","slug":"240126React零碎知識點","date":"2024-01-27T11:32:36.000Z","updated":"2024-01-28T04:24:37.264Z","comments":true,"path":"api/articles/240126React零碎知識點.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/734257355c559d394eb900a70ea03a08.jpg?raw=true","content":"<h1 id=\"渲染（Rendering）\"><a href=\"#渲染（Rendering）\" class=\"headerlink\" title=\"渲染（Rendering）\"></a>渲染（Rendering）</h1><p>在軟體開發和電腦圖形領域中，”渲染” 指的是將資料或程式碼轉換為可視化的形式或格式的過程。在不同的上下文中，”渲染” 的含義可能有所不同。</p>\n<ul>\n<li><p>**瀏覽器中的渲染引擎(Rendering Engine)**：瀏覽器的渲染引擎是負責將網頁的 HTML、CSS 和 JavaScript 等前端資源轉換為使用者能夠閱讀和互動的可視化內容的核心部分。常見的瀏覽器渲染引擎包括 WebKit（Chrome 和 Safari 使用的），Gecko（Firefox 使用的），以及 Trident（舊版的 Internet Explorer 使用的）。</p>\n</li>\n<li><p>**React 中的渲染(Render)**：在 React 中，”渲染” 是指更新虛擬 DOM 的過程，以及將虛擬 DOM 轉換為真實 DOM 的過程。React 使用虛擬 DOM 來提高效能，當應用的狀態（State）發生變化時，React 會重新渲染虛擬 DOM，然後透過比對虛擬 DOM 和實際 DOM 的變化，最小化更新真實 DOM，從而提高應用的效能。</p>\n</li>\n<li><p><strong>State 狀態</strong>：在 React 應用中，”State” 是指描述應用當前狀態的資料。當 State 發生變化時，React 會重新渲染相應的元件，從而更新應用的 UI。</p>\n</li>\n<li><p>**CSR (Client-Side Rendering)**：客戶端渲染是指在網頁應用中，所有的渲染運算都在用戶的瀏覽器中完成，而不是在伺服器端完成。這意味著當用戶與應用互動時，不需要每次都向伺服器發送請求，從而提高了應用的效能和反應速度。</p>\n</li>\n</ul>\n<p>在開發應用程序時，了解渲染的過程和原理對於優化應用的性能和提高用戶體驗非常重要。</p>\n<h1 id=\"Immutability-不可改變性\"><a href=\"#Immutability-不可改變性\" class=\"headerlink\" title=\"Immutability 不可改變性\"></a>Immutability 不可改變性</h1><p>在 React 中，所有的狀態（state）都是不可改變的（immutable）。一旦某個值成為狀態後，它的值將無法直接改變。即使是物件的屬性值也要視為被凍結（freeze）或唯讀（read-only）不可改變。任何對狀態的改變都要透過 setState 方法傳入一個全新的值或物件。</p>\n<ul>\n<li><strong>在 React 中的應用</strong>：React 鼓勵開發者使用不可改變性來管理組件的狀態。這意味著在更新狀態時，應該創建新的物件，而不是直接修改現有的狀態。這樣可以幫助 React 更有效地追蹤和處理組件的變化，並且有助於避免一些意外的行為。</li>\n</ul>\n<p>註：<code>immutable</code> 與 <code>unchangeable</code> 同義，都是不可改變的意思。</p>\n<p>註：實際上，對於元件而言，它接收到的 props（屬性）也是不可變的，不過較精確的說法是唯讀（read-only）的純函式（pure function）特性。</p>\n<h1 id=\"Pure-Function（純函式）\"><a href=\"#Pure-Function（純函式）\" class=\"headerlink\" title=\"Pure Function（純函式）\"></a>Pure Function（純函式）</h1><p>在程式設計中，一個函式如果滿足以下兩個條件，就可以被稱為純函式：</p>\n<ol>\n<li><strong>相同的輸入總是產生相同的輸出</strong>：函式的執行不依賴於程式的狀態，而是只依賴於輸入參數。</li>\n<li><strong>函式沒有副作用</strong>：函式的執行過程中不會修改外部的狀態，也不會產生其他可觀察到的影響，比如修改全域變數或發出網絡請求等。</li>\n</ol>\n<p>在 React 中，純函式通常用於渲染 UI 組件和處理資料。</p>\n<h1 id=\"Side-Effect（副作用）\"><a href=\"#Side-Effect（副作用）\" class=\"headerlink\" title=\"Side Effect（副作用）\"></a>Side Effect（副作用）</h1><p>副作用是指函式執行過程中，除了返回值之外，還對函式外部的狀態產生了影響的行為。副作用可能包括但不限於：</p>\n<ul>\n<li>修改全域變數或外部狀態</li>\n<li>發送網絡請求</li>\n<li>修改 DOM</li>\n<li>改變了參數本身</li>\n</ul>\n<p>在 React 開發中，要盡量減少副作用的使用，特別是在純 UI 組件中。這有助於減少代碼的不可預測性，並使程式更容易理解和測試。通常情況下，React 應用程式的狀態和資料流都應該被視為不可改變的，以確保組件的行為是可預測的並且易於管理。</p>\n","feature":null,"text":"渲染（Rendering）在軟體開發和電腦圖形領域中，”渲染” 指的是將資料或程式碼轉換為可視化的形式或格式的過程。在不同的上下文中，”渲染” 的含義可能有所不...","permalink":"/post/240126React零碎知識點","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":4,"path":"api/categories/React.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%EF%BC%88Rendering%EF%BC%89\"><span class=\"toc-text\">渲染（Rendering）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Immutability-%E4%B8%8D%E5%8F%AF%E6%94%B9%E8%AE%8A%E6%80%A7\"><span class=\"toc-text\">Immutability 不可改變性</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Pure-Function%EF%BC%88%E7%B4%94%E5%87%BD%E5%BC%8F%EF%BC%89\"><span class=\"toc-text\">Pure Function（純函式）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Side-Effect%EF%BC%88%E5%89%AF%E4%BD%9C%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">Side Effect（副作用）</span></a></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"01 【Sass的安装使用】","date":"2024-02-06T04:11:45.933Z","updated":"2024-02-06T04:07:46.165Z","comments":true,"path":"api/articles/01 【Sass的安装使用】.json","keywords":null,"cover":[],"text":"01 【Sass 的安裝使用】1.介紹1.1 什麼是 CSS 預處理技術？CSS 預處理器是一種工具或語言，它們擴展了 CSS 的功能，讓開發者可以使用變量、嵌...","permalink":"/post/01 【Sass的安装使用】","photos":[],"count_time":{"symbolsCount":"9.5k","symbolsTime":"9 mins."},"categories":[],"tags":[],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"240125React零碎知識點","uid":"2c4df57117660657820746cd0823ec89","slug":"240125React零碎知識點","date":"2024-01-25T12:35:16.000Z","updated":"2024-01-28T04:24:31.123Z","comments":true,"path":"api/articles/240125React零碎知識點.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/734257355c559d394eb900a70ea03a08.jpg?raw=true","text":"在 React 應用程式部署前的檔案和資料夾清理在 React 應用程式的開發過程中，有一些檔案和資料夾是開發時使用的，但在最終的發布版本中並不需要包含。在進行...","permalink":"/post/240125React零碎知識點","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":4,"path":"api/categories/React.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}