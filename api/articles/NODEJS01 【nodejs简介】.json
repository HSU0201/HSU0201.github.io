{"title":"nodejs 簡介","uid":"977c23653e58c4b66e13f0c68d29b569","slug":"NODEJS01 【nodejs简介】","date":"2024-01-05T11:30:05.000Z","updated":"2024-02-13T04:56:26.504Z","comments":true,"path":"api/articles/NODEJS01 【nodejs简介】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/3050a56ba33ff757c6fa4872a4a672f2.jpg?raw=true","content":"<h1 id=\"01-【nodejs-簡介】\"><a href=\"#01-【nodejs-簡介】\" class=\"headerlink\" title=\"01 【nodejs 簡介】\"></a>01 【nodejs 簡介】</h1><p>1、Node.js 使用 JavaScript 語言開發伺服器端應用，是一個開源的、跨平台的 JavaScript 運行環境。</p>\n<p>2、實現了前後端的語法統一，<strong>有利於和前端代碼整合</strong>，甚至共用部分代碼。</p>\n<p>比如說，針對API返回的各種字段，前後端都必須要做校驗。此時，如果用 Node.js 來做後臺開發的話，前後端可以共用校驗的代碼。</p>\n<p>3、Node.js 性能高、生態系統活躍，提供了大量的開源庫。</p>\n<p>4、Jeff Atwood（<a href=\"https://stackoverflow.com/\">Stack Overflow</a> 網站的聯合創始人） 在 2007 年提出了著名的 Atwood 定律：<strong>任何能夠用 JavaScript 實現的應用系統，最終都必將用 JavaScript 實現</strong>。</p>\n<h2 id=\"1-前言\"><a href=\"#1-前言\" class=\"headerlink\" title=\"1.前言\"></a>1.前言</h2><p>當今，許多網際網路公司都在採用 Node.js，因其能夠提供出色的性能和效率。Node.js 以其獨特的特性，如單線程和非阻塞的 IO 操作，<strong>使得高性能成為可能</strong>。此外，現今流行的 Web 開發方式是<strong>前後端分離</strong>(即前端和後端開發者各自在自己喜愛的開發環境中進行獨立開發，通過 HTTP 或 RPC 等方式進行資料和流程的互動)。在這種模式下，Node.js 的作用尤為關鍵，它讓開發過程更加高效，因此受到眾多網際網路公司的青睞。</p>\n<p><a href=\"https://cloud.tencent.com/developer/article/1979507\"><strong>DEEP DIVE</strong>-HTTP 和 RPC 的區別</a><br><a href=\"https://aws.amazon.com/tw/compare/the-difference-between-rpc-and-rest/\"><strong>DEEP DIVE</strong>-RPC 與 REST 之間有什麼區別？</a></p>\n<h2 id=\"2-Node-js-是什麼？\"><a href=\"#2-Node-js-是什麼？\" class=\"headerlink\" title=\"2.Node.js 是什麼？\"></a>2.Node.js 是什麼？</h2><h3 id=\"2-1-官方定義\"><a href=\"#2-1-官方定義\" class=\"headerlink\" title=\"2.1 官方定義\"></a>2.1 官方定義</h3><p><a href=\"https://nodejs.org/en/learn/getting-started/introduction-to-nodejs\">Node.js</a> 是一個基於 <strong>Chrome V8 引擎</strong>的 JavaScript 運行時環境，用於在服務器端執行 JavaScript 代碼。它採用了<strong>事件驅動</strong>、<strong>非阻塞 I&#x2F;O 的模型</strong>，這使得它特別適合於處理<strong>高效率</strong>和<strong>低延遲</strong>的應用程序，特別是在處理大量並發請求時。Node.js 可以用於開發各種後端應用程序，包括 Web 應用、API 服務、即時通訊應用、<strong>數據庫管理</strong>等。此外，它還可以用於構建前端開發工具，跨平台應用程序開發等。Node.js 的包管理工具 npm 是全球最大的開源庫生態系統。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Node.js 不是一門語言，也不是 JavaScript 的框架，也不是像 Nginx 一樣的 Web 伺服器 ，<strong>Node.js 是 JavaScript 在伺服器端的執行環境（平臺）</strong>。</p></blockquote>\n<h3 id=\"2-2-Node-js-的組成\"><a href=\"#2-2-Node-js-的組成\" class=\"headerlink\" title=\"2.2 Node.js 的組成\"></a>2.2 Node.js 的組成</h3><p><strong>在 Node.js 裏執行 JavaScript，跟在 Chrome 裏執行 JavaScript 有什麼不同？</strong></p>\n<p>Node.js 和在瀏覽器中運行 JavaScript 有著不同的執行環境和可用的 API。雖然它們都使用<strong>相同的 JavaScript 引擎</strong>，但 Node.js 環境中<strong>沒有瀏覽器相關的 API</strong>，取而代之的是一些<strong>針對伺服器端開發的 API</strong>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>簡而言之，Node.js 讓開發者可以使用 JavaScript 控制整個計算機，而不僅僅是瀏覽器。</p></blockquote>\n<p>在 JavaScript 中，通常由三部分組成：</p>\n<ul>\n<li>ECMAScript：語言的核心部分，定義了語法和基本對象。</li>\n<li>DOM：文檔對象模型，提供了操作 HTML 和 XML 文檔的方法和API。</li>\n<li>BOM：瀏覽器對象模型，提供了與瀏覽器交互的方法和API。</li>\n</ul>\n<p>而 Node.js 的組成則包括：</p>\n<ul>\n<li><strong>ECMAScript</strong>：Node.js 環境支持所有的 ECMAScript 語法。</li>\n<li><strong>Node 環境</strong>提供的<strong>附加 API</strong>，包括文件系統、網絡等伺服器端相關的 API。</li>\n</ul>\n<p>如下圖所示：</p>\n<p><img src=\"https://github.com/HSU0201/images/blob/main/node.js/bab95704bf2f5dd8e05236c74a98d487fafa6d41.png?raw=true\" alt=\"image-20221102140543274\"></p>\n<h3 id=\"2-3-小總結\"><a href=\"#2-3-小總結\" class=\"headerlink\" title=\"2.3 小總結\"></a>2.3 小總結</h3><ul>\n<li>Node 是一個伺服器端 JavaScript 直譯器</li>\n<li>Node.js 是一個基於 Chrome V8 引擎的 JavaScript 執行環境</li>\n<li>Node.js 使用了一個事件驅動、非阻塞式 I&#x2F;O 的模型，使其輕量又高效</li>\n<li>Node.js 的包管理器 npm，是全球最大的開源庫生態系統</li>\n<li>Node.js 是一門動態語言，執行在服務端的 Javascript</li>\n<li>Node.js 無法使用 BOM 與 DOM</li>\n</ul>\n<h2 id=\"3-Node-js-的應用\"><a href=\"#3-Node-js-的應用\" class=\"headerlink\" title=\"3.Node.js 的應用\"></a>3.Node.js 的應用</h2><p>Node.js 擁有強大的開發者社群，現在已經發展出比較成熟的技術體係，以及龐大的生態。它被廣泛地應用在 Web 服務、開發工作流、客戶端應用等諸多領域。其中，在 <strong>Web 服務</strong>領域，業界對 Node.js 的接受程度最高。</p>\n<h3 id=\"3-1-BFF-中間層\"><a href=\"#3-1-BFF-中間層\" class=\"headerlink\" title=\"3.1 BFF 中間層\"></a>3.1 BFF 中間層</h3><p>BFF，即 Backend For Frontend（服務於前端的後端）。玉伯在《<a href=\"https://mp.weixin.qq.com/s/IYddaaw2ps1wR2VT1dZWPg\">從前端技術進化到體驗科技</a>》這篇文章中點出了 BFF 層的概念：</p>\n<p><a href=\"https://medium.com/mobilepeople/backend-for-frontend-pattern-why-you-need-to-know-it-46f94ce420b0\"><strong>DEEP DIVE</strong>-Backend for frontend (BFF) pattern— why do you need to know it?</a></p>\n<p>在 Web 服務中，引入了一個中間層，稱為 <strong>BFF（Backend For Frontend）</strong>，其目的是讓前端應用和後端服務之間建立清晰的分工和溝通模式。在這種架構下，後端使用 Java、C++ 等語言負責實現服務，提供基於領域模型的 HTTP&#x2F;RPC API，而前端則直接通過 BFF 層執行服務端的 HTTP&#x2F;RPC API，獲取資料並進行加工，以實現人機互動。這種開發模式尤其適合具有前端技術背景的全棧型工程師。透過 BFF，後端可以專注於業務邏輯的實現，而前端則負責處理頁面資料，這樣可以有效解耦領域模型和頁面資料的思維模式，使開發更加專業和高效。</p>\n<p>在這樣的服務架構中，需要搭建一個中間層，前端通過存取中間層的API來訪問後端服務。這種服務具有較低的伺服器運算需求，但對程序的靈活性要求較高。這正是 Node.js 的優勢所在。Node.js 非常適合用於構建 BFF 層，因為它能讓前端有<strong>能力自由組裝後臺資料</strong>，減少業務溝通成本，加快業務的叠代速度。同時，前端可以自主決定與後臺的通訊方式。對於後端和運維人員而言，使用 Node.js 作為 BFF 層也有諸多好處，包括<strong>提高安全性（不會暴露主伺服器）</strong>、降低主伺服器的複雜度等。</p>\n<h3 id=\"3-2-服務端渲染\"><a href=\"#3-2-服務端渲染\" class=\"headerlink\" title=\"3.2 服務端渲染\"></a>3.2 服務端渲染</h3><p><strong>客戶端渲染</strong>（CSR &#x2F; Client side render）：前端通過一大堆API請求資料，然後通過 JS 動態處理和生成頁面結構和展示。優點是<strong>前後端分離</strong>、減小伺服器壓力、局部重新整理。缺點是不利於 SEO（如果你的頁面然後通過 Ajax 異步獲取內容，抓取工具並不會等待異步完成後再行抓取頁面內容）、首屏渲染慢。</p>\n<p><strong>服務端渲染</strong>（SSR &#x2F; Server Side Render）：伺服器返回的不是API資料，而是一整個頁面（或整個樓層）的 HTML 字符串，瀏覽器直接顯示即可。也就是說，在伺服器端直接就渲染好了，然後一次性打包返回給前端。優點是<strong>有利於 SEO、首屏渲染很快</strong>。</p>\n<p><strong>總結： 搜索引擎優化 + 首屏速度優化 &#x3D; 服務端渲染</strong>。</p>\n<p>備註：這裏的「服務端渲染」只是讓 Node.js 做中間層，不會替代後端的。</p>\n<p>參考連結：</p>\n<ul>\n<li><a href=\"https://ssr.vuejs.org/zh/\">Vue 服務端渲染的概念</a></li>\n<li><a href=\"https://blog.csdn.net/u012036171/article/details/88833200\">https://blog.csdn.net/u012036171/article/details/88833200</a></li>\n<li><a href=\"https://juejin.im/post/5c068fd8f265da61524d2abc\">https://juejin.im/post/5c068fd8f265da61524d2abc</a></li>\n<li><a href=\"https://www.zhihu.com/question/59578433/answer/326694511\">方應杭</a></li>\n</ul>\n<h3 id=\"3-3-Node-js-在不同領域的應用十分廣泛，包括但不限於：\"><a href=\"#3-3-Node-js-在不同領域的應用十分廣泛，包括但不限於：\" class=\"headerlink\" title=\"3.3 Node.js 在不同領域的應用十分廣泛，包括但不限於：\"></a>3.3 Node.js 在不同領域的應用十分廣泛，包括但不限於：</h3><ul>\n<li><strong>開發伺服器端的應用程式</strong><ul>\n<li><em><strong>網路應用和 API 服務</strong></em>：例如，使用 Express，這是一個在 NodeJS 上構建的輕量級的 web 應用框架。許多公司（如 Uber，IBM 等）都使用 Express 和 NodeJS 來構建他們的後端服務。</li>\n<li><em><strong>即時服務</strong></em>：例如，使用 Socket.IO 來開發聊天應用或協同工具。Socket.IO 允許即時雙向通訊，並且在 NodeJS 環境中運行得非常好。</li>\n<li><em><strong>微服務架構</strong></em>：NodeJS 的事件驅動和非阻塞特性使得它成為微服務架構的理想選擇。例如，Netflix 和 Walmart 都使用 NodeJS 來開發他們的微服務。</li>\n</ul>\n</li>\n<li><strong>開發工具類應用程式</strong><ul>\n<li><em><strong>建構工具</strong></em>：例如，Webpack、Grunt、Gulp 這樣的前端自動化工具。這些工具可以用來進行任務如合併和壓縮 JavaScript 和 CSS 檔案，以及運行測試等。</li>\n<li><em><strong>套件管理工具</strong></em>：如 npm 和 yarn，他們用於 NodeJS 的模組管理，可以讓你輕易地分享和重用代碼。</li>\n<li><strong>編譯器&#x2F;轉譯器</strong>：例如，Babel 是一個 JavaScript 編譯器，主要用於將 ECMAScript 2015+ 版本的代碼轉換為向後兼容的 JavaScript 版本。</li>\n</ul>\n</li>\n<li><strong>開發桌面應用程式</strong><ul>\n<li><strong>跨平台桌面應用</strong>：使用 Electron.js，你可以使用 JavaScript，HTML，CSS 等網路技術來開發跨平台的桌面應用。知名的應用如 Visual Studio Code、Slack 用戶端、figma、Postman 都是使用 ElectronJS 建立的。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"3-4-總結\"><a href=\"#3-4-總結\" class=\"headerlink\" title=\"3.4 總結\"></a>3.4 總結</h3><p>或許，能用 Node.js 做的後臺應用，Java&#x2F;C++ 也能做；但是 Node.js 可以讓我們多一種選擇。</p>\n<p>短期來看，Node.js 很難像 Java&#x2F;C++ 那樣，成為後臺的主力開發語言。這並非是因為 Node.js 的性能問題，主要是因為，Node.js 還比較年輕，經驗積纍太少，框架的支持度不夠。在企業級服務 Node.js 敵不過 Java&#x2F;C++，所以目前只能搞「輕量級」；但未來可期。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>限製語言能力的不是語言本身，而是生態。</p></blockquote>\n<h2 id=\"4-Node-js-的特點\"><a href=\"#4-Node-js-的特點\" class=\"headerlink\" title=\"4.Node.js 的特點\"></a>4.Node.js 的特點</h2><ul>\n<li><p><strong>非阻塞I&#x2F;O模型</strong>：Node.js使用非阻塞、事件驅動的I&#x2F;O模型，使得在單個進程中可以處理大量的並發連接，提高了應用的性能和效率。</p>\n</li>\n<li><p><strong>基於事件驅動</strong>：Node.js基於事件驅動的設計，可以有效處理大量的I&#x2F;O操作，並且允許開發者編寫簡潔、易於理解的代碼。</p>\n</li>\n<li><p><strong>單線程</strong>：Node.js基於單線程事件循環模型，但通過事件驅動和非阻塞I&#x2F;O實現了高效率的並發處理，適合處理I&#x2F;O密集型的應用。</p>\n</li>\n<li><p><strong>高效的包管理工具</strong>：Node.js擁有強大的包管理工具npm，使得開發者可以方便地尋找、安裝、管理和共享JavaScript模組。</p>\n</li>\n</ul>\n<p>v跨平台：Node.js可以在多個平台上運行，包括Windows、Linux和macOS等，使得開發者可以更容易地開發和部署應用程序。</p>\n<ul>\n<li><p><strong>生態系統豐富</strong>：Node.js擁有龐大的生態系統，有許多第三方庫和框架可供開發者使用，可以快速構建各種類型的應用程序。</p>\n</li>\n<li><p><strong>前後端統一</strong>：Node.js可以用於開發後端服務器和前端應用程序，使得開發人員可以使用相同的語言和技術棧來開發整個應用。</p>\n</li>\n</ul>\n<p>Node.js 的性能和效率非常高。</p>\n<p>傳統的 Java 語言通常是用多線程模式來處理多個請求，每個請求都會啟動一個新的線程進行處理。這種方式有點像開很多個窗口，但每個窗口都只處理一個人的需求，當需求很多時，就需要開很多窗口，這樣會耗費很多資源。</p>\n<p>而 Node.js 則採用了一種不同的方式，它是用單一個線程在處理所有的請求，不需要開很多個窗口。這個線程主要是用來接收客戶端的請求，但不會立即處理它們，而是把它們交給一個「工人」去處理。這些「工人」就像是一群很快速的小精靈，他們負責處理各種不同的工作，比如去買東西、去郵局寄信等等。當這些工作完成後，他們會把結果交還給主線程，主線程再將結果返回給客戶端。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>這種方式讓 Node.js 可以處理大量的請求，因為主線程不會被阻塞，可以迅速地處理請求並返回結果，就像是一個很靈活的小組，能夠有效地應對各種不同的工作。</p></blockquote>\n<h2 id=\"5-使用-Node-js-時的劣勢\"><a href=\"#5-使用-Node-js-時的劣勢\" class=\"headerlink\" title=\"5.使用 Node.js 時的劣勢\"></a>5.使用 Node.js 時的劣勢</h2><ul>\n<li><p><strong>單線程限制</strong>：雖然單線程帶來了高效的事件驅動模型，但同時也意味著當一個阻塞操作發生時，整個應用程序的性能都會受到影響。這使得 Node.js 對於 CPU 密集型任務的處理能力較弱。</p>\n</li>\n<li><p><strong>較少的成熟庫</strong>：儘管 Node.js 生態系統非常豐富，但相對於一些成熟的後端框架（如Java或Python），某些領域的庫和工具可能會較少或不夠成熟。</p>\n</li>\n<li><p><strong>不適合長連接</strong>：由於 Node.js 的單線程模型，長時間的連接會阻塞事件循環，並且可能導致記憶體泄漏和性能問題。因此，對於需要長時間保持連接的應用場景（如即時通訊、遊戲伺服器），Node.js 可能不是最佳選擇。</p>\n</li>\n<li><p><strong>較高的學習曲線</strong>：對於一些開發者來說，特別是那些沒有經驗的開發者來說，理解並適應非阻塞、事件驅動的程式模型可能需要一些時間和努力。</p>\n</li>\n</ul>\n","feature":null,"text":"01 【nodejs 簡介】1、Node.js 使用 JavaScript 語言開發伺服器端應用，是一個開源的、跨平台的 JavaScript 運行環境。 2、...","permalink":"/post/NODEJS01 【nodejs简介】","photos":[],"count_time":{"symbolsCount":"5.2k","symbolsTime":"5 mins."},"categories":[{"name":"node.js","slug":"node-js","count":6,"path":"api/categories/node-js.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":30,"path":"api/tags/桃園資展筆記.json"},{"name":"node.js","slug":"node-js","count":8,"path":"api/tags/node-js.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#01-%E3%80%90nodejs-%E7%B0%A1%E4%BB%8B%E3%80%91\"><span class=\"toc-text\">01 【nodejs 簡介】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">1.前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Node-js-%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F\"><span class=\"toc-text\">2.Node.js 是什麼？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%98%E6%96%B9%E5%AE%9A%E7%BE%A9\"><span class=\"toc-text\">2.1 官方定義</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-Node-js-%E7%9A%84%E7%B5%84%E6%88%90\"><span class=\"toc-text\">2.2 Node.js 的組成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%B0%8F%E7%B8%BD%E7%B5%90\"><span class=\"toc-text\">2.3 小總結</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-Node-js-%E7%9A%84%E6%87%89%E7%94%A8\"><span class=\"toc-text\">3.Node.js 的應用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-BFF-%E4%B8%AD%E9%96%93%E5%B1%A4\"><span class=\"toc-text\">3.1 BFF 中間層</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%9C%8D%E5%8B%99%E7%AB%AF%E6%B8%B2%E6%9F%93\"><span class=\"toc-text\">3.2 服務端渲染</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-Node-js-%E5%9C%A8%E4%B8%8D%E5%90%8C%E9%A0%98%E5%9F%9F%E7%9A%84%E6%87%89%E7%94%A8%E5%8D%81%E5%88%86%E5%BB%A3%E6%B3%9B%EF%BC%8C%E5%8C%85%E6%8B%AC%E4%BD%86%E4%B8%8D%E9%99%90%E6%96%BC%EF%BC%9A\"><span class=\"toc-text\">3.3 Node.js 在不同領域的應用十分廣泛，包括但不限於：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E7%B8%BD%E7%B5%90\"><span class=\"toc-text\">3.4 總結</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-Node-js-%E7%9A%84%E7%89%B9%E9%BB%9E\"><span class=\"toc-text\">4.Node.js 的特點</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E4%BD%BF%E7%94%A8-Node-js-%E6%99%82%E7%9A%84%E5%8A%A3%E5%8B%A2\"><span class=\"toc-text\">5.使用 Node.js 時的劣勢</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"nodejs 開發環境安裝","uid":"080396e1adb14ff1690d9b335f3a1888","slug":"NODEJS02 【nodejs開發環境安裝】","date":"2024-01-05T11:30:05.000Z","updated":"2024-02-10T17:01:28.163Z","comments":true,"path":"api/articles/NODEJS02 【nodejs開發環境安裝】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/3050a56ba33ff757c6fa4872a4a672f2.jpg?raw=true","text":"02 【nodejs 開發環境安裝】1.版本介紹 在指令窗口中輸入 node -v 可以查看版本 0.x 完全不技術 ES6 4.x 部分支持 ES6 特性 5...","permalink":"/post/NODEJS02 【nodejs開發環境安裝】","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"node.js","slug":"node-js","count":6,"path":"api/categories/node-js.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":30,"path":"api/tags/桃園資展筆記.json"},{"name":"node.js","slug":"node-js","count":8,"path":"api/tags/node-js.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"內建-路徑處理模組 ( path )","uid":"1033bc320af8e95a06637ef625a7542f","slug":"NODEJS06 【內建-路徑處理模組 ( path ) 】","date":"2024-01-05T11:30:05.000Z","updated":"2024-02-10T10:48:36.190Z","comments":true,"path":"api/articles/NODEJS06 【內建-路徑處理模組 ( path ) 】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/node.js/what-is-npm.png?raw=true","text":"06 【內建-路徑處理模組 ( path ) 】1. path模組簡介路徑處理模組（path module）是 Node.js 核心模組之一，用於處理文件路徑和...","permalink":"/post/NODEJS06 【內建-路徑處理模組 ( path ) 】","photos":[],"count_time":{"symbolsCount":"8k","symbolsTime":"7 mins."},"categories":[{"name":"node.js","slug":"node-js","count":6,"path":"api/categories/node-js.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":30,"path":"api/tags/桃園資展筆記.json"},{"name":"node.js","slug":"node-js","count":8,"path":"api/tags/node-js.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}