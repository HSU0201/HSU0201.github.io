{"title":"240124React零碎知識點","uid":"6587c0dcefcdc69eda60933087e365f3","slug":"240124React零碎知識點","date":"2024-01-24T11:28:08.000Z","updated":"2024-01-27T11:30:36.369Z","comments":true,"path":"api/articles/240124React零碎知識點.json","keywords":null,"cover":null,"content":"<h1 id=\"單向資料流程（One-Way-Data-Flow）\"><a href=\"#單向資料流程（One-Way-Data-Flow）\" class=\"headerlink\" title=\"單向資料流程（One-Way Data Flow）\"></a>單向資料流程（One-Way Data Flow）</h1><p>單向資料流程是一種軟體設計模式，其中資料在應用程式中的流動方向是單一且明確的。這種模式通常應用在使用者介面（UI）的開發中，特別是在 React 等前端框架中。以下是單向資料流程的一些優缺點：</p>\n<h2 id=\"優點：\"><a href=\"#優點：\" class=\"headerlink\" title=\"優點：\"></a>優點：</h2><ul>\n<li><p><strong>可預測性：</strong> 單向資料流程使應用程式的狀態變得可預測，因為資料的流動是單一方向的，不會有雙向綁定可能引起的混亂。</p>\n</li>\n<li><p><strong>易於追蹤錯誤：</strong> 因為資料流動是單一方向的，當應用程式中發生錯誤時，可以更輕鬆地追蹤錯誤的來源，不需要考慮雙向綁定可能帶來的複雜性。</p>\n</li>\n<li><p><strong>可維護性：</strong> 單向資料流程使應用程式的結構更清晰，易於維護。開發者更容易理解資料的流動路徑，並進行相應的修改。</p>\n</li>\n<li><p><strong>組件化：</strong> 單向資料流程通常與組件化的開發風格相結合，每個組件都可以被看作是一個獨立的單位，這使得代碼的重用性更強，也更容易進行單元測試。</p>\n</li>\n</ul>\n<h2 id=\"缺點：\"><a href=\"#缺點：\" class=\"headerlink\" title=\"缺點：\"></a>缺點：</h2><ul>\n<li><p><strong>複雜性：</strong> 對於小型應用程式，單向資料流程可能會帶來一些不必要的複雜性。在某些情況下，雙向綁定可能更加簡單和直觀。</p>\n</li>\n<li><p><strong>學習曲線：</strong> 對於初學者來說，單向資料流程的學習曲線可能相對較陡峭。理解資料的單向流動可能需要一些時間和實踐。</p>\n</li>\n<li><p><strong>冗餘代碼：</strong> 在某些情況下，為了實現單向資料流程，可能需要寫更多的冗餘代碼，這可能會增加開發時間和代碼量。</p>\n</li>\n</ul>\n<p>總的來說，單向資料流程在大型應用程式和團隊協作中通常表現得更好，因為它提供了更高的可維護性和可預測性。然而，對於較小的專案或個人開發者來說，可能需要權衡其複雜性和學習成本。</p>\n<h1 id=\"Create-React-App-已經過時\"><a href=\"#Create-React-App-已經過時\" class=\"headerlink\" title=\"Create React App 已經過時\"></a>Create React App 已經過時</h1><p>Create React App（CRA）是一個用於快速搭建 React 應用程式的工具。然而，由於 React 生態系統的不斷演進，Create React App 也可能會有一些更新或取代的情況。可能的替代方案包括新的 React 工具或其他較新的應用程式脚手架。</p>\n<h2 id=\"替代方案\"><a href=\"#替代方案\" class=\"headerlink\" title=\"替代方案\"></a>替代方案</h2><ul>\n<li><p><strong>Vite：</strong> Vite 是一個由 Vue.js 團隊開發的快速、簡單的前端開發工具，同樣支援 React。它以其快速的啟動時間和即時編譯（Hot Module Replacement）而受到關注。</p>\n</li>\n<li><p><strong>Snowpack：</strong> Snowpack 是另一個現代的前端構建工具，以其快速的開發速度和模組化的特點而受到青睞。它也支援 React。</p>\n</li>\n<li><p><strong>Webpack + React：</strong> 如果你喜歡更精細地控制構建過程，你可以手動配置 Webpack，然後集成 React。這需要更多的配置，但可以滿足更特殊的需求。</p>\n</li>\n</ul>\n<h1 id=\"Vue-中國團隊開發，在台灣的公家單位不可使用\"><a href=\"#Vue-中國團隊開發，在台灣的公家單位不可使用\" class=\"headerlink\" title=\"Vue 中國團隊開發，在台灣的公家單位不可使用\"></a>Vue 中國團隊開發，在台灣的公家單位不可使用</h1><p>Vue 是一個流行的 JavaScript 框架，由中國團隊維護和開發。然而，在一些台灣的公家單位中，可能出於安全性或政治等因素，不願意或不被允許使用來自中國的技術產品。</p>\n<h2 id=\"解決方案\"><a href=\"#解決方案\" class=\"headerlink\" title=\"解決方案\"></a>解決方案</h2><ul>\n<li><p><strong>React 或其他框架：</strong> 如果 Vue 不被接受，可以考慮使用 React 或其他前端框架，以滿足台灣公家機構的要求。</p>\n</li>\n<li><p><strong>技術調查和合規性：</strong> 在選擇框架之前，應進行技術調查，確保所選擇的技術符合當地法規和組織的合規性要求。</p>\n</li>\n</ul>\n<h1 id=\"技術渲染方式與優缺點比較\"><a href=\"#技術渲染方式與優缺點比較\" class=\"headerlink\" title=\"技術渲染方式與優缺點比較\"></a>技術渲染方式與優缺點比較</h1><h2 id=\"CSR-Client-Side-Rendering\"><a href=\"#CSR-Client-Side-Rendering\" class=\"headerlink\" title=\"CSR (Client-Side Rendering)\"></a>CSR (Client-Side Rendering)</h2><p>CSR 技術是指在客戶端透過 JavaScript 等前端技術來渲染網頁內容。當用戶訪問網站時，瀏覽器會下載必要的 HTML、CSS 和 JavaScript 文件，然後在用戶的設備上執行 JavaScript 代碼以生成並渲染網頁。</p>\n<h3 id=\"優點\"><a href=\"#優點\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li><strong>快速的初始載入速度：</strong> 由於整個應用程式不需要在伺服器上進行渲染，所以初始載入速度較快。</li>\n<li><strong>動態互動性：</strong> 客戶端渲染允許在用戶與應用程序互動時即時更新內容，提供更好的用戶體驗。</li>\n</ul>\n<h3 id=\"缺點\"><a href=\"#缺點\" class=\"headerlink\" title=\"缺點\"></a>缺點</h3><ul>\n<li><strong>SEO 不友好：</strong> 搜索引擎難以爬取動態生成的內容，對搜索引擎優化(SEO)不利。</li>\n<li><strong>較長的初次載入時間：</strong> 需要下載並執行 JavaScript 代碼，因此初次載入時間可能較長。</li>\n<li><strong>對於弱網絡連接不友好：</strong> 在弱網絡連接下，客戶端渲染可能導致應用程序運行緩慢。</li>\n</ul>\n<h2 id=\"SSR-Server-Side-Rendering\"><a href=\"#SSR-Server-Side-Rendering\" class=\"headerlink\" title=\"SSR (Server-Side Rendering)\"></a>SSR (Server-Side Rendering)</h2><p>SSR 技術是指在伺服器端生成並渲染網頁內容，然後將整個渲染好的 HTML 送至客戶端。</p>\n<h3 id=\"優點-1\"><a href=\"#優點-1\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li><strong>SEO 友好：</strong> 由於在伺服器端就生成了完整的 HTML，搜索引擎能夠輕鬆爬取並索引內容。</li>\n<li><strong>較短的初次載入時間：</strong> 用戶收到的是伺服器端生成的 HTML，因此初次載入時間較短。</li>\n<li><strong>對弱網絡連接較友好：</strong> 伺服器端已經完成了渲染，用戶在接收到 HTML 後即可顯示內容。</li>\n</ul>\n<h3 id=\"缺點-1\"><a href=\"#缺點-1\" class=\"headerlink\" title=\"缺點\"></a>缺點</h3><ul>\n<li><strong>較差的動態互動性：</strong> 由於每次互動都需要向伺服器發送請求重新獲取 HTML，因此動態互動性可能受到限制。</li>\n<li><strong>伺服器壓力增加：</strong> 伺服器需要處理更多的渲染工作，可能導致伺服器壓力增加。</li>\n</ul>\n<h2 id=\"SSG-Static-Site-Generation\"><a href=\"#SSG-Static-Site-Generation\" class=\"headerlink\" title=\"SSG (Static Site Generation)\"></a>SSG (Static Site Generation)</h2><p>SSG 是指在構建時(通常是在部署之前)將所有頁面預先生成為靜態 HTML 文件。這些文件在用戶訪問網站時被提供，而不需要伺服器進行實時渲染。</p>\n<h3 id=\"優點-2\"><a href=\"#優點-2\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li><strong>極快的初次載入速度：</strong> 所有頁面在構建時都已經生成，因此初次載入速度非常快。</li>\n<li><strong>SEO 友好：</strong> 與 SSR 相似，生成的靜態 HTML 對搜索引擎友好。</li>\n<li><strong>簡化伺服器需求：</strong> 由於所有內容都是靜態的，不需要伺服器進行實時渲染，減輕了伺服器壓力。</li>\n</ul>\n<h3 id=\"缺點-2\"><a href=\"#缺點-2\" class=\"headerlink\" title=\"缺點\"></a>缺點</h3><ul>\n<li><strong>較差的動態互動性：</strong> 與 SSR 相似，動態互動性可能受到限制，需要透過客戶端 JavaScript 進行。</li>\n</ul>\n<h2 id=\"ISR-Incremental-Static-Regeneration\"><a href=\"#ISR-Incremental-Static-Regeneration\" class=\"headerlink\" title=\"ISR (Incremental Static Regeneration)\"></a>ISR (Incremental Static Regeneration)</h2><p>ISR 是 SSG 的一種擴展，允許在用戶訪問網站時在伺服器端重新生成特定頁面的靜態內容。</p>\n<h3 id=\"優點-3\"><a href=\"#優點-3\" class=\"headerlink\" title=\"優點\"></a>優點</h3><ul>\n<li><strong>保持靜態性能優勢：</strong> 利用 SSG 的優勢，同時在需要時動態更新特定頁面的內容。</li>\n<li><strong>動態互動性：</strong> 與 CSR 相似，能夠提供更好的動態互動性。</li>\n</ul>\n<h3 id=\"缺點-3\"><a href=\"#缺點-3\" class=\"headerlink\" title=\"缺點\"></a>缺點</h3><ul>\n<li><strong>需要伺服器處理：</strong> 重新生成靜態內容仍然需要伺服器處理，可能增加伺服器壓力。</li>\n<li><strong>可能有一些延遲：</strong> 如果某些內容需要重新生成，用戶訪問時可能會有一些延遲。</li>\n</ul>\n<h2 id=\"渲染方式比較表格\"><a href=\"#渲染方式比較表格\" class=\"headerlink\" title=\"渲染方式比較表格\"></a>渲染方式比較表格</h2><table>\n<thead>\n<tr>\n<th>技術方式</th>\n<th>CSR (客戶端渲染)</th>\n<th>SSR (伺服器端渲染)</th>\n<th>SSG (靜態網站生成)</th>\n<th>ISR (增量靜態再生)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>初始載入速度</td>\n<td>快速</td>\n<td>較快</td>\n<td>極快</td>\n<td>快速（靜態內容）</td>\n</tr>\n<tr>\n<td>SEO 友好</td>\n<td>不友好</td>\n<td>友好</td>\n<td>友好</td>\n<td>友好</td>\n</tr>\n<tr>\n<td>動態互動性</td>\n<td>良好</td>\n<td>較差</td>\n<td>較差</td>\n<td>良好</td>\n</tr>\n<tr>\n<td>伺服器壓力</td>\n<td>低</td>\n<td>高</td>\n<td>低</td>\n<td>高（特定頁面動態更新時）</td>\n</tr>\n<tr>\n<td>网络连接友好性</td>\n<td>對弱網絡連接不友好</td>\n<td>對弱網絡連接較友好</td>\n<td>對弱網絡連接較友好</td>\n<td>對弱網絡連接較友好</td>\n</tr>\n<tr>\n<td>需要伺服器處理</td>\n<td>否</td>\n<td>是</td>\n<td>否</td>\n<td>是（ISR 時）</td>\n</tr>\n<tr>\n<td>延遲</td>\n<td>初次載入可能較長</td>\n<td>重新獲取 HTML 時可能有延遲</td>\n<td>無</td>\n<td>重新生成時可能有延遲</td>\n</tr>\n</tbody></table>\n<h1 id=\"水合作用-Hydration-與水合化-Hydration\"><a href=\"#水合作用-Hydration-與水合化-Hydration\" class=\"headerlink\" title=\"水合作用 (Hydration) 與水合化 (Hydration)\"></a>水合作用 (Hydration) 與水合化 (Hydration)</h1><p><strong>水合作用 (Hydration)</strong> 是 SSR 中的專有術語，它使用與 React 初始的瀏覽器 DOM 渲染技術相似的方法，但在伺服器端進行。相較於直接將完整的 HTML、CSS 和 JavaScript 文件發送給客戶端，SSR 先將一個已經擁有 HTML DOM 元素的網頁發送給用戶，類似於框架的灰色頁面。接著再載入相對應的 JavaScript 代碼，然後進行**水合化 (Hydration)**。</p>\n<p><strong>水合化 (Hydration)</strong> 過程涉及檢查已經載入的 DOM 結構是否與伺服器端生成的結構相符。如果相符，則將相應的事件附加到元素上，使其成為 CSR (Client-Side Rendering) 元件，具有事件監聽和互動性。</p>\n<p>此過程確保了 SSR 的初始載入速度的優勢，同時在客戶端進行水合化，保留了後續的動態互動性。</p>\n<h1 id=\"Next-js-vs-Vite-vs-Create-React-App-CRA\"><a href=\"#Next-js-vs-Vite-vs-Create-React-App-CRA\" class=\"headerlink\" title=\"Next.js vs Vite vs Create React App (CRA)\"></a>Next.js vs Vite vs Create React App (CRA)</h1><h2 id=\"Next-js\"><a href=\"#Next-js\" class=\"headerlink\" title=\"Next.js\"></a>Next.js</h2><p>Next.js 是一個 React 框架，提供了許多內建功能，使得 React 應用開發更加簡單。以下是一些 Next.js 的詳細資訊：</p>\n<ul>\n<li><strong>服務端渲染 (SSR)：</strong> Next.js 支援服務端渲染，提高首次載入速度和優化搜尋引擎優化 (SEO)。</li>\n<li><strong>靜態網站生成 (SSG)：</strong> 支援靜態網站生成，可以在構建時生成靜態頁面，提供更快的載入速度。</li>\n<li><strong>動態路由：</strong> 允許使用動態路由，輕鬆處理動態生成的頁面。</li>\n<li><strong>水合作用 (Hydration)：</strong> 提供了客戶端水合作用，保持了動態互動性。</li>\n</ul>\n<h2 id=\"Vite\"><a href=\"#Vite\" class=\"headerlink\" title=\"Vite\"></a>Vite</h2><p>Vite 是一個現代化的前端建構工具，專為 Vue 和 React 開發的。以下是一些 Vite 的詳細資訊：</p>\n<ul>\n<li><strong>快速的開發伺服器：</strong> Vite 使用原生 ES 模塊導入，提供了快速的開發伺服器，支援 HMR (熱模塊替換)。</li>\n<li><strong>即時編譯：</strong> Vite 使用即時編譯 (Instant Compilation)，加速開發過程。</li>\n<li><strong>Plugin 系統：</strong> 具有豐富的 Plugin 系統，支援許多插件擴充。</li>\n<li><strong>搭建靜態網站：</strong> 可以用 Vite 構建靜態網站，提供快速載入和更好的性能。</li>\n</ul>\n<h2 id=\"Create-React-App-CRA-已經被淘汰，官網暫停更新\"><a href=\"#Create-React-App-CRA-已經被淘汰，官網暫停更新\" class=\"headerlink\" title=\"Create React App (CRA) 已經被淘汰，官網暫停更新\"></a>Create React App (CRA) 已經被淘汰，官網暫停更新</h2><p>Create React App 是一個由 React 團隊提供的官方建構工具，用於快速啟動 React 應用。以下是一些 CRA 的詳細資訊：</p>\n<ul>\n<li><strong>零配置：</strong> CRA 提供了零配置的開發環境，無需手動設定 Webpack 或 Babel。</li>\n<li><strong>內建功能：</strong> 包含了一些預設配置和一些內建功能，例如快速的開發伺服器和編譯工具。</li>\n<li><strong>易於開始：</strong> 適合初學者，可以快速上手 React 開發。</li>\n<li><strong>有限的配置選項：</strong> CRA 提供了有限的配置選項，不如其他工具靈活。</li>\n</ul>\n<h2 id=\"比較表格\"><a href=\"#比較表格\" class=\"headerlink\" title=\"比較表格\"></a>比較表格</h2><table>\n<thead>\n<tr>\n<th>功能&#x2F;特性</th>\n<th>Next.js</th>\n<th>Vite</th>\n<th>Create React App (CRA)</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服務端渲染 (SSR)</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>靜態網站生成 (SSG)</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>快速開發伺服器</td>\n<td>是</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>即時編譯</td>\n<td>否（部分支援）</td>\n<td>是</td>\n<td>是</td>\n</tr>\n<tr>\n<td>Plugin 系統</td>\n<td>否</td>\n<td>是</td>\n<td>有限的配置選項</td>\n</tr>\n<tr>\n<td>動態路由</td>\n<td>是</td>\n<td>是</td>\n<td>部分支援（React Router）</td>\n</tr>\n<tr>\n<td>水合作用 (Hydration)</td>\n<td>是</td>\n<td>部分支援（Vue）</td>\n<td>部分支援（React）</td>\n</tr>\n</tbody></table>\n<p>這個比較表格列舉了 Next.js、Vite 和 Create React App (CRA) 的一些功能和特性，以便您可以更容易地選擇適合您項目的工具。</p>\n<h1 id=\"npm-start-與-npm-build-補充說明\"><a href=\"#npm-start-與-npm-build-補充說明\" class=\"headerlink\" title=\"npm start 與 npm build 補充說明\"></a>npm start 與 npm build 補充說明</h1><h2 id=\"npm-start\"><a href=\"#npm-start\" class=\"headerlink\" title=\"npm start\"></a>npm start</h2><p><code>npm start</code> 是一個常見的指令，通常用於啟動應用程式的開發伺服器。在許多前端框架中，特別是像 <a href=\"https://reactjs.org/\">React</a>、<a href=\"https://angular.io/\">Angular</a>、<a href=\"https://vuejs.org/\">Vue</a> 等等，開發者可以使用這個指令來快速啟動本地伺服器，以便在開發過程中即時預覽應用程式的變更。</p>\n<p>具體來說，在 Next.js 中，<code>npm start</code> 可能會啟動一個本地伺服器，用於開發環境的實時預覽。這個伺服器通常會監聽在某個指定的端口，開發者可以通過瀏覽器訪問該端口以查看應用程式。</p>\n<h2 id=\"npm-build\"><a href=\"#npm-build\" class=\"headerlink\" title=\"npm build\"></a>npm build</h2><p><code>npm build</code> 則是一個用於建置應用程式的指令。在前端開發中，建置的過程通常包括將原始碼進行編譯、優化、壓縮等處理，生成最終可在生產環境中運行的代碼。</p>\n<p>在 Next.js 中，<code>npm build</code> 的執行將會生成一個或多個優化過的應用程式檔案，這些檔案通常會存放在一個特定的資料夾中，例如 <code>/.next</code>。這些檔案包含了編譯後的 JavaScript 代碼、CSS 樣式、圖片等資源，可以被部署到生產環境中，以提供最佳的性能和效能。</p>\n<p>簡單來說，<code>npm start</code> 是在開發階段用來啟動本地伺服器的指令，而 <code>npm build</code> 則是用於建置應用程式以準備部署到生產環境。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 啟動本地伺服器，用於開發預覽\nnpm start\n\n# 建置應用程式，生成生產環境可運行的代碼\nnpm run build</code></pre>\n\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><ol>\n<li><p><strong>npm start：啟動開發伺服器</strong></p>\n<ul>\n<li>打開終端機，移動到專案目錄。</li>\n<li>執行 <code>npm start</code>。</li>\n<li>開發伺服器啟動後，可以在瀏覽器中訪問指定的端口，預覽應用程式，並在開發過程中即時看到變更。</li>\n</ul>\n</li>\n<li><p><strong>npm build：建置應用程式</strong></p>\n<ul>\n<li>打開終端機，移動到專案目錄。</li>\n<li>執行 <code>npm run build</code>。</li>\n<li>建置過程將會生成優化過的應用程式檔案，通常存放在 <code>/.next</code> 資料夾中。</li>\n<li>這些檔案可以被部署到生產環境，以提供更快的載入速度和最佳的效能。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"注意事項\"><a href=\"#注意事項\" class=\"headerlink\" title=\"注意事項\"></a>注意事項</h2><ul>\n<li>在開發階段，通常使用 <code>npm start</code> 以便快速預覽和測試應用程式。</li>\n<li>在部署到生產環境之前，應當使用 <code>npm run build</code> 進行建置，確保應用程式的最終版本是經過優化的。</li>\n</ul>\n<p>這兩個指令是前端開發中常見的操作，有助於提高開發效率並確保應用程式在生產環境中運行順暢。</p>\n<h1 id=\"React-元件命名規則\"><a href=\"#React-元件命名規則\" class=\"headerlink\" title=\"React 元件命名規則\"></a>React 元件命名規則</h1><p>在 React 中，元件的命名有一個重要的規則：元件名稱必須以大寫字母開頭。這是由於 React 使用這種命名約定來區分 DOM 元素和 React 元件。</p>\n<h2 id=\"為什麼要大寫開頭？\"><a href=\"#為什麼要大寫開頭？\" class=\"headerlink\" title=\"為什麼要大寫開頭？\"></a>為什麼要大寫開頭？</h2><ol>\n<li><p><strong>區分 DOM 元素：</strong> React 使用大寫字母開頭的元件名稱，以便在 JSX 中區分 HTML 標籤和 React 元件。例如，<code>&lt;div&gt;</code> 是 HTML 標籤，而 <code>&lt;MyComponent&gt;</code> 是 React 元件。</p>\n</li>\n<li><p><strong>JSX 語法規定：</strong> 在 JSX 語法中，如果標籤名稱以小寫字母開頭，它將視為一個 HTML 標籤，而如果以大寫字母開頭，它則視為一個 React 元件。</p>\n</li>\n</ol>\n<h2 id=\"範例\"><a href=\"#範例\" class=\"headerlink\" title=\"範例\"></a>範例</h2><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; React 元件，名稱以大寫字母開頭\nclass MyComponent extends React.Component &#123;\n  render() &#123;\n    return &lt;div&gt;Hello, I am a React component!&lt;&#x2F;div&gt;;\n  &#125;\n&#125;\n\n&#x2F;&#x2F; HTML 標籤，名稱以小寫字母開頭\nconst myElement &#x3D; &lt;div&gt;This is a regular HTML element.&lt;&#x2F;div&gt;;</code></pre>\n\n<h2 id=\"命名風格\"><a href=\"#命名風格\" class=\"headerlink\" title=\"命名風格\"></a>命名風格</h2><p>React 元件的命名通常使用帕斯卡命名法（PascalCase），即每個單字的首字母都大寫。這有助於清晰地區分 React 元件和其他 JavaScript 變數或函數。</p>\n<h1 id=\"虛擬-DOM-與真實-DOM-轉換過程\"><a href=\"#虛擬-DOM-與真實-DOM-轉換過程\" class=\"headerlink\" title=\"虛擬 DOM 與真實 DOM 轉換過程\"></a>虛擬 DOM 與真實 DOM 轉換過程</h1><p>虛擬 DOM（Virtual DOM）是 React 中的核心概念，它存在於記憶體中，用以抽象表示真實 DOM。當 React 元件的狀態（State）或屬性（Props）發生變化時，React 會進行以下虛擬 DOM 到真實 DOM 的轉換過程：</p>\n<ol>\n<li><p><strong>虛擬 DOM 構建：</strong> 當元件的狀態或屬性發生變化時，React 會重新構建虛擬 DOM。</p>\n</li>\n<li><p><strong>比較：</strong> React 使用一個演算法比較新的虛擬 DOM 與之前的虛擬 DOM，找出變化的部分。這種比較通常是高效的，因為虛擬 DOM 是輕量級的，存在於記憶體中。</p>\n</li>\n<li><p><strong>差異更新：</strong> React 會計算出變化的部分，然後僅更新這些部分，而不是重新渲染整個真實 DOM。這使得更新過程更加高效。</p>\n</li>\n<li><p><strong>產生真實 DOM 操作：</strong> 根據虛擬 DOM 的變化，React 生成對應的真實 DOM 操作，例如新增、更新、或刪除元素。</p>\n</li>\n<li><p><strong>應用變化：</strong> React 通過 DOM Diff 算法計算出的變化，將這些變化應用到真實 DOM 上。</p>\n</li>\n</ol>\n<p>這樣的過程保證了 React 在性能上的優勢，因為它只更新真正發生變化的部分，而不是整個 DOM 樹。</p>\n<p>在 React 中，你不需要手動進行虛擬 DOM 到真實 DOM 的轉換操作，React 會自動處理這些細節。你只需關注元件的狀態和 UI 的邏輯，React 會優化並管理 DOM 的更新過程。</p>\n<h1 id=\"React-四種最基本的-Hooks\"><a href=\"#React-四種最基本的-Hooks\" class=\"headerlink\" title=\"React 四種最基本的 Hooks\"></a>React 四種最基本的 Hooks</h1><h2 id=\"React-Hooks-解釋\"><a href=\"#React-Hooks-解釋\" class=\"headerlink\" title=\"React Hooks 解釋\"></a>React Hooks 解釋</h2><p>React Hooks 是 React 16.8.0 版本引入的一項功能，它提供了在不使用類別（Class）的情況下使用狀態（State）和其他 React 特性的能力。Hooks 讓你在函數型元件中使用 React 的狀態和生命週期方法，從而使代碼更加簡潔且易於理解。</p>\n<h2 id=\"1-useState\"><a href=\"#1-useState\" class=\"headerlink\" title=\"1. useState\"></a>1. useState</h2><p><code>useState</code> 是用來在函式型元件中添加狀態的 Hook。它返回一個包含目前狀態和更新狀態的陣列。這個 Hook 的基本用法如下：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; useState &#125; from &quot;react&quot;;\n\nfunction ExampleComponent() &#123;\n  const [count, setCount] &#x3D; useState(0);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: &#123;count&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; setCount(count + 1)&#125;&gt;Increment&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<h2 id=\"2-useEffect\"><a href=\"#2-useEffect\" class=\"headerlink\" title=\"2. useEffect\"></a>2. useEffect</h2><p><code>useEffect</code> 是用來在函式型元件中執行副作用操作（例如資料獲取、訂閱、手動修改 DOM）的 Hook。它接收兩個參數，第一個參數是一個函式，第二個參數是一個陣列，用來指定什麼條件下觸發 <code>useEffect</code>。若第二個參數不傳，則每次渲染都會執行 <code>useEffect</code>。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; useEffect, useState &#125; from &quot;react&quot;;\n\nfunction ExampleComponent() &#123;\n  const [data, setData] &#x3D; useState(null);\n\n  useEffect(() &#x3D;&gt; &#123;\n    &#x2F;&#x2F; 執行副作用操作，例如資料獲取\n    fetchData();\n  &#125;, []); &#x2F;&#x2F; 空陣列表示僅在初次渲染時執行\n\n  return &lt;div&gt;&#123;&#x2F;* 渲染元件內容 *&#x2F;&#125;&lt;&#x2F;div&gt;;\n&#125;</code></pre>\n\n<h3 id=\"3-useContext\"><a href=\"#3-useContext\" class=\"headerlink\" title=\"3. useContext\"></a>3. useContext</h3><p><code>useContext</code> 是用來在函式型元件中使用 React 上下文的 Hook。它接收一個上下文對象（使用 React.createContext 創建）並返回上下文的當前值</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; useContext &#125; from &quot;react&quot;;\nimport MyContext from &quot;.&#x2F;MyContext&quot;;\n\nfunction ExampleComponent() &#123;\n  const contextValue &#x3D; useContext(MyContext);\n\n  return &lt;p&gt;Context Value: &#123;contextValue&#125;&lt;&#x2F;p&gt;;\n&#125;</code></pre>\n\n<h3 id=\"4-useReducer\"><a href=\"#4-useReducer\" class=\"headerlink\" title=\"4. useReducer\"></a>4. useReducer</h3><p><code>useReducer</code> 是一個進階的 Hook，用來管理複雜狀態邏輯。它接收一個 reducer 函式和初始狀態，返回一個包含目前狀態和 dispatch 函式的陣列。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React, &#123; useReducer &#125; from &quot;react&quot;;\n\nfunction reducer(state, action) &#123;\n  switch (action.type) &#123;\n    case &quot;increment&quot;:\n      return &#123; count: state.count + 1 &#125;;\n    case &quot;decrement&quot;:\n      return &#123; count: state.count - 1 &#125;;\n    default:\n      return state;\n  &#125;\n&#125;\n\nfunction ExampleComponent() &#123;\n  const [state, dispatch] &#x3D; useReducer(reducer, &#123; count: 0 &#125;);\n\n  return (\n    &lt;div&gt;\n      &lt;p&gt;Count: &#123;state.count&#125;&lt;&#x2F;p&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;Increment&lt;&#x2F;button&gt;\n      &lt;button onClick&#x3D;&#123;() &#x3D;&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;Decrement&lt;&#x2F;button&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;</code></pre>\n\n<p>這些是 React 中的四種最基本的 Hooks，每種 Hook 都提供了特定的功能，讓函式型元件能夠擁有狀態、副作用處理、上下文使用和複雜狀態管理等功能。</p>\n<h2 id=\"Hooks-的優勢\"><a href=\"#Hooks-的優勢\" class=\"headerlink\" title=\"Hooks 的優勢\"></a>Hooks 的優勢</h2><ol>\n<li><p><strong>更容易共用狀態邏輯：</strong> Hooks 提供了一種更好的方式來共用狀態邏輯，無需使用高階組件或渲染屬性。</p>\n</li>\n<li><p><strong>更容易理解和測試：</strong> 使用 Hooks 的函數型元件通常比類別型元件更加簡潔和易於理解，並且更容易進行測試。</p>\n</li>\n<li><p><strong>避免類別的繼承問題：</strong> Hooks 解決了類別型元件中的一些繼承問題，使代碼更加清晰。</p>\n</li>\n<li><p><strong>使 React 更加自然：</strong> Hooks 將 React 更加靠近函數式編程的理念，使得函數型元件的使用更加自然。</p>\n</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總的來說，React Hooks 提供了一種更現代、簡潔且方便的方式來處理狀態和副作用，提高了 React 開發的效率和可維護性。</p></blockquote>\n<h1 id=\"Accessibility-a11y\"><a href=\"#Accessibility-a11y\" class=\"headerlink\" title=\"Accessibility (a11y)\"></a>Accessibility (a11y)</h1><p>“a11y” 是 “accessibility” 這個單詞的縮寫。它代表著網頁或應用程式的可及性（accessibility）方面，強調讓所有使用者，包括身心障礙者，都能方便地訪問和使用網頁或應用程式。</p>\n<p>透過可及性的設計，我們可以確保所有使用者都能獲得相同的資訊、功能和互動體驗，而不論他們是否有視力、聽力、運動能力或認知能力的障礙。提升可及性不僅是一種道德責任，還能擴大受眾並提升用戶滿意度。</p>\n<p>以下是一些可提升可及性的常見做法：</p>\n<h2 id=\"1-有意義的-HTML\"><a href=\"#1-有意義的-HTML\" class=\"headerlink\" title=\"1. 有意義的 HTML\"></a>1. 有意義的 HTML</h2><p>使用正確的 HTML 標籤，確保文檔結構清晰，並使用標題標籤（<code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>, 等等）來組織內容。</p>\n<h2 id=\"2-表單可及性\"><a href=\"#2-表單可及性\" class=\"headerlink\" title=\"2. 表單可及性\"></a>2. 表單可及性</h2><p>提供明確的表單標籤，使用標籤（<code>&lt;label&gt;</code>）來關聯表單元素和其標籤，以及提供適當的提示。</p>\n<h2 id=\"3-鍵盤導航\"><a href=\"#3-鍵盤導航\" class=\"headerlink\" title=\"3. 鍵盤導航\"></a>3. 鍵盤導航</h2><p>確保所有功能都可以使用鍵盤進行操作，而不僅僅依賴滑鼠。</p>\n<h2 id=\"4-對比度\"><a href=\"#4-對比度\" class=\"headerlink\" title=\"4. 對比度\"></a>4. 對比度</h2><p>使用高對比度的色彩，以確保文字和背景之間的區別明顯，有助於視力較差的使用者。</p>\n<h2 id=\"5-無障礙的多媒體內容\"><a href=\"#5-無障礙的多媒體內容\" class=\"headerlink\" title=\"5. 無障礙的多媒體內容\"></a>5. 無障礙的多媒體內容</h2><p>提供音訊描述（audio descriptions）和字幕（captions）來支援聽覺或視覺障礙的使用者。</p>\n<h2 id=\"6-焦點可見性\"><a href=\"#6-焦點可見性\" class=\"headerlink\" title=\"6. 焦點可見性\"></a>6. 焦點可見性</h2><p>在焦點移動時，確保使用者可以清楚看到焦點所在的位置，這對於使用鍵盤導航的人很重要。</p>\n<h2 id=\"7-動態內容的可訪問性\"><a href=\"#7-動態內容的可訪問性\" class=\"headerlink\" title=\"7. 動態內容的可訪問性\"></a>7. 動態內容的可訪問性</h2><p>當有動態內容（例如單頁應用程序）時，確保內容對螢幕助讀器和其他輔助技術可訪問。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總的來說，”a11y” 的目標是讓所有使用者都能夠平等地獲得和使用網站或應用程式的功能，而不受他們的能力或特殊需求的影響。</p></blockquote>\n<h1 id=\"“HTML-in-JS”-和-“CSS-in-JS”\"><a href=\"#“HTML-in-JS”-和-“CSS-in-JS”\" class=\"headerlink\" title=\"“HTML in JS” 和 “CSS in JS”\"></a>“HTML in JS” 和 “CSS in JS”</h1><p>“HTML in JS” 和 “CSS in JS” 是指在 JavaScript 文件中直接嵌入 HTML 和 CSS 的一種開發模式。這種模式通常與一些 JavaScript 框架或庫結合使用，例如 React，Vue，或者一些 CSS-in-JS 的庫（如 Styled Components）。</p>\n<h2 id=\"HTML-in-JS：\"><a href=\"#HTML-in-JS：\" class=\"headerlink\" title=\"HTML in JS：\"></a>HTML in JS：</h2><p>在 React 中，JSX（JavaScript XML）是一種語法擴展，它允許開發者在 JavaScript 文件中直接撰寫類似 XML（或 HTML）的語法。JSX 最終會被編譯成 JavaScript。以下是一個簡單的 React 組件，展示了 HTML 在 JavaScript 文件中的使用：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &quot;react&quot;;\n\nconst MyComponent &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;div&gt;\n      &lt;h1&gt;Hello, JSX!&lt;&#x2F;h1&gt;\n      &lt;p&gt;This is an example of HTML in JS using JSX.&lt;&#x2F;p&gt;\n    &lt;&#x2F;div&gt;\n  );\n&#125;;\n\nexport default MyComponent;</code></pre>\n\n<p>這種方式使得 UI 的結構和邏輯能夠更加緊密地結合在一起，方便了組件的定義和維護。</p>\n<h2 id=\"CSS-in-JS：\"><a href=\"#CSS-in-JS：\" class=\"headerlink\" title=\"CSS in JS：\"></a>CSS in JS：</h2><p>“CSS in JS” 是一種將 CSS 代碼嵌入到 JavaScript 文件中的模式。這種方式可以提供一些額外的好處，如範圍作用域（Scoped Styles）和動態生成樣式。以下是使用 Styled Components 库的一個簡單範例：</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import styled from &quot;styled-components&quot;;\n\nconst StyledDiv &#x3D; styled.div&#96;\n  background-color: lightblue;\n  padding: 20px;\n&#96;;\n\nconst MyStyledComponent &#x3D; () &#x3D;&gt; &#123;\n  return (\n    &lt;StyledDiv&gt;\n      &lt;p&gt;This is a styled component with CSS in JS.&lt;&#x2F;p&gt;\n    &lt;&#x2F;StyledDiv&gt;\n  );\n&#125;;\n\nexport default MyStyledComponent;</code></pre>\n\n<p>這裡，styled.div 是 Styled Components 提供的函數，它接受一個包含 CSS 屬性的模板字符串。這樣的做法使得 CSS 能夠更好地與組件綁定在一起，同時避免了全局命名空間的衝突。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總的來說，HTML in JS 和 CSS in JS 這兩種模式通過將不同語言的代碼放在同一個文件中，使得代碼的組織和維護更加方便，同時提供了一些額外的特性，如組件級別的樣式和動態生成樣式。</p></blockquote>\n<h1 id=\"虛擬-DOM（Virtual-DOM）\"><a href=\"#虛擬-DOM（Virtual-DOM）\" class=\"headerlink\" title=\"虛擬 DOM（Virtual DOM）\"></a>虛擬 DOM（Virtual DOM）</h1><p>虛擬 DOM 是 React 中的一個核心概念，它在記憶體中構建了一個樹狀結構，用來表示真實 DOM 的抽象。React 使用虛擬 DOM 以最小化對實際 DOM 的操作，從而提高應用程式的性能和效能。</p>\n<h2 id=\"工作原理\"><a href=\"#工作原理\" class=\"headerlink\" title=\"工作原理\"></a>工作原理</h2><ol>\n<li><p><strong>構建虛擬 DOM：</strong> 當 React 應用程式進行渲染時，首先構建一個虛擬 DOM，這是一個 JavaScript 物件，包含整個應用程式的 UI 結構和狀態。虛擬 DOM 的構建基於 React 元件的層次結構。</p>\n</li>\n<li><p><strong>狀態變更引發更新：</strong> 當應用程式的狀態發生變化時，React 重新構建虛擬 DOM。新的虛擬 DOM 與之前的進行比較，找出變化的部分。</p>\n</li>\n<li><p><strong>虛擬 DOM 的比較：</strong> React 使用「調和（Reconciliation）」演算法，比較新的虛擬 DOM 與之前的虛擬 DOM，找出差異。這個比較是高效的，因為虛擬 DOM 是輕量級的，存在於記憶體中。</p>\n</li>\n<li><p><strong>差異更新：</strong> React 計算出虛擬 DOM 的變化部分，僅更新這些部分，而不是整個真實 DOM。這節省計算資源，提高性能。</p>\n</li>\n<li><p><strong>產生真實 DOM 操作：</strong> 根據虛擬 DOM 的變化，React 生成對應的真實 DOM 操作，例如新增、更新或刪除元素。</p>\n</li>\n<li><p><strong>應用變化：</strong> React 將這些真實 DOM 操作應用到實際 DOM 上，保持 UI 與應用程式狀態同步。</p>\n</li>\n</ol>\n<h2 id=\"優勢\"><a href=\"#優勢\" class=\"headerlink\" title=\"優勢\"></a>優勢</h2><ul>\n<li><p><strong>性能優化：</strong> 透過最小化對實際 DOM 的直接操作，減少瀏覽器的重新繪製次數，提高應用程式性能。</p>\n</li>\n<li><p><strong>開發效率：</strong> React 開發者無需手動處理 DOM 操作，專注於應用程式狀態和 UI 邏輯，React 會自動優化和管理 DOM 更新過程。</p>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總的來說，虛擬 DOM 是 React 實現高效且快速 UI 更新的核心機制之一。</p></blockquote>\n<h1 id=\"JSX（JavaScript-XML）解釋\"><a href=\"#JSX（JavaScript-XML）解釋\" class=\"headerlink\" title=\"JSX（JavaScript XML）解釋\"></a>JSX（JavaScript XML）解釋</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>JSX 使用的是 XHTML 標準，並非 HTML5 標準。<br>JSX 是 React 中用來描述 UI 的一種語法擴展，通常與 React 框架一同使用。它允許在 JavaScript 代碼中嵌入類似 XML 或 HTML 的語法，使得 React 元件的定義和渲染更直觀和易於理解。</p></blockquote>\n<h2 id=\"主要特點和語法解釋\"><a href=\"#主要特點和語法解釋\" class=\"headerlink\" title=\"主要特點和語法解釋\"></a>主要特點和語法解釋</h2><h3 id=\"1-嵌入-JavaScript-表達式：\"><a href=\"#1-嵌入-JavaScript-表達式：\" class=\"headerlink\" title=\"1. 嵌入 JavaScript 表達式：\"></a>1. 嵌入 JavaScript 表達式：</h3><p>在 JSX 中，可以使用 <code>&#123;&#125;</code> 中括號將 JavaScript 表達式嵌入到 XML 或 HTML 中，方便動態數據的渲染。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const name &#x3D; &quot;World&quot;;\nconst greeting &#x3D; &lt;p&gt;Hello, &#123;name&#125;!&lt;&#x2F;p&gt;;</code></pre>\n\n<h3 id=\"2-創建元素：\"><a href=\"#2-創建元素：\" class=\"headerlink\" title=\"2. 創建元素：\"></a>2. 創建元素：</h3><p>JSX 允許直接使用類似 HTML 的語法創建 React 元素。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const element &#x3D; &lt;h1&gt;Hello, JSX!&lt;&#x2F;h1&gt;;</code></pre>\n\n<h3 id=\"3-屬性：\"><a href=\"#3-屬性：\" class=\"headerlink\" title=\"3. 屬性：\"></a>3. 屬性：</h3><p>JSX 中可以使用 HTML 一樣的屬性，屬性值可以是字符串或包含 JavaScript 表達式的括號。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const imageUrl &#x3D; &quot;path&#x2F;to&#x2F;image.jpg&quot;;\nconst image &#x3D; &lt;img src&#x3D;&#123;imageUrl&#125; alt&#x3D;&quot;An Example&quot; &#x2F;&gt;;</code></pre>\n\n<h3 id=\"4-子元素：\"><a href=\"#4-子元素：\" class=\"headerlink\" title=\"4. 子元素：\"></a>4. 子元素：</h3><p>JSX 中可以包含其他 JSX 元素作為子元素，就像 HTML 一樣。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const container &#x3D; (\n  &lt;div&gt;\n    &lt;h1&gt;Main Title&lt;&#x2F;h1&gt;\n    &lt;p&gt;Some content here.&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n);</code></pre>\n\n<h3 id=\"5-條件渲染：\"><a href=\"#5-條件渲染：\" class=\"headerlink\" title=\"5. 條件渲染：\"></a>5. 條件渲染：</h3><p>可以使用 JavaScript 中的條件語句，如 if 或三元運算符，來根據不同條件渲染不同的 JSX 內容。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const isLoggedIn &#x3D; true;\n\nconst loginStatus &#x3D; (\n  &lt;p&gt;&#123;isLoggedIn ? &quot;User is logged in&quot; : &quot;User is logged out&quot;&#125;&lt;&#x2F;p&gt;\n);</code></pre>\n\n<h3 id=\"6-列表渲染：\"><a href=\"#6-列表渲染：\" class=\"headerlink\" title=\"6. 列表渲染：\"></a>6. 列表渲染：</h3><p>JSX 可以與 JavaScript 中的 .map() 函數一起使用，以便根據數據集合生成列表。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">const numbers &#x3D; [1, 2, 3, 4, 5];\n\nconst list &#x3D; (\n  &lt;ul&gt;\n    &#123;numbers.map((number) &#x3D;&gt; (\n      &lt;li key&#x3D;&#123;number&#125;&gt;&#123;number&#125;&lt;&#x2F;li&gt;\n    ))&#125;\n  &lt;&#x2F;ul&gt;\n);</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總的來說，JSX 提供了一種直觀和方便的語法，使得 React 元件的定義和渲染更加容易，同時保留了 JavaScript 的強大功能。當 React 代碼被編譯時，JSX 最終會被轉換為普通的 JavaScript 對象，並由 React DOM 使用。</p></blockquote>\n<h1 id=\"JSX-注意事項\"><a href=\"#JSX-注意事項\" class=\"headerlink\" title=\"JSX 注意事項\"></a>JSX 注意事項</h1><p>在使用 JSX 時，開發者需要注意一些潛在的細節和規則，以確保程式碼的正確性和可讀性。以下是一些建議和需要注意的事項：</p>\n<h2 id=\"1-包裝元素：\"><a href=\"#1-包裝元素：\" class=\"headerlink\" title=\"1. 包裝元素：\"></a>1. 包裝元素：</h2><p>JSX 中的每個返回值必須包裝在一個外層元素中。這是因為 JSX 被視為一個表達式，而表達式僅能返回單一值。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 正確\nconst element &#x3D; (\n  &lt;div&gt;\n    &lt;h1&gt;Title&lt;&#x2F;h1&gt;\n    &lt;p&gt;Content&lt;&#x2F;p&gt;\n  &lt;&#x2F;div&gt;\n);\n\n&#x2F;&#x2F; 正確-[Fragment(片段)]\nconst element &#x3D; (\n  &lt;&gt;\n    &lt;h1&gt;Title&lt;&#x2F;h1&gt;\n    &lt;p&gt;Content&lt;&#x2F;p&gt;\n  &lt;&#x2F;&gt;\n);\n\n\n&#x2F;&#x2F; 錯誤 - 缺少外層包裝元素\nconst invalidElement &#x3D; &lt;h1&gt;Title&lt;&#x2F;h1&gt;&lt;p&gt;Content&lt;&#x2F;p&gt;;</code></pre>\n\n<p>建議儘可能使用內建的 Fragment(片段) 元件。因為當層級多、複雜且分散時，如果有過多層 div 或其它多餘標記，可能有樣式套用或小幅度效能影響問題。<br><code>&lt;&gt;&lt;/&gt;</code>是<code>&lt;Fragment&gt;&lt;/Fragment&gt;</code>的簡寫法</p>\n<h2 id=\"2-使用-className：\"><a href=\"#2-使用-className：\" class=\"headerlink\" title=\"2. 使用 className：\"></a>2. 使用 className：</h2><p>在 JSX 中，指定 HTML 元素的 class 屬性應該使用 className 而非 class。這是因為 class 是 JavaScript 中的保留字。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 正確\nconst element &#x3D; &lt;div className&#x3D;&quot;my-class&quot;&gt;Content&lt;&#x2F;div&gt;;\n\n&#x2F;&#x2F; 錯誤 - 使用 class\nconst invalidElement &#x3D; &lt;div class&#x3D;&quot;my-class&quot;&gt;Content&lt;&#x2F;div&gt;;</code></pre>\n\n<h2 id=\"3-屬性名稱使用-camelCase：\"><a href=\"#3-屬性名稱使用-camelCase：\" class=\"headerlink\" title=\"3. 屬性名稱使用 camelCase：\"></a>3. 屬性名稱使用 camelCase：</h2><p>在 JSX 中，屬性名稱應該使用 camelCase 寫法，就像在 JavaScript 中一樣。這是為了與 HTML 的屬性區分開來。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 正確\nconst element &#x3D; &lt;input type&#x3D;&quot;text&quot; maxLength&#x3D;&#123;10&#125; &#x2F;&gt;;\n\n&#x2F;&#x2F; 錯誤 - 使用 kebab-case\nconst invalidElement &#x3D; &lt;input type&#x3D;&quot;text&quot; max-length&#x3D;&#123;10&#125; &#x2F;&gt;;</code></pre>\n\n<h2 id=\"4-自閉合標籤：\"><a href=\"#4-自閉合標籤：\" class=\"headerlink\" title=\"4. 自閉合標籤：\"></a>4. 自閉合標籤：</h2><p>對於沒有子元素的標籤，應該使用自閉合的方式，以確保一致性和可讀性。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 正確\nconst selfClosingTag &#x3D; &lt;img src&#x3D;&quot;path&#x2F;to&#x2F;image.jpg&quot; alt&#x3D;&quot;An Image&quot; &#x2F;&gt;;\n\n&#x2F;&#x2F; 錯誤 - 不使用自閉合\nconst invalidTag &#x3D; &lt;img src&#x3D;&quot;path&#x2F;to&#x2F;image.jpg&quot; alt&#x3D;&quot;An Image&quot;&gt;&lt;&#x2F;img&gt;;</code></pre>\n\n<h2 id=\"5-表達式中的注意事項：\"><a href=\"#5-表達式中的注意事項：\" class=\"headerlink\" title=\"5. 表達式中的注意事項：\"></a>5. 表達式中的注意事項：</h2><p>在 <code>&#123;&#125;</code> 中的表達式中，應該注意不要放置太複雜或長的邏輯，以保持可讀性。若邏輯複雜，建議在外部先定義再引用。</p>\n<pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">&#x2F;&#x2F; 正確\nconst greeting &#x3D; &lt;p&gt;Hello, &#123;name&#125;!&lt;&#x2F;p&gt;;\n\n&#x2F;&#x2F; 錯誤 - 過於複雜的邏輯\nconst invalidGreeting &#x3D; (\n  &lt;p&gt;&#123;name &amp;&amp; name.length &gt; 0 ? &#96;Hello, $&#123;name&#125;!&#96; : &quot;Hello!&quot;&#125;&lt;&#x2F;p&gt;\n);</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>這些是在使用 JSX 時需要注意的一些建議和細節，遵守這些規則有助於保持代碼的一致性和可維護性。</p></blockquote>\n<h1 id=\"React-Fragments\"><a href=\"#React-Fragments\" class=\"headerlink\" title=\"React Fragments\"></a>React Fragments</h1><p>React Fragments 是一種允許在 JSX 中返回多個元素而無需添加多餘外層包裝元素的機制。當你希望返回多個元素卻不想在 DOM 中添加額外的父元素時，React Fragments 提供了一種優雅的解決方案。</p>\n<h2 id=\"使用方式-1\"><a href=\"#使用方式-1\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"1-使用-lt-React-Fragment-gt-：\"><a href=\"#1-使用-lt-React-Fragment-gt-：\" class=\"headerlink\" title=\"1. 使用 &lt;React.Fragment&gt;：\"></a>1. 使用 &lt;React.Fragment&gt;：</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &quot;react&quot;;\n\nconst ComponentWithFragments &#x3D; () &#x3D;&gt; (\n  &lt;React.Fragment&gt;\n    &lt;p&gt;Paragraph 1&lt;&#x2F;p&gt;\n    &lt;p&gt;Paragraph 2&lt;&#x2F;p&gt;\n  &lt;&#x2F;React.Fragment&gt;\n);\n\nexport default ComponentWithFragments;</code></pre>\n\n<h3 id=\"2-簡化-lt-gt-lt-x2F-gt-語法（僅在-React-16-2-0-以上版本支援）：\"><a href=\"#2-簡化-lt-gt-lt-x2F-gt-語法（僅在-React-16-2-0-以上版本支援）：\" class=\"headerlink\" title=\"2. 簡化 &lt;&gt;&lt;&#x2F;&gt; 語法（僅在 React 16.2.0 以上版本支援）：\"></a>2. 簡化 &lt;&gt;&lt;&#x2F;&gt; 語法（僅在 React 16.2.0 以上版本支援）：</h3><pre class=\"line-numbers language-jsx\" data-language=\"jsx\"><code class=\"language-jsx\">import React from &quot;react&quot;;\n\nconst ComponentWithFragments &#x3D; () &#x3D;&gt; (\n  &lt;&gt;\n    &lt;p&gt;Paragraph 1&lt;&#x2F;p&gt;\n    &lt;p&gt;Paragraph 2&lt;&#x2F;p&gt;\n  &lt;&#x2F;&gt;\n);\n\nexport default ComponentWithFragments;</code></pre>\n\n<h2 id=\"優勢-1\"><a href=\"#優勢-1\" class=\"headerlink\" title=\"優勢\"></a>優勢</h2><ol>\n<li><p>減少不必要的 DOM 元素： 使用 Fragments 可以防止因為外層包裝元素而導致不必要的 DOM 層次。</p>\n</li>\n<li><p>提高可讀性： Fragments 使得返回多個元素時更加清晰和簡潔，無需額外的 div 或其他元素。</p>\n</li>\n<li><p>避免樣式和佈局影響： 不添加多餘的父元素，可以避免對樣式和佈局產生不必要的影響。</p>\n</li>\n</ol>\n<h2 id=\"注意事項-1\"><a href=\"#注意事項-1\" class=\"headerlink\" title=\"注意事項\"></a>注意事項</h2><ul>\n<li>Fragments 不會在最終的渲染結果中產生任何實際的 DOM 元素。</li>\n<li>當返回多個元素時，React Fragments 是一個優雅而有效的解決方案，特別是在不需要額外包裝元素的情況下。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>React Fragments 提供了一種清晰的方式來處理返回多個元素的情況，同時保持了代碼的可讀性和結構。</p></blockquote>\n<h1 id=\"Node-js-模組系統\"><a href=\"#Node-js-模組系統\" class=\"headerlink\" title=\"Node.js 模組系統\"></a>Node.js 模組系統</h1><p>Node.js 最初使用的是 CommonJS 模組系統，其中使用 <code>require</code> 和 <code>module.exports</code>。</p>\n<p>隨著 Node.js 的發展，ECMAScript 模組系統（使用 <code>import</code> 和 <code>export</code>）已成為標準，Node.js 也加入了對其的支援。</p>\n<p>Node.js 會將 .cjs 檔案視為 CommonJS 模組，將 .mjs 檔案視為 ECMAScript 模組。對於 .js 檔案，Node.js 將其視為專案的預設模組系統（除非 <strong>package.json</strong> 中指定 **”type”: “module”**）。</p>\n","feature":true,"text":"單向資料流程（One-Way Data Flow）單向資料流程是一種軟體設計模式，其中資料在應用程式中的流動方向是單一且明確的。這種模式通常應用在使用者介面（UI）的開發中，特別是在 React 等前端框架中。以下是單向資料流程的一些優缺點： 優點： 可預測性： 單向資料流程使應...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"React","slug":"React","count":3,"path":"api/categories/React.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%96%AE%E5%90%91%E8%B3%87%E6%96%99%E6%B5%81%E7%A8%8B%EF%BC%88One-Way-Data-Flow%EF%BC%89\"><span class=\"toc-text\">單向資料流程（One-Way Data Flow）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%84%AA%E9%BB%9E%EF%BC%9A\"><span class=\"toc-text\">優點：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%BB%9E%EF%BC%9A\"><span class=\"toc-text\">缺點：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Create-React-App-%E5%B7%B2%E7%B6%93%E9%81%8E%E6%99%82\"><span class=\"toc-text\">Create React App 已經過時</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">替代方案</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Vue-%E4%B8%AD%E5%9C%8B%E5%9C%98%E9%9A%8A%E9%96%8B%E7%99%BC%EF%BC%8C%E5%9C%A8%E5%8F%B0%E7%81%A3%E7%9A%84%E5%85%AC%E5%AE%B6%E5%96%AE%E4%BD%8D%E4%B8%8D%E5%8F%AF%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">Vue 中國團隊開發，在台灣的公家單位不可使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">解決方案</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8A%80%E8%A1%93%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E8%88%87%E5%84%AA%E7%BC%BA%E9%BB%9E%E6%AF%94%E8%BC%83\"><span class=\"toc-text\">技術渲染方式與優缺點比較</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSR-Client-Side-Rendering\"><span class=\"toc-text\">CSR (Client-Side Rendering)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%84%AA%E9%BB%9E\"><span class=\"toc-text\">優點</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%BB%9E\"><span class=\"toc-text\">缺點</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SSR-Server-Side-Rendering\"><span class=\"toc-text\">SSR (Server-Side Rendering)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%84%AA%E9%BB%9E-1\"><span class=\"toc-text\">優點</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%BB%9E-1\"><span class=\"toc-text\">缺點</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#SSG-Static-Site-Generation\"><span class=\"toc-text\">SSG (Static Site Generation)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%84%AA%E9%BB%9E-2\"><span class=\"toc-text\">優點</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%BB%9E-2\"><span class=\"toc-text\">缺點</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ISR-Incremental-Static-Regeneration\"><span class=\"toc-text\">ISR (Incremental Static Regeneration)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%84%AA%E9%BB%9E-3\"><span class=\"toc-text\">優點</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BC%BA%E9%BB%9E-3\"><span class=\"toc-text\">缺點</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BC%83%E8%A1%A8%E6%A0%BC\"><span class=\"toc-text\">渲染方式比較表格</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B0%B4%E5%90%88%E4%BD%9C%E7%94%A8-Hydration-%E8%88%87%E6%B0%B4%E5%90%88%E5%8C%96-Hydration\"><span class=\"toc-text\">水合作用 (Hydration) 與水合化 (Hydration)</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Next-js-vs-Vite-vs-Create-React-App-CRA\"><span class=\"toc-text\">Next.js vs Vite vs Create React App (CRA)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Next-js\"><span class=\"toc-text\">Next.js</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Vite\"><span class=\"toc-text\">Vite</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Create-React-App-CRA-%E5%B7%B2%E7%B6%93%E8%A2%AB%E6%B7%98%E6%B1%B0%EF%BC%8C%E5%AE%98%E7%B6%B2%E6%9A%AB%E5%81%9C%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">Create React App (CRA) 已經被淘汰，官網暫停更新</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BC%83%E8%A1%A8%E6%A0%BC\"><span class=\"toc-text\">比較表格</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#npm-start-%E8%88%87-npm-build-%E8%A3%9C%E5%85%85%E8%AA%AA%E6%98%8E\"><span class=\"toc-text\">npm start 與 npm build 補充說明</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-start\"><span class=\"toc-text\">npm start</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#npm-build\"><span class=\"toc-text\">npm build</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">使用方式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85\"><span class=\"toc-text\">注意事項</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React-%E5%85%83%E4%BB%B6%E5%91%BD%E5%90%8D%E8%A6%8F%E5%89%87\"><span class=\"toc-text\">React 元件命名規則</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%82%BA%E4%BB%80%E9%BA%BC%E8%A6%81%E5%A4%A7%E5%AF%AB%E9%96%8B%E9%A0%AD%EF%BC%9F\"><span class=\"toc-text\">為什麼要大寫開頭？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AF%84%E4%BE%8B\"><span class=\"toc-text\">範例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%91%BD%E5%90%8D%E9%A2%A8%E6%A0%BC\"><span class=\"toc-text\">命名風格</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9B%E6%93%AC-DOM-%E8%88%87%E7%9C%9F%E5%AF%A6-DOM-%E8%BD%89%E6%8F%9B%E9%81%8E%E7%A8%8B\"><span class=\"toc-text\">虛擬 DOM 與真實 DOM 轉換過程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React-%E5%9B%9B%E7%A8%AE%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84-Hooks\"><span class=\"toc-text\">React 四種最基本的 Hooks</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#React-Hooks-%E8%A7%A3%E9%87%8B\"><span class=\"toc-text\">React Hooks 解釋</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-useState\"><span class=\"toc-text\">1. useState</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-useEffect\"><span class=\"toc-text\">2. useEffect</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-useContext\"><span class=\"toc-text\">3. useContext</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-useReducer\"><span class=\"toc-text\">4. useReducer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Hooks-%E7%9A%84%E5%84%AA%E5%8B%A2\"><span class=\"toc-text\">Hooks 的優勢</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Accessibility-a11y\"><span class=\"toc-text\">Accessibility (a11y)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%9C%89%E6%84%8F%E7%BE%A9%E7%9A%84-HTML\"><span class=\"toc-text\">1. 有意義的 HTML</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%A1%A8%E5%96%AE%E5%8F%AF%E5%8F%8A%E6%80%A7\"><span class=\"toc-text\">2. 表單可及性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E9%8D%B5%E7%9B%A4%E5%B0%8E%E8%88%AA\"><span class=\"toc-text\">3. 鍵盤導航</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%B0%8D%E6%AF%94%E5%BA%A6\"><span class=\"toc-text\">4. 對比度</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E7%84%A1%E9%9A%9C%E7%A4%99%E7%9A%84%E5%A4%9A%E5%AA%92%E9%AB%94%E5%85%A7%E5%AE%B9\"><span class=\"toc-text\">5. 無障礙的多媒體內容</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E7%84%A6%E9%BB%9E%E5%8F%AF%E8%A6%8B%E6%80%A7\"><span class=\"toc-text\">6. 焦點可見性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E5%8B%95%E6%85%8B%E5%85%A7%E5%AE%B9%E7%9A%84%E5%8F%AF%E8%A8%AA%E5%95%8F%E6%80%A7\"><span class=\"toc-text\">7. 動態內容的可訪問性</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E2%80%9CHTML-in-JS%E2%80%9D-%E5%92%8C-%E2%80%9CCSS-in-JS%E2%80%9D\"><span class=\"toc-text\">“HTML in JS” 和 “CSS in JS”</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HTML-in-JS%EF%BC%9A\"><span class=\"toc-text\">HTML in JS：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CSS-in-JS%EF%BC%9A\"><span class=\"toc-text\">CSS in JS：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%99%9B%E6%93%AC-DOM%EF%BC%88Virtual-DOM%EF%BC%89\"><span class=\"toc-text\">虛擬 DOM（Virtual DOM）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">工作原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%84%AA%E5%8B%A2\"><span class=\"toc-text\">優勢</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JSX%EF%BC%88JavaScript-XML%EF%BC%89%E8%A7%A3%E9%87%8B\"><span class=\"toc-text\">JSX（JavaScript XML）解釋</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E8%A6%81%E7%89%B9%E9%BB%9E%E5%92%8C%E8%AA%9E%E6%B3%95%E8%A7%A3%E9%87%8B\"><span class=\"toc-text\">主要特點和語法解釋</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%B5%8C%E5%85%A5-JavaScript-%E8%A1%A8%E9%81%94%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">1. 嵌入 JavaScript 表達式：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%89%B5%E5%BB%BA%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">2. 創建元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%B1%AC%E6%80%A7%EF%BC%9A\"><span class=\"toc-text\">3. 屬性：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E5%AD%90%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">4. 子元素：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E6%A2%9D%E4%BB%B6%E6%B8%B2%E6%9F%93%EF%BC%9A\"><span class=\"toc-text\">5. 條件渲染：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%EF%BC%9A\"><span class=\"toc-text\">6. 列表渲染：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JSX-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85\"><span class=\"toc-text\">JSX 注意事項</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%8C%85%E8%A3%9D%E5%85%83%E7%B4%A0%EF%BC%9A\"><span class=\"toc-text\">1. 包裝元素：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8-className%EF%BC%9A\"><span class=\"toc-text\">2. 使用 className：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%B1%AC%E6%80%A7%E5%90%8D%E7%A8%B1%E4%BD%BF%E7%94%A8-camelCase%EF%BC%9A\"><span class=\"toc-text\">3. 屬性名稱使用 camelCase：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E8%87%AA%E9%96%89%E5%90%88%E6%A8%99%E7%B1%A4%EF%BC%9A\"><span class=\"toc-text\">4. 自閉合標籤：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%A1%A8%E9%81%94%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85%EF%BC%9A\"><span class=\"toc-text\">5. 表達式中的注意事項：</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#React-Fragments\"><span class=\"toc-text\">React Fragments</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F-1\"><span class=\"toc-text\">使用方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E4%BD%BF%E7%94%A8-lt-React-Fragment-gt-%EF%BC%9A\"><span class=\"toc-text\">1. 使用 &lt;React.Fragment&gt;：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E7%B0%A1%E5%8C%96-lt-gt-lt-x2F-gt-%E8%AA%9E%E6%B3%95%EF%BC%88%E5%83%85%E5%9C%A8-React-16-2-0-%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E6%94%AF%E6%8F%B4%EF%BC%89%EF%BC%9A\"><span class=\"toc-text\">2. 簡化 &lt;&gt;&lt;&#x2F;&gt; 語法（僅在 React 16.2.0 以上版本支援）：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%84%AA%E5%8B%A2-1\"><span class=\"toc-text\">優勢</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85-1\"><span class=\"toc-text\">注意事項</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Node-js-%E6%A8%A1%E7%B5%84%E7%B3%BB%E7%B5%B1\"><span class=\"toc-text\">Node.js 模組系統</span></a></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"./source/img/1.jpg","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"240125React零碎知識點","uid":"2c4df57117660657820746cd0823ec89","slug":"240125React零碎知識點","date":"2024-01-25T12:35:16.000Z","updated":"2024-01-27T11:31:08.606Z","comments":true,"path":"api/articles/240125React零碎知識點.json","keywords":null,"cover":null,"text":"在 React 應用程式部署前的檔案和資料夾清理在 React 應用程式的開發過程中，有一些檔案和資料夾是開發時使用的，但在最終的發布版本中並不需要包含。在進行壓縮、打包或部署到生產環境時，建議考慮刪除以下檔案和資料夾： 1. package-lock.json：package-...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":3,"path":"api/categories/React.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"./source/img/1.jpg","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"240127前期練習-建立開發環境","uid":"0634d188a86a5b5d91c4c97fbcbf73a7","slug":"240124前期練習-建立開發環境","date":"2024-01-24T11:24:33.000Z","updated":"2024-01-27T11:26:07.188Z","comments":true,"path":"api/articles/240124前期練習-建立開發環境.json","keywords":null,"cover":null,"text":"前期練習 - 建立開發環境Github Repo 注意: 是用 branch(分支)的同一 repo 的協作者進行方式，並非 fork(分叉)，分叉的管理流程會較複雜不同。 建立一個共同 repo，每個組員區分分支(branch) 建立自己私有的數個 repo，主要作測試，或前期...","link":"","photos":[],"count_time":{"symbolsCount":924,"symbolsTime":"1 mins."},"categories":[{"name":"github","slug":"github","count":2,"path":"api/categories/github.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"./source/img/1.jpg","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}