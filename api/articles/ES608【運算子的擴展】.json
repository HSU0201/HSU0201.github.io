{"title":"運算子的擴展","uid":"c288451229d981ac1c523a14e9961496","slug":"ES608【運算子的擴展】","date":"2024-01-24T00:06:25.000Z","updated":"2024-02-05T00:37:28.716Z","comments":true,"path":"api/articles/ES608【運算子的擴展】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","content":"<h1 id=\"08【運算子的擴展】\"><a href=\"#08【運算子的擴展】\" class=\"headerlink\" title=\"08【運算子的擴展】\"></a>08【運算子的擴展】</h1><h2 id=\"1-指數運算子-Exponentiation-Operator\"><a href=\"#1-指數運算子-Exponentiation-Operator\" class=\"headerlink\" title=\"1.指數運算子(Exponentiation Operator)\"></a>1.指數運算子(Exponentiation Operator)</h2><p>ES2016 新增了一個指數運算子（<code>**</code>）。</p>\n<p><strong>指數的基本運算</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span>; <span class=\"comment\">// 8</span></span><br><span class=\"line\"><span class=\"number\">3</span> ** <span class=\"number\">2</span>; <span class=\"comment\">// 9</span></span><br><span class=\"line\"><span class=\"number\">3</span> ** <span class=\"number\">2.5</span>; <span class=\"comment\">// 15.588457268119896</span></span><br><span class=\"line\"><span class=\"number\">10</span> ** -<span class=\"number\">1</span>; <span class=\"comment\">// 0.1</span></span><br><span class=\"line\"><span class=\"title class_\">NaN</span> ** <span class=\"number\">2</span>; <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-1-指數運算子（-）會回傳以第一個數字作為底數；第二個數字做為指數的運算結果。\"><a href=\"#1-1-指數運算子（-）會回傳以第一個數字作為底數；第二個數字做為指數的運算結果。\" class=\"headerlink\" title=\"1.1 指數運算子（**）會回傳以第一個數字作為底數；第二個數字做為指數的運算結果。\"></a>1.1 指數運算子（<code>**</code>）會回傳以第一個數字作為底數；第二個數字做為指數的運算結果。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">2</span>; <span class=\"comment\">// Expected output: 4</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** <span class=\"number\">3</span>; <span class=\"comment\">// Expected output: 8</span></span><br><span class=\"line\"><span class=\"number\">3</span> ** <span class=\"number\">4</span>; <span class=\"comment\">// Expected output: 81</span></span><br><span class=\"line\"><span class=\"number\">10</span> ** -<span class=\"number\">2</span>; <span class=\"comment\">// Expected output: 0.01</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-right-associative\"><a href=\"#1-2-right-associative\" class=\"headerlink\" title=\"1.2 right-associative\"></a>1.2 right-associative</h3><p>這個運算子的一個特點是右結合 (right-associative)，而不是常見的左結合。多個指數運算子連用時，是從最右邊開始計算的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// a ** b ** c  相當於   a ** (b ** c)</span></span><br><span class=\"line\"><span class=\"comment\">// 相當於 2 ** (3 ** 2)</span></span><br><span class=\"line\"><span class=\"number\">2</span> ** (<span class=\"number\">3</span> ** <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 512</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，首先計算的是第二個指數運算子，而不是第一個。</p>\n<h3 id=\"1-3-指數運算子可以與等號結合，形成一個新的賦值運算子（-）。\"><a href=\"#1-3-指數運算子可以與等號結合，形成一個新的賦值運算子（-）。\" class=\"headerlink\" title=\"1.3 指數運算子可以與等號結合，形成一個新的賦值運算子（**=）。\"></a>1.3 指數運算子可以與等號結合，形成一個新的賦值運算子（<code>**=</code>）。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1.5</span>;</span><br><span class=\"line\">a **= <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同於 a = a * a;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">4</span>;</span><br><span class=\"line\">b **= <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同於 b = b * b * b;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-4-與一元運算子一同使用\"><a href=\"#1-4-與一元運算子一同使用\" class=\"headerlink\" title=\"1.4 與一元運算子一同使用\"></a>1.4 與一元運算子一同使用</h3><p><strong>反轉指數運算結果之正負：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-(<span class=\"number\">2</span> ** <span class=\"number\">2</span>); <span class=\"comment\">// -4</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>計算底數為負數的指數運算：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(-<span class=\"number\">2</span>) ** <span class=\"number\">2</span>; <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-可選串連運算子-Optional-chaining-operator\"><a href=\"#2-可選串連運算子-Optional-chaining-operator\" class=\"headerlink\" title=\"2.可選串連運算子(Optional chaining operator)\"></a>2.可選串連運算子(Optional chaining operator)</h2><p>在許多程式語言中，當我們嘗試存取一個物件的屬性或方法時，如果該物件為 <code>null</code> 或 <code>undefined</code>，就會引發錯誤。為了避免這種情況，我們通常需要額外進行多層的存在性檢查來檢查物件是否存在，這樣會使程式碼變得冗長且難以閱讀。</p>\n<p>可選串連運算子的出現解決了這個問題。它允許我們在存取物件屬性或方法時，同時進行存在性檢查，如果物件為 <code>null</code> 或 <code>undefined</code>，則返回 <code>undefined</code> 而不是拋出錯誤。這樣我們就可以在不必添加額外檢查程式碼的情況下，安全地存取物件屬性或方法。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可選串連運算子可讓程式碼在存取可能不存在的屬性時更加安全，減少了因為<strong>屬性不存在</strong>而引發的錯誤，使程式碼更具可靠性。</p></blockquote>\n<h3 id=\"2-1-不使用-運算子的存在性檢查校驗方法\"><a href=\"#2-1-不使用-運算子的存在性檢查校驗方法\" class=\"headerlink\" title=\"2.1 不使用?.運算子的存在性檢查校驗方法\"></a>2.1 不使用<code>?.</code>運算子的存在性檢查校驗方法</h3><p>以 <code>message.body.user.firstName</code> 為例，為了安全地取得 <code>firstName</code> 屬性，傳統做法需要進行多次層層判斷，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 錯誤的寫法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstName = message.<span class=\"property\">body</span>.<span class=\"property\">user</span>.<span class=\"property\">firstName</span> || <span class=\"string\">&quot;default&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正確的寫法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> firstName =</span><br><span class=\"line\">  (message &amp;&amp;</span><br><span class=\"line\">    message.<span class=\"property\">body</span> &amp;&amp;</span><br><span class=\"line\">    message.<span class=\"property\">body</span>.<span class=\"property\">user</span> &amp;&amp;</span><br><span class=\"line\">    message.<span class=\"property\">body</span>.<span class=\"property\">user</span>.<span class=\"property\">firstName</span>) ||</span><br><span class=\"line\">  <span class=\"string\">&quot;default&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，<code>firstName</code>屬性在物件的第四層，所以需要判斷四次，每一層是否有值。<br>為了簡化這種層層判斷的過程，JavaScript 引入了可選串連運算子 <code>?.</code>。</p>\n<h3 id=\"2-2-利用-運算子的方式簡化三元運算子的寫法\"><a href=\"#2-2-利用-運算子的方式簡化三元運算子的寫法\" class=\"headerlink\" title=\"2.2 利用?.運算子的方式簡化三元運算子的寫法\"></a>2.2 利用?.運算子的方式簡化三元運算子的寫法</h3><p>[補充]<strong>三元運算子<code>?:</code>也常用於判斷物件是否存在。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fooInput = myForm.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;input[name=foo]&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fooValue = fooInput ? fooInput.<span class=\"property\">value</span> : <span class=\"literal\">undefined</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，必須先判斷<code>fooInput</code>是否存在，才能讀取<code>fooInput.value</code>。</p>\n<p><strong>利用<code>?.</code>運算子的方式簡化三元運算子的寫法</strong></p>\n<p>這樣的層層判斷非常麻煩，因此 ES2020 引入了“可選串連運算子”（optional chaining operator）<code>?.</code>，簡化上面的寫法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> firstName = message?.<span class=\"property\">body</span>?.<span class=\"property\">user</span>?.<span class=\"property\">firstName</span> || <span class=\"string\">&quot;default&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fooValue = myForm.<span class=\"title function_\">querySelector</span>(<span class=\"string\">&quot;input[name=foo]&quot;</span>)?.<span class=\"property\">value</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼使用了<code>?.</code>運算子，直接在鏈式執行的時候判斷，左側的物件是否為<code>null</code>或<code>undefined</code>。如果是的，就不再往下運算，而是返回<code>undefined</code>。</p>\n<h3 id=\"2-3-其他場景下的可選串連運算子應用\"><a href=\"#2-3-其他場景下的可選串連運算子應用\" class=\"headerlink\" title=\"2.3 其他場景下的可選串連運算子應用\"></a>2.3 其他場景下的可選串連運算子應用</h3><p>可選串連運算子不僅僅用於屬性存取，還可以應用在方法的執行上，尤其是在判斷方法是否存在並立即執行的場景下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iterator.<span class=\"property\">return</span>?.();</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，<code>iterator.return</code>如果有定義，就會執行該方法，否則<code>iterator.return</code>直接返回<code>undefined</code>，不再執行<code>?.</code>後面的部分。這對於可能存在或不存在的方法，尤其有用。</p>\n<h3 id=\"2-4-使用可選串連運算子進行可能校驗失敗的方法\"><a href=\"#2-4-使用可選串連運算子進行可能校驗失敗的方法\" class=\"headerlink\" title=\"2.4 使用可選串連運算子進行可能校驗失敗的方法\"></a>2.4 使用可選串連運算子進行可能校驗失敗的方法</h3><p>對於那些可能沒有實現的方法，這個運算子尤其有用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (myForm.<span class=\"property\">checkValidity</span>?.() === <span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 表單校驗失敗</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，老式瀏覽器的表單物件可能沒有<code>checkValidity()</code>這個方法，這時<code>?.</code>運算子就會返回<code>undefined</code>，判斷語句就變成了<code>undefined === false</code>，所以就會跳過下面的代碼。</p>\n<h3 id=\"2-5-可選串連運算子-有三種寫法。\"><a href=\"#2-5-可選串連運算子-有三種寫法。\" class=\"headerlink\" title=\"2.5 可選串連運算子?.有三種寫法。\"></a>2.5 可選串連運算子<code>?.</code>有三種寫法。</h3><ul>\n<li><code>obj?.prop</code> &#x2F;&#x2F; 物件屬性是否存在</li>\n<li><code>obj?.[expr]</code> &#x2F;&#x2F; 同上</li>\n<li><code>func?.(...args)</code> &#x2F;&#x2F; 函式或物件方法是否存在</li>\n</ul>\n<p>下面是<code>obj?.[expr]</code>用法的一個例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> hex = <span class=\"string\">&quot;#C0FFEE&quot;</span>.<span class=\"title function_\">match</span>(<span class=\"regexp\">/#([A-Z]+)/i</span>)?.[<span class=\"number\">1</span>];</span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，字符串的<code>match()</code>方法，如果沒有發現匹配會返回<code>null</code>，如果發現匹配會返回一個陣列，<code>?.</code>運算子起到了判斷作用。</p>\n<h3 id=\"2-6-運算子常見形式及等價形式\"><a href=\"#2-6-運算子常見形式及等價形式\" class=\"headerlink\" title=\"2.6 ?.運算子常見形式及等價形式\"></a>2.6 <code>?.</code>運算子常見形式及等價形式</h3><p><code>?.</code>運算子有幾種常見形式，以及等價的非簡寫形式，如下所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a?.<span class=\"property\">b</span>;</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.<span class=\"property\">b</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">a?.[x];</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a[x];</span><br><span class=\"line\"></span><br><span class=\"line\">a?.<span class=\"title function_\">b</span>();</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.<span class=\"title function_\">b</span>();</span><br><span class=\"line\"><span class=\"comment\">// 即使 `a?.b()` 中的 `a` 存在且 `b` 屬性存在，但如果 `b` 不是一個函式，那麼調用 `a?.b()` 就會引發錯誤。</span></span><br><span class=\"line\"></span><br><span class=\"line\">a?.();</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : <span class=\"title function_\">a</span>();</span><br><span class=\"line\"><span class=\"comment\">// 使用 `a?.()` 來調用函式，如果 `a` 存在但不是一個函式，也會報錯。</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>注意事項：</strong></p>\n<ol>\n<li><code>a?.b()</code>運算子：</li>\n</ol>\n<ul>\n<li>如果 <code>a</code> 不是 <code>null</code> 或 <code>undefined</code>，但是 <code>a.b</code> 存在且不是函式，那麼 <code>a?.b()</code> 會報錯。</li>\n<li>這意味著，即使 <code>a</code> 不是 <code>null</code> 或 <code>undefined</code>，但是 <code>b</code> 屬性不是一個可調用的函式，也會導致錯誤。</li>\n</ul>\n<ol start=\"2\">\n<li><code>a?.()</code>運算子：</li>\n</ol>\n<ul>\n<li>如果 <code>a</code> 不是 <code>null</code> 或 <code>undefined</code>，但也不是一個函式，那麼 <code>a?.()</code> 會報錯。</li>\n<li>這意味著，即使 <code>a</code> 存在，但是它並不是一個可以調用的函式，使用 <code>a?.()</code> 也會引發錯誤。</li>\n</ul>\n<h3 id=\"使用-運算子的注意點。\"><a href=\"#使用-運算子的注意點。\" class=\"headerlink\" title=\"使用?.運算子的注意點。\"></a>使用<code>?.</code>運算子的注意點。</h3><p>（1）短路機製(Short-circuiting)</p>\n<p>本質上，<code>?.</code>運算子相當於一種短路機製，只要不滿足條件，就不再往下執行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a?.[++x];</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a[++x];</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那麼<code>x</code>不會進行遞增運算。也就是說，可選串連運算子一旦為真，右側的表達式就不再求值。</p>\n<p>（2）括號的影響</p>\n<p>如果屬性鏈有圓括號，可選串連運算子對圓括號外部沒有影響，只對圓括號內部有影響。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a?.<span class=\"property\">b</span>).<span class=\"title function_\">c</span>(</span><br><span class=\"line\">  <span class=\"comment\">// 等價於</span></span><br><span class=\"line\">  a == <span class=\"literal\">null</span> ? <span class=\"literal\">undefined</span> : a.<span class=\"property\">b</span></span><br><span class=\"line\">).<span class=\"property\">c</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，<code>?.</code>對圓括號外部沒有影響，不管<code>a</code>物件是否存在，圓括號後面的<code>.c</code>總是會執行。</p>\n<p>一般來說，使用<code>?.</code>運算子的場合，不應該使用圓括號。</p>\n<p>（3）報錯場合</p>\n<p>以下寫法是禁止的，會報錯。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 構造函式</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> a?.()</span><br><span class=\"line\"><span class=\"keyword\">new</span> a?.<span class=\"title function_\">b</span>()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可選串連運算子的右側有模板字符串</span></span><br><span class=\"line\">a?.<span class=\"string\">`&#123;b&#125;`</span></span><br><span class=\"line\">a?.<span class=\"property\">b</span><span class=\"string\">`&#123;c&#125;`</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可選串連運算子的左側是 super</span></span><br><span class=\"line\"><span class=\"variable language_\">super</span>?.()</span><br><span class=\"line\"><span class=\"variable language_\">super</span>?.<span class=\"property\">foo</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 鏈運算子用於賦值運算子左側</span></span><br><span class=\"line\">a?.<span class=\"property\">b</span> = c</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-空值合併運算子-Nullish-coalescing-operator\"><a href=\"#3-空值合併運算子-Nullish-coalescing-operator\" class=\"headerlink\" title=\"3.空值合併運算子(Nullish coalescing operator)\"></a>3.空值合併運算子(Nullish coalescing operator)</h2><p><code>??</code> 運算子是 ES2020 中引入的 Nullish Coalescing Operator，用於設置預設值，僅在左側的值為<code>null</code>或<code>undefined</code> 時，才會返回右側的值。</p>\n<h3 id=\"3-1-使用-運算子的原因\"><a href=\"#3-1-使用-運算子的原因\" class=\"headerlink\" title=\"3.1 使用 ?? 運算子的原因\"></a>3.1 使用 <code>??</code> 運算子的原因</h3><p>前三行代碼透過<code>||</code>運算子指定預設值，但是這樣寫會與開發者的原意不同。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>開發者的原意是，只要屬性的值為<code>null</code>或<code>undefined</code>，預設值就會生效，但是屬性的值如果為空字符串或<code>false</code>或<code>0</code>，預設值也會生效。</p></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通過`||`運算子指定預設值(錯誤寫法)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> headerText = response.<span class=\"property\">settings</span>.<span class=\"property\">headerText</span> || <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> animationDuration = response.<span class=\"property\">settings</span>.<span class=\"property\">animationDuration</span> || <span class=\"number\">300</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> showSplashScreen = response.<span class=\"property\">settings</span>.<span class=\"property\">showSplashScreen</span> || <span class=\"literal\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用空值合併運算子`??`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> headerText = response.<span class=\"property\">settings</span>.<span class=\"property\">headerText</span> ?? <span class=\"string\">&quot;Hello, world!&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> animationDuration = response.<span class=\"property\">settings</span>.<span class=\"property\">animationDuration</span> ?? <span class=\"number\">300</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> showSplashScreen = response.<span class=\"property\">settings</span>.<span class=\"property\">showSplashScreen</span> ?? <span class=\"literal\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>為了避免這種情況，使用空值合併運算子<code>??</code>。它的行為類似<code>||</code>，但是只有運算子左側的值為<code>null</code>或<code>undefined</code>時，才會返回右側的值。</p>\n<p>上面代碼中，預設值只有在左側屬性值為<code>null</code>或<code>undefined</code>時，才會生效。</p>\n<h3 id=\"3-2-運算子與-運算子的結合使用\"><a href=\"#3-2-運算子與-運算子的結合使用\" class=\"headerlink\" title=\"3.2 ?? 運算子與 ?. 運算子的結合使用\"></a>3.2 <code>??</code> 運算子與 <code>?.</code> 運算子的結合使用</h3><p><code>??</code> 運算子跟可選串連運算子<code>?.</code>配合使用，為<code>null</code>或<code>undefined</code>的值設定預設值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animationDuration = response.<span class=\"property\">settings</span>?.<span class=\"property\">animationDuration</span> ?? <span class=\"number\">300</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，如果<code>response.settings</code>是<code>null</code>或<code>undefined</code>，或者<code>response.settings.animationDuration</code>是<code>null</code>或<code>undefined</code>，就會返回預設值 300。也就是說，這一行代碼包括了兩級屬性的判斷。</p>\n<h3 id=\"3-3-運算子在函數參數中的應用\"><a href=\"#3-3-運算子在函數參數中的應用\" class=\"headerlink\" title=\"3.3 ?? 運算子在函數參數中的應用\"></a>3.3 <code>??</code> 運算子在函數參數中的應用</h3><p><code>??</code> 運算子也適用於判斷函數參數是否賦值，並設置默認值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Component</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> enable = props.<span class=\"property\">enabled</span> ?? <span class=\"literal\">true</span>;</span><br><span class=\"line\">  <span class=\"comment\">// …</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼判斷<code>props</code>參數的<code>enabled</code>屬性是否賦值，基本等同於下面的寫法。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Component</span>(<span class=\"params\">props</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; <span class=\"attr\">enabled</span>: enable = <span class=\"literal\">true</span> &#125; = props;</span><br><span class=\"line\">  <span class=\"comment\">// …</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-優先級和使用括號\"><a href=\"#3-4-優先級和使用括號\" class=\"headerlink\" title=\"3.4 優先級和使用括號\"></a>3.4 優先級和使用括號</h3><p><code>??</code>本質上是邏輯運算，它與其他兩個邏輯運算子<code>&amp;&amp;</code>和<code>||</code>有一個優先級問題，它們之間的優先級到底孰高孰低。優先級的不同，往往會導致邏輯運算的結果不同。</p>\n<p>如果同時使用多個邏輯運算子，應該使用括號來明確指定優先級，以避免混淆和報錯。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 報錯</span></span><br><span class=\"line\">lhs &amp;&amp; middle ?? rhs</span><br><span class=\"line\">lhs ?? middle &amp;&amp; rhs</span><br><span class=\"line\">lhs || middle ?? rhs</span><br><span class=\"line\">lhs ?? middle || rhs</span><br></pre></td></tr></table></figure>\n\n<p>上面四個表達式都會報錯，必須加入表明優先級的括號。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(lhs &amp;&amp; middle) ?? rhs;</span><br><span class=\"line\">lhs &amp;&amp; (middle ?? rhs);</span><br><span class=\"line\"></span><br><span class=\"line\">(lhs ?? middle) &amp;&amp; rhs;</span><br><span class=\"line\">lhs ?? (middle &amp;&amp; rhs);</span><br><span class=\"line\"></span><br><span class=\"line\">(lhs || middle) ?? rhs;</span><br><span class=\"line\">lhs || (middle ?? rhs);</span><br><span class=\"line\"></span><br><span class=\"line\">(lhs ?? middle) || rhs;</span><br><span class=\"line\">lhs ?? (middle || rhs);</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>空合併運算子的運算子優先順序倒數第五，直接低於 || 並直接高於條件（三元）運算子。</p></blockquote>\n<h3 id=\"3-5-短路機制-Short-circuiting\"><a href=\"#3-5-短路機制-Short-circuiting\" class=\"headerlink\" title=\"3.5 短路機制(Short-circuiting)\"></a>3.5 短路機制(Short-circuiting)</h3><p>與 OR 和 AND 邏輯運算子一樣，如果左側表達式既不是 null 也不是 undefined ，則不會評估右側表達式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">a</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;a was called&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">b</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;b was called&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">c</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;c was called&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;foo&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">a</span>() ?? <span class=\"title function_\">c</span>());</span><br><span class=\"line\"><span class=\"comment\">// 輸出 &quot;a was called&quot; 然後 &quot;c was called&quot; 接著 &quot;foo&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 因為 a() 返回 undefined，所以兩個表達式都被評估</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">b</span>() ?? <span class=\"title function_\">c</span>());</span><br><span class=\"line\"><span class=\"comment\">// 輸出 &quot;b was called&quot; 然後 &quot;false&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 因為 b() 返回 false（而不是 null 或 undefined），右邊的表達式沒有被評估</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-邏輯賦值運算子\"><a href=\"#4-邏輯賦值運算子\" class=\"headerlink\" title=\"4.邏輯賦值運算子\"></a>4.邏輯賦值運算子</h2><p>ES2021 引入了三個新的邏輯賦值運算子（logical assignment operators），將邏輯運算子與賦值運算子進行結合。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 或賦值運算子</span></span><br><span class=\"line\">x ||= y;</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">x || (x = y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 與賦值運算子</span></span><br><span class=\"line\">x &amp;&amp;= y;</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">x &amp;&amp; (x = y);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Null 賦值運算子</span></span><br><span class=\"line\">x ??= y;</span><br><span class=\"line\"><span class=\"comment\">// 等同於</span></span><br><span class=\"line\">x ?? (x = y);</span><br></pre></td></tr></table></figure>\n\n<p>這三個運算子<code>||=</code>、<code>&amp;&amp;=</code>、<code>??=</code>相當於先進行邏輯運算，然後根據運算結果，再視情況進行賦值運算。</p>\n<p>它們的一個用途是，為變量或屬性設定預設值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 老的寫法</span></span><br><span class=\"line\">user.<span class=\"property\">id</span> = user.<span class=\"property\">id</span> || <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 新的寫法</span></span><br><span class=\"line\">user.<span class=\"property\">id</span> ||= <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n\n<p>上面示例中，<code>user.id</code>屬性如果不存在，則設為<code>1</code>，新的寫法比老的寫法更緊湊一些。</p>\n<p>下面是另一個例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\">opts</span>) &#123;</span><br><span class=\"line\">  opts.<span class=\"property\">foo</span> = opts.<span class=\"property\">foo</span> ?? <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">  opts.<span class=\"property\">baz</span> ?? (opts.<span class=\"property\">baz</span> = <span class=\"string\">&quot;qux&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面示例中，參數物件<code>opts</code>如果不存在屬性<code>foo</code>和屬性<code>baz</code>，則為這兩個屬性設定預設值。有了“Null 賦值運算子”以後，就可以統一寫成下面這樣。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">example</span>(<span class=\"params\">opts</span>) &#123;</span><br><span class=\"line\">  opts.<span class=\"property\">foo</span> ??= <span class=\"string\">&quot;bar&quot;</span>;</span><br><span class=\"line\">  opts.<span class=\"property\">baz</span> ??= <span class=\"string\">&quot;qux&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","feature":null,"text":"08【運算子的擴展】1.指數運算子(Exponentiation Operator)ES2016 新增了一個指數運算子（**）。 指數的基本運算 123452 ...","permalink":"/post/ES608【運算子的擴展】","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#08%E3%80%90%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E6%93%B4%E5%B1%95%E3%80%91\"><span class=\"toc-text\">08【運算子的擴展】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E6%8C%87%E6%95%B8%E9%81%8B%E7%AE%97%E5%AD%90-Exponentiation-Operator\"><span class=\"toc-text\">1.指數運算子(Exponentiation Operator)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E6%8C%87%E6%95%B8%E9%81%8B%E7%AE%97%E5%AD%90%EF%BC%88-%EF%BC%89%E6%9C%83%E5%9B%9E%E5%82%B3%E4%BB%A5%E7%AC%AC%E4%B8%80%E5%80%8B%E6%95%B8%E5%AD%97%E4%BD%9C%E7%82%BA%E5%BA%95%E6%95%B8%EF%BC%9B%E7%AC%AC%E4%BA%8C%E5%80%8B%E6%95%B8%E5%AD%97%E5%81%9A%E7%82%BA%E6%8C%87%E6%95%B8%E7%9A%84%E9%81%8B%E7%AE%97%E7%B5%90%E6%9E%9C%E3%80%82\"><span class=\"toc-text\">1.1 指數運算子（**）會回傳以第一個數字作為底數；第二個數字做為指數的運算結果。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-right-associative\"><span class=\"toc-text\">1.2 right-associative</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E6%8C%87%E6%95%B8%E9%81%8B%E7%AE%97%E5%AD%90%E5%8F%AF%E4%BB%A5%E8%88%87%E7%AD%89%E8%99%9F%E7%B5%90%E5%90%88%EF%BC%8C%E5%BD%A2%E6%88%90%E4%B8%80%E5%80%8B%E6%96%B0%E7%9A%84%E8%B3%A6%E5%80%BC%E9%81%8B%E7%AE%97%E5%AD%90%EF%BC%88-%EF%BC%89%E3%80%82\"><span class=\"toc-text\">1.3 指數運算子可以與等號結合，形成一個新的賦值運算子（**&#x3D;）。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E8%88%87%E4%B8%80%E5%85%83%E9%81%8B%E7%AE%97%E5%AD%90%E4%B8%80%E5%90%8C%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">1.4 與一元運算子一同使用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%8F%AF%E9%81%B8%E4%B8%B2%E9%80%A3%E9%81%8B%E7%AE%97%E5%AD%90-Optional-chaining-operator\"><span class=\"toc-text\">2.可選串連運算子(Optional chaining operator)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E4%B8%8D%E4%BD%BF%E7%94%A8-%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E5%AD%98%E5%9C%A8%E6%80%A7%E6%AA%A2%E6%9F%A5%E6%A0%A1%E9%A9%97%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.1 不使用?.運算子的存在性檢查校驗方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%88%A9%E7%94%A8-%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E6%96%B9%E5%BC%8F%E7%B0%A1%E5%8C%96%E4%B8%89%E5%85%83%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E5%AF%AB%E6%B3%95\"><span class=\"toc-text\">2.2 利用?.運算子的方式簡化三元運算子的寫法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%85%B6%E4%BB%96%E5%A0%B4%E6%99%AF%E4%B8%8B%E7%9A%84%E5%8F%AF%E9%81%B8%E4%B8%B2%E9%80%A3%E9%81%8B%E7%AE%97%E5%AD%90%E6%87%89%E7%94%A8\"><span class=\"toc-text\">2.3 其他場景下的可選串連運算子應用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E4%BD%BF%E7%94%A8%E5%8F%AF%E9%81%B8%E4%B8%B2%E9%80%A3%E9%81%8B%E7%AE%97%E5%AD%90%E9%80%B2%E8%A1%8C%E5%8F%AF%E8%83%BD%E6%A0%A1%E9%A9%97%E5%A4%B1%E6%95%97%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.4 使用可選串連運算子進行可能校驗失敗的方法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E5%8F%AF%E9%81%B8%E4%B8%B2%E9%80%A3%E9%81%8B%E7%AE%97%E5%AD%90-%E6%9C%89%E4%B8%89%E7%A8%AE%E5%AF%AB%E6%B3%95%E3%80%82\"><span class=\"toc-text\">2.5 可選串連運算子?.有三種寫法。</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E9%81%8B%E7%AE%97%E5%AD%90%E5%B8%B8%E8%A6%8B%E5%BD%A2%E5%BC%8F%E5%8F%8A%E7%AD%89%E5%83%B9%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">2.6 ?.運算子常見形式及等價形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E6%B3%A8%E6%84%8F%E9%BB%9E%E3%80%82\"><span class=\"toc-text\">使用?.運算子的注意點。</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E7%A9%BA%E5%80%BC%E5%90%88%E4%BD%B5%E9%81%8B%E7%AE%97%E5%AD%90-Nullish-coalescing-operator\"><span class=\"toc-text\">3.空值合併運算子(Nullish coalescing operator)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E4%BD%BF%E7%94%A8-%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E5%8E%9F%E5%9B%A0\"><span class=\"toc-text\">3.1 使用 ?? 運算子的原因</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E9%81%8B%E7%AE%97%E5%AD%90%E8%88%87-%E9%81%8B%E7%AE%97%E5%AD%90%E7%9A%84%E7%B5%90%E5%90%88%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">3.2 ?? 運算子與 ?. 運算子的結合使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-%E9%81%8B%E7%AE%97%E5%AD%90%E5%9C%A8%E5%87%BD%E6%95%B8%E5%8F%83%E6%95%B8%E4%B8%AD%E7%9A%84%E6%87%89%E7%94%A8\"><span class=\"toc-text\">3.3 ?? 運算子在函數參數中的應用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E5%84%AA%E5%85%88%E7%B4%9A%E5%92%8C%E4%BD%BF%E7%94%A8%E6%8B%AC%E8%99%9F\"><span class=\"toc-text\">3.4 優先級和使用括號</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-5-%E7%9F%AD%E8%B7%AF%E6%A9%9F%E5%88%B6-Short-circuiting\"><span class=\"toc-text\">3.5 短路機制(Short-circuiting)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E9%82%8F%E8%BC%AF%E8%B3%A6%E5%80%BC%E9%81%8B%E7%AE%97%E5%AD%90\"><span class=\"toc-text\">4.邏輯賦值運算子</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ES6 介绍","uid":"1e00bbc5a1a969d8b4414c942e9fedc9","slug":"ES601 【ES6 介绍】","date":"2024-01-24T00:06:25.000Z","updated":"2024-01-30T12:54:52.424Z","comments":true,"path":"api/articles/ES601 【ES6 介绍】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","text":"01 【ES6 介紹】ECMAScript 6.0（以下簡稱 ES6）是 JavaScript 語言的下一代標準，已於 2015 年 6 月正式發布。它的目標是...","permalink":"/post/ES601 【ES6 介绍】","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":29,"path":"api/tags/桃園資展筆記.json"},{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"async 函式","uid":"08a95690396abe22dee79253dd37972c","slug":"ES611【async 函式】","date":"2024-01-24T00:06:25.000Z","updated":"2024-02-04T13:09:43.821Z","comments":true,"path":"api/articles/ES611【async 函式】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/unnamed.png?raw=true","text":"11【async 函式】async 簡介處理 JavaScript 中的異步程序總是需要面臨各種不同應用情況的挑戰。在 ES6(ES2015)中加入的 Prom...","permalink":"/post/ES611【async 函式】","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":29,"path":"api/tags/桃園資展筆記.json"},{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}