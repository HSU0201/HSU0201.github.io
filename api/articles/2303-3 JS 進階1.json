{"title":"JavaScript 進階 - 第1天","uid":"35ba1b013b453118df98cec61f2a93fb","slug":"2303-3 JS 進階1","date":"2023-03-29T01:22:08.000Z","updated":"2023-04-01T13:58:55.500Z","comments":true,"path":"api/articles/2303-3 JS 進階1.json","keywords":null,"cover":null,"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>學習作用域、變數提升、閉包等語言特徵，加深對 JavaScript 的理解，掌握變數賦值、函式宣告的簡潔語法，降低代碼的冗餘度。</p></blockquote>\n<ul>\n<li>理解作用域對程式執行的影響</li>\n<li>能夠分析程式執行的作用域範圍</li>\n<li>理解閉包本質，利用閉包創建隔離作用域</li>\n<li>瞭解什麼變數提升及函數提升</li>\n<li>掌握箭頭函數、解析剩餘參數等簡潔語法</li>\n</ul>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>瞭解作用域對程式執行的影響及作用域鏈的查找機制，使用閉包函數創建隔離作用域避免全域變數污染。</p></blockquote>\n<p>作用域（scope）規定了變數能夠被訪問的“範圍”，離開了這個“範圍”變數便不能被訪問，作用域分為全域作用域和局部作用域。</p>\n<h2 id=\"局部作用域\"><a href=\"#局部作用域\" class=\"headerlink\" title=\"局部作用域\"></a>局部作用域</h2><p>局部作用域分為函數作用域和塊作用域。</p>\n<h3 id=\"函數作用域\"><a href=\"#函數作用域\" class=\"headerlink\" title=\"函數作用域\"></a>函數作用域</h3><p>在函數內部聲明的變數只能在函數內部被訪問，外部無法直接訪問。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 聲明 counter 函數\n  function counter(x, y) &#123;\n    &#x2F;&#x2F; 函數內部聲明的變數\n    const s &#x3D; x + y\n    console.log(s) &#x2F;&#x2F; 18\n  &#125;\n  &#x2F;&#x2F; 設用 counter 函數\n  counter(10, 8)\n  &#x2F;&#x2F; 訪問變數 s\n  console.log(s)&#x2F;&#x2F; 報錯\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>函數內部聲明的變數，在函數外部無法被訪問</li>\n<li>函數的參數也是函數內部的區域變數</li>\n<li>不同函數內部聲明的變數無法互相訪問</li>\n<li>函數執行完畢後，函數內部的變數實際被清空了</li>\n</ol>\n<h3 id=\"塊作用域\"><a href=\"#塊作用域\" class=\"headerlink\" title=\"塊作用域\"></a>塊作用域</h3><p>在 JavaScript 中使用 <code>&#123;&#125;</code> 包裹的代碼稱為代碼塊，代碼塊內部聲明的變數外部將【有可能】無法被訪問。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#123;\n    &#x2F;&#x2F; age 只能在該代碼塊中被訪問\n    let age &#x3D; 18;\n    console.log(age); &#x2F;&#x2F; 正常\n  &#125;\n  \n  &#x2F;&#x2F; 超出了 age 的作用域\n  console.log(age) &#x2F;&#x2F; 報錯\n  \n  let flag &#x3D; true;\n  if(flag) &#123;\n    &#x2F;&#x2F; str 只能在該代碼塊中被訪問\n    let str &#x3D; &#39;hello world!&#39;\n    console.log(str); &#x2F;&#x2F; 正常\n  &#125;\n  \n  &#x2F;&#x2F; 超出了 age 的作用域\n  console.log(str); &#x2F;&#x2F; 報錯\n  \n  for(let t &#x3D; 1; t &lt;&#x3D; 6; t++) &#123;\n    &#x2F;&#x2F; t 只能在該代碼塊中被訪問\n    console.log(t); &#x2F;&#x2F; 正常\n  &#125;\n  \n  &#x2F;&#x2F; 超出了 t 的作用域\n  console.log(t); &#x2F;&#x2F; 報錯\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>JavaScript 中除了變數外還有常量，常量與變數本質的區別是【常量必須要有值且不允許被重新賦值】，常量值為物件時其屬性和方法允許重新賦值。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 必須要有值\n  const version &#x3D; &#39;1.0.0&#39;;\n\n  &#x2F;&#x2F; 不能重新賦值\n  &#x2F;&#x2F; version &#x3D; &#39;1.0.1&#39;;\n\n  &#x2F;&#x2F; 常量值為對象類型\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  &#x2F;&#x2F; 不能重新賦值\n  user &#x3D; &#123;&#125;;\n\n  &#x2F;&#x2F; 屬性和方法允許被修改\n  user.name &#x3D; &#39;小小明&#39;;\n  user.gender &#x3D; &#39;男&#39;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li><code>let</code> 聲明的變數會產生塊作用域，<code>var</code> 不會產生塊作用域</li>\n<li><code>const</code> 聲明的常量也會產生塊作用域</li>\n<li>不同代碼塊之間的變數無法互相訪問</li>\n<li>推薦使用 <code>let</code> 或 <code>const</code></li>\n</ol>\n<p>注：開發中 <code>let</code> 和 <code>const</code> 經常不加區分的使用，如果擔心某個值會不小被修改時，則只能使用 <code>const</code> 聲明成常量。</p>\n<h2 id=\"全域作用域\"><a href=\"#全域作用域\" class=\"headerlink\" title=\"全域作用域\"></a>全域作用域</h2><p><code>&lt;script&gt;</code> 標籤和 <code>.js</code> 檔的【最外層】就是所謂的全域作用域，在此聲明的變數在函數內部也可以被訪問。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 此處是全域\n  \n  function sayHi() &#123;\n    &#x2F;&#x2F; 此處為局部\n  &#125;\n\n  &#x2F;&#x2F; 此處為全域\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>全域作用域中聲明的變數，任何其它作用域都可以被訪問，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n    &#x2F;&#x2F; 全域變數 name\n    const name &#x3D; &#39;小明&#39;\n  \n    &#x2F;&#x2F; 函數作用域中訪問全域\n    function sayHi() &#123;\n      &#x2F;&#x2F; 此處為局部\n      console.log(&#39;你好&#39; + name)\n    &#125;\n\n    &#x2F;&#x2F; 全域變數 flag 和 x\n    const flag &#x3D; true\n    let x &#x3D; 10\n  \n    &#x2F;&#x2F; 塊作用域中訪問全域\n    if(flag) &#123;\n      let y &#x3D; 5\n      console.log(x + y) &#x2F;&#x2F; x 是全域的\n    &#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>為 <code>window</code> 物件動態添加的屬性預設也是全域的，不推薦！</li>\n<li>函數中未使用任何關鍵字聲明的變數為全域變數，不推薦！！！</li>\n<li>盡可能少的聲明全域變數，防止全域變數被污染</li>\n</ol>\n<p>JavaScript 中的作用域是程式被執行時的底層機制，瞭解這一機制有助於規範代碼書寫習慣，避免因作用域導致的語法錯誤。</p>\n<h2 id=\"作用域鏈\"><a href=\"#作用域鏈\" class=\"headerlink\" title=\"作用域鏈\"></a>作用域鏈</h2><p>在解釋什麼是作用域鏈前先來看一段代碼：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 全域作用域\n  let a &#x3D; 1\n  let b &#x3D; 2\n  &#x2F;&#x2F; 局部作用域\n  function f() &#123;\n    let c\n    &#x2F;&#x2F; 局部作用域\n    function g() &#123;\n      let d &#x3D; &#39;yo&#39;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>函數內部允許創建新的函數，<code>f</code> 函數內部創建的新函數 <code>g</code>，會產生新的函數作用域，由此可知作用域產生了嵌套的關係。</p>\n<p>如下圖所示，父子關係的作用域關聯在一起形成了鏈狀的結構，作用域鏈的名字也由此而來。</p>\n<p><strong>作用域鏈本質上是底層的變數查找機制</strong>，在函數被執行時，會優先查找當前函數作用域中查找變數，如果當前作用域查找不到則會<strong>依次逐級查找</strong>父級作用域直到全域作用域，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 全域作用域\n  let a &#x3D; 1\n  let b &#x3D; 2\n\n  &#x2F;&#x2F; 局部作用域\n  function f() &#123;\n    let c\n    &#x2F;&#x2F; let a &#x3D; 10;\n    console.log(a) &#x2F;&#x2F; 1 或 10\n    console.log(d) &#x2F;&#x2F; 報錯\n    \n    &#x2F;&#x2F; 局部作用域\n    function g() &#123;\n      let d &#x3D; &#39;yo&#39;\n      &#x2F;&#x2F; let b &#x3D; 20;\n      console.log(b) &#x2F;&#x2F; 2 或 20\n    &#125;\n    \n    &#x2F;&#x2F; 調用 g 函數\n    g()\n  &#125;\n\n  console.log(c) &#x2F;&#x2F; 報錯\n  console.log(d) &#x2F;&#x2F; 報錯\n  \n  f();\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>嵌套關係的作用域串聯起來形成了作用域鏈</li>\n<li>相同作用域鏈中按著從小到大的規則查找變數</li>\n<li>子作用域能夠訪問父作用域，<strong>父級作用域無法訪問子級作用域</strong></li>\n</ol>\n<h2 id=\"JS垃圾回收機制\"><a href=\"#JS垃圾回收機制\" class=\"headerlink\" title=\"JS垃圾回收機制\"></a>JS垃圾回收機制</h2><p>垃圾回收機制(Garbage Collection) 簡稱 GC<br>JS中內存的分配和回收都是自動完成的，<strong>內存在不使用的時候會被垃圾回收器自動回收。 **<br>如果不了解JS的內存管理機制，我們同樣非常容易成內存洩漏（內存無法被回收）的情況<br><em>不再用到的內存，沒有及時釋放</em>，就叫做**內存洩漏</strong></p>\n<hr>\n<p><strong>內存的生命週期</strong><br>JS環境中分配的內存, 一般有如下生命週期：</p>\n<ol>\n<li>內存分配：當我們聲明變量、函數、對象的時候，系統會自動為他們分配內存</li>\n<li>內存使用：即讀寫內存，也就是使用變量、函數等</li>\n<li>內存回收：使用完畢，由垃圾回收自動回收不再使用的內存</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>說明：</p>\n<ul>\n<li>全局變量一般不會回收(關閉頁面回收)；</li>\n<li>一般情況下局部變量的值, 不用了, 會被自動回收掉</li>\n</ul></blockquote>\n<hr>\n<p><strong>算法說明</strong><br>堆棧空間分配區別：</p>\n<ol>\n<li>棧（操作系統）: 由操作系統自動分配釋放函數的參數值、局部變量等，基本數據類型放到棧裡面。</li>\n<li>堆（操作系統）: 一般由程序員分配釋放，若程序員不釋放，由垃圾回收機制回收。複雜數據類型放到堆裡面。</li>\n</ol>\n<hr>\n<p><strong>常見的瀏覽器垃圾回收算法</strong>: 引用計數法 和 標記清除法</p>\n<p><strong>引用計數</strong><br>IE採用的引用計數算法, 定義“內存不再使用”，就是看一個對像是否有指向它的引用，沒有引用了就回收對象</p>\n<ol>\n<li>跟踪記錄被引用的次數</li>\n<li>如果被引用了一次，那麼就記錄次數1,多次引用會累加 ++</li>\n<li>如果減少一個引用就減1 –</li>\n<li>如果引用次數是0 ，則釋放內存</li>\n</ol>\n<p><strong>標記清除法</strong><br>現代的瀏覽器已經不再使用引用計數算法了。<br>現代瀏覽器通用的大多是基於標記清除算法的某些改進算法，總體思想都是一致的。<br>核心：</p>\n<ol>\n<li>標記清除算法將“<strong>不再使用的對象</strong>”定義為“無法達到的對象”。</li>\n<li>就是從根部（在JS中就是全局對象）出發定時掃描內存中的對象。凡是能從根部到達的對象，都是還需要使用的。</li>\n<li>那些無法由根部出發觸及到的對像被標記為不再使用，稍後進行回收。</li>\n</ol>\n<h2 id=\"閉包\"><a href=\"#閉包\" class=\"headerlink\" title=\"閉包\"></a>閉包</h2><p>閉包是一種比較特殊和函數，使用閉包能夠訪問函數作用域中的變數。從代碼形式上看閉包是一個做為返回值的函數，如下代碼所示：</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>閉包 : 內層函數 + 外層函數變數</p></blockquote>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 閉包 : 內層函數 + 外層函數變數\n    &#x2F;&#x2F; function outer() &#123;\n        &#x2F;&#x2F;外層函數變數\n    &#x2F;&#x2F;   const a &#x3D; 1\n        &#x2F;&#x2F;內層函數\n    &#x2F;&#x2F;   function f() &#123;\n    &#x2F;&#x2F;     console.log(a)\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F;   f()\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; outer()\n\n    &#x2F;&#x2F; 2. 閉包的應用： 統計函數的調用次數\n    &#x2F;&#x2F; let count &#x3D; 1\n    &#x2F;&#x2F; function fn() &#123;\n    &#x2F;&#x2F;   count++\n    &#x2F;&#x2F;   console.log(&#96;函數被調用$&#123;count&#125;次&#96;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F;  因为 count 是全局變量，容易被修改\n\n    &#x2F;&#x2F; 3. 閉包的升級寫法 實現資料的私有。 統計函數的調用次數\n    function outer() &#123;\n      let count &#x3D; 1\n      function fn() &#123;\n        count++\n        console.log(&#96;函數被調用$&#123;count&#125;次&#96;)\n      &#125;\n      return fn\n    &#125;\n    &#x2F;&#x2F;全局~\n    const re &#x3D; outer()\n    &#x2F;&#x2F; const re &#x3D; function fn() &#123;\n    &#x2F;&#x2F;   count++\n    &#x2F;&#x2F;   console.log(&#96;函數被調用$&#123;count&#125;次&#96;)\n    &#x2F;&#x2F; &#125;\n    re()\n    re()\n    &#x2F;&#x2F; const fn &#x3D; function() &#123; &#125;  函數運算式\n    &#x2F;&#x2F; 4. 閉包存在的問題： 可能會造成記憶體洩漏\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<p>總結：</p>\n<p>1.怎麼理解閉包？</p>\n<ul>\n<li>閉包 &#x3D; 內層函數 + 外層函數的變數</li>\n</ul>\n<p>2.閉包的作用？</p>\n<ul>\n<li>封閉資料，實現資料私有，外部也可以訪問函數內部的變數</li>\n<li>閉包很有用，因為它允許將函數與其所操作的某些資料（環境）關聯起來</li>\n</ul>\n<p>3.閉包可能引起的問題？</p>\n<ul>\n<li>記憶體洩漏</li>\n</ul>\n<h2 id=\"變數提升\"><a href=\"#變數提升\" class=\"headerlink\" title=\"變數提升\"></a>變數提升</h2><p>變數提升是 JavaScript 中比較“奇怪”的現象，它允許在變數聲明之前即被訪問，</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 訪問變數 str\n  console.log(str + &#39;world!&#39;);\n\n  &#x2F;&#x2F; 聲明變數 str\n  var str &#x3D; &#39;hello &#39;;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>變數在未聲明即被訪問時會報語法錯誤</li>\n<li>變數在聲明之前即被訪問，變數的值為 <code>undefined</code></li>\n<li><code>let</code> 聲明的變數不存在變數提升，推薦使用 <code>let</code></li>\n<li>變數提升出現在相同作用域當中</li>\n<li>實際開發中推薦先聲明再訪問變數</li>\n</ol>\n<p>注：關於變數提升的原理分析會涉及較為複雜的詞法分析等知識，而開發中使用 <code>let</code> 可以輕鬆規避變數的提升，因此在此不做過多的探討，有興趣可<a href=\"https://segmentfault.com/a/1190000013915935\">查閱資料</a>。</p>\n<h1 id=\"函數\"><a href=\"#函數\" class=\"headerlink\" title=\"函數\"></a>函數</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>知道函數參數預設值、動態參數、剩餘參數的使用細節，提升函數應用的靈活度，知道箭頭函數的語法及與普通函數的差異。</p></blockquote>\n<h2 id=\"函數提升\"><a href=\"#函數提升\" class=\"headerlink\" title=\"函數提升\"></a>函數提升</h2><p>函數提升與變數提升比較類似，是指函數在聲明之前即可被調用。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 調用函數\n  foo()\n  &#x2F;&#x2F; 聲明函數\n  function foo() &#123;\n    console.log(&#39;聲明之前即被調用...&#39;)\n  &#125;\n\n  &#x2F;&#x2F; 不存在提升現象\n  bar()  &#x2F;&#x2F; 錯誤\n  var bar &#x3D; function () &#123;\n    console.log(&#39;函數運算式不存在提升現象...&#39;)\n  &#125;\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>函數提升能夠使函數的聲明調用更靈活</li>\n<li>函數運算式不存在提升的現象</li>\n<li>函數提升出現在相同作用域當中</li>\n</ol>\n<h2 id=\"函數參數\"><a href=\"#函數參數\" class=\"headerlink\" title=\"函數參數\"></a>函數參數</h2><p>函數參數的使用細節，能夠提升函數應用的靈活度。</p>\n<h3 id=\"預設值\"><a href=\"#預設值\" class=\"headerlink\" title=\"預設值\"></a>預設值</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 設置參數預設值\n  function sayHi(name&#x3D;&quot;小明&quot;, age&#x3D;18) &#123;\n    document.write(&#96;&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;歲了。&lt;&#x2F;p&gt;&#96;);\n  &#125;\n  &#x2F;&#x2F; 調用函數\n  sayHi();\n  sayHi(&#39;小紅&#39;);\n  sayHi(&#39;小剛&#39;, 21);\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>聲明函數時為形參賦值即為參數的預設值</li>\n<li>如果參數未自訂預設值時，參數的預設值為 <code>undefined</code></li>\n<li>調用函數時沒有傳入對應實參時，參數的預設值被當做實參傳入</li>\n</ol>\n<h4 id=\"動態參數\"><a href=\"#動態參數\" class=\"headerlink\" title=\"動態參數\"></a>動態參數</h4><p><code>arguments</code> 是函數內部內置的偽陣列變數，它包含了調用函數時傳入的所有實參。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 求生函數，計算所有參數的和\n  function sum() &#123;\n    &#x2F;&#x2F; console.log(arguments)\n    let s &#x3D; 0\n    for(let i &#x3D; 0; i &lt; arguments.length; i++) &#123;\n      s +&#x3D; arguments[i]\n    &#125;\n    console.log(s)\n  &#125;\n  &#x2F;&#x2F; 調用求和函數\n  sum(5, 10)&#x2F;&#x2F; 兩個參數\n  sum(1, 2, 4) &#x2F;&#x2F; 兩個參數\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li><code>arguments</code> 是一個偽陣列</li>\n<li><code>arguments</code> 的作用是動態獲取函數的實參</li>\n</ol>\n<h3 id=\"剩餘參數-與-展開運算符-相似\"><a href=\"#剩餘參數-與-展開運算符-相似\" class=\"headerlink\" title=\"剩餘參數 (與 展開運算符 相似)\"></a>剩餘參數 (與 展開運算符 相似)</h3><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function config(baseURL, ...other) &#123;\n    console.log(baseURL) &#x2F;&#x2F; 得到 &#39;http:&#x2F;&#x2F;baidu.com&#39;\n    console.log(other)  &#x2F;&#x2F; other  得到 [&#39;get&#39;, &#39;json&#39;]\n  &#125;\n  &#x2F;&#x2F; 調用函數\n  config(&#39;http:&#x2F;&#x2F;baidu.com&#39;, &#39;get&#39;, &#39;json&#39;);\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li><code>...</code> 是語法符號，置於最末函數形參之前，用於獲取多餘的實參</li>\n<li>借助 <code>...</code> 獲取的剩餘實參，是個真陣列</li>\n</ol>\n<p><strong>展開運算符 or 剩餘參數</strong><br>剩餘參數：函數參數使用，得到真數組<br>展開運算符：數組中使用，數組展開</p>\n<h2 id=\"箭頭函數\"><a href=\"#箭頭函數\" class=\"headerlink\" title=\"箭頭函數\"></a>箭頭函數</h2><p>箭頭函數是一種聲明函數的簡潔語法，它與普通函數並無本質的區別，差異性更多體現在語法格式上，更適用於那些本來需要匿名函數的地方。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; const fn &#x3D; function () &#123;\n    &#x2F;&#x2F;   console.log(123)\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; 1. 箭頭函數 基本語法\n    &#x2F;&#x2F; const fn &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(123)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; fn()\n\n    &#x2F;&#x2F; const fn &#x3D; (x) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(x)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; fn(1)\n\n    &#x2F;&#x2F; 2. 只有一個形參的時候，可以省略小括弧\n    &#x2F;&#x2F; const fn &#x3D; x &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(x)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; fn(1)\n\n    &#x2F;&#x2F; &#x2F;&#x2F; 3. 只有一行代碼的時候，我們可以省略大括弧\n    &#x2F;&#x2F; const fn &#x3D; x &#x3D;&gt; console.log(x)\n    &#x2F;&#x2F; fn(1)\n\n    &#x2F;&#x2F; 4. 只有一行代碼的時候，可以省略return\n    &#x2F;&#x2F; const fn &#x3D; x &#x3D;&gt; x + x\n    &#x2F;&#x2F; console.log(fn(1))\n\n    &#x2F;&#x2F; 5. 箭頭函數可以直接返回一個物件\n    &#x2F;&#x2F; const fn &#x3D; (uname) &#x3D;&gt; (&#123; uname: uname &#125;)\n    &#x2F;&#x2F; console.log(fn(&#39;劉德華&#39;))\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>箭頭函數屬於運算式函數，因此不存在函數提升</li>\n<li>箭頭函數只有一個參數時可以省略圓括號 <code>()</code></li>\n<li>箭頭函數函數體只有一行代碼時可以省略花括弧 <code>&#123;&#125;</code>，並自動做為返回值被返回</li>\n</ol>\n<h3 id=\"箭頭函數參數\"><a href=\"#箭頭函數參數\" class=\"headerlink\" title=\"箭頭函數參數\"></a>箭頭函數參數</h3><p>箭頭函數中沒有動態參數 <code>arguments</code>，只能使用剩餘參數 <code>...</code> 動態獲取實參</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 利用箭頭函數來求和\n    const getSum &#x3D; (...arr) &#x3D;&gt; &#123;\n      let sum &#x3D; 0\n      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n        sum +&#x3D; arr[i]\n      &#125;\n      return sum\n    &#125;\n    const result &#x3D; getSum(2, 3, 4)\n    console.log(result) &#x2F;&#x2F; 9\n  &lt;&#x2F;script&gt;</code></pre>\n\n<h3 id=\"箭頭函數-this\"><a href=\"#箭頭函數-this\" class=\"headerlink\" title=\"箭頭函數 this\"></a>箭頭函數 this</h3><p>箭頭函數不會創建自己的this,它只會從自己的作用域鏈的上一層沿用this。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n   &#x2F;&#x2F; 以前this的指向：  誰調用的這個函數，this 就指向誰\n   &#x2F;&#x2F; console.log(this)  &#x2F;&#x2F; window\n   &#x2F;&#x2F; &#x2F;&#x2F; 普通函數\n   &#x2F;&#x2F; function fn() &#123;\n   &#x2F;&#x2F;   console.log(this)  &#x2F;&#x2F; window\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; window.fn()\n   &#x2F;&#x2F; &#x2F;&#x2F; 物件方法裡面的this\n   &#x2F;&#x2F; const obj &#x3D; &#123;\n   &#x2F;&#x2F;   name: &#39;andy&#39;,\n   &#x2F;&#x2F;   sayHi: function () &#123;\n   &#x2F;&#x2F;     console.log(this)  &#x2F;&#x2F; obj\n   &#x2F;&#x2F;   &#125;\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; obj.sayHi()\n\n   &#x2F;&#x2F; 2. 箭頭函數的this  是上一層作用域的this 指向\n   &#x2F;&#x2F; const fn &#x3D; () &#x3D;&gt; &#123;\n   &#x2F;&#x2F;   console.log(this)  &#x2F;&#x2F; window\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; fn()\n   &#x2F;&#x2F; 物件方法箭頭函數 this\n   &#x2F;&#x2F; const obj &#x3D; &#123;\n   &#x2F;&#x2F;   uname: &#39;pink老師&#39;,\n   &#x2F;&#x2F;   sayHi: () &#x3D;&gt; &#123;\n   &#x2F;&#x2F;     console.log(this)  &#x2F;&#x2F; this 指向誰？ window\n   &#x2F;&#x2F;   &#125;\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; obj.sayHi()\n\n   const obj &#x3D; &#123;\n     uname: &#39;老師&#39;,\n     sayHi: function () &#123;\n       console.log(this)  &#x2F;&#x2F; obj\n       let i &#x3D; 10\n       const count &#x3D; () &#x3D;&gt; &#123;\n         console.log(this)  &#x2F;&#x2F; obj \n       &#125;\n       count()\n     &#125;\n   &#125;\n   obj.sayHi()\n\n &lt;&#x2F;script&gt;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>箭頭函數不會創建自己的this,它只會從自己的作用域鏈的上一層沿用this<br>DOM事件回調函數不推薦使用箭頭函數嗎，特別是需要用到this的時候<br>事件回調函數使用箭頭函數時，this 為全局的 window</p></blockquote>\n<h1 id=\"解構賦值\"><a href=\"#解構賦值\" class=\"headerlink\" title=\"解構賦值\"></a>解構賦值</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>知道解構的語法及分類，使用解構簡潔語法快速為變數賦值。</p></blockquote>\n<p>解構賦值是一種快速為變數賦值的簡潔語法，本質上仍然是為變數賦值，分為陣列解構、物件解構兩大類型。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">console [變量1,變量2,變量3] &#x3D; [單元值1, 單元值2, 單元值3]</code></pre>\n\n<h2 id=\"陣列解構\"><a href=\"#陣列解構\" class=\"headerlink\" title=\"陣列解構\"></a>陣列解構</h2><p>陣列解構是將陣列的單元值快速批量賦值給一系列變數的簡潔語法，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 普通的陣列\n  let arr &#x3D; [1, 2, 3]\n  &#x2F;&#x2F; 批量聲明變數 a b c \n  &#x2F;&#x2F; 同時將陣列單元值 1 2 3 依次賦值給變數 a b c\n  let [a, b, c] &#x3D; arr\n  console.log(a); &#x2F;&#x2F; 1\n  console.log(b); &#x2F;&#x2F; 2\n  console.log(c); &#x2F;&#x2F; 3\n&lt;&#x2F;script&gt;</code></pre>\n\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; const arr &#x3D; [100, 60, 80]\n  &#x2F;&#x2F; 數組解構 賦值\n  &#x2F;&#x2F; &#x2F;&#x2F; const [max, min, avg] &#x3D; arr\n  const [max, min, avg] &#x3D; [100, 60, 80]\n  &#x2F;&#x2F; &#x2F;&#x2F; const max &#x3D; arr[0]\n  &#x2F;&#x2F; &#x2F;&#x2F; const min &#x3D; arr[1]\n  &#x2F;&#x2F; &#x2F;&#x2F; const avg &#x3D; arr[2]\n  console.log(max) &#x2F;&#x2F; 100\n  console.log(avg) &#x2F;&#x2F; 80\n\n  &#x2F;&#x2F; 交換2個變量的值\n  let a &#x3D; 1\n  let b &#x3D; 2;\n  [b, a] &#x3D; [a, b]\n  console.log(a, b)\n  &lt;&#x2F;script&gt;</code></pre>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n    &#x2F;&#x2F; 1. 立即执行函数要加\n    &#x2F;&#x2F; (function () &#123; &#125;)();\n    &#x2F;&#x2F; (function () &#123; &#125;)();\n    &#x2F;&#x2F; 2. 使用数组的时候\n    &#x2F;&#x2F; const arr &#x3D; [1, 2, 3]\n    const str &#x3D; &#39;pink&#39;;\n    [1, 2, 3].map(function (item) &#123;\n      console.log(item)\n    &#125;)\n\n    let a &#x3D; 1\n    let b &#x3D; 2\n      ;[b, a] &#x3D; [a, b]\n\n    console.log(a, b)\n  &lt;&#x2F;script&gt;</code></pre>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n    &#x2F;&#x2F; const pc &#x3D; [&#39;海爾&#39;, &#39;聯想&#39;, &#39;小米&#39;, &#39;方正&#39;];\n    &#x2F;&#x2F; [hr, lx, mi, fz] &#x3D; pc\n    &#x2F;&#x2F; console.log(hr, lx, mi, fz);\n\n\n    &#x2F;&#x2F; function getValue() &#123;\n    &#x2F;&#x2F;   return [100, 60]\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; [max, min] &#x3D; getValue()\n    &#x2F;&#x2F; console.log(max, min);\n\n\n\n    &#x2F;&#x2F; const pc &#x3D; [&#39;海爾&#39;, &#39;聯想&#39;, &#39;小米&#39;, &#39;方正&#39;]\n    &#x2F;&#x2F; const [hr, lx, mi, fz] &#x3D; [&#39;海爾&#39;, &#39;聯想&#39;, &#39;小米&#39;, &#39;方正&#39;]\n    &#x2F;&#x2F; console.log(hr)\n    &#x2F;&#x2F; console.log(lx)\n    &#x2F;&#x2F; console.log(mi)\n    &#x2F;&#x2F; console.log(fz)\n\n    &#x2F;&#x2F; &#x2F;&#x2F; 請將最大值和最小值函數返回值解構 max 和min 兩個變量\n    &#x2F;&#x2F; function getValue() &#123;\n    &#x2F;&#x2F;   return [100, 60]\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; const [max, min] &#x3D; getValue()\n    &#x2F;&#x2F; console.log(max)\n    &#x2F;&#x2F; console.log(min)\n    \n    &#x2F;&#x2F; 1. 變量多， 單元值少 ， undefined\n    &#x2F;&#x2F; const [a, b, c, d] &#x3D; [1, 2, 3]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; 3\n    &#x2F;&#x2F; console.log(d) &#x2F;&#x2F; undefined\n    &#x2F;&#x2F; 2. 變量少， 單元值多\n    &#x2F;&#x2F; const [a, b] &#x3D; [1, 2, 3]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; 3.  剩餘參數 變量少， 單元值多\n    &#x2F;&#x2F; const [a, b, ...c] &#x3D; [1, 2, 3, 4]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; [3, 4]  真數組\n    &#x2F;&#x2F; 4.  防止 undefined 傳遞\n    &#x2F;&#x2F; const [a &#x3D; 0, b &#x3D; 0] &#x3D; [1, 2]\n    &#x2F;&#x2F; const [a &#x3D; 0, b &#x3D; 0] &#x3D; []\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; 5.  按需導入賦值\n    &#x2F;&#x2F; const [a, b, , d] &#x3D; [1, 2, 3, 4]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(d) &#x2F;&#x2F; 4\n\n    &#x2F;&#x2F; const arr &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; console.log(arr[0])  &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(arr[1])  &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(arr[2])  &#x2F;&#x2F; [3,4]\n    &#x2F;&#x2F; console.log(arr[2][0])  &#x2F;&#x2F; 3\n\n    &#x2F;&#x2F; 多維數組解構\n    &#x2F;&#x2F; const arr &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; const [a, b, c] &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; [3,4]\n\n    &#x2F;&#x2F; const [a, b, [c, d]] &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; 3\n    &#x2F;&#x2F; console.log(d) &#x2F;&#x2F; 4\n  &lt;&#x2F;script&gt;</code></pre>\n<p>總結：</p>\n<ol>\n<li>設定運算子 <code>=</code> 左側的 <code>[]</code> 用於<strong>批量聲明變數</strong>，右側陣列的單元值將被賦值給左側的變數</li>\n<li>變數的順序對應陣列單元值的位置依次進行賦值操作</li>\n<li>變數的數量大於單元值數量時，多餘的變數將被賦值為  <code>undefined</code></li>\n<li>變數的數量小於單元值數量時，可以通過 <code>...</code> 獲取剩餘單元值，但只能置於最末位</li>\n<li>允許初始化變數的預設值，且只有單元值為 <code>undefined</code> 時預設值才會生效</li>\n</ol>\n<p>注：支持多維解構賦值，比較複雜後續有應用需求時再進一步分析</p>\n<h2 id=\"對象解構-重要\"><a href=\"#對象解構-重要\" class=\"headerlink\" title=\"對象解構 (重要)\"></a>對象解構 (重要)</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>複習: 數組中括號[]，對象大括號{}</p></blockquote>\n<p>物件解構是將物件屬性和方法快速批量賦值給一系列變數的簡潔語法，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  &#x2F;&#x2F; 普通對象\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;;\n  &#x2F;&#x2F; 批量聲明變數 name age\n  &#x2F;&#x2F; 同時將陣列單元值 小明  18 依次賦值給變數 name  age\n\n  &#x2F;&#x2F;解構的語法\n  const &#123;name, age&#125; &#x3D; user\n  &#x2F;&#x2F; const &#123;name, age&#125; &#x3D; &#123;name: &#39;小明&#39;,age: 18&#125; 亦可\n  &#x2F;&#x2F; 等價於 const name &#x3D;  obj.name\n  \n  &#x2F;&#x2F; 要求屬性名和變量名必須一直才可以\n  console.log(name) &#x2F;&#x2F; 小明\n  console.log(age) &#x2F;&#x2F; 18\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：</p>\n<ol>\n<li>設定運算子 <code>=</code> 左側的 <code>&#123;&#125;</code> 用於批量聲明變數，右側物件的屬性值將被賦值給左側的變數</li>\n<li>物件<strong>屬性的值</strong>將被賦值給與<strong>屬性名相同</strong>的變數</li>\n<li>物件中找不到與變數名一致的屬性時變數值為 <code>undefined</code></li>\n<li>允許初始化變數的預設值，屬性不存在或單元值為 <code>undefined</code> 時預設值才會生效</li>\n</ol>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n    &#x2F;&#x2F; 1. 對象解構的變量名 可以重新改名  舊變量名: 新變量名\n    &#x2F;&#x2F; const &#123; uname: username, age &#125; &#x3D; &#123; uname: &#39;老師&#39;, age: 18 &#125;\n\n    &#x2F;&#x2F; &#x2F;&#x2F; console.log(username)\n    &#x2F;&#x2F; &#x2F;&#x2F; console.log(age)\n\n    &#x2F;&#x2F; 2. 解構數組對象\n    const pig &#x3D; [\n      &#123;\n        uname: &#39;佩奇&#39;,\n        age: 6\n      &#125;\n    ]\n    const [&#123; uname, age &#125;] &#x3D; pig\n    console.log(uname)\n    console.log(age)\n  &lt;&#x2F;script&gt;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注：支持多維解構賦值</p></blockquote>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 這是後臺傳遞過來的資料\n    const msg &#x3D; &#123;\n      &quot;code&quot;: 200,\n      &quot;msg&quot;: &quot;獲取新聞列表成功&quot;,\n      &quot;data&quot;: [\n        &#123;\n          &quot;id&quot;: 1,\n          &quot;title&quot;: &quot;5G商用自己，三大運用商收入下降&quot;,\n          &quot;count&quot;: 58\n        &#125;,\n        &#123;\n          &quot;id&quot;: 2,\n          &quot;title&quot;: &quot;國際媒體頭條速覽&quot;,\n          &quot;count&quot;: 56\n        &#125;,\n        &#123;\n          &quot;id&quot;: 3,\n          &quot;title&quot;: &quot;烏克蘭和俄羅斯持續衝突&quot;,\n          &quot;count&quot;: 1669\n        &#125;,\n\n      ]\n    &#125;\n\n    &#x2F;&#x2F; 需求1： 請將以上msg物件  採用物件解構的方式 只選出  data 方面後面使用渲染頁面\n    &#x2F;&#x2F; const &#123; data &#125; &#x3D; msg\n    &#x2F;&#x2F; console.log(data)\n    &#x2F;&#x2F; 需求2： 上面msg是後臺傳遞過來的資料，我們需要把data選出當做參數傳遞給 函數\n    &#x2F;&#x2F; const &#123; data &#125; &#x3D; msg\n    &#x2F;&#x2F; msg 雖然很多屬性，但是我們利用解構只要 data值\n    function render(&#123; data &#125;) &#123;\n      &#x2F;&#x2F; const &#123; data &#125; &#x3D; arr\n      &#x2F;&#x2F; 我們只要 data 資料\n      &#x2F;&#x2F; 內部處理\n      console.log(data)\n    &#125;\n    render(msg)\n\n    &#x2F;&#x2F;給新的變量名賦值(冒號表示 “ 什麼值：賦值給誰 ”)\n    &#x2F;&#x2F; 需求3， 為了防止msg裡面的data名字混淆，要求渲染函數裡面的資料名改為 myData\n    function render(&#123; data: myData &#125;) &#123;\n      &#x2F;&#x2F; 要求將 獲取過來的 data資料 更名為 myData\n      &#x2F;&#x2F; 內部處理\n      console.log(myData)\n\n    &#125;\n    render(msg)\n\n  &lt;&#x2F;script&gt;</code></pre>\n\n<h1 id=\"綜合案例\"><a href=\"#綜合案例\" class=\"headerlink\" title=\"綜合案例\"></a>綜合案例</h1><h2 id=\"forEach遍歷陣列\"><a href=\"#forEach遍歷陣列\" class=\"headerlink\" title=\"forEach遍歷陣列\"></a>forEach遍歷陣列</h2><p>forEach() 方法用於調用陣列的每個元素，並將元素傳遞給回呼函數</p>\n<pre class=\"line-numbers language-javaScript\" data-language=\"javaScript\"><code class=\"language-javaScript\">語法:\n被遍歷的數組.forEach(function (當前數組元素, 當前元素索引號) &#123;\n  &#x2F;&#x2F;函數體\n&#125;)</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>注意：  </p>\n<p>1.forEach 主要是遍歷陣列</p>\n<p>2.參數當前陣列元素是必須要寫的， 索引號可選。</p></blockquote>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; forEach 就是遍歷  加強版的for迴圈  適合於遍歷陣列物件\n    const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;pink&#39;]\n    const result &#x3D; arr.forEach(function (item, index) &#123;\n      console.log(item)  &#x2F;&#x2F; 陣列元素 red  green pink\n      console.log(index) &#x2F;&#x2F; 索引號\n    &#125;)\n    &#x2F;&#x2F; console.log(result)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<h2 id=\"filter篩選陣列\"><a href=\"#filter篩選陣列\" class=\"headerlink\" title=\"filter篩選陣列\"></a>filter篩選陣列</h2><p>filter() 方法創建一個新的陣列，新陣列中的元素是通過檢查指定陣列中符合條件的所有元素</p>\n<pre class=\"line-numbers language-javaScript\" data-language=\"javaScript\"><code class=\"language-javaScript\">語法:\n被遍歷的數組.filter(function (参數, index) &#123;\n  return 篩選條件\n&#125;)</code></pre>\n\n<p>主要使用場景： 篩選陣列符合條件的元素，並返回篩選之後元素的新陣列</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    const arr &#x3D; [10, 20, 30]\n    &#x2F;&#x2F; const newArr &#x3D; arr.filter(function (item, index) &#123;\n    &#x2F;&#x2F;   &#x2F;&#x2F; console.log(item)\n    &#x2F;&#x2F;   &#x2F;&#x2F; console.log(index)\n    &#x2F;&#x2F;   return item &gt;&#x3D; 20\n    &#x2F;&#x2F; &#125;)\n    &#x2F;&#x2F; 返回的符合條件的新陣列\n\n    const newArr &#x3D; arr.filter(item &#x3D;&gt; item &gt;&#x3D; 20)\n    console.log(newArr)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n\n\n\n","feature":null,"text":" 學習作用域、變數提升、閉包等語言特徵，加深對 JavaScript 的理解，掌握變數賦值、函式宣告的簡潔語法，降低代碼的冗餘度。 理解作用域對程式執行的影響 能夠分析程式執行的作用域範圍 理解閉包本質，利用閉包創建隔離作用域 瞭解什麼變數提升及函數提升 掌握箭頭函數、解析剩餘參...","link":"","photos":[],"count_time":{"symbolsCount":"20k","symbolsTime":"19 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%80%E9%83%A8%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">局部作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B8%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">函數作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A1%8A%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">塊作用域</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%9F%9F%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">全域作用域</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%8F%88\"><span class=\"toc-text\">作用域鏈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A9%9F%E5%88%B6\"><span class=\"toc-text\">JS垃圾回收機制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%96%89%E5%8C%85\"><span class=\"toc-text\">閉包</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AE%8A%E6%95%B8%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">變數提升</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">函數</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B8%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">函數提升</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B8%E5%8F%83%E6%95%B8\"><span class=\"toc-text\">函數參數</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A0%90%E8%A8%AD%E5%80%BC\"><span class=\"toc-text\">預設值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8B%95%E6%85%8B%E5%8F%83%E6%95%B8\"><span class=\"toc-text\">動態參數</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%A9%E9%A4%98%E5%8F%83%E6%95%B8-%E8%88%87-%E5%B1%95%E9%96%8B%E9%81%8B%E7%AE%97%E7%AC%A6-%E7%9B%B8%E4%BC%BC\"><span class=\"toc-text\">剩餘參數 (與 展開運算符 相似)</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E9%A0%AD%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">箭頭函數</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E9%A0%AD%E5%87%BD%E6%95%B8%E5%8F%83%E6%95%B8\"><span class=\"toc-text\">箭頭函數參數</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%AD%E9%A0%AD%E5%87%BD%E6%95%B8-this\"><span class=\"toc-text\">箭頭函數 this</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC\"><span class=\"toc-text\">解構賦值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%99%A3%E5%88%97%E8%A7%A3%E6%A7%8B\"><span class=\"toc-text\">陣列解構</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8D%E8%B1%A1%E8%A7%A3%E6%A7%8B-%E9%87%8D%E8%A6%81\"><span class=\"toc-text\">對象解構 (重要)</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B6%9C%E5%90%88%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">綜合案例</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#forEach%E9%81%8D%E6%AD%B7%E9%99%A3%E5%88%97\"><span class=\"toc-text\">forEach遍歷陣列</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#filter%E7%AF%A9%E9%81%B8%E9%99%A3%E5%88%97\"><span class=\"toc-text\">filter篩選陣列</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaScript 進階 - 第2天","uid":"b57064d0869ba36d27730b8b11beee0b","slug":"2303-3 JS 進階2","date":"2023-03-30T01:22:08.000Z","updated":"2023-04-04T00:04:34.343Z","comments":true,"path":"api/articles/2303-3 JS 進階2.json","keywords":null,"cover":[],"text":" 瞭解物件導向程式設計的基礎概念及構造函數的作用，體會 JavaScript 一切皆物件的語言特徵，掌握常見的物件屬性和方法的使用。 瞭解物件導向程式設計中的一般概念 能夠基於構造函數創建物件 理解 JavaScript 中一切皆物件的語言特徵 理解引用物件類型值存儲的的特徵 掌...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"JavaScript Web APIs - 第6天","uid":"1359ad702c466c1bb96b6c62885f8401","slug":"2303-2 JS Web APIs 06","date":"2023-03-28T01:22:08.000Z","updated":"2023-03-30T03:57:26.346Z","comments":true,"path":"api/articles/2303-2 JS Web APIs 06.json","keywords":null,"cover":[],"text":" 目標：能夠利用規則運算式完成小兔鮮註冊頁面的表單驗證，具備常見的表單驗證能力 規則運算式 綜合案例 階段案例 規則運算式規則運算式（Regular Expression）是一種字串匹配的模式（規則） 使用場景： 例如驗證表單：手機號表單要求用戶只能輸入11位元的數字 (匹配) ...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}