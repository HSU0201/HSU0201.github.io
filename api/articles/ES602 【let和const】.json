{"title":"ES6 介绍","uid":"1e00bbc5a1a969d8b4414c942e9fedc9","slug":"ES602 【let和const】","date":"2024-01-24T02:06:25.000Z","updated":"2024-02-01T23:36:11.014Z","comments":true,"path":"api/articles/ES602 【let和const】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","content":"<h1 id=\"02-【let-和-const】\"><a href=\"#02-【let-和-const】\" class=\"headerlink\" title=\"02 【let 和 const】\"></a>02 【let 和 const】</h1><h2 id=\"1-let-指令\"><a href=\"#1-let-指令\" class=\"headerlink\" title=\"1.let 指令\"></a>1.let 指令</h2><h3 id=\"1-1-基本用法\"><a href=\"#1-1-基本用法\" class=\"headerlink\" title=\"1.1 基本用法\"></a>1.1 基本用法</h3><p>ES6 新增了 <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/let\"><strong>let</strong></a> 指令，用來聲明變量。<br>它的用法類似於<code>var</code>，但是所聲明的變量，只在<code>let</code>指令所在的代碼區塊內有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">a; <span class=\"comment\">// ReferenceError: a is not defined.</span></span><br><span class=\"line\">b; <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼在代碼區塊之中，分別用<code>let</code>和<code>var</code>聲明了兩個變量。然後在代碼區塊之外執行這兩個變量，結果<code>let</code>聲明的變量報錯，<code>var</code>聲明的變量返回了正確的值。這表明，<code>let</code>聲明的變量只在它所在的代碼區塊有效。</p>\n<p><code>for</code>循環的計數器，就很合適使用<code>let</code>指令。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\"><span class=\"comment\">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，計數器<code>i</code>只在<code>for</code>循環體內有效，在循環體外引用就會報錯。</p>\n<p>下面的代碼如果使用<code>var</code>，最後輸出的是<code>10</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 10</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，變量<code>i</code>是<code>var</code>指令聲明的，在全局範圍內都有效，所以全局只有一個變量<code>i</code>。每一次循環，變量<code>i</code>的值都會發生改變，而循環內被賦給陣列<code>a</code>的函式內部的<code>console.log(i)</code>，裡面的<code>i</code>指向的就是全局的<code>i</code>。也就是說，所有陣列<code>a</code>的成員裡面的<code>i</code>，指向的都是同一個<code>i</code>，導致執行時輸出的是最後一輪的<code>i</code>的值，也就是 10。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果使用<code>let</code>，聲明的變量僅在塊級作用域內有效，最後輸出的是 6。</p></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  a[i] = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a[<span class=\"number\">6</span>](); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>使用了 <code>let</code> 來宣告迴圈中的變數 <code>i</code>，這意味著 <code>i</code> 是在每次迴圈迭代時都會建立一個新的 binding，並且在每次迭代中都會有不同的值。</p>\n<p>當迴圈結束後，a 陣列中的每個函式都記住了在其宣告的時候 <code>i</code> 的值，因此當你執行 <code>a[6]()</code> 時，它會輸出迴圈結束時 <code>i</code> 的值，即 6。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Q: 如果每一輪循環的變量<code>i</code>都是重新聲明的，那它怎麼知道上一輪循環的值，從而計算出本輪循環的值？</p>\n<p>A: JavaScript 的<a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Closures\">閉包(closure)</a>特性。閉包允許函式在其宣告的範圍外訪問變數，而且它們可以<strong>記住宣告時的上下文</strong>。在這種情況下，每個函式都記住了它們宣告時的迴圈範圍內的 i 的值，而不是在函式被調用時的值。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>補充資料:<a href=\"https://segmentfault.com/q/1010000007541743/a-1020000007542563\">怎麼理解for迴圈中用let宣告的迭代變數每次都是新的變數</a></p></blockquote>\n<hr>\n<p>另外，<code>for</code>循環還有一個特別之處，就是設定循環變量的那部分是一個父作用域，而循環體內部是一個單獨的子作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">3</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = <span class=\"string\">&quot;abc&quot;</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// abc</span></span><br><span class=\"line\"><span class=\"comment\">// abc</span></span><br><span class=\"line\"><span class=\"comment\">// abc</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼正確執行，輸出了 3 次<code>abc</code>。這表明函式內部的變量<code>i</code>與循環變量<code>i</code>不在同一個作用域，有各自單獨的作用域（同一個作用域不可使用 <code>let</code> 重複聲明同一個變量）。</p>\n<h3 id=\"1-2-不存在變量提升\"><a href=\"#1-2-不存在變量提升\" class=\"headerlink\" title=\"1.2 不存在變量提升\"></a>1.2 不存在變量提升</h3><p><code>var</code>指令會發生“變量提升”現象(類似將代碼移至程式頂端之行為)，值為<code>undefined</code>。這種現象多多少少是有些奇怪的，按照一般的邏輯，變量應該在聲明語句之後才可以使用。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>**<a href=\"https://developer.mozilla.org/zh-TW/docs/Glossary/Hoisting\">變數提升</a>**在執行任何程式碼前，JavaScript 會把函式宣告放進記憶體裡面，這樣做的優點是：可以在程式碼宣告該函式之前使用它。</p></blockquote>\n<p>為了糾正這種現象，<code>let</code>指令改變了語法行為，它所聲明的變量一定要在聲明後使用，否則報錯。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// var 的情況</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(foo); <span class=\"comment\">// 輸出undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// let 的情況</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(bar); <span class=\"comment\">// 報錯ReferenceError</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用 <code>var</code> 声明的變數會發生變量提升，在腳本開始執行時，變數已經存在，但尚未賦值，因此訪問它會得到 <code>undefined</code>。</li>\n<li>使用 <code>let</code> 声明的變數不會發生變量提升，變數在聲明之前不存在，如果在聲明之前訪問它，會導致 <code>ReferenceError</code> 錯誤。</li>\n<li><code>var</code> 存在變量提升的特性，而 <code>let</code> 則引入了<strong>暫時性死區（TDZ）</strong>的概念，確保變量在聲明之前無法被訪問，使代碼更加可控和健壯。</li>\n</ul>\n<h3 id=\"1-3-暫時性死區（Temporal-Dead-Zone，TDZ）\"><a href=\"#1-3-暫時性死區（Temporal-Dead-Zone，TDZ）\" class=\"headerlink\" title=\"1.3 暫時性死區（Temporal Dead Zone，TDZ）\"></a>1.3 暫時性死區（Temporal Dead Zone，TDZ）</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>let、const，所聲明的變量或常數就自動 “綁定” 作用域，不再受到外部作用域的影響。</p></blockquote>\n<p>ES6 中的「暫時性死區」（Temporal Dead Zone，TDZ）指的是在使用 let 或 const 狀態變數時，變數在程式碼區塊內存在但在<strong>宣告之前</strong>無法被訪問的情況。</p>\n<p>在 ES6 之前，JavaScript 中只有函式作用域和全域作用域，變數宣告會被提升到其作用域的頂部。但是 ES6 引入了 let 和 const，它們的作用域僅限於宣告它們的程式碼區塊內。</p>\n<p>TDZ 的概念源自於這樣一種行為：在宣告 let 或 const 變數之前，任何對變數的引用都會導致 ReferenceError 錯誤。這是因為在程式碼執行過程中，JavaScript 引擎會在進入作用域時對 let 或 const 宣告的變數進行宣告（在編譯階段），但是初始化（賦值）卻留在了原始位置。在宣告到初始化的這一過程中，變數處於 TDZ。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// 暫時性死區</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>();</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>();</span><br></pre></td></tr></table></figure>\n\n<p><strong>只要作用域內出現了同名的 let 或 const，那麼就會去找這個量（向前找），如果找不到也不會跳去外部找，只會直接報錯！</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>遵守 “<strong>先聲明後使用</strong>”，那基本不會遇到變量提升及暫時性死區問題。</p></blockquote>\n<h3 id=\"1-4-不允許重複聲明\"><a href=\"#1-4-不允許重複聲明\" class=\"headerlink\" title=\"1.4 不允許重複聲明\"></a>1.4 不允許重複聲明</h3><p><code>let</code>不允許在相同作用域內，重複聲明同一個變量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 報錯</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 報錯，相同作用域中不可重複聲明變數</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>因此，不能在函式內部重新聲明參數。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> arg;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>(); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">func</span>(<span class=\"params\">arg</span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">func</span>(); <span class=\"comment\">// 不報錯</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-塊級作用域\"><a href=\"#2-塊級作用域\" class=\"headerlink\" title=\"2.塊級作用域\"></a>2.塊級作用域</h2><h3 id=\"2-1-為什麼需要塊級作用域？\"><a href=\"#2-1-為什麼需要塊級作用域？\" class=\"headerlink\" title=\"2.1 為什麼需要塊級作用域？\"></a>2.1 為什麼需要塊級作用域？</h3><p>ES5 只有全局作用域和函式作用域，沒有塊級作用域，這帶來很多不合理的場景。</p>\n<p>第一種場景，內層變量可能會覆蓋外層變量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span> <span class=\"title class_\">Date</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(tmp);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> tmp = <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>(); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼的原意是，<code>if</code>代碼區塊的外部使用外層的<code>tmp</code>變量，內部使用內層的<code>tmp</code>變量。但是，函式<code>f</code>執行後，輸出結果為<code>undefined</code>，原因在於變量提升，導致內層的<code>tmp</code>變量覆蓋了外層的<code>tmp</code>變量。</p>\n<p>第二種場景，用來計數的循環變量泄露為全局變量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> s = <span class=\"string\">&quot;hello&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"property\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(s[i]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，變量<code>i</code>只用來控制循環，但是循環結束後，它並沒有消失，泄露成了全局變量。</p>\n<h3 id=\"2-2-ES6-的塊級作用域\"><a href=\"#2-2-ES6-的塊級作用域\" class=\"headerlink\" title=\"2.2 ES6 的塊級作用域\"></a>2.2 ES6 的塊級作用域</h3><p><code>let</code>實際上為 JavaScript 新增了<a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/block\">塊級作用域</a>。</p>\n<ul>\n<li><p>作用域鏈：內層作用域 ——&gt; 外層作用域 ——&gt; 全局作用域</p>\n</li>\n<li><p>塊級作用域：除了物件 <code>&#123;&#125;</code>，函式 <code>&#123;&#125;</code>（函式作用域）之外的一切 <code>&#123;&#125;</code> 都屬於塊級作用域。</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// logs 1</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">&quot;var&quot;</span>;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> a = <span class=\"string\">&quot;let&quot;</span>;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// let</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// var</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">foo</span>();</span><br></pre></td></tr></table></figure>\n\n<p>上面的函式有兩個區塊分別定義了變數 <code>a</code>，一個是外層區塊使用 <code>var</code> 定義的 <code>a</code>，另一個是在內層區塊中，使用 <code>let</code> 定義的變數 <code>a</code> 只存在於該區塊範圍內，不會影響外層區塊中的 <code>a</code>。</p>\n<p>因此，第一個 <code>console.log(a)</code> 印出的是內層區塊中的 <code>a</code>，值為 **”let”**。而第二個 <code>console.log(a)</code> 印出的是外層區塊中的 <code>a</code>，值為 <strong>“var”</strong></p>\n<hr>\n<p>ES6 允許塊級作用域的任意嵌套。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> insane = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(insane); <span class=\"comment\">// 報錯</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼使用了一個五層的塊級作用域，每一層都是一個單獨的作用域。第四層作用域無法讀取第五層作用域的內部變量。</p>\n<p>內層作用域可以定義外層作用域的同名變量。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> insane = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> insane = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>塊級作用域的出現，實際上使得獲得廣泛應用的<a href=\"https://developer.mozilla.org/zh-TW/docs/Glossary/IIFE\">匿名立即執行函式表達式（匿名 IIFE）</a>不再必要了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// IIFE 寫法</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp = ...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 塊級作用域寫法</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> tmp = ...;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-塊級作用域與函式聲明\"><a href=\"#2-3-塊級作用域與函式聲明\" class=\"headerlink\" title=\"2.3 塊級作用域與函式聲明\"></a>2.3 塊級作用域與函式聲明</h3><p>函式能不能在塊級作用域之中聲明？這是一個相當令人混淆的問題。</p>\n<p>ES5 規定，函式只能在頂層作用域和函式作用域之中聲明，不能在塊級作用域聲明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 情況一</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 情況二</span></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面兩種函式聲明，根據 ES5 的規定都是非法的。</p>\n<p>但是，瀏覽器沒有遵守這個規定，為了相容以前的舊代碼，還是支持在塊級作用域之中聲明函式，因此上面兩種情況實際都能執行，不會報錯。</p>\n<p>ES6 引入了塊級作用域，明確允許在塊級作用域之中聲明函式。ES6 規定，塊級作用域之中，函式聲明語句的行為類似於<code>let</code>，在塊級作用域之外不可引用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am outside!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 重複聲明一次函式f</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am inside!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">f</span>();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼在 ES5 中執行，會得到“I am inside!”，因為在<code>if</code>內聲明的函式<code>f</code>會被提升到函式頭部，實際執行的代碼如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ES5 環境</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am outside!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am inside!&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"title function_\">f</span>();</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p>ES6 就完全不一樣了，理論上會得到“I am outside!”。因為塊級作用域內聲明的函式類似於<code>let</code>，對作用域之外沒有影響。但是，如果你真的在 ES6 瀏覽器中執行一下上面的代碼，是會報錯的，這是為什麼呢？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 瀏覽器的 ES6 環境</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am outside!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 重複聲明一次函式f</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am inside!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">f</span>();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>上面的代碼在 ES6 瀏覽器中，都會報錯。</p>\n<p>原來，如果改變了塊級作用域內聲明的函式的處理規則，顯然會對老代碼産生很大影響。</p>\n<ul>\n<li>允許在塊級作用域內聲明函式。</li>\n<li>函式聲明類似於<code>var</code>，即會提升到全局作用域或函式作用域的頭部。</li>\n<li>同時，函式聲明還會提升到所在的塊級作用域的頭部。</li>\n</ul>\n<p>注意，上面三條規則只對 ES6 的瀏覽器實現有效，其他環境的實現不用遵守，還是將塊級作用域的函式聲明當作<code>let</code>處理。</p>\n<p>根據這三條規則，瀏覽器的 ES6 環境中，塊級作用域內聲明的函式，行為類似於<code>var</code>聲明的變量。上面的例子實際執行的代碼如下。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 瀏覽器的 ES6 環境</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am outside!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;I am inside!&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">f</span>();</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\"><span class=\"comment\">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>\n\n<p>考慮到環境導致的行為差異太大，應該避免在塊級作用域內聲明函式。如果確實需要，也應該寫成函式表達式，而不是函式聲明語句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 塊級作用域內部的函式聲明語句，建議不要使用</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">&quot;secret&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 塊級作用域內部，優先使用函式表達式</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> a = <span class=\"string\">&quot;secret&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> f = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另外，還有一個需要注意的地方。ES6 的塊級作用域必須有大括號，如果沒有大括號，JavaScript 引擎就認為不存在塊級作用域。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第一種寫法，報錯</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第二種寫法，不報錯</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，第一種寫法沒有大括號，所以不存在塊級作用域，而<code>let</code>只能出現在當前作用域的頂層，所以報錯。第二種寫法有大括號，所以塊級作用域成立。</p>\n<p>函式聲明也是如此，<a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Strict_mode\">嚴格模式</a>下，函式只能聲明在當前作用域的頂層。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 不報錯</span></span><br><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 報錯</span></span><br><span class=\"line\">(<span class=\"string\">&quot;use strict&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-const-指令\"><a href=\"#3-const-指令\" class=\"headerlink\" title=\"3.const 指令\"></a>3.const 指令</h2><h3 id=\"3-1-基本用法\"><a href=\"#3-1-基本用法\" class=\"headerlink\" title=\"3.1 基本用法\"></a>3.1 基本用法</h3><p><code>const</code>聲明一個只讀的常數。一旦聲明，常數的值就不能改變。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">PI</span> = <span class=\"number\">3.1415</span>;</span><br><span class=\"line\"><span class=\"variable constant_\">PI</span>; <span class=\"comment\">// 3.1415</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">PI</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"comment\">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼表明改變常數的值會報錯。</p>\n<p><code>const</code>聲明的變量不得改變值，這意味著，<code>const</code>一旦聲明變量，就必須立即初始化，不能留到以後賦值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼表示，對於<code>const</code>來說，只聲明不賦值，就會報錯。</p>\n<p><code>const</code>的作用域與<code>let</code>指令相同：只在聲明所在的塊級作用域內有效。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"variable constant_\">MAX</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable constant_\">MAX</span>; <span class=\"comment\">// Uncaught ReferenceError: MAX is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p><code>const</code>指令聲明的常數也是不提升，同樣存在暫時性死區，只能在聲明的位置後面使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable constant_\">MAX</span>); <span class=\"comment\">// ReferenceError</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"variable constant_\">MAX</span> = <span class=\"number\">5</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼在常數<code>MAX</code>聲明之前就執行，結果報錯。</p>\n<p><code>const</code>聲明的常數，也與<code>let</code>一樣不可重複聲明。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> message = <span class=\"string\">&quot;Hello!&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 以下兩行都會報錯</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> message = <span class=\"string\">&quot;Goodbye!&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> age = <span class=\"number\">30</span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-本質\"><a href=\"#3-2-本質\" class=\"headerlink\" title=\"3.2 本質\"></a>3.2 本質</h3><ul>\n<li><code>const</code>實際上保證的，並不是變量的值不得改動，而是變量指向的那個內存地址所儲存的資料不得改動。</li>\n<li>對於簡單型別的資料（數值、字符串、布爾值），值就儲存在變量指向的那個內存地址，因此等同於常數。</li>\n<li>對於複合型別的資料（主要是物件和陣列），變量指向的內存地址，儲存的只是一個指向實際資料的指針，<code>const</code>只能保證這個指針是固定的（即總是指向另一個固定的地址），至於它指向的資料結構是不是可變的，就完全不能控制了。</li>\n<li>因此，將一個物件聲明為常數必須非常小心。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> foo = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 為 foo 加入一個屬性，可以成功</span></span><br><span class=\"line\">foo.<span class=\"property\">prop</span> = <span class=\"number\">123</span>;</span><br><span class=\"line\">foo.<span class=\"property\">prop</span>; <span class=\"comment\">// 123</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 將 foo 指向另一個物件，就會報錯</span></span><br><span class=\"line\">foo = &#123;&#125;; <span class=\"comment\">// TypeError: &quot;foo&quot; is read-only</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，常數<code>foo</code>儲存的是一個地址，這個地址指向一個物件。不可變的只是這個地址，即不能把<code>foo</code>指向另一個地址，但物件本身是可變的，所以依然可以為其加入新屬性。</p>\n<p>下面是另一個例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = [];</span><br><span class=\"line\">a.<span class=\"title function_\">push</span>(<span class=\"string\">&quot;Hello&quot;</span>); <span class=\"comment\">// 可執行</span></span><br><span class=\"line\">a.<span class=\"property\">length</span> = <span class=\"number\">0</span>; <span class=\"comment\">// 可執行</span></span><br><span class=\"line\">a = [<span class=\"string\">&quot;Dave&quot;</span>]; <span class=\"comment\">// 報錯</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，常數<code>a</code>是一個陣列，這個陣列本身是可寫的，但是如果將另一個陣列賦值給<code>a</code>，就會報錯。</p>\n<h3 id=\"3-3-window-物件的屬性和方法（全局作用域中）\"><a href=\"#3-3-window-物件的屬性和方法（全局作用域中）\" class=\"headerlink\" title=\"3.3 window 物件的屬性和方法（全局作用域中）\"></a>3.3 window 物件的屬性和方法（全局作用域中）</h3><p>全局作用域中，<code>var</code> 聲明的變量，<code>function</code> 聲明的函式，會自動變成 window 物件的屬性或方法。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">age</span>); <span class=\"comment\">// 18</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">add</span> === add); <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age = <span class=\"number\">18</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;&#125;;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">age</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">window</span>.<span class=\"property\">add</span> === add); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-什麼時候用-let，什麼使用-const\"><a href=\"#3-4-什麼時候用-let，什麼使用-const\" class=\"headerlink\" title=\"3.4 什麼時候用 let，什麼使用 const\"></a>3.4 什麼時候用 let，什麼使用 const</h3><p>原則：如果不知道用什麼的時候，就用 const，這有助於提高代碼的可靠性和安全性，同時也使程式碼更易於理解和維護。</p>\n<p>原因：如果應該是常數，那麼剛好符合需求。如果應該是變量，那麼後來報錯時，再來改為變量也為時不晚。同時，一開始就設定為常數還會避免真的需要為常數時，該值在後來被意外修改的情況。</p>\n<h2 id=\"4-let-和-const-總結\"><a href=\"#4-let-和-const-總結\" class=\"headerlink\" title=\"4.let 和 const 總結\"></a>4.let 和 const 總結</h2><ol>\n<li>let 聲明的變量會産生塊作用域，var 不會産生塊作用域</li>\n<li>const 聲明的常數也會産生塊作用域</li>\n<li>不同代碼區塊之間的變量無法互相存取</li>\n<li>注意: 物件屬性修改和陣列元素變化不會出發 const 錯誤 （陣列和物件存的是引用地址）</li>\n<li>應用場景：聲明物件型別使用 const，非物件型別聲明選擇 let</li>\n<li>cosnt 聲明必須賦初始值，標識符一般為大寫，值不允許修改。</li>\n</ol>\n<h2 id=\"5-頂層物件的屬性\"><a href=\"#5-頂層物件的屬性\" class=\"headerlink\" title=\"5.頂層物件的屬性\"></a>5.頂層物件的屬性</h2><p>頂層物件，在瀏覽器環境指的是<code>window</code>物件，在 Node 指的是<code>global</code>物件。ES5 之中，頂層物件的屬性與全局變量是等價的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">a</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\">a; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，頂層物件的屬性賦值與全局變量的賦值，是同一件事。</p>\n<h2 id=\"6-JavaScript-全局變量與頂層物件的挂鈎問題與-ES6-的改進\"><a href=\"#6-JavaScript-全局變量與頂層物件的挂鈎問題與-ES6-的改進\" class=\"headerlink\" title=\"6.JavaScript 全局變量與頂層物件的挂鈎問題與 ES6 的改進\"></a>6.JavaScript 全局變量與頂層物件的挂鈎問題與 ES6 的改進</h2><p>JavaScript 中，全局變量與頂層物件的屬性掛鈎被認為是該語言設計上的一個重大缺陷。這樣的設計帶來了多個問題：</p>\n<ul>\n<li><strong>編譯時錯誤檢測不完善：</strong> JavaScript 在編譯時無法即時報告變量未聲明的錯誤，只有在執行時才能得知。這是因為全局變量可能是頂層物件的屬性動態創建的。</li>\n<li><strong>易於創建全局變量：</strong> 程式員容易通過錯誤的拼寫等方式意外創建全局變量。</li>\n<li><strong>不利於模塊化編程：</strong> 頂層物件的屬性是全局可讀寫的，這對於模塊化編程是不利的。</li>\n</ul>\n<p>另外，<code>window</code> 物件有著實際的含義，代表瀏覽器的窗口物件。因此，將頂層物件視為有實體含義的物件是不合適的。</p>\n<p>為了改善這些問題，ES6 做出了以下改進：</p>\n<ul>\n<li><strong>保持相容性：</strong> 使用 <code>var</code> 和 <code>function</code> 定義的全局變量仍然是頂層物件的屬性。</li>\n<li><strong>脫鈎全局變量：</strong> 使用 <code>let</code>、<code>const</code> 和 <code>class</code> 定義的全局變量不再是頂層物件的屬性。這意味著從 ES6 開始，全局變量將逐步與頂層物件的屬性脫鈎。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"comment\">// 如果在 Node 的 REPL 環境，可以寫成 global.a</span></span><br><span class=\"line\"><span class=\"comment\">// 或者採用通用方法，寫成 this.a</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">b</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，全局變量<code>a</code>由<code>var</code>指令聲明，所以它是頂層物件的屬性；全局變量<code>b</code>由<code>let</code>指令聲明，所以它不是頂層物件的屬性，返回<code>undefined</code>。</p>\n","feature":null,"text":"02 【let 和 const】1.let 指令1.1 基本用法ES6 新增了 let 指令，用來聲明變量。它的用法類似於var，但是所聲明的變量，只在let指...","permalink":"/post/ES602 【let和const】","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":31,"path":"api/tags/桃園資展筆記.json"},{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#02-%E3%80%90let-%E5%92%8C-const%E3%80%91\"><span class=\"toc-text\">02 【let 和 const】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-let-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">1.let 指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.1 基本用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%AE%8A%E9%87%8F%E6%8F%90%E5%8D%87\"><span class=\"toc-text\">1.2 不存在變量提升</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E6%9A%AB%E6%99%82%E6%80%A7%E6%AD%BB%E5%8D%80%EF%BC%88Temporal-Dead-Zone%EF%BC%8CTDZ%EF%BC%89\"><span class=\"toc-text\">1.3 暫時性死區（Temporal Dead Zone，TDZ）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E4%B8%8D%E5%85%81%E8%A8%B1%E9%87%8D%E8%A4%87%E8%81%B2%E6%98%8E\"><span class=\"toc-text\">1.4 不允許重複聲明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%A1%8A%E7%B4%9A%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">2.塊級作用域</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E7%82%BA%E4%BB%80%E9%BA%BC%E9%9C%80%E8%A6%81%E5%A1%8A%E7%B4%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%9F\"><span class=\"toc-text\">2.1 為什麼需要塊級作用域？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-ES6-%E7%9A%84%E5%A1%8A%E7%B4%9A%E4%BD%9C%E7%94%A8%E5%9F%9F\"><span class=\"toc-text\">2.2 ES6 的塊級作用域</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%A1%8A%E7%B4%9A%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%88%87%E5%87%BD%E5%BC%8F%E8%81%B2%E6%98%8E\"><span class=\"toc-text\">2.3 塊級作用域與函式聲明</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-const-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">3.const 指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">3.1 基本用法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E6%9C%AC%E8%B3%AA\"><span class=\"toc-text\">3.2 本質</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-window-%E7%89%A9%E4%BB%B6%E7%9A%84%E5%B1%AC%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%88%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%EF%BC%89\"><span class=\"toc-text\">3.3 window 物件的屬性和方法（全局作用域中）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E4%BB%80%E9%BA%BC%E6%99%82%E5%80%99%E7%94%A8-let%EF%BC%8C%E4%BB%80%E9%BA%BC%E4%BD%BF%E7%94%A8-const\"><span class=\"toc-text\">3.4 什麼時候用 let，什麼使用 const</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-let-%E5%92%8C-const-%E7%B8%BD%E7%B5%90\"><span class=\"toc-text\">4.let 和 const 總結</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E9%A0%82%E5%B1%A4%E7%89%A9%E4%BB%B6%E7%9A%84%E5%B1%AC%E6%80%A7\"><span class=\"toc-text\">5.頂層物件的屬性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-JavaScript-%E5%85%A8%E5%B1%80%E8%AE%8A%E9%87%8F%E8%88%87%E9%A0%82%E5%B1%A4%E7%89%A9%E4%BB%B6%E7%9A%84%E6%8C%82%E9%88%8E%E5%95%8F%E9%A1%8C%E8%88%87-ES6-%E7%9A%84%E6%94%B9%E9%80%B2\"><span class=\"toc-text\">6.JavaScript 全局變量與頂層物件的挂鈎問題與 ES6 的改進</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"如何發問程式碼問題","uid":"70dadd491ec3695ca3bd2adef4b59f9a","slug":"240124如何發問程式碼問題","date":"2024-01-24T11:17:41.000Z","updated":"2024-01-28T04:25:19.696Z","comments":true,"path":"api/articles/240124如何發問程式碼問題.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/9044a634e09b2a633ff73efad0fdf470.jpg?raw=true","text":"如何發問程式碼問題使用 Gist (推薦!!!)Gist 是 Github 的一個免費服務，且任何人都可以使用這個服務，不論你是否擁有 Github 帳號。 以...","permalink":"/post/240124如何發問程式碼問題","photos":[],"count_time":{"symbolsCount":630,"symbolsTime":"1 mins."},"categories":[{"name":"github","slug":"github","count":2,"path":"api/categories/github.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"ES6 介绍","uid":"1e00bbc5a1a969d8b4414c942e9fedc9","slug":"ES601 【ES6 介绍】","date":"2024-01-24T00:06:25.000Z","updated":"2024-01-30T12:54:52.424Z","comments":true,"path":"api/articles/ES601 【ES6 介绍】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","text":"01 【ES6 介紹】ECMAScript 6.0（以下簡稱 ES6）是 JavaScript 語言的下一代標準，已於 2015 年 6 月正式發布。它的目標是...","permalink":"/post/ES601 【ES6 介绍】","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"桃園資展筆記","slug":"桃園資展筆記","count":31,"path":"api/tags/桃園資展筆記.json"},{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}