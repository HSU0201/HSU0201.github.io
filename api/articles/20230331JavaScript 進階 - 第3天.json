{"title":"JavaScript 進階 - 第3天","uid":"c43b2d50b25bb22e84622db700db53eb","slug":"20230331JavaScript 進階 - 第3天","date":"2023-03-31T01:22:08.000Z","updated":"2023-03-25T02:06:48.240Z","comments":true,"path":"api/articles/20230331JavaScript 進階 - 第3天.json","keywords":null,"cover":[],"content":"<h1 id=\"JavaScript-進階-第3天筆記\"><a href=\"#JavaScript-進階-第3天筆記\" class=\"headerlink\" title=\"JavaScript 進階 - 第3天筆記\"></a>JavaScript 進階 - 第3天筆記</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>瞭解構造函數原型物件的語法特徵，掌握 JavaScript 中物件導向程式設計的實現方式，基於物件導向程式設計思想實現 DOM 操作的封裝。</p></blockquote>\n<ul>\n<li>瞭解物件導向程式設計的一般特徵</li>\n<li>掌握基於構造函數原型物件的邏輯封裝</li>\n<li>掌握基於原型物件實現的繼承</li>\n<li>理解什麼原型鏈及其作用</li>\n<li>能夠處理常式異常提升程式執行的健壯性</li>\n</ul>\n<h2 id=\"程式設計思想\"><a href=\"#程式設計思想\" class=\"headerlink\" title=\"程式設計思想\"></a>程式設計思想</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>學習 JavaScript 中基於原型的物件導向編程式的語法實現，理解物件導向程式設計的特徵。</p></blockquote>\n<h3 id=\"面向過程\"><a href=\"#面向過程\" class=\"headerlink\" title=\"面向過程\"></a>面向過程</h3><p>面向過程就是分析出解決問題所需要的步驟，然後用函數把這些步驟一步一步實現，使用的時候再一個一個的依次</p>\n<p>調用就可以了。</p>\n<p> 舉個栗子：蛋炒飯</p>\n<p><img src=\"/assets/1676792906898.png\" alt=\"67679290689\"></p>\n<h3 id=\"物件導向\"><a href=\"#物件導向\" class=\"headerlink\" title=\"物件導向\"></a>物件導向</h3><p>物件導向是把事務分解成為一個個物件，然後由物件之間分工與合作。</p>\n<p><img src=\"/assets/1676792930329.png\" alt=\"67679293032\"></p>\n<p>在物件導向程式開發思想中，每一個物件都是功能中心，具有明確分工。</p>\n<p>物件導向程式設計具有靈活、代碼可複用、容易維護和開發的優點，更適合多人合作的大型軟體專案。</p>\n<p>物件導向的特性：</p>\n<ul>\n<li><p>封裝性</p>\n</li>\n<li><p>繼承性</p>\n</li>\n<li><p>多態性</p>\n</li>\n</ul>\n<h2 id=\"構造函數\"><a href=\"#構造函數\" class=\"headerlink\" title=\"構造函數\"></a>構造函數</h2><p>對比以下通過物件導向的構造函數實現的封裝：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    this.name &#x3D; &#39;佚名&#39;\n    &#x2F;&#x2F; 設置名字\n    this.setName &#x3D; function (name) &#123;\n      this.name &#x3D; name\n    &#125;\n    &#x2F;&#x2F; 讀取名字\n    this.getName &#x3D; () &#x3D;&gt; &#123;\n      console.log(this.name)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 實例對像，獲得了構造函數中封裝的所有邏輯\n  let p1 &#x3D; new Person()\n  p1.setName(&#39;小明&#39;)\n  console.log(p1.name)\n\n  &#x2F;&#x2F; 實例物件\n  let p2 &#x3D; new Person()\n  console.log(p2.name)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。</p>\n<p>同樣的將變數和函數組合到了一起並能通過 this 實現資料的共用，所不同的是借助構造函數創建出來的實例物件之</p>\n<p>間是彼此不影響的</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總結：</p>\n<ol>\n<li>構造函數體現了物件導向的封裝特性</li>\n<li>構造函數實例創建的物件彼此獨立、互不影響</li>\n</ol></blockquote>\n<p>封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。</p>\n<p>前面我們學過的構造函數方法很好用，但是 存在<code>浪費記憶體</code>的問題</p>\n<h2 id=\"原型物件\"><a href=\"#原型物件\" class=\"headerlink\" title=\"原型物件\"></a>原型物件</h2><p>構造函數通過原型分配的函數是所有物件所 共用的。</p>\n<ul>\n<li>JavaScript 規定，每一個構造函數都有一個 prototype 屬性，指向另一個物件，所以我們也稱為原型物件</li>\n<li>這個物件可以掛載函數，物件產生實體不會多次創建原型上函數，節約記憶體</li>\n<li>我們可以把那些不變的方法，直接定義在 prototype 物件上，這樣所有物件的實例就可以共用這些方法。</li>\n<li>構造函數和原型物件中的this 都指向 產生實體的物件</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    \n  &#125;\n\n  &#x2F;&#x2F; 每個函數都有 prototype 屬性\n  console.log(Person.prototype)\n&lt;&#x2F;script&gt;</code></pre>\n\n\n<p>瞭解了 JavaScript 中構造函數與原型物件的關係後，再來看原型物件具體的作用，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處未定義任何方法\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n  \n  &#x2F;&#x2F; 產生實體\n  let p1 &#x3D; new Person();\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 Hi~\n&lt;&#x2F;script&gt;</code></pre>\n\n\n<p>構造函數 <code>Person</code> 中未定義任何方法，這時實例物件調用了原型物件中的方法 <code>sayHi</code>，接下來改動一下代碼：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處定義同名方法 sayHi\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;嗨!&#39;);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n\n  let p1 &#x3D; new Person();\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 嗨!\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>構造函數 <code>Person</code> 中定義與原型物件中相同名稱的方法，這時實例物件調用則是構造函中的方法 <code>sayHi</code>。</p>\n<p>通過以上兩個簡單示例不難發現 JavaScript 中物件的工作機制：<strong>當訪問物件的屬性或方法時，先在當前實例物件是查找，然後再去原型物件查找，並且原型物件被所有實例共用。</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處定義同名方法 sayHi\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;嗨!&#39; + this.name)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39; + this.name)\n  &#125;\n  &#x2F;&#x2F; 在構造函數的原型物件上添加屬性\n  Person.prototype.name &#x3D; &#39;小明&#39;\n\n  let p1 &#x3D; new Person()\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 嗨!\n  \n  let p2 &#x3D; new Person()\n  p2.sayHi()\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：<strong>結合構造函數原型的特徵，實際開發重往往會將封裝的功能函數添加到原型物件中。</strong></p>\n<h3 id=\"constructor-屬性\"><a href=\"#constructor-屬性\" class=\"headerlink\" title=\"constructor 屬性\"></a>constructor 屬性</h3><p>在哪裡？ 每個原型物件裡面都有個constructor 屬性（constructor 構造函數）</p>\n<p>作用：該屬性指向該原型物件的構造函數， 簡單理解，就是指向我的爸爸，我是有爸爸的孩子</p>\n<p><strong>使用場景：</strong></p>\n<p>如果有多個物件的方法，我們可以給原型物件採取物件形式賦值.</p>\n<p>但是這樣就會覆蓋構造函數原型物件原來的內容，這樣修改後的原型物件 constructor 就不再指向當前構造函數了</p>\n<p>此時，我們可以在修改後的原型物件中，添加一個 constructor 指向原來的構造函數。</p>\n<h3 id=\"物件原型\"><a href=\"#物件原型\" class=\"headerlink\" title=\"物件原型\"></a>物件原型</h3><p>物件都會有一個屬性 <strong>proto</strong> 指向構造函數的 prototype 原型物件，之所以我們物件可以使用構造函數 prototype </p>\n<p>原型物件的屬性和方法，就是因為物件有 <strong>proto</strong> 原型的存在。</p>\n<p>注意：</p>\n<ul>\n<li><strong>proto</strong> 是JS非標準屬性</li>\n<li>[[prototype]]和__proto__意義相同</li>\n<li>用來表明當前實例物件指向哪個原型物件prototype</li>\n<li>__proto__物件原型裡面也有一個 constructor屬性，指向創建該實例物件的構造函數</li>\n</ul>\n<h3 id=\"原型繼承\"><a href=\"#原型繼承\" class=\"headerlink\" title=\"原型繼承\"></a>原型繼承</h3><p>繼承是物件導向程式設計的另一個特徵，通過繼承進一步提升代碼封裝的程度，JavaScript 中大多是借助原型物件實現繼承</p>\n<p>的特性。</p>\n<p>龍生龍、鳳生鳳、老鼠的兒子會打洞描述的正是繼承的含義。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 繼續抽取   公共的部分放到原型上\n    &#x2F;&#x2F; const Person1 &#x3D; &#123;\n    &#x2F;&#x2F;   eyes: 2,\n    &#x2F;&#x2F;   head: 1\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; const Person2 &#x3D; &#123;\n    &#x2F;&#x2F;   eyes: 2,\n    &#x2F;&#x2F;   head: 1\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; 構造函數  new 出來的物件 結構一樣，但是物件不一樣\n    function Person() &#123;\n      this.eyes &#x3D; 2\n      this.head &#x3D; 1\n    &#125;\n    &#x2F;&#x2F; console.log(new Person)\n    &#x2F;&#x2F; 女人  構造函數   繼承  想要 繼承 Person\n    function Woman() &#123;\n\n    &#125;\n    &#x2F;&#x2F; Woman 通過原型來繼承 Person\n    &#x2F;&#x2F; 父構造函數（父類）   子構造函數（子類）\n    &#x2F;&#x2F; 子類的原型 &#x3D;  new 父類  \n    Woman.prototype &#x3D; new Person()   &#x2F;&#x2F; &#123;eyes: 2, head: 1&#125; \n    &#x2F;&#x2F; 指回原來的構造函數\n    Woman.prototype.constructor &#x3D; Woman\n\n    &#x2F;&#x2F; 給女人添加一個方法  生孩子\n    Woman.prototype.baby &#x3D; function () &#123;\n      console.log(&#39;寶貝&#39;)\n    &#125;\n    const red &#x3D; new Woman()\n    console.log(red)\n    &#x2F;&#x2F; console.log(Woman.prototype)\n    &#x2F;&#x2F; 男人 構造函數  繼承  想要 繼承 Person\n    function Man() &#123;\n\n    &#125;\n    &#x2F;&#x2F; 通過 原型繼承 Person\n    Man.prototype &#x3D; new Person()\n    Man.prototype.constructor &#x3D; Man\n    const pink &#x3D; new Man()\n    console.log(pink)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<h3 id=\"原型鏈\"><a href=\"#原型鏈\" class=\"headerlink\" title=\"原型鏈\"></a>原型鏈</h3><p>基於原型物件的繼承使得不同構造函數的原型物件關聯在一起，並且這種關聯的關係是一種鏈狀的結構，我們將原型對</p>\n<p>象的鏈狀結構關係稱為原型鏈</p>\n<p><img src=\"/assets/1676793388695.png\" alt=\"67679338869\"></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; function Objetc() &#123;&#125;\n    console.log(Object.prototype)\n    console.log(Object.prototype.__proto__)\n\n    function Person() &#123;\n\n    &#125;\n    const ldh &#x3D; new Person()\n    &#x2F;&#x2F; console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype)\n    &#x2F;&#x2F; console.log(Person.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype)\n    console.log(ldh instanceof Person)\n    console.log(ldh instanceof Object)\n    console.log(ldh instanceof Array)\n    console.log([1, 2, 3] instanceof Array)\n    console.log(Array instanceof Object)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<p>① 當訪問一個物件的屬性（包括方法）時，首先查找這個物件自身有沒有該屬性。</p>\n<p>② 如果沒有就查找它的原型（也就是 __proto__指向的 prototype 原型物件）</p>\n<p>③ 如果還沒有就查找原型物件的原型（Object的原型物件）</p>\n<p>④ 依此類推一直找到 Object 為止（null）</p>\n<p>⑤ __proto__物件原型的意義就在於為物件成員查找機制提供一個方向，或者說一條路線</p>\n<p>⑥ 可以使用 instanceof 運算子用於檢測構造函數的 prototype 屬性是否出現在某個實例物件的原型鏈上</p>\n","feature":true,"text":"JavaScript 進階 - 第3天筆記 瞭解構造函數原型物件的語法特徵，掌握 JavaScript 中物件導向程式設計的實現方式，基於物件導向程式設計思想實現 DOM 操作的封裝。 瞭解物件導向程式設計的一般特徵 掌握基於構造函數原型物件的邏輯封裝 掌握基於原型物件實現的繼承...","link":"","photos":[],"count_time":{"symbolsCount":"6k","symbolsTime":"5 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":15,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":15,"path":"api/tags/javaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JavaScript-%E9%80%B2%E9%9A%8E-%E7%AC%AC3%E5%A4%A9%E7%AD%86%E8%A8%98\"><span class=\"toc-text\">JavaScript 進階 - 第3天筆記</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">程式設計思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E9%81%8E%E7%A8%8B\"><span class=\"toc-text\">面向過程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91\"><span class=\"toc-text\">物件導向</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">構造函數</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E7%89%A9%E4%BB%B6\"><span class=\"toc-text\">原型物件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#constructor-%E5%B1%AC%E6%80%A7\"><span class=\"toc-text\">constructor 屬性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%89%A9%E4%BB%B6%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">物件原型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E7%B9%BC%E6%89%BF\"><span class=\"toc-text\">原型繼承</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%8F%88\"><span class=\"toc-text\">原型鏈</span></a></li></ol></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"(./source/img/1.jpg)","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaScript 進階 - 第4天","uid":"956114e1932534f6adc2e3848138c40e","slug":"20230401JavaScript 進階 - 第4天","date":"2023-04-01T01:22:08.000Z","updated":"2023-03-25T02:06:49.968Z","comments":true,"path":"api/articles/20230401JavaScript 進階 - 第4天.json","keywords":null,"cover":null,"text":"JavaScript 進階 - 第4天深淺拷貝淺拷貝首先淺拷貝和深拷貝只針對參考類型 淺拷貝：拷貝的是位址 常見方法： 拷貝物件：Object.assgin() &#x2F; 展開運運算元 {…obj} 拷貝物件 拷貝陣列：Array.prototype.concat() 或者 ...","link":"","photos":[],"count_time":{"symbolsCount":"9.2k","symbolsTime":"8 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":15,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":15,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"(./source/img/1.jpg)","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"JavaScript 進階 - 第2天","uid":"b57064d0869ba36d27730b8b11beee0b","slug":"20230330JavaScript 進階 - 第2天","date":"2023-03-30T01:22:08.000Z","updated":"2023-04-03T02:16:01.016Z","comments":true,"path":"api/articles/20230330JavaScript 進階 - 第2天.json","keywords":null,"cover":null,"text":" 瞭解物件導向程式設計的基礎概念及構造函數的作用，體會 JavaScript 一切皆物件的語言特徵，掌握常見的物件屬性和方法的使用。 瞭解物件導向程式設計中的一般概念 能夠基於構造函數創建物件 理解 JavaScript 中一切皆物件的語言特徵 理解引用物件類型值存儲的的特徵 掌...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":15,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":15,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"(./source/img/1.jpg)","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}