{"title":"JavaScript 進階 - 第3天","uid":"c43b2d50b25bb22e84622db700db53eb","slug":"2303-3 JS 進階3","date":"2023-03-31T01:22:08.000Z","updated":"2023-04-05T01:18:28.622Z","comments":true,"path":"api/articles/2303-3 JS 進階3.json","keywords":null,"cover":[],"content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>瞭解構造函數原型物件的語法特徵，掌握 JavaScript 中物件導向程式設計的實現方式，基於物件導向程式設計思想實現 DOM 操作的封裝。</p></blockquote>\n<ul>\n<li>瞭解物件導向程式設計的一般特徵</li>\n<li>掌握基於構造函數原型物件的邏輯封裝</li>\n<li>掌握基於原型物件實現的繼承</li>\n<li>理解什麼原型鏈及其作用</li>\n<li>能夠處理常式異常提升程式執行的健壯性</li>\n</ul>\n<h1 id=\"程式設計思想\"><a href=\"#程式設計思想\" class=\"headerlink\" title=\"程式設計思想\"></a>程式設計思想</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>學習 JavaScript 中基於原型的物件導向編程式的語法實現，理解物件導向程式設計的特徵。</p></blockquote>\n<h2 id=\"面向過程-前端使用居多\"><a href=\"#面向過程-前端使用居多\" class=\"headerlink\" title=\"面向過程(前端使用居多)\"></a>面向過程(前端使用居多)</h2><p>面向過程就是分析出解決問題所需要的步驟，然後用函數把這些步驟一步一步實現，使用的時候再一個一個的依次</p>\n<p>調用就可以了。</p>\n<h2 id=\"物件導向-面向對象\"><a href=\"#物件導向-面向對象\" class=\"headerlink\" title=\"物件導向(面向對象)\"></a>物件導向(面向對象)</h2><p>物件導向是把事務分解成為一個個物件，然後由物件之間分工與合作。</p>\n<p>在物件導向程式開發思想中，每一個物件都是功能中心，具有明確分工。</p>\n<p>物件導向程式設計具有靈活、代碼可複用、容易維護和開發的優點，更適合多人合作的大型軟體專案。</p>\n<p>物件導向的特性：</p>\n<ul>\n<li><p>封裝性</p>\n</li>\n<li><p>繼承性</p>\n</li>\n<li><p>多態性</p>\n</li>\n</ul>\n<h2 id=\"比較\"><a href=\"#比較\" class=\"headerlink\" title=\"比較\"></a>比較</h2><ul>\n<li><p>面向過程編程</p>\n<ul>\n<li>優點：性能比面向對象高 ，適合跟 硬件聯繫很緊密<br>的東西 ，例如單片機就採用的面向過程 編程。</li>\n<li>缺點：沒有面向對象易維護、易復用、易擴展</li>\n</ul>\n</li>\n<li><p>面向對象編程</p>\n<ul>\n<li>優點：易維護、易復用、易擴展，由於面向對像有封裝<br>、繼承、多態性的特性，可以設計出低耦合的系統，使<br>系統 更加靈活、更加易於維護</li>\n<li>缺點：性能比面向過程低</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"構造函數\"><a href=\"#構造函數\" class=\"headerlink\" title=\"構造函數\"></a>構造函數</h1><p>對比以下通過物件導向的構造函數實現的封裝：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    this.name &#x3D; &#39;佚名&#39;\n    &#x2F;&#x2F; 設置名字\n    this.setName &#x3D; function (name) &#123;\n      this.name &#x3D; name\n    &#125;\n    &#x2F;&#x2F; 讀取名字\n    this.getName &#x3D; () &#x3D;&gt; &#123;\n      console.log(this.name)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 實例對像，獲得了構造函數中封裝的所有邏輯\n  let p1 &#x3D; new Person()\n  p1.setName(&#39;小明&#39;)\n  console.log(p1.name)\n\n  &#x2F;&#x2F; 實例物件\n  let p2 &#x3D; new Person()\n  console.log(p2.name)\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。</p>\n<p>同樣的將變數和函數組合到了一起並能通過 this 實現資料的共用，所不同的是借助構造函數創建出來的<strong>實例物件之間是彼此不影響的</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>總結：</p>\n<ol>\n<li>構造函數體現了物件導向的封裝特性</li>\n<li>構造函數實例創建的物件彼此獨立、互不影響</li>\n</ol></blockquote>\n<p>封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。</p>\n<p>前面我們學過的構造函數方法很好用，但是 存在<code>浪費記憶體</code>的問題</p>\n<h1 id=\"原型物件\"><a href=\"#原型物件\" class=\"headerlink\" title=\"原型物件\"></a>原型物件</h1><p>構造函數通過原型分配的函數是所有物件所 共用的。</p>\n<ul>\n<li>JavaScript 規定，每一個構造函數都有一個 <strong>prototype</strong> 屬性，指向另一個物件，所以我們也稱為原型物件</li>\n<li>這個物件可以掛載函數，物件產生實體不會多次創建原型上函數，節約記憶體</li>\n<li>我們可以<strong>把那些不變的方法，直接定義在 prototype 物件上，這樣所有物件的實例就可以共用這些方法。</strong></li>\n<li>構造函數和原型物件中的this 都指向 產生實體的物件</li>\n</ul>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    \n  &#125;\n\n  &#x2F;&#x2F; 每個函數都有 prototype 屬性\n  console.log(Person.prototype)\n&lt;&#x2F;script&gt;</code></pre>\n\n\n<p>瞭解了 JavaScript 中構造函數與原型物件的關係後，再來看原型物件具體的作用，如下代碼所示：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處未定義任何方法\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n  \n  &#x2F;&#x2F; 產生實體\n  let p1 &#x3D; new Person();\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 Hi~\n&lt;&#x2F;script&gt;</code></pre>\n\n\n<p>構造函數 <code>Person</code> 中未定義任何方法，這時實例物件調用了原型物件中的方法 <code>sayHi</code>，接下來改動一下代碼：</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處定義同名方法 sayHi\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;嗨!&#39;);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n\n  let p1 &#x3D; new Person();\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 嗨!\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>構造函數 <code>Person</code> 中定義與原型物件中相同名稱的方法，這時實例物件調用則是構造函中的方法 <code>sayHi</code>。</p>\n<p>通過以上兩個簡單示例不難發現 JavaScript 中物件的工作機制：<strong>當訪問物件的屬性或方法時，先在當前實例物件是查找，然後再去原型物件查找，並且原型物件被所有實例共用。</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處定義同名方法 sayHi\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;嗨!&#39; + this.name)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39; + this.name)\n  &#125;\n  &#x2F;&#x2F; 在構造函數的原型物件上添加屬性\n  Person.prototype.name &#x3D; &#39;小明&#39;\n\n  let p1 &#x3D; new Person()\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 嗨!\n  \n  let p2 &#x3D; new Person()\n  p2.sayHi()\n&lt;&#x2F;script&gt;</code></pre>\n\n<p>總結：<strong>結合構造函數原型的特徵，實際開發重往往會將封裝的功能函數添加到原型物件中。</strong></p>\n<h2 id=\"constructor-屬性\"><a href=\"#constructor-屬性\" class=\"headerlink\" title=\"constructor 屬性\"></a>constructor 屬性</h2><p>在哪裡？ 每個原型物件裡面都有個constructor 屬性（constructor 構造函數）</p>\n<p>作用：該屬性指向該原型物件的構造函數， 簡單理解，就是指向我的爸爸，我是有爸爸的孩子</p>\n<p><strong>使用場景：</strong></p>\n<p>如果有多個物件的方法，我們可以給原型物件採取物件形式賦值.</p>\n<p>但是這樣就會覆蓋構造函數原型物件原來的內容，這樣修改後的原型物件 constructor 就不再指向當前構造函數了</p>\n<p>此時，我們可以在修改後的原型物件中，添加一個 constructor 指向原來的構造函數。</p>\n<h2 id=\"物件原型\"><a href=\"#物件原型\" class=\"headerlink\" title=\"物件原型\"></a>物件原型</h2><p>物件都會有一個屬性<code> _proto_</code> 指向構造函數的 prototype 原型物件，之所以我們物件可以使用構造函數 prototype </p>\n<p>原型物件的屬性和方法，就是因為物件有 <code>_proto_</code> 原型的存在。</p>\n<p>注意：</p>\n<ul>\n<li><code>__proto__</code> 是JS非標準屬性</li>\n<li>[[prototype]]和<code>_proto_</code>意義相同</li>\n<li>用來表明當前實例物件指向哪個原型物件prototype</li>\n<li>_proto_物件原型裡面也有一個 constructor屬性，指向創建該實例物件的構造函數</li>\n</ul>\n<h2 id=\"小節\"><a href=\"#小節\" class=\"headerlink\" title=\"小節\"></a>小節</h2><ul>\n<li><ol>\n<li>prototype 是什麼？哪裡來的？</li>\n</ol>\n<ul>\n<li>原型（原型對象）</li>\n<li>構造函數都自動有原型</li>\n</ul>\n</li>\n<li><ol start=\"2\">\n<li>constructor 屬性在哪裡？作用乾啥的？</li>\n</ol>\n<ul>\n<li>prototype 原型和對象原型 <code>_proto_</code> 裡面都有</li>\n<li>都<strong>指向</strong>創建實例對象 原型的 <strong>構造函數</strong></li>\n</ul>\n</li>\n<li><ol start=\"3\">\n<li><code>_proto_</code>屬性 在哪裡 ？指向誰</li>\n</ol>\n<ul>\n<li>在實例對象裡面</li>\n<li>指向原型 prototype</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"原型繼承\"><a href=\"#原型繼承\" class=\"headerlink\" title=\"原型繼承\"></a>原型繼承</h2><p>繼承是物件導向程式設計的另一個特徵，通過繼承進一步提升代碼封裝的程度，JavaScript 中大多是借助原型物件實現繼承的特性。</p>\n<p>龍生龍、鳳生鳳、老鼠的兒子會打洞描述的正是繼承的含義。</p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 繼續抽取   公共的部分放到原型上\n    &#x2F;&#x2F; const Person1 &#x3D; &#123;\n    &#x2F;&#x2F;   eyes: 2,\n    &#x2F;&#x2F;   head: 1\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; const Person2 &#x3D; &#123;\n    &#x2F;&#x2F;   eyes: 2,\n    &#x2F;&#x2F;   head: 1\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; 構造函數  new 出來的物件 結構一樣，但是物件不一樣\n    function Person() &#123;\n      this.eyes &#x3D; 2\n      this.head &#x3D; 1\n    &#125;\n    &#x2F;&#x2F; console.log(new Person)\n    &#x2F;&#x2F; 女人  構造函數   繼承  想要 繼承 Person\n    function Woman() &#123;\n\n    &#125;\n    &#x2F;&#x2F; Woman 通過原型來繼承 Person\n    &#x2F;&#x2F; 父構造函數（父類）   子構造函數（子類）\n    &#x2F;&#x2F; 子類的原型 &#x3D;  new 父類  \n    Woman.prototype &#x3D; new Person()   &#x2F;&#x2F; &#123;eyes: 2, head: 1&#125; \n    &#x2F;&#x2F; 指回原來的構造函數\n    Woman.prototype.constructor &#x3D; Woman\n\n    &#x2F;&#x2F; 給女人添加一個方法  生孩子\n    Woman.prototype.baby &#x3D; function () &#123;\n      console.log(&#39;寶貝&#39;)\n    &#125;\n    const red &#x3D; new Woman()\n    console.log(red)\n    &#x2F;&#x2F; console.log(Woman.prototype)\n    &#x2F;&#x2F; 男人 構造函數  繼承  想要 繼承 Person\n    function Man() &#123;\n\n    &#125;\n    &#x2F;&#x2F; 通過 原型繼承 Person\n    Man.prototype &#x3D; new Person()\n    Man.prototype.constructor &#x3D; Man\n    const pink &#x3D; new Man()\n    console.log(pink)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<h2 id=\"原型鏈\"><a href=\"#原型鏈\" class=\"headerlink\" title=\"原型鏈\"></a>原型鏈</h2><p>基於原型物件的繼承使得不同構造函數的原型物件關聯在一起，並且這種關聯的關係是一種鏈狀的結構，我們將原型對象的鏈狀結構關係稱為原型鏈</p>\n<p><img src=\"/../img/1676793388695.png\"></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; function Objetc() &#123;&#125;\n    console.log(Object.prototype)\n    console.log(Object.prototype.__proto__)\n\n    function Person() &#123;\n\n    &#125;\n    const ldh &#x3D; new Person()\n    &#x2F;&#x2F; console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype)\n    &#x2F;&#x2F; console.log(Person.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype)\n    console.log(ldh instanceof Person)\n    console.log(ldh instanceof Object)\n    console.log(ldh instanceof Array)\n    console.log([1, 2, 3] instanceof Array)\n    console.log(Array instanceof Object)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;</code></pre>\n\n<p>① 當訪問一個物件的屬性（包括方法）時，首先查找這個<strong>物件自身</strong>有沒有該屬性。<br>② 如果沒有就查找它的原型（也就是 <code>__proto__</code>指向的 <strong>prototype 原型物件</strong>）<br>③ 如果還沒有就查找原型物件的原型（<strong>Object的原型物件</strong>）<br>④ 依此類推一直找到 Object 為止（<strong>null</strong>）<br>⑤ __proto__物件原型的意義就在於為物件成員查找機制提供一個方向，或者說一條路線<br>⑥ 可以使用 instanceof 運算子用於檢測構造函數的 prototype 屬性是否出現在某個實例物件的原型鏈上</p>\n","feature":null,"text":" 瞭解構造函數原型物件的語法特徵，掌握 JavaScript 中物件導向程式設計的實現方式，基於物件導向程式設計思想實現 DOM 操作的封裝。 瞭解物件導向程式設計的一般特徵 掌握基於構造函數原型物件的邏輯封裝 掌握基於原型物件實現的繼承 理解什麼原型鏈及其作用 能夠處理常式異常...","link":"","photos":[],"count_time":{"symbolsCount":"6.3k","symbolsTime":"6 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">程式設計思想</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%A2%E5%90%91%E9%81%8E%E7%A8%8B-%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E5%B1%85%E5%A4%9A\"><span class=\"toc-text\">面向過程(前端使用居多)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-%E9%9D%A2%E5%90%91%E5%B0%8D%E8%B1%A1\"><span class=\"toc-text\">物件導向(面向對象)</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%AF%94%E8%BC%83\"><span class=\"toc-text\">比較</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A7%8B%E9%80%A0%E5%87%BD%E6%95%B8\"><span class=\"toc-text\">構造函數</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E7%89%A9%E4%BB%B6\"><span class=\"toc-text\">原型物件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#constructor-%E5%B1%AC%E6%80%A7\"><span class=\"toc-text\">constructor 屬性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%89%A9%E4%BB%B6%E5%8E%9F%E5%9E%8B\"><span class=\"toc-text\">物件原型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%AF%80\"><span class=\"toc-text\">小節</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E7%B9%BC%E6%89%BF\"><span class=\"toc-text\">原型繼承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9E%8B%E9%8F%88\"><span class=\"toc-text\">原型鏈</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JavaScript 進階 - 第4天","uid":"956114e1932534f6adc2e3848138c40e","slug":"2303-3 JS 進階4-4 防抖節流","date":"2023-04-01T01:22:08.000Z","updated":"2024-01-28T04:26:03.749Z","comments":true,"path":"api/articles/2303-3 JS 進階4-4 防抖節流.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/46a3e3ddbdade37866e3aaf24a04bbe6.jpg?raw=true","text":"防抖節流節流 和防抖的區別是？ 防抖（debounce） 所謂防抖，就是指觸發事件後在 n 秒內函數只能執行一次(最後一次)，如果在 n 秒內又觸發了事件，則會重新計算函數執行時間 節流（throttle） 所謂節流，就是指連續觸發事件但是在 n 秒中只執行一次函數(不會被打斷)...","link":"","photos":[],"count_time":{"symbolsCount":266,"symbolsTime":"1 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"JavaScript 進階 - 第2天","uid":"b57064d0869ba36d27730b8b11beee0b","slug":"2303-3 JS 進階2","date":"2023-03-30T01:22:08.000Z","updated":"2023-04-04T00:04:34.343Z","comments":true,"path":"api/articles/2303-3 JS 進階2.json","keywords":null,"cover":[],"text":" 瞭解物件導向程式設計的基礎概念及構造函數的作用，體會 JavaScript 一切皆物件的語言特徵，掌握常見的物件屬性和方法的使用。 瞭解物件導向程式設計中的一般概念 能夠基於構造函數創建物件 理解 JavaScript 中一切皆物件的語言特徵 理解引用物件類型值存儲的的特徵 掌...","link":"","photos":[],"count_time":{"symbolsCount":"6.2k","symbolsTime":"6 mins."},"categories":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/categories/javaScript.json"}],"tags":[{"name":"javaScript","slug":"javaScript","count":20,"path":"api/tags/javaScript.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}