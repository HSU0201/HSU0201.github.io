{"title":"ES6 介绍","uid":"1e00bbc5a1a969d8b4414c942e9fedc9","slug":"es6/03【解構賦值(Destructuring Assignment)】","date":"2024-01-25T11:06:25.000Z","updated":"2024-02-03T06:48:51.986Z","comments":true,"path":"api/articles/es6/03【解構賦值(Destructuring Assignment)】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","content":"<h1 id=\"03【解構賦值-Destructuring-Assignment-】\"><a href=\"#03【解構賦值-Destructuring-Assignment-】\" class=\"headerlink\" title=\"03【解構賦值(Destructuring Assignment)】\"></a>03【解構賦值(Destructuring Assignment)】</h1><p>將陣列或物件中的資料解開擷取成為獨立變數。</p>\n<h2 id=\"語法\"><a href=\"#語法\" class=\"headerlink\" title=\"語法\"></a>語法</h2><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a, b, rest;\n[a, b] &#x3D; [10, 20];\nconsole.log(a); &#x2F;&#x2F; 10\nconsole.log(b); &#x2F;&#x2F; 20\n\n[a, b, ...rest] &#x3D; [10, 20, 30, 40, 50];\nconsole.log(a); &#x2F;&#x2F; 10\nconsole.log(b); &#x2F;&#x2F; 20\nconsole.log(rest); &#x2F;&#x2F; [30, 40, 50]\n\n(&#123; a, b &#125; &#x3D; &#123; a: 10, b: 20 &#125;);\nconsole.log(a); &#x2F;&#x2F; 10\nconsole.log(b); &#x2F;&#x2F; 20\n\n&#x2F;&#x2F; Stage 4(finished) proposal\n(&#123; a, b, ...rest &#125; &#x3D; &#123; a: 10, b: 20, c: 30, d: 40 &#125;);\nconsole.log(a); &#x2F;&#x2F; 10\nconsole.log(b); &#x2F;&#x2F; 20\nconsole.log(rest); &#x2F;&#x2F; &#123;c: 30, d: 40&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>destructuring</strong>: 變性、破壞性。使⽤”解構”是對照<code>de-</code>字頭有”脫離”、”去除”的意思。<br><strong>assignment</strong>: 賦值、指定。賦值通常指的是程式中使⽤等號(&#x3D;)運算符的語句。</p></blockquote>\n<h2 id=\"1-陣列的解構賦值\"><a href=\"#1-陣列的解構賦值\" class=\"headerlink\" title=\"1.陣列的解構賦值\"></a>1.陣列的解構賦值</h2><h3 id=\"1-1-原理\"><a href=\"#1-1-原理\" class=\"headerlink\" title=\"1.1 原理\"></a>1.1 原理</h3><p>ES6 中的解構（Destructuring）語法允許從數組和物件中提取值，並將其賦給變量，這樣的賦值方式更加簡潔和靈活。</p>\n<p>以前，為變量賦值，只能直接指定值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a &#x3D; 1;\nlet b &#x3D; 2;\nlet c &#x3D; 3;</code></pre>\n\n<p>ES6 允許寫成下面這樣。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let [a, b, c] &#x3D; [1, 2, 3];</code></pre>\n\n<p>上面代碼表示，可以從陣列中提取值，按照對應位置，對變量賦值。</p>\n<ol>\n<li><p>模式（結構）匹配 <code>[] = [1, 2, 3];</code>，其中方括號內的模式和賦值的陣列結構相符。</p>\n</li>\n<li><p>索引值相同的完成賦值 <code>const [a, b, c] = [1, 2, 3];</code></p>\n</li>\n<li><p>舉例</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const [a, [, , b], c] &#x3D; [1, [2, 3, 4], 5];\nconsole.log(a, b, c); &#x2F;&#x2F; 1 4 5</code></pre>\n\n<p><code>a</code>被賦值為數組的第一個元素，<code>b</code>被賦值為<strong>巢狀數組的第三個元素</strong>，<code>c</code>被賦值為數組的最後一個元素。</p>\n</li>\n</ol>\n<h3 id=\"1-2-陣列解構賦值的預設值\"><a href=\"#1-2-陣列解構賦值的預設值\" class=\"headerlink\" title=\"1.2 陣列解構賦值的預設值\"></a>1.2 陣列解構賦值的預設值</h3><p><strong>（1）預設值的基本用法</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const [a, b] &#x3D; [];\nconsole.log(a, b); &#x2F;&#x2F; undefined undefined\n\n&#x2F;&#x2F; ---------------------------------------\nconst [a &#x3D; 1, b &#x3D; 2] &#x3D; [];\nconsole.log(a, b); &#x2F;&#x2F; 1 2</code></pre>\n\n<p><strong>（2）預設值的生效條件</strong></p>\n<p>只有當一個陣列成員嚴格等於 (&#x3D;&#x3D;&#x3D;) undefined 時，對應的預設值才會生效。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const [a &#x3D; 1, b &#x3D; 2] &#x3D; [3, 0]; &#x2F;&#x2F; 3 0\nconst [a &#x3D; 1, b &#x3D; 2] &#x3D; [3, null]; &#x2F;&#x2F; 3 null\nconst [a &#x3D; 1, b &#x3D; 2] &#x3D; [3, undefined]; &#x2F;&#x2F; 3 2\nconst [a &#x3D; 1, b &#x3D; 2] &#x3D; [3]; &#x2F;&#x2F; 3 2</code></pre>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">解構賦值 MDN 文檔</a></li>\n</ul>\n<p><strong>（3）預設值表達式</strong></p>\n<p>如果預設值是表達式，預設值表達式是<a href=\"https://zh.wikipedia.org/zh-tw/%E6%83%B0%E6%80%A7%E6%B1%82%E5%80%BC\">延遲求值</a>的（即：當無需用到預設值時，表達式是不會求值的）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const func &#x3D; () &#x3D;&gt; &#123;\n  return 24;\n&#125;;\n\nconst [a &#x3D; func()] &#x3D; [1]; &#x2F;&#x2F; 1\nconst [b &#x3D; func()] &#x3D; []; &#x2F;&#x2F; 24</code></pre>\n\n<h3 id=\"1-3-陣列解構賦值的應用\"><a href=\"#1-3-陣列解構賦值的應用\" class=\"headerlink\" title=\"1.3 陣列解構賦值的應用\"></a>1.3 陣列解構賦值的應用</h3><p><strong>（1）交換變量的值</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let a &#x3D; 1;\nlet b &#x3D; 3;\n\n[a, b] &#x3D; [b, a];\nconsole.log(a); &#x2F;&#x2F; 3\nconsole.log(b); &#x2F;&#x2F; 1\n\nconst arr &#x3D; [1, 2, 3];\n[arr[2], arr[1]] &#x3D; [arr[1], arr[2]];\nconsole.log(arr); &#x2F;&#x2F; [1,3,2]</code></pre>\n\n<p><strong>（2）解析自函式回傳的陣列</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function f() &#123;\n  return [1, 2];\n&#125;\n\nlet a, b;\n[a, b] &#x3D; f();\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(b); &#x2F;&#x2F; 2</code></pre>\n\n<p><strong>（3）忽略某些回傳值</strong></p>\n<p>在解構陣列時，可以忽略不需要解構的值，可以使用逗號對解構的陣列進行忽略操作，這樣就不需要聲明更多的變量去存值了：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function f() &#123;\n  return [1, 2, 2, 3];\n&#125;\n\nconst [a, , , b] &#x3D; f();\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(b); &#x2F;&#x2F; 3</code></pre>\n\n<ul>\n<li>上面的例子中，在 a、b 中間用逗號隔開了兩個值，這裏怎麼判斷間隔幾個值呢，可以看出逗號之間組成了多少間隔，就是間隔了多少個值。如果取值很少的情況下可以使用下標索引的方式來獲取值。</li>\n</ul>\n<p>也可以忽略全部回傳值</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">[, ,] &#x3D; f();</code></pre>\n\n<p><strong>（4）剩餘參數中的使用</strong></p>\n<p>通常情況下，需要把剩餘的陣列項作為一個單獨的陣列，這個時候我們可以借助展開語法把剩下的陣列中的值，作為一個單獨的陣列，如下：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var [a, b, ...rest] &#x3D; [10, 20, 30, 40, 50];\nconsole.log(a); &#x2F;&#x2F; 10\nconsole.log(b); &#x2F;&#x2F; 20\nconsole.log(rest); &#x2F;&#x2F; [30, 40, 50]</code></pre>\n\n<p>在 rest 的後面不能有 逗號 不然會報錯，程序會認出你後面還有值。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[非常重要!]<code>...rest</code> 是剩餘參數的解構，所以只能放在陣列的最後，在它之後不能再有變量，否則則會報錯。</p></blockquote>\n<p><strong>（5）從正則運算式的比對結果取值</strong></p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function parseProtocol(url) &#123;\n  const parsedURL &#x3D; &#x2F;^(\\w+)\\:\\&#x2F;\\&#x2F;([^\\&#x2F;]+)\\&#x2F;(.*)$&#x2F;.exec(url);\n  if (!parsedURL) &#123;\n    return false;\n  &#125;\n  console.log(parsedURL); &#x2F;&#x2F; [&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;Web&#x2F;JavaScript&quot;, &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US&#x2F;Web&#x2F;JavaScript&quot;]\n\n  const [, protocol, fullhost, fullpath] &#x3D; parsedURL;\n  return protocol;\n&#125;\n\nconsole.log(\n  parseProtocol(&quot;https:&#x2F;&#x2F;developer.mozilla.org&#x2F;en-US&#x2F;Web&#x2F;JavaScript&quot;)\n); &#x2F;&#x2F; &quot;https&quot;</code></pre>\n\n<p><strong>（補充）arguments</strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>arguments 物件是一個對應傳入函式之引數的類陣列（Array-like）物件。</p></blockquote>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function func() &#123;\n  const [a, b] &#x3D; arguments;\n  console.log(a, b); &#x2F;&#x2F; 1 2\n&#125;\nfunc(1, 2);</code></pre>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/from#%E6%8F%8F%E8%BF%B0\">擴展閱讀-Array-like</a></li>\n</ul>\n<p><strong>（補充）NodeList</strong></p>\n<pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;NodeList&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;p&gt;1&lt;&#x2F;p&gt;\n    &lt;p&gt;2&lt;&#x2F;p&gt;\n    &lt;p&gt;3&lt;&#x2F;p&gt;\n    &lt;script&gt;\n      const [p1, p2, p3] &#x3D; document.querySelectorAll(&quot;p&quot;);\n      console.log(p1, p2, p3);\n      &#x2F;*\n    &lt;p&gt;1&lt;&#x2F;p&gt;\n    &lt;p&gt;2&lt;&#x2F;p&gt;\n    &lt;p&gt;3&lt;&#x2F;p&gt;\n    *&#x2F;\n    &lt;&#x2F;script&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n\n<h3 id=\"1-4-必須要分號的兩種情況\"><a href=\"#1-4-必須要分號的兩種情況\" class=\"headerlink\" title=\"1.4 必須要分號的兩種情況\"></a>1.4 必須要分號的兩種情況</h3><ol>\n<li>立即執行函式</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 加上分號可以避免可能的錯誤，或者，在函式定義之前加上分號，以避免這種情況。\n(function () &#123;\n  &#x2F;&#x2F; 函式內容\n&#125;)();</code></pre>\n\n<ol start=\"2\">\n<li>使用陣列解構的時候</li>\n</ol>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; const arr &#x3D; [1, 2, 3]\nconst str &#x3D; &quot;pink&quot;;\n[1, 2, 3].map(function (item) &#123;\n  console.log(item);\n&#125;);\n\nlet a &#x3D; 1;\nlet b &#x3D; 2;\n[b, a] &#x3D; [a, b];\n\nconsole.log(a, b);</code></pre>\n\n<h2 id=\"2-物件的解構賦值\"><a href=\"#2-物件的解構賦值\" class=\"headerlink\" title=\"2.物件的解構賦值\"></a>2.物件的解構賦值</h2><h3 id=\"2-1-原理\"><a href=\"#2-1-原理\" class=\"headerlink\" title=\"2.1 原理\"></a>2.1 原理</h3><p>物件的解構和陣列基本類似，物件解構的變量是在 <code>&#123;&#125;</code> 中定義的。物件沒有索引，但物件有更明確的鍵，通過鍵可以很方便地去物件中取值。在 ES6 之前直接使用鍵取值已經很方便了：</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123; name: &quot;imooc&quot;, age: 7 &#125;;\nconst name &#x3D; obj.name; &#x2F;&#x2F; imooc\nconst age &#x3D; obj.age; &#x2F;&#x2F; 7</code></pre>\n\n<p>但是在 ES6 中通過解構的方式，更加簡潔地對取值做了簡化，不需要通過點操作增加額外的取值操作。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123; name: &quot;imooc&quot;, age: 7 &#125;;\nconst &#123; name, age &#125; &#x3D; obj; &#x2F;&#x2F; name: imooc, age: 7</code></pre>\n\n<p>在 <code>&#123;&#125;</code> 直接聲明 name 和 age 用逗號隔開即可得到目標物件上的值，完成聲明賦值操作。</p>\n<ol>\n<li>模式（結構）匹配 <code>&#123;&#125; = &#123;&#125;;</code></li>\n<li>屬性名相同的完成賦值 <code>const &#123;name, age&#125; = &#123;name: &#39;jerry&#39;, age: 18&#125;;</code> 或 <code>const &#123;age, name&#125; = &#123;name: &#39;jerry&#39;, age: 18&#125;;</code></li>\n</ol>\n<h3 id=\"2-2-物件解構賦值的預設值\"><a href=\"#2-2-物件解構賦值的預設值\" class=\"headerlink\" title=\"2.2 物件解構賦值的預設值\"></a>2.2 物件解構賦值的預設值</h3><ol>\n<li><p>物件的屬性值嚴格等於 undefined 時，對應的預設值才會生效。</p>\n</li>\n<li><p>如果預設值是表達式，預設值表達式是惰性求值的。</p>\n</li>\n</ol>\n<p>物件的預設值和陣列的預設值一樣，只能通過嚴格相等運算子（&#x3D;&#x3D;&#x3D;）來進行判斷，只有當一個物件的屬性值嚴格等於 <code>undefined</code>，預設值才會生效。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var &#123; a &#x3D; 10, b &#x3D; 5 &#125; &#x3D; &#123; a: 3 &#125;; &#x2F;&#x2F; a &#x3D; 3, b &#x3D; 5\nvar &#123; a &#x3D; 10, b &#x3D; 5 &#125; &#x3D; &#123; a: 3, b: undefined &#125;; &#x2F;&#x2F; a &#x3D; 3, b &#x3D; 5\nvar &#123; a &#x3D; 10, b &#x3D; 5 &#125; &#x3D; &#123; a: 3, b: null &#125;; &#x2F;&#x2F; a &#x3D; 3, b &#x3D; null</code></pre>\n\n<p>所以這裏的第二項 b 的值是預設值，第三項的 <code>null === undefined</code> 的值為 false，所以 b 的值為 null。</p>\n<h3 id=\"2-3-重命名屬性\"><a href=\"#2-3-重命名屬性\" class=\"headerlink\" title=\"2.3 重命名屬性\"></a>2.3 重命名屬性</h3><p>在物件解構出來的變量不是我們想要的變量命名，這時我們需要對它進行重命名。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const &#123; a: aa &#x3D; 10, b: bb &#x3D; 5 &#125; &#x3D; &#123; a: 3 &#125;;\n\nconsole.log(aa); &#x2F;&#x2F; 3\nconsole.log(bb); &#x2F;&#x2F; 5</code></pre>\n\n<p>這裏把 a 和 b 的變量名重新命名為 aa 和 bb。</p>\n<h3 id=\"2-4-物件解構賦值的應用\"><a href=\"#2-4-物件解構賦值的應用\" class=\"headerlink\" title=\"2.4 物件解構賦值的應用\"></a>2.4 物件解構賦值的應用</h3><h4 id=\"（1）物件作為函式參數\"><a href=\"#（1）物件作為函式參數\" class=\"headerlink\" title=\"（1）物件作為函式參數\"></a>（1）物件作為函式參數</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const user &#x3D; &#123;\n  id: 42,\n  displayName: &quot;jdoe&quot;,\n  fullName: &#123;\n    firstName: &quot;John&quot;,\n    lastName: &quot;Doe&quot;,\n  &#125;,\n&#125;;\n\nfunction userId(&#123; id &#125;) &#123;\n  return id;\n&#125;\n\nfunction whois(&#123; displayName, fullName: &#123; firstName: name &#125; &#125;) &#123;\n  return &#96;$&#123;displayName&#125; is $&#123;name&#125;&#96;;\n&#125;\n\nconsole.log(userId(user)); &#x2F;&#x2F; 42\nconsole.log(whois(user)); &#x2F;&#x2F; &quot;jdoe is John&quot;</code></pre>\n\n<h4 id=\"（2）物件作為函式參數\"><a href=\"#（2）物件作為函式參數\" class=\"headerlink\" title=\"（2）物件作為函式參數\"></a>（2）物件作為函式參數</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">function drawChart(&#123;\n  size &#x3D; &quot;big&quot;,\n  coords &#x3D; &#123; x: 0, y: 0 &#125;,\n  radius &#x3D; 25,\n&#125; &#x3D; &#123;&#125;) &#123;\n  console.log(size, coords, radius);\n  &#x2F;&#x2F; do some chart drawing\n&#125;\n\ndrawChart(&#123;\n  coords: &#123; x: 18, y: 30 &#125;,\n  radius: 30,\n&#125;);</code></pre>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>備註： 在上述函式 drawChart 中，左方之解構式被指派到一個空物件: {size &#x3D; ‘big’, coords &#x3D; {x: 0, y: 0}, radius &#x3D; 25} &#x3D; {} 。你也可以略過填寫右方的指派式。不過，當你沒有使用右方指派式時，函式在呼叫時會找出最少一個參數。透過上述形式，你可以直接不使用參數的呼叫 drawChart() 。當你希望在呼叫這個函式時不傳送參數，這個設計會帶來方便。而另一個設計則能讓你確保函式必須傳上一個物件作為參數。</p></blockquote>\n<h4 id=\"補充-設定函式參數的預設值\"><a href=\"#補充-設定函式參數的預設值\" class=\"headerlink\" title=\"[補充]設定函式參數的預設值\"></a>[補充]設定函式參數的預設值</h4><pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">const obj &#x3D; &#123;\n  x: 1,\n  y: [2, 3, 4],\n  z: &#123;\n    a: 5,\n    b: 6,\n  &#125;,\n&#125;;\n\n&#x2F;&#x2F; ----------------------------------------------------\nconst &#123; x, y, z &#125; &#x3D; obj;\nconsole.log(x, y, z); &#x2F;&#x2F; 1 [ 2, 3, 4 ] &#123; a: 5, b: 6 &#125;\n\n&#x2F;&#x2F; ----------------------------------------------------\nconst &#123;\n  y: [, y2],\n&#125; &#x3D; obj;\nconsole.log(y2); &#x2F;&#x2F; 3\nconsole.log(y); &#x2F;&#x2F; 報錯\n\n&#x2F;&#x2F; ----------------------------------------------------\nconst &#123;\n  y: y,\n  y: [, y2],\n&#125; &#x3D; obj;\nconsole.log(y2); &#x2F;&#x2F; 3\nconsole.log(y); &#x2F;&#x2F; [ 2, 3, 4 ]\n\n&#x2F;&#x2F; ----------------------------------------------------\nconst &#123;\n  y,\n  y: [, y2],\n  z,\n  z: &#123; b &#125;,\n&#125; &#x3D; obj;\nconsole.log(y2); &#x2F;&#x2F; 3\nconsole.log(y); &#x2F;&#x2F; [ 2, 3, 4 ]\nconsole.log(z); &#x2F;&#x2F; &#123; a: 5, b: 6 &#125;\nconsole.log(b); &#x2F;&#x2F; 6</code></pre>\n\n<h4 id=\"（3）剩餘參數中的使用\"><a href=\"#（3）剩餘參數中的使用\" class=\"headerlink\" title=\"（3）剩餘參數中的使用\"></a>（3）剩餘參數中的使用</h4><p>在物件的解構中也可以使用剩餘參數，對物件中沒有解構的剩餘屬性做聚合操作，生成一個新的物件。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">var &#123; a, c, ...rest &#125; &#x3D; &#123; a: 1, b: 2, c: 3, d: 4 &#125;;\nconsole.log(a); &#x2F;&#x2F; 1\nconsole.log(c); &#x2F;&#x2F; 3\nconsole.log(rest); &#x2F;&#x2F; &#123; b: 2, d: 4 &#125;</code></pre>\n\n<p>物件中的 b、d 沒有被解構，通過剩餘參數語法把沒有解構的物件屬性聚合到一起形成新的物件。</p>\n<h3 id=\"2-5-注意點\"><a href=\"#2-5-注意點\" class=\"headerlink\" title=\"2.5 注意點\"></a>2.5 注意點</h3><p>（1）如果要將一個已經聲明的變量用於解構賦值，必須非常小心。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 錯誤的寫法\nlet x;\n&#123;x&#125; &#x3D; &#123;x: 1&#125;;\n&#x2F;&#x2F; SyntaxError: syntax error</code></pre>\n\n<p>上面代碼的寫法會報錯，因為 JavaScript 引擎會將<code>&#123;x&#125;</code>理解成一個代碼區塊，從而發生語法錯誤。只有不將大括號寫在行首，避免 JavaScript 將其解釋為代碼區塊，才能解決這個問題。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 正確的寫法\nlet x;\n(&#123; x &#125; &#x3D; &#123; x: 1 &#125;);</code></pre>\n\n<p>上面代碼將整個解構賦值語句，放在一個圓括號裡面，就可以正確執行。關於圓括號與解構賦值的關係，參見下文。</p>\n<p>（2）解構賦值允許等號左邊的模式之中，不放置任何變量名。因此，可以寫出非常古怪的賦值表達式。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">(&#123;&#125; &#x3D; [true, false]);\n(&#123;&#125; &#x3D; &quot;abc&quot;);\n(&#123;&#125; &#x3D; []);</code></pre>\n\n<p>上面的表達式雖然毫無意義，但是語法是合法的，可以執行。</p>\n<p>（3）由於陣列本質是特殊的物件，因此可以對陣列進行物件屬性的解構。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">let arr &#x3D; [1, 2, 3];\nlet &#123; 0: first, [arr.length - 1]: last &#125; &#x3D; arr;\nfirst; &#x2F;&#x2F; 1\nlast; &#x2F;&#x2F; 3</code></pre>\n\n<p>上面代碼對陣列進行物件解構。陣列<code>arr</code>的<code>0</code>鍵對應的值是<code>1</code>，<code>[arr.length - 1]</code>就是<code>2</code>鍵，對應的值是<code>3</code>。</p>\n<h2 id=\"3-字符串的解構賦值\"><a href=\"#3-字符串的解構賦值\" class=\"headerlink\" title=\"3.字符串的解構賦值\"></a>3.字符串的解構賦值</h2><p>既可以用陣列的形式來解構賦值，也可以用物件的形式來解構賦值。</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 陣列形式解構賦值\nconst [a, b, , , c] &#x3D; &quot;hello&quot;;\nconsole.log(a, b, c); &#x2F;&#x2F; h e o\n\n&#x2F;&#x2F; 物件形式解構賦值\nconst &#123; 0: a, 1: b, 4: o, length &#125; &#x3D; &quot;hello&quot;;\nconsole.log(a, b, o, length); &#x2F;&#x2F; h e o 5</code></pre>\n\n<h2 id=\"4-數值和布爾值的解構賦值\"><a href=\"#4-數值和布爾值的解構賦值\" class=\"headerlink\" title=\"4.數值和布爾值的解構賦值\"></a>4.數值和布爾值的解構賦值</h2><p>只能按照物件的形式來解構賦值。</p>\n<p>（會先自動將等號右邊的值轉為物件）</p>\n<pre class=\"line-numbers language-javascript\" data-language=\"javascript\"><code class=\"language-javascript\">&#x2F;&#x2F; 先來複習一下將數值和布爾值轉化為物件\nconsole.log(new Number(123)); &#x2F;&#x2F; [Number: 123]\nconsole.log(new Boolean(true)); &#x2F;&#x2F; [Boolean: true]\n&#x2F;&#x2F; 轉化後的物件裏沒有任何的屬性（沒有 123 這個屬性，也沒有 true 這個屬性）和方法，\n&#x2F;&#x2F; 所有的屬性和方法都在它的繼承 __proto__ 中，比如 toString 方法就是繼承來的。\n\n&#x2F;&#x2F; 裡面的值只能是預設值，繼承的方法倒是可以取到\nconst &#123; a &#x3D; 1, toString &#125; &#x3D; 123;\nconsole.log(a, toString); &#x2F;&#x2F; 1 [Function: toString]\n\n&#x2F;&#x2F; 裡面的值只能是預設值，繼承的方法倒是可以取到\nconst &#123; b &#x3D; 1, toString &#125; &#x3D; true;\nconsole.log(b, toString); &#x2F;&#x2F; 1 [Function: toString]</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>以上展示了將數值和布爾值轉化為物件後，使用解構賦值的過程。需要注意的是，這種操作雖然能夠實現，但通常情況下並不常見，因為它沒有太大的實用意義。</p></blockquote>\n<h2 id=\"5-undefined-和-null-沒有解構賦值\"><a href=\"#5-undefined-和-null-沒有解構賦值\" class=\"headerlink\" title=\"5.undefined 和 null 沒有解構賦值\"></a>5.undefined 和 null 沒有解構賦值</h2><p>由於 undefined 和 null 無法轉為物件，所以對它們進行解構賦值，都會報錯。</p>\n<h2 id=\"6-小結\"><a href=\"#6-小結\" class=\"headerlink\" title=\"6.小結\"></a>6.小結</h2><p>本節講解了 ES6 解構賦值的使用方法，總結下來一共有以下幾點：</p>\n<ol>\n<li>解構賦值一般針對物件和陣列，如果解構物件是 <code>undefined</code> 或是 <code>null</code> 都會報錯；</li>\n<li>預設值的生效條件是，只有當解構的物件的值是嚴格模式下的 <code>undefined</code> 的情況下，預設值才會生效；</li>\n<li>可以不借助中間變量來交換兩個值；</li>\n<li>在解構複雜的資料解構時，注意聲明的物件要和目標的物件有著相同的解構形式，才能去解構目標物件。</li>\n</ol>\n","feature":true,"text":"03【解構賦值(Destructuring Assignment)】將陣列或物件中的資料解開擷取成為獨立變數。 語法let a, b, rest; [a, b] &#x3D; [10, 20]; console.log(a); &#x2F;&#x2F; 10 console.lo...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"ES6","slug":"ES6","count":3,"path":"api/categories/ES6.json"}],"tags":[{"name":"ES6","slug":"ES6","count":3,"path":"api/tags/ES6.json"},{"name":"桃園資展筆記","slug":"桃園資展筆記","count":3,"path":"api/tags/桃園資展筆記.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#03%E3%80%90%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC-Destructuring-Assignment-%E3%80%91\"><span class=\"toc-text\">03【解構賦值(Destructuring Assignment)】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%AA%9E%E6%B3%95\"><span class=\"toc-text\">語法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E9%99%A3%E5%88%97%E7%9A%84%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC\"><span class=\"toc-text\">1.陣列的解構賦值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">1.1 原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E9%99%A3%E5%88%97%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC%E7%9A%84%E9%A0%90%E8%A8%AD%E5%80%BC\"><span class=\"toc-text\">1.2 陣列解構賦值的預設值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E9%99%A3%E5%88%97%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC%E7%9A%84%E6%87%89%E7%94%A8\"><span class=\"toc-text\">1.3 陣列解構賦值的應用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E5%BF%85%E9%A0%88%E8%A6%81%E5%88%86%E8%99%9F%E7%9A%84%E5%85%A9%E7%A8%AE%E6%83%85%E6%B3%81\"><span class=\"toc-text\">1.4 必須要分號的兩種情況</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E7%89%A9%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC\"><span class=\"toc-text\">2.物件的解構賦值</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">2.1 原理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E7%89%A9%E4%BB%B6%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC%E7%9A%84%E9%A0%90%E8%A8%AD%E5%80%BC\"><span class=\"toc-text\">2.2 物件解構賦值的預設值</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E9%87%8D%E5%91%BD%E5%90%8D%E5%B1%AC%E6%80%A7\"><span class=\"toc-text\">2.3 重命名屬性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E7%89%A9%E4%BB%B6%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC%E7%9A%84%E6%87%89%E7%94%A8\"><span class=\"toc-text\">2.4 物件解構賦值的應用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%881%EF%BC%89%E7%89%A9%E4%BB%B6%E4%BD%9C%E7%82%BA%E5%87%BD%E5%BC%8F%E5%8F%83%E6%95%B8\"><span class=\"toc-text\">（1）物件作為函式參數</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%882%EF%BC%89%E7%89%A9%E4%BB%B6%E4%BD%9C%E7%82%BA%E5%87%BD%E5%BC%8F%E5%8F%83%E6%95%B8\"><span class=\"toc-text\">（2）物件作為函式參數</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A3%9C%E5%85%85-%E8%A8%AD%E5%AE%9A%E5%87%BD%E5%BC%8F%E5%8F%83%E6%95%B8%E7%9A%84%E9%A0%90%E8%A8%AD%E5%80%BC\"><span class=\"toc-text\">[補充]設定函式參數的預設值</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%EF%BC%883%EF%BC%89%E5%89%A9%E9%A4%98%E5%8F%83%E6%95%B8%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">（3）剩餘參數中的使用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E6%B3%A8%E6%84%8F%E9%BB%9E\"><span class=\"toc-text\">2.5 注意點</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC\"><span class=\"toc-text\">3.字符串的解構賦值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%95%B8%E5%80%BC%E5%92%8C%E5%B8%83%E7%88%BE%E5%80%BC%E7%9A%84%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC\"><span class=\"toc-text\">4.數值和布爾值的解構賦值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-undefined-%E5%92%8C-null-%E6%B2%92%E6%9C%89%E8%A7%A3%E6%A7%8B%E8%B3%A6%E5%80%BC\"><span class=\"toc-text\">5.undefined 和 null 沒有解構賦值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E5%B0%8F%E7%B5%90\"><span class=\"toc-text\">6.小結</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"240125React零碎知識點","uid":"2c4df57117660657820746cd0823ec89","slug":"240125React零碎知識點","date":"2024-01-25T12:35:16.000Z","updated":"2024-01-28T04:24:31.123Z","comments":true,"path":"api/articles/240125React零碎知識點.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/734257355c559d394eb900a70ea03a08.jpg?raw=true","text":"在 React 應用程式部署前的檔案和資料夾清理在 React 應用程式的開發過程中，有一些檔案和資料夾是開發時使用的，但在最終的發布版本中並不需要包含。在進行壓縮、打包或部署到生產環境時，建議考慮刪除以下檔案和資料夾： 1. package-lock.json：package-...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"React","slug":"React","count":3,"path":"api/categories/React.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"240124React零碎知識點","uid":"6587c0dcefcdc69eda60933087e365f3","slug":"240124React零碎知識點","date":"2024-01-24T11:28:08.000Z","updated":"2024-01-28T04:24:25.865Z","comments":true,"path":"api/articles/240124React零碎知識點.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/blog-Article-Cover/734257355c559d394eb900a70ea03a08.jpg?raw=true","text":"單向資料流程（One-Way Data Flow）單向資料流程是一種軟體設計模式，其中資料在應用程式中的流動方向是單一且明確的。這種模式通常應用在使用者介面（UI）的開發中，特別是在 React 等前端框架中。以下是單向資料流程的一些優缺點： 優點： 可預測性： 單向資料流程使應...","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"16 mins."},"categories":[{"name":"React","slug":"React","count":3,"path":"api/categories/React.json"}],"tags":[{"name":"資策會上課筆記","slug":"資策會上課筆記","count":5,"path":"api/tags/資策會上課筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}