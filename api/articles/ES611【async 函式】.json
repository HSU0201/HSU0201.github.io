{"title":"async 函式","uid":"08a95690396abe22dee79253dd37972c","slug":"ES611【async 函式】","date":"2024-01-24T00:06:25.000Z","updated":"2024-02-04T13:09:43.821Z","comments":true,"path":"api/articles/ES611【async 函式】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/unnamed.png?raw=true","content":"<h1 id=\"11【async-函式】\"><a href=\"#11【async-函式】\" class=\"headerlink\" title=\"11【async 函式】\"></a>11【async 函式】</h1><h2 id=\"async-簡介\"><a href=\"#async-簡介\" class=\"headerlink\" title=\"async 簡介\"></a>async 簡介</h2><p>處理 JavaScript 中的異步程序總是需要面臨各種不同應用情況的挑戰。在 ES6(ES2015)中加入的 Promise 和 Generator 提供了一些新的工具和語法，可以更方便地處理這些異步程序的流程控制。然而，這些新的工具或結構也帶來了一些新的問題，例如：</p>\n<ul>\n<li>語法複雜，需要進一步學習與大幅度修改原有的程式碼</li>\n<li>除錯不容易</li>\n<li>錯誤處理不容易</li>\n<li>對於情況控制(Conditionals)與迴圈&#x2F;迭代處理仍然不是很理想</li>\n</ul>\n<p>在 ECMAScript 2017(ES8) 後，async 函式加入了標準中，其目的是為了解決上述問題。它可以進一步簡化整個語法。</p>\n<p>async&#x2F;await 的語法非常容易學習與使用。相較於 Promise 或 Generator，開發者可以在很短的時間內理解用法，並開始使用它們，甚至不需要對 Promise 或 Generator 有太深入的知識。</p>\n<p>然而，async 函式的基礎仍然是 Promise，它的相對轉換的語法則是組合了 Promise 與 Generator。儘管它提供了更方便使用的語法，能夠輕鬆處理異步程序的流程控制，但仍然需要對 Promise 有一定的理解，才能真正靈活地應用到各種情況中。換句話說，Promise 的知識仍然是必須的，沒有什麼誰可以取代誰的問題。</p>\n<h2 id=\"1-基本用法\"><a href=\"#1-基本用法\" class=\"headerlink\" title=\"1.基本用法\"></a>1.基本用法</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>當 <code>async</code> 函式被呼叫時，它會回傳一個 Promise，這與有沒有使用 await 無關</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>async</code>函式返回一個 Promise 物件，可以使用<code>then</code>方法加入回調函式。</p></blockquote>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在 async 函式內部，遇到 await 指令會暫停當前函式的執行，等待後面的 Promise 物件解析為止，然後繼續執行函式體內後面的語句。</p></blockquote>\n<h3 id=\"1-1-不同的-async-函式形式\"><a href=\"#1-1-不同的-async-函式形式\" class=\"headerlink\" title=\"1.1 不同的 async 函式形式\"></a>1.1 不同的 async 函式形式</h3><p>async 函式可以以不同的形式聲明，包括函式聲明、函式表達式、物件的方法、以及箭頭函式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 函式聲明</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函式表達式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">async</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 物件的方法</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> obj = &#123; <span class=\"keyword\">async</span> <span class=\"title function_\">foo</span>(<span class=\"params\"></span>) &#123;&#125; &#125;;</span><br><span class=\"line\">obj.<span class=\"title function_\">foo</span>().<span class=\"title function_\">then</span>(...)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 箭頭函式</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-async-函式與-Promise-差異\"><a href=\"#1-2-async-函式與-Promise-差異\" class=\"headerlink\" title=\"1.2 async 函式與 Promise 差異\"></a>1.2 async 函式與 Promise 差異</h3><h4 id=\"1-2-1-Promise\"><a href=\"#1-2-1-Promise\" class=\"headerlink\" title=\"1.2.1 Promise\"></a>1.2.1 Promise</h4><p>Promise 是一種非同步操作的解決方案，它提供了一個連續的、非阻塞的語法結構，用於處理異步操作的結果或錯誤。其基本語法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://example.com/items&quot;</span>)</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">response</span>) =&gt;</span> response.<span class=\"title function_\">json</span>())</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">updateView</span>(data);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">error</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Update failed&quot;</span>, error);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<p>這種結構的涵意是 “我想要進行這個操作，然後在下一步對操作得到的資料再進行處理”。</p>\n<h4 id=\"1-2-2-async-await\"><a href=\"#1-2-2-async-await\" class=\"headerlink\" title=\"1.2.2 async&#x2F;await\"></a>1.2.2 async&#x2F;await</h4><p>await 的語法涵意會是 “我想要得到這個操作的結果(值)”，這會感覺像是在撰寫同步的語句。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://example.com/items&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\"><span class=\"title function_\">updateView</span>(data);</span><br></pre></td></tr></table></figure>\n\n\n<p>由於 await 運算子是被設計來等待 Promise 的，建議寫在 async 函式 內使用，像下面這樣的程式碼:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateMyView</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://example.com/items&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">  <span class=\"title function_\">updateView</span>(data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>ES13（ECMAScript 2022）將 await 運算子的使用擴展到了非 async 函式中</p></blockquote>\n<h3 id=\"示例-：獲取股票報價\"><a href=\"#示例-：獲取股票報價\" class=\"headerlink\" title=\"[示例]：獲取股票報價\"></a>[示例]：獲取股票報價</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getStockPriceByName</span>(<span class=\"params\">name</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> symbol = <span class=\"keyword\">await</span> <span class=\"title function_\">getStockSymbol</span>(name);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> stockPrice = <span class=\"keyword\">await</span> <span class=\"title function_\">getStockPrice</span>(symbol);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> stockPrice;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getStockPriceByName</span>(<span class=\"string\">&quot;goog&quot;</span>).<span class=\"title function_\">then</span>(<span class=\"keyword\">function</span> (<span class=\"params\">result</span>) &#123;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(result);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼是一個獲取股票報價的函式，函式前面的<code>async</code>關鍵字，表明該函式內部有異步操作。執行該函式時，會立即返回一個<code>Promise</code>物件。</p>\n<h3 id=\"示例-：指定多少毫秒後輸出一個值。\"><a href=\"#示例-：指定多少毫秒後輸出一個值。\" class=\"headerlink\" title=\"[示例]：指定多少毫秒後輸出一個值。\"></a>[示例]：指定多少毫秒後輸出一個值。</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">timeout</span>(<span class=\"params\">ms</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">asyncPrint</span>(<span class=\"params\">value, ms</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">timeout</span>(ms);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">asyncPrint</span>(<span class=\"string\">&quot;hello world&quot;</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼指定 50 毫秒以後，輸出<code>hello world</code>。</p>\n<p>由於<code>async</code>函式返回的是 Promise 物件，可以作為<code>await</code>指令的參數。所以，上面的例子也可以寫成下面的形式。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">timeout</span>(<span class=\"params\">ms</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, ms);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">asyncPrint</span>(<span class=\"params\">value, ms</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">timeout</span>(ms);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">asyncPrint</span>(<span class=\"string\">&quot;hello world&quot;</span>, <span class=\"number\">50</span>);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2-語法\"><a href=\"#2-語法\" class=\"headerlink\" title=\"2.語法\"></a>2.語法</h2><p><code>async</code>函式的語法規則總體上比較簡單，難點是錯誤處理機製。</p>\n<h3 id=\"2-1-返回-Promise-物件\"><a href=\"#2-1-返回-Promise-物件\" class=\"headerlink\" title=\"2.1 返回 Promise 物件\"></a>2.1 返回 Promise 物件</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>async</code> 函式被呼叫後，如果回傳一個值，就會被視為帶有該回傳值的<code>實現(resolved)狀態的 Promise</code>，反之如果拋出例外，就會被視為帶有被<br>拋出值的<code>拒絕(rejected)狀態的 Promise</code>。</p></blockquote>\n<p><code>async</code>函式內部<code>return</code>語句返回的值，會成為<code>then</code>方法回調函式的參數。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v));</span><br><span class=\"line\"><span class=\"comment\">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，函式<code>f</code>內部<code>return</code>指令返回的值，會被<code>then</code>方法回調函式接收到(透過Promise 物件)。</p>\n<p><code>async</code>函式內部拋出錯誤，會導致返回的 Promise 物件變為<code>reject</code>狀態。拋出的錯誤物件會被<code>catch</code>方法回調函式接收到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;出錯了&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;resolve&quot;</span>, v),</span><br><span class=\"line\">  <span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;reject&quot;</span>, e)</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"comment\">//reject Error: 出錯了</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Promise-物件的狀態變化\"><a href=\"#2-2-Promise-物件的狀態變化\" class=\"headerlink\" title=\"2.2 Promise 物件的狀態變化\"></a>2.2 Promise 物件的狀態變化</h3><p><code>async</code>函式返回的 Promise 物件，必須等到內部所有<code>await</code>指令後面的 Promise 物件執行完，才會發生狀態改變，除非遇到<code>return</code>語句或者拋出錯誤。也就是說，只有<code>async</code>函式內部的異步操作執行完，<code>then</code>方法才會執行指定的回調函式。</p>\n<p>下面是一個例子。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getTitle</span>(<span class=\"params\">url</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(url);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> html = <span class=\"keyword\">await</span> response.<span class=\"title function_\">text</span>();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> html.<span class=\"title function_\">match</span>(<span class=\"regexp\">/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"title function_\">getTitle</span>(<span class=\"string\">&quot;https://tc39.github.io/ecma262/&quot;</span>).<span class=\"title function_\">then</span>(<span class=\"variable language_\">console</span>.<span class=\"property\">log</span>);</span><br><span class=\"line\"><span class=\"comment\">// &quot;ECMAScript 2017 Language Specification&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，函式<code>getTitle</code>內部有三個操作：抓取網頁、取出文本、匹配頁面標題。只有這三個操作全部完成，才會執行<code>then</code>方法裡面的<code>console.log</code>。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>[備註]： <code>async/await</code> 函式的目的在於簡化同步操作 promise 的表現，以及對多個 Promise 物件執行某些操作。就像 Promise 類似於具結構性的回呼函式，同樣地，<code>async/await</code> 好比將 <code>generator</code> 與 <code>promise</code> 組合起來。</p></blockquote>\n<h3 id=\"2-3-await-指令\"><a href=\"#2-3-await-指令\" class=\"headerlink\" title=\"2.3 await 指令\"></a>2.3 await 指令</h3><p><code>async</code> 函式內部可以使用 <code>await</code> 表達式，它會暫停此 <code>async</code> 函式的執行，並且等待傳遞至表達式的 Promise 的解析，解析完之後會回傳解析值，並繼續此 <code>async</code> 函式的執行。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><code>await</code> 是一個運算子，使用這個關鍵字在表達式前作為修飾關鍵字詞，會讓表達式變為 “等待 Promise 解析的表達式”</p></blockquote>\n<h4 id=\"2-3-1-等待-Promise-解析的表達式\"><a href=\"#2-3-1-等待-Promise-解析的表達式\" class=\"headerlink\" title=\"2.3.1 等待 Promise 解析的表達式\"></a>2.3.1 等待 Promise 解析的表達式</h4><p>正常情況下，<code>await</code>指令後面是一個 Promise 物件，返回該物件的結果。如果不是 Promise 物件，就直接返回對應的值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 等同於　return 123;</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"number\">123</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v)); <span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，<code>await</code>指令的參數是數值<code>123</code>，這時等同於<code>return 123</code>。</p>\n<h4 id=\"2-3-2-實現休眠效果\"><a href=\"#2-3-2-實現休眠效果\" class=\"headerlink\" title=\"2.3.2 實現休眠效果\"></a>2.3.2 實現休眠效果</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>可以利用 await 指令來實現程式的暫停，例如在一段時間後再繼續執行。</p></blockquote>\n<p>JavaScript 一直沒有休眠的語法，但是借助<code>await</code>指令就可以讓程序停頓指定的時間。下面給出了一個簡化的<code>sleep</code>實現。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sleep</span>(<span class=\"params\">interval</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(resolve, interval);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">countOneToFive</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">5</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i);</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">sleep</span>(<span class=\"number\">1000</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">countOneToFive</span>();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-3-處理-Promise-的-reject-狀態\"><a href=\"#2-3-3-處理-Promise-的-reject-狀態\" class=\"headerlink\" title=\"2.3.3 處理 Promise 的 reject 狀態\"></a>2.3.3 處理 Promise 的 reject 狀態</h4><p>如果 <code>await</code> 後面的 Promise 物件變為 <code>reject 狀態</code>，則可以通過 <code>catch</code> 方法處理錯誤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&quot;出錯了&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e)); <span class=\"comment\">// 出錯了</span></span><br></pre></td></tr></table></figure>\n\n<p>注意，上面代碼中，<code>await</code>語句前面沒有<code>return</code>，但是<code>reject</code>方法的參數依然傳入了<code>catch</code>方法的回調函式。這裏如果在<code>await</code>前面加上<code>return</code>，效果是一樣的。</p>\n<h4 id=\"2-3-4-中斷整個-async-函式的執行\"><a href=\"#2-3-4-中斷整個-async-函式的執行\" class=\"headerlink\" title=\"2.3.4 中斷整個 async 函式的執行\"></a>2.3.4 中斷整個 async 函式的執行</h4><p>如果任何一個<code>await</code>語句後面的 Promise 物件變為<code>reject</code>狀態，整個<code>async</code>函式都會中斷執行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&quot;出錯了&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;hello world&quot;</span>); <span class=\"comment\">// 不會執行</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，第二個<code>await</code>語句是不會執行的，因為第一個<code>await</code>語句狀態變成了<code>reject</code>。</p>\n<h4 id=\"2-3-5-避免中斷執行\"><a href=\"#2-3-5-避免中斷執行\" class=\"headerlink\" title=\"2.3.5 避免中斷執行\"></a>2.3.5 避免中斷執行</h4><p>如果希望即使前一個異步操作失敗，也不要中斷後面的異步操作，可以將第一個<code>await</code>放在<code>try...catch</code>結構裡面，這樣不管這個異步操作是否成功，第二個<code>await</code>都會執行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&quot;出錯了&quot;</span>);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v)); <span class=\"comment\">// hello world</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2-3-6-處理可能出現的錯誤\"><a href=\"#2-3-6-處理可能出現的錯誤\" class=\"headerlink\" title=\"2.3.6 處理可能出現的錯誤\"></a>2.3.6 處理可能出現的錯誤</h4><p>可以將 <code>await</code> 後面的 Promise 物件再跟一個 <code>catch 方法</code>，處理可能出現的錯誤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">reject</span>(<span class=\"string\">&quot;出錯了&quot;</span>).<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">resolve</span>(<span class=\"string\">&quot;hello world&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>().<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v)); <span class=\"comment\">// 出錯了, hello world</span></span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>await 這個英文字詞也是有 “等待、等候” 意思的動詞，它與另一個常用的英文字詞 wait 意思相近。</p>\n<p>wait 後面通常會加上 for，經常使用在等候某人、等公車、等聖誕老公公…等等，它也可以不需要加上後面的受詞。</p>\n<p>await 則會用於比 wait 較為正式的場合或書面文章，它有預期某事物會延時發生的意思，後面必定要加上受詞，經常用於例如等候法院判決、等候合約審查、等候某人作決定…等等情況。</p></blockquote>\n<h3 id=\"2-4-錯誤處理\"><a href=\"#2-4-錯誤處理\" class=\"headerlink\" title=\"2.4 錯誤處理\"></a>2.4 錯誤處理</h3><h4 id=\"2-4-1-利用-catch-方法-類似-Promise-裡的-catch-方法\"><a href=\"#2-4-1-利用-catch-方法-類似-Promise-裡的-catch-方法\" class=\"headerlink\" title=\"2.4.1 利用 catch 方法(類似 Promise 裡的 catch 方法)\"></a>2.4.1 利用 catch 方法(類似 Promise 裡的 catch 方法)</h4><p>如果<code>await</code>後面的異步操作出錯，那麼等同於<code>async</code>函式返回的 Promise 物件被<code>reject</code>。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;出錯了&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">f</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">then</span>(<span class=\"function\">(<span class=\"params\">v</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(v))</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\">(<span class=\"params\">e</span>) =&gt;</span> <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(e));</span><br><span class=\"line\"><span class=\"comment\">// Error：出錯了</span></span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，<code>async</code>函式<code>f</code>執行後，<code>await</code>後面的 Promise 物件會拋出一個錯誤物件，導致<code>catch</code>方法的回調函式被執行，它的參數就是拋出的錯誤物件。</p>\n<h4 id=\"2-4-2-利用-try…catch-方法\"><a href=\"#2-4-2-利用-try…catch-方法\" class=\"headerlink\" title=\"2.4.2 利用 try…catch 方法\"></a>2.4.2 利用 try…catch 方法</h4><p>在 JavaScript 中，使用 <code>try...catch</code> 機制可以捕獲異步操作中的錯誤，這在處理異步程式碼中尤其重要。</p>\n<p>以下是幾種利用 <code>try...catch</code> 的情境和範例：</p>\n<p><strong>1. 單個異步操作的錯誤處理</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&quot;出錯了&quot;</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(e.<span class=\"property\">message</span>); <span class=\"comment\">// 處理錯誤</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">&quot;hello world&quot;</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在 async 函式中使用 <code>try...catch</code> 來捕捉異步操作中的錯誤，並在 <code>catch</code> 區塊中進行錯誤處理。</p>\n<p><strong>2. 多個異步操作的錯誤處理</strong></p>\n<p>如果有多個<code>await</code>指令，可以統一放在<code>try...catch</code>結構中。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val1 = <span class=\"keyword\">await</span> <span class=\"title function_\">firstStep</span>();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val2 = <span class=\"keyword\">await</span> <span class=\"title function_\">secondStep</span>(val1);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> val3 = <span class=\"keyword\">await</span> <span class=\"title function_\">thirdStep</span>(val1, val2);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Final: &quot;</span>, val3);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err); <span class=\"comment\">// 處理錯誤</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在這個示例中，<code>main()</code> 函式中的多個異步操作被放置在 <code>try...catch</code> 結構中，如果其中任何一個操作出錯，都會被 <code>catch</code> 區塊捕獲，並進行錯誤處理。</p>\n<p><strong>3. 多次重複嘗試的錯誤處理</strong></p>\n<p>下面的例子使用<code>try...catch</code>結構，實現多次重複嘗試。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> superagent = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;superagent&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"variable constant_\">NUM_RETRIES</span> = <span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">test</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"variable constant_\">NUM_RETRIES</span>; ++i) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> superagent.<span class=\"title function_\">get</span>(<span class=\"string\">&quot;http://google.com/this-throws-an-error&quot;</span>);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(err); <span class=\"comment\">// 處理錯誤</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(i); <span class=\"comment\">// 3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">test</span>();</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，如果<code>await</code>操作成功，就會使用<code>break</code>語句退出循環；如果失敗，會被<code>catch</code>語句捕捉，然後進入下一輪循環。</p>\n<h3 id=\"2-5-用-IIFE-或是箭頭函式的語法來搭配-async-函式\"><a href=\"#2-5-用-IIFE-或是箭頭函式的語法來搭配-async-函式\" class=\"headerlink\" title=\"2.5 用 IIFE 或是箭頭函式的語法來搭配 async 函式\"></a>2.5 用 IIFE 或是箭頭函式的語法來搭配 async 函式</h3><p>這可以因應不同的使用情況，以及讓語法更為簡化，在處理異步操作時，能夠清晰地表達程式的邏輯和流程，像下面的程式碼:</p>\n<p><strong>1. 立即執行函式表達式（IIFE）與 async 函式結合</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義了匿名的async立即執行函式，並等待異步操作完成。</span></span><br><span class=\"line\">(<span class=\"keyword\">async</span> () =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 透過 await 來等待 fetch 函式的回應</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://example.com/items&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 將其解析為 JSON 格式</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">    <span class=\"title function_\">updateView</span>(data);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果任何一步出錯，catch 區塊將捕獲到錯誤並加以處理。</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Update failed&quot;</span>, error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<p><strong>2. 箭頭函式與 async 函式結合</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定義了一個箭頭函式 fetchData (亦是 async 函式)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">fetchData</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 使用 await 來等待 fetch 函式的回應</span></span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> response = <span class=\"keyword\">await</span> <span class=\"title function_\">fetch</span>(<span class=\"string\">&quot;http://example.com/items&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 將其解析為 JSON 格式</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> data = <span class=\"keyword\">await</span> response.<span class=\"title function_\">json</span>();</span><br><span class=\"line\">    <span class=\"title function_\">updateView</span>(data);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果任何一步出錯，catch 區塊將捕獲到錯誤並加以處理。</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&quot;Update failed&quot;</span>, error);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">fetchData</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"3-使用注意點\"><a href=\"#3-使用注意點\" class=\"headerlink\" title=\"3.使用注意點\"></a>3.使用注意點</h2><h3 id=\"3-1-await-指令的錯誤處理\"><a href=\"#3-1-await-指令的錯誤處理\" class=\"headerlink\" title=\"3.1 await 指令的錯誤處理\"></a>3.1 await 指令的錯誤處理</h3><p>在 <code>await</code> 指令後面的 <code>Promise</code> 物件可能被拒絕（rejected），因此最好將 <code>await</code> 指令放在 <code>try...catch</code> 代碼區塊中，以便捕獲可能的錯誤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> <span class=\"title function_\">somethingThatReturnsAPromise</span>();</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 另一種寫法</span></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">somethingThatReturnsAPromise</span>().<span class=\"title function_\">catch</span>(<span class=\"keyword\">function</span> (<span class=\"params\">err</span>) &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(err);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-多個-await-指令的並行執行\"><a href=\"#3-2-多個-await-指令的並行執行\" class=\"headerlink\" title=\"3.2 多個 await 指令的並行執行\"></a>3.2 多個 await 指令的並行執行</h3><p>如果多個 await 指令後面的異步操作彼此獨立(不存在繼發關係)，最好讓它們同時觸發以減少執行時間。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> <span class=\"title function_\">getFoo</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> <span class=\"title function_\">getBar</span>();</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，<code>getFoo</code>和<code>getBar</code>是兩個獨立的異步操作（即互不依賴），被寫成繼發關係。這樣比較耗時，因為只有<code>getFoo</code>完成以後，才會執行<code>getBar</code>，完全可以讓它們同時觸發。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 寫法一</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> [foo, bar] = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>([<span class=\"title function_\">getFoo</span>(), <span class=\"title function_\">getBar</span>()]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 寫法二</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> fooPromise = <span class=\"title function_\">getFoo</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> barPromise = <span class=\"title function_\">getBar</span>();</span><br><span class=\"line\"><span class=\"keyword\">let</span> foo = <span class=\"keyword\">await</span> fooPromise;</span><br><span class=\"line\"><span class=\"keyword\">let</span> bar = <span class=\"keyword\">await</span> barPromise;</span><br></pre></td></tr></table></figure>\n\n<p>上面兩種寫法，將<code>getFoo</code>和<code>getBar</code>改成同時觸發，這樣將會縮短程式的執行時間。</p>\n<h3 id=\"3-3-async-函式中的非同步操作\"><a href=\"#3-3-async-函式中的非同步操作\" class=\"headerlink\" title=\"3.3 async 函式中的非同步操作\"></a>3.3 async 函式中的非同步操作</h3><p><code>await</code> 指令只能用在 <code>async</code> 函式內部，嘗試在普通函式內部使用會導致錯誤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">dbFuc</span>(<span class=\"params\">db</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 報錯，因為await用在普通函式之中了</span></span><br><span class=\"line\">  docs.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.<span class=\"title function_\">post</span>(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是，如果將<code>forEach</code>方法的參數改成<code>async</code>函式，也有問題。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">dbFuc</span>(<span class=\"params\">db</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//這裏不需要 async</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 可能得到錯誤結果</span></span><br><span class=\"line\">  docs.<span class=\"title function_\">forEach</span>(<span class=\"keyword\">async</span> <span class=\"keyword\">function</span> (<span class=\"params\">doc</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.<span class=\"title function_\">post</span>(doc);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼可能不會正常工作，原因是這時三個<code>db.post()</code>操作將是並發執行，也就是同時執行，而不是繼發執行。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在 <code>async 函式</code>內部使用 <code>forEach</code> 等迭代方法，也可能會產生意外的行為，應該使用 <code>for 循環</code>來處理。</p></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">dbFuc</span>(<span class=\"params\">db</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> doc <span class=\"keyword\">of</span> docs) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.<span class=\"title function_\">post</span>(doc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>另一種方法是使用陣列的<code>reduce()</code>方法。</p></blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">dbFuc</span>(<span class=\"params\">db</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">await</span> docs.<span class=\"title function_\">reduce</span>(<span class=\"keyword\">async</span> (_, doc) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> _;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> db.<span class=\"title function_\">post</span>(doc);</span><br><span class=\"line\">  &#125;, <span class=\"literal\">undefined</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上面例子中，<code>reduce()</code>方法的第一個參數是<code>async</code>函式，導致該函式的第一個參數是前一步操作返回的 Promise 物件，所以必須使用<code>await</code>等待它操作結束。另外，<code>reduce()</code>方法返回的是<code>docs</code>陣列最後一個成員的<code>async</code>函式的執行結果，也是一個 Promise 物件，導致在它前面也必須加上<code>await</code>。</p>\n<p>上面的<code>reduce()</code>的參數函式裡面沒有<code>return</code>語句，原因是這個函式的主要目的是<code>db.post()</code>操作，不是返回值。而且<code>async</code>函式不管有沒有<code>return</code>語句，總是返回一個 Promise 物件，所以這裏的<code>return</code>是不必要的。</p>\n<p>如果確實希望多個請求並發執行，可以使用<code>Promise.all</code>方法。當三個請求都會<code>resolved</code>時，下面兩種寫法效果相同。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">dbFuc</span>(<span class=\"params\">db</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.<span class=\"title function_\">post</span>(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = <span class=\"keyword\">await</span> <span class=\"title class_\">Promise</span>.<span class=\"title function_\">all</span>(promises);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(results);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用下面的寫法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">dbFuc</span>(<span class=\"params\">db</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promises = docs.<span class=\"title function_\">map</span>(<span class=\"function\">(<span class=\"params\">doc</span>) =&gt;</span> db.<span class=\"title function_\">post</span>(doc));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> results = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> promise <span class=\"keyword\">of</span> promises) &#123;</span><br><span class=\"line\">    results.<span class=\"title function_\">push</span>(<span class=\"keyword\">await</span> promise);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(results);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"3-4-保留執行堆棧\"><a href=\"#3-4-保留執行堆棧\" class=\"headerlink\" title=\"3.4 保留執行堆棧\"></a>3.4 保留執行堆棧</h3><p>async 函式可以保留執行堆棧，這意味著在 async 函式內部的異步操作完成之前，函式的上下文環境將被保留。這有助於更好地處理異步操作中的錯誤。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"title function_\">b</span>().<span class=\"title function_\">then</span>(<span class=\"function\">() =&gt;</span> <span class=\"title function_\">c</span>());</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，函式<code>a</code>內部執行了一個異步任務<code>b()</code>。當<code>b()</code>執行的時候，函式<code>a()</code>不會中斷，而是繼續執行。等到<code>b()</code>執行結束，可能<code>a()</code>早就執行結束了，<code>b()</code>所在的上下文環境已經消失了。如果<code>b()</code>或<code>c()</code>報錯，錯誤堆棧將不包括<code>a()</code>。</p>\n<p><strong>現在將這個例子改成<code>async</code>函式。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">a</span> = <span class=\"keyword\">async</span> (<span class=\"params\"></span>) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> <span class=\"title function_\">b</span>();</span><br><span class=\"line\">  <span class=\"title function_\">c</span>();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>上面代碼中，<code>b()</code>執行的時候，<code>a()</code>是暫停執行，上下文環境都儲存著。一旦<code>b()</code>或<code>c()</code>報錯，錯誤堆棧將包括<code>a()</code>。</p>\n<h2 id=\"4-es13-新增\"><a href=\"#4-es13-新增\" class=\"headerlink\" title=\"4.es13 新增\"></a>4.es13 新增</h2><p>在 JavaScript 中，await 運算子用於暫停執行，直到 Promise 被解決（履行或拒絕）。以前，我們只能在 async 函式中使用此運算子 - 使用 async 關鍵字聲明的函式。我們無法在全域範圍內這樣做。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setTimeoutAsync</span>(<span class=\"params\">timeout</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    &#125;, timeout);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: await is only valid in async functions</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> setTimeoutAsync(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在 JavaScript 中，ES13（ECMAScript 2022）將 await 運算子的使用擴展到了非 async 函式中。在過去，await 運算子只能在使用 async 關鍵字聲明的函式中使用，這意味著它只能在 Promise-based 的異步操作中使用。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setTimeoutAsync</span>(<span class=\"params\">timeout</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"title function_\">resolve</span>();</span><br><span class=\"line\">    &#125;, timeout);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// Waits for timeout - no error thrown</span></span><br><span class=\"line\"><span class=\"keyword\">await</span> setTimeoutAsync(<span class=\"number\">3000</span>);</span><br></pre></td></tr></table></figure>\n\n<p>ES13 中能更靈活地使用 await 運算子，而不僅僅局限於 async 函式中。這對於某些場景下，特別是在代碼的邏輯結構上，將會更方便。</p>\n","feature":null,"text":"11【async 函式】async 簡介處理 JavaScript 中的異步程序總是需要面臨各種不同應用情況的挑戰。在 ES6(ES2015)中加入的 Prom...","permalink":"/post/ES611【async 函式】","photos":[],"count_time":{"symbolsCount":"13k","symbolsTime":"12 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"},{"name":"桃園資展筆記","slug":"桃園資展筆記","count":18,"path":"api/tags/桃園資展筆記.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#11%E3%80%90async-%E5%87%BD%E5%BC%8F%E3%80%91\"><span class=\"toc-text\">11【async 函式】</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#async-%E7%B0%A1%E4%BB%8B\"><span class=\"toc-text\">async 簡介</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95\"><span class=\"toc-text\">1.基本用法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E4%B8%8D%E5%90%8C%E7%9A%84-async-%E5%87%BD%E5%BC%8F%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">1.1 不同的 async 函式形式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-async-%E5%87%BD%E5%BC%8F%E8%88%87-Promise-%E5%B7%AE%E7%95%B0\"><span class=\"toc-text\">1.2 async 函式與 Promise 差異</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-1-Promise\"><span class=\"toc-text\">1.2.1 Promise</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-2-2-async-await\"><span class=\"toc-text\">1.2.2 async&#x2F;await</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-%EF%BC%9A%E7%8D%B2%E5%8F%96%E8%82%A1%E7%A5%A8%E5%A0%B1%E5%83%B9\"><span class=\"toc-text\">[示例]：獲取股票報價</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B-%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%A4%9A%E5%B0%91%E6%AF%AB%E7%A7%92%E5%BE%8C%E8%BC%B8%E5%87%BA%E4%B8%80%E5%80%8B%E5%80%BC%E3%80%82\"><span class=\"toc-text\">[示例]：指定多少毫秒後輸出一個值。</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%AA%9E%E6%B3%95\"><span class=\"toc-text\">2.語法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E8%BF%94%E5%9B%9E-Promise-%E7%89%A9%E4%BB%B6\"><span class=\"toc-text\">2.1 返回 Promise 物件</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-Promise-%E7%89%A9%E4%BB%B6%E7%9A%84%E7%8B%80%E6%85%8B%E8%AE%8A%E5%8C%96\"><span class=\"toc-text\">2.2 Promise 物件的狀態變化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-await-%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">2.3 await 指令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-1-%E7%AD%89%E5%BE%85-Promise-%E8%A7%A3%E6%9E%90%E7%9A%84%E8%A1%A8%E9%81%94%E5%BC%8F\"><span class=\"toc-text\">2.3.1 等待 Promise 解析的表達式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-2-%E5%AF%A6%E7%8F%BE%E4%BC%91%E7%9C%A0%E6%95%88%E6%9E%9C\"><span class=\"toc-text\">2.3.2 實現休眠效果</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-3-%E8%99%95%E7%90%86-Promise-%E7%9A%84-reject-%E7%8B%80%E6%85%8B\"><span class=\"toc-text\">2.3.3 處理 Promise 的 reject 狀態</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-4-%E4%B8%AD%E6%96%B7%E6%95%B4%E5%80%8B-async-%E5%87%BD%E5%BC%8F%E7%9A%84%E5%9F%B7%E8%A1%8C\"><span class=\"toc-text\">2.3.4 中斷整個 async 函式的執行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-5-%E9%81%BF%E5%85%8D%E4%B8%AD%E6%96%B7%E5%9F%B7%E8%A1%8C\"><span class=\"toc-text\">2.3.5 避免中斷執行</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-3-6-%E8%99%95%E7%90%86%E5%8F%AF%E8%83%BD%E5%87%BA%E7%8F%BE%E7%9A%84%E9%8C%AF%E8%AA%A4\"><span class=\"toc-text\">2.3.6 處理可能出現的錯誤</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86\"><span class=\"toc-text\">2.4 錯誤處理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-1-%E5%88%A9%E7%94%A8-catch-%E6%96%B9%E6%B3%95-%E9%A1%9E%E4%BC%BC-Promise-%E8%A3%A1%E7%9A%84-catch-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.4.1 利用 catch 方法(類似 Promise 裡的 catch 方法)</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-4-2-%E5%88%A9%E7%94%A8-try%E2%80%A6catch-%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">2.4.2 利用 try…catch 方法</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E7%94%A8-IIFE-%E6%88%96%E6%98%AF%E7%AE%AD%E9%A0%AD%E5%87%BD%E5%BC%8F%E7%9A%84%E8%AA%9E%E6%B3%95%EF%A4%AD%E6%90%AD%E9%85%8D-async-%E5%87%BD%E5%BC%8F\"><span class=\"toc-text\">2.5 用 IIFE 或是箭頭函式的語法來搭配 async 函式</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E9%BB%9E\"><span class=\"toc-text\">3.使用注意點</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-1-await-%E6%8C%87%E4%BB%A4%E7%9A%84%E9%8C%AF%E8%AA%A4%E8%99%95%E7%90%86\"><span class=\"toc-text\">3.1 await 指令的錯誤處理</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-2-%E5%A4%9A%E5%80%8B-await-%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%A6%E8%A1%8C%E5%9F%B7%E8%A1%8C\"><span class=\"toc-text\">3.2 多個 await 指令的並行執行</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-3-async-%E5%87%BD%E5%BC%8F%E4%B8%AD%E7%9A%84%E9%9D%9E%E5%90%8C%E6%AD%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">3.3 async 函式中的非同步操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-4-%E4%BF%9D%E7%95%99%E5%9F%B7%E8%A1%8C%E5%A0%86%E6%A3%A7\"><span class=\"toc-text\">3.4 保留執行堆棧</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-es13-%E6%96%B0%E5%A2%9E\"><span class=\"toc-text\">4.es13 新增</span></a></li></ol></li></ol>","author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"ES6 介绍","uid":"1e00bbc5a1a969d8b4414c942e9fedc9","slug":"ES601 【ES6 介绍】","date":"2024-01-24T00:06:25.000Z","updated":"2024-01-30T12:54:52.424Z","comments":true,"path":"api/articles/ES601 【ES6 介绍】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","text":"01 【ES6 介紹】ECMAScript 6.0（以下簡稱 ES6）是 JavaScript 語言的下一代標準，已於 2015 年 6 月正式發布。它的目標是...","permalink":"/post/ES601 【ES6 介绍】","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"},{"name":"桃園資展筆記","slug":"桃園資展筆記","count":18,"path":"api/tags/桃園資展筆記.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null},"next_post":{"title":"運算子的擴展","uid":"c288451229d981ac1c523a14e9961496","slug":"ES608【運算子的擴展】","date":"2024-01-24T00:06:25.000Z","updated":"2024-02-05T00:37:28.716Z","comments":true,"path":"api/articles/ES608【運算子的擴展】.json","keywords":null,"cover":"https://github.com/HSU0201/images/blob/main/es6/1_8nfBRAssY0DuETYwdwyqqw.png?raw=true","text":"08【運算子的擴展】1.指數運算子(Exponentiation Operator)ES2016 新增了一個指數運算子（**）。 指數的基本運算 123452 ...","permalink":"/post/ES608【運算子的擴展】","photos":[],"count_time":{"symbolsCount":"7.2k","symbolsTime":"7 mins."},"categories":[{"name":"ES6","slug":"ES6","count":5,"path":"api/categories/ES6.json"}],"tags":[{"name":"ES6","slug":"ES6","count":5,"path":"api/tags/ES6.json"}],"author":{"name":"Hsu's Blog","slug":"blog-author","avatar":"https://github.com/HSU0201/images/blob/main/blogimage.jpg?raw=true","link":"/","description":"“Stay curious, keep learning, and never stop creating.”","socials":{"github":"https://github.com/HSU0201","twitter":"","stackoverflow":"https://stackoverflow.com/users/21010008/hsu","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":null}}