[{"id":"956114e1932534f6adc2e3848138c40e","title":"JavaScript 進階 - 第4天","content":"JavaScript 進階 - 第4天深淺拷貝淺拷貝首先淺拷貝和深拷貝只針對參考類型\n淺拷貝：拷貝的是位址\n常見方法：\n\n拷貝物件：Object.assgin() &#x2F; 展開運運算元 {…obj} 拷貝物件\n拷貝陣列：Array.prototype.concat() 或者 […arr]\n\n\n\n\n\n\n\n\n\n\n如果是單一資料型別拷貝值，引用資料類型拷貝的是位址 (簡單理解： 如果是單層物件，沒問題，如果有多層就有問題)\n深拷貝首先淺拷貝和深拷貝只針對參考類型\n深拷貝：拷貝的是物件，不是位址\n常見方法：\n\n通過遞迴實現深拷貝\nlodash&#x2F;cloneDeep\n通過JSON.stringify()實現\n\n遞迴實現深拷貝函數遞迴：\n如果一個函數在內部可以調用其本身，那麼這個函數就是遞迴函數\n\n簡單理解:函數內部自己調用自己, 這個函數就是遞迴函數\n遞迴函數的作用和迴圈效果類似\n由於遞迴很容易發生“棧溢出”錯誤（stack overflow），所以必須要加退出條件 return\n\n&lt;body&gt;\n  &lt;script&gt;\n    const obj &#x3D; &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o &#x3D; &#123;&#125;\n    &#x2F;&#x2F; 拷貝函數\n    function deepCopy(newObj, oldObj) &#123;\n      debugger\n      for (let k in oldObj) &#123;\n        &#x2F;&#x2F; 處理陣列的問題  一定先寫陣列 在寫 物件 不能顛倒\n        if (oldObj[k] instanceof Array) &#123;\n          newObj[k] &#x3D; []\n          &#x2F;&#x2F;  newObj[k] 接收 []  hobby\n          &#x2F;&#x2F;  oldObj[k]   [&#39;乒乓球&#39;, &#39;足球&#39;]\n          deepCopy(newObj[k], oldObj[k])\n        &#125; else if (oldObj[k] instanceof Object) &#123;\n          newObj[k] &#x3D; &#123;&#125;\n          deepCopy(newObj[k], oldObj[k])\n        &#125;\n        else &#123;\n          &#x2F;&#x2F;  k  屬性名 uname age    oldObj[k]  屬性值  18\n          &#x2F;&#x2F; newObj[k]  &#x3D;&#x3D;&#x3D; o.uname  給新物件添加屬性\n          newObj[k] &#x3D; oldObj[k]\n        &#125;\n      &#125;\n    &#125;\n    deepCopy(o, obj) &#x2F;&#x2F; 函式呼叫  兩個參數 o 新物件  obj 舊物件\n    console.log(o)\n    o.age &#x3D; 20\n    o.hobby[0] &#x3D; &#39;籃球&#39;\n    o.family.baby &#x3D; &#39;老pink&#39;\n    console.log(obj)\n    console.log([1, 23] instanceof Object)\n    &#x2F;&#x2F; 複習\n    &#x2F;&#x2F; const obj &#x3D; &#123;\n    &#x2F;&#x2F;   uname: &#39;pink&#39;,\n    &#x2F;&#x2F;   age: 18,\n    &#x2F;&#x2F;   hobby: [&#39;乒乓球&#39;, &#39;足球&#39;]\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; function deepCopy(&#123; &#125;, oldObj) &#123;\n    &#x2F;&#x2F;   &#x2F;&#x2F; k 屬性名  oldObj[k] 屬性值\n    &#x2F;&#x2F;   for (let k in oldObj) &#123;\n    &#x2F;&#x2F;     &#x2F;&#x2F; 處理陣列的問題   k 變數\n    &#x2F;&#x2F;     newObj[k] &#x3D; oldObj[k]\n    &#x2F;&#x2F;     &#x2F;&#x2F; o.uname &#x3D; &#39;pink&#39;\n    &#x2F;&#x2F;     &#x2F;&#x2F; newObj.k  &#x3D; &#39;pink&#39;\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\njs庫lodash裡面cloneDeep內部實現了深拷貝&lt;body&gt;\n  &lt;!-- 先引用 --&gt;\n  &lt;script src&#x3D;&quot;.&#x2F;lodash.min.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script&gt;\n    const obj &#x3D; &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    const o &#x3D; _.cloneDeep(obj)\n    console.log(o)\n    o.family.baby &#x3D; &#39;老pink&#39;\n    console.log(obj)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\nJSON序列化&lt;body&gt;\n  &lt;script&gt;\n    const obj &#x3D; &#123;\n      uname: &#39;pink&#39;,\n      age: 18,\n      hobby: [&#39;乒乓球&#39;, &#39;足球&#39;],\n      family: &#123;\n        baby: &#39;小pink&#39;\n      &#125;\n    &#125;\n    &#x2F;&#x2F; 把物件轉換為 JSON 字串\n    &#x2F;&#x2F; console.log(JSON.stringify(obj))\n    const o &#x3D; JSON.parse(JSON.stringify(obj))\n    console.log(o)\n    o.family.baby &#x3D; &#39;123&#39;\n    console.log(obj)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n異常處理\n\n\n\n\n\n\n\n\n瞭解 JavaScript 中程式異常處理的方法，提升代碼運行的健壯性。\nthrow異常處理是指預估代碼執行過程中可能發生的錯誤，然後最大程度的避免錯誤的發生導致整個程式無法繼續運行\n總結：\n\nthrow 拋出異常資訊，程式也會終止執行\nthrow 後面跟的是錯誤提示資訊\nError 物件配合 throw 使用，能夠設置更詳細的錯誤資訊\n\n&lt;script&gt;\n  function counter(x, y) &#123;\n\n    if(!x || !y) &#123;\n      &#x2F;&#x2F; throw &#39;參數不能為空!&#39;;\n      throw new Error(&#39;參數不能為空!&#39;)\n    &#125;\n\n    return x + y\n  &#125;\n\n  counter()\n&lt;&#x2F;script&gt;\n\n總結：\n\nthrow 拋出異常資訊，程式也會終止執行\nthrow 後面跟的是錯誤提示資訊\nError 物件配合 throw 使用，能夠設置更詳細的錯誤資訊\n\ntry … catch&lt;script&gt;\n   function foo() &#123;\n      try &#123;\n        &#x2F;&#x2F; 查找 DOM 節點\n        const p &#x3D; document.querySelector(&#39;.p&#39;)\n        p.style.color &#x3D; &#39;red&#39;\n      &#125; catch (error) &#123;\n        &#x2F;&#x2F; try 程式碼片段中執行有錯誤時，會執行 catch 程式碼片段\n        &#x2F;&#x2F; 查看錯誤資訊\n        console.log(error.message)\n        &#x2F;&#x2F; 終止代碼繼續執行\n        return\n\n      &#125;\n      finally &#123;\n          alert(&#39;執行&#39;)\n      &#125;\n      console.log(&#39;如果出現錯誤，我的語句不會執行&#39;)\n    &#125;\n    foo()\n&lt;&#x2F;script&gt;\n\n總結：\n\ntry...catch 用於捕獲錯誤資訊\n將預估可能發生錯誤的代碼寫在 try 程式碼片段中\n如果 try 程式碼片段中出現錯誤後，會執行 catch 程式碼片段，並截獲到錯誤資訊\n\ndebugger相當於中斷點調試\n處理this\n\n\n\n\n\n\n\n\n瞭解函數中 this 在不同場景下的預設值，知道動態指定函數 this 值的方法。\nthis 是 JavaScript 最具“魅惑”的知識點，不同的應用場合 this 的取值可能會有意想不到的結果，在此我們對以往學習過的關於【 this 預設的取值】情況進行歸納和總結。\n普通函數普通函數的調用方式決定了 this 的值，即【誰調用 this 的值指向誰】，如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this)  \n  &#125;\n  &#x2F;&#x2F; 函數運算式\n  const sayHello &#x3D; function () &#123;\n    console.log(this)\n  &#125;\n  &#x2F;&#x2F; 函數的調用方式決定了 this 的值\n  sayHi() &#x2F;&#x2F; window\n  window.sayHi()\n  \n\n&#x2F;&#x2F; 普通對象\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    walk: function () &#123;\n      console.log(this)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 動態為 user 添加方法\n  user.sayHi &#x3D; sayHi\n  uesr.sayHello &#x3D; sayHello\n  &#x2F;&#x2F; 函式呼叫方式，決定了 this 的值\n  user.sayHi()\n  user.sayHello()\n&lt;&#x2F;script&gt;\n\n注： 普通函數沒有明確調用者時 this 值為 window，嚴格模式下沒有調用者時 this 的值為 undefined。\n箭頭函數箭頭函數中的 this 與普通函數完全不同，也不受調用方式的影響，事實上箭頭函數中並不存在 this ！箭頭函數中訪問的 this 不過是箭頭函數所在作用域的 this 變數。\n&lt;script&gt;\n    \n  console.log(this) &#x2F;&#x2F; 此處為 window\n  &#x2F;&#x2F; 箭頭函數\n  const sayHi &#x3D; function() &#123;\n    console.log(this) &#x2F;&#x2F; 該箭頭函數中的 this 為函式宣告環境中 this 一致\n  &#125;\n  &#x2F;&#x2F; 普通對象\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    &#x2F;&#x2F; 該箭頭函數中的 this 為函式宣告環境中 this 一致\n    walk: () &#x3D;&gt; &#123;\n      console.log(this)\n    &#125;,\n    \n    sleep: function () &#123;\n      let str &#x3D; &#39;hello&#39;\n      console.log(this)\n      let fn &#x3D; () &#x3D;&gt; &#123;\n        console.log(str)\n        console.log(this) &#x2F;&#x2F; 該箭頭函數中的 this 與 sleep 中的 this 一致\n      &#125;\n      &#x2F;&#x2F; 調用箭頭函數\n      fn();\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 動態添加方法\n  user.sayHi &#x3D; sayHi\n  \n  &#x2F;&#x2F; 函式呼叫\n  user.sayHi()\n  user.sleep()\n  user.walk()\n&lt;&#x2F;script&gt;\n\n在開發中【使用箭頭函數前需要考慮函數中 this 的值】，事件回呼函數使用箭頭函數時，this 為全域的 window，因此DOM事件回呼函數不推薦使用箭頭函數，如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; DOM 節點\n  const btn &#x3D; document.querySelector(&#39;.btn&#39;)\n  &#x2F;&#x2F; 箭頭函數 此時 this 指向了 window\n  btn.addEventListener(&#39;click&#39;, () &#x3D;&gt; &#123;\n    console.log(this)\n  &#125;)\n  &#x2F;&#x2F; 普通函數 此時 this 指向了 DOM 對象\n  btn.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(this)\n  &#125;)\n&lt;&#x2F;script&gt;\n\n同樣由於箭頭函數 this 的原因，基於原型的物件導向也不推薦採用箭頭函數，如下代碼所示：\n&lt;script&gt;\n  function Person() &#123;\n  &#125;\n  &#x2F;&#x2F; 原型對像上添加了箭頭函數\n  Person.prototype.walk &#x3D; () &#x3D;&gt; &#123;\n    console.log(&#39;人都要走路...&#39;)\n    console.log(this); &#x2F;&#x2F; window\n  &#125;\n  const p1 &#x3D; new Person()\n  p1.walk()\n&lt;&#x2F;script&gt;\n\n改變this指向以上歸納了普通函數和箭頭函數中關於 this 預設值的情形，不僅如此 JavaScript 中還允許指定函數中 this 的指向，有 3 個方法可以動態指定普通函數中 this 的指向：\ncall使用 call 方法調用函數，同時指定函數中 this 的值，使用方法如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this);\n  &#125;\n\n  let user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student &#x3D; &#123;\n    name: &#39;小紅&#39;,\n    age: 16\n  &#125;\n\n  &#x2F;&#x2F; 調用函數並指定 this 的值\n  sayHi.call(user); &#x2F;&#x2F; this 值為 user\n  sayHi.call(student); &#x2F;&#x2F; this 值為 student\n\n  &#x2F;&#x2F; 求和函數\n  function counter(x, y) &#123;\n    return x + y;\n  &#125;\n\n  &#x2F;&#x2F; 調用 counter 函數，並傳入參數\n  let result &#x3D; counter.call(null, 5, 10);\n  console.log(result);\n&lt;&#x2F;script&gt;\n\n總結：\n\ncall 方法能夠在調用函數的同時指定 this 的值\n使用 call 方法調用函數時，第1個參數為 this 指定的值\ncall 方法的其餘參數會依次自動傳入函數做為函數的參數\n\napply使用 call 方法調用函數，同時指定函數中 this 的值，使用方法如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n\n  let user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  let student &#x3D; &#123;\n    name: &#39;小紅&#39;,\n    age: 16\n  &#125;\n\n  &#x2F;&#x2F; 調用函數並指定 this 的值\n  sayHi.apply(user) &#x2F;&#x2F; this 值為 user\n  sayHi.apply(student) &#x2F;&#x2F; this 值為 student\n\n  &#x2F;&#x2F; 求和函數\n  function counter(x, y) &#123;\n    return x + y\n  &#125;\n  &#x2F;&#x2F; 調用 counter 函數，並傳入參數\n  let result &#x3D; counter.apply(null, [5, 10])\n  console.log(result)\n&lt;&#x2F;script&gt;\n\n總結：\n\napply 方法能夠在調用函數的同時指定 this 的值\n使用 apply 方法調用函數時，第1個參數為 this 指定的值\napply 方法第2個參數為陣列，陣列的單元值依次自動傳入函數做為函數的參數\n\nbindbind 方法並不會調用函數，而是創建一個指定了 this 值的新函數，使用方法如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 普通函數\n  function sayHi() &#123;\n    console.log(this)\n  &#125;\n  let user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n  &#x2F;&#x2F; 調用 bind 指定 this 的值\n  let sayHello &#x3D; sayHi.bind(user);\n  &#x2F;&#x2F; 調用使用 bind 創建的新函數\n  sayHello()\n&lt;&#x2F;script&gt;\n\n注：bind 方法創建新的函數，與原函數的唯一的變化是改變了 this 的值。\n防抖節流\n防抖（debounce）所謂防抖，就是指觸發事件後在 n 秒內函數只能執行一次，如果在 n 秒內又觸發了事件，則會重新計算函數執行時間\n節流（throttle）所謂節流，就是指連續觸發事件但是在 n 秒中只執行一次函數\n\n","slug":"20230401JavaScript 進階 - 第4天","date":"2023-04-01T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"c43b2d50b25bb22e84622db700db53eb","title":"JavaScript 進階 - 第3天","content":"JavaScript 進階 - 第3天筆記\n\n\n\n\n\n\n\n\n瞭解構造函數原型物件的語法特徵，掌握 JavaScript 中物件導向程式設計的實現方式，基於物件導向程式設計思想實現 DOM 操作的封裝。\n\n瞭解物件導向程式設計的一般特徵\n掌握基於構造函數原型物件的邏輯封裝\n掌握基於原型物件實現的繼承\n理解什麼原型鏈及其作用\n能夠處理常式異常提升程式執行的健壯性\n\n程式設計思想\n\n\n\n\n\n\n\n\n學習 JavaScript 中基於原型的物件導向編程式的語法實現，理解物件導向程式設計的特徵。\n面向過程面向過程就是分析出解決問題所需要的步驟，然後用函數把這些步驟一步一步實現，使用的時候再一個一個的依次\n調用就可以了。\n 舉個栗子：蛋炒飯\n\n物件導向物件導向是把事務分解成為一個個物件，然後由物件之間分工與合作。\n\n在物件導向程式開發思想中，每一個物件都是功能中心，具有明確分工。\n物件導向程式設計具有靈活、代碼可複用、容易維護和開發的優點，更適合多人合作的大型軟體專案。\n物件導向的特性：\n\n封裝性\n\n繼承性\n\n多態性\n\n\n構造函數對比以下通過物件導向的構造函數實現的封裝：\n&lt;script&gt;\n  function Person() &#123;\n    this.name &#x3D; &#39;佚名&#39;\n    &#x2F;&#x2F; 設置名字\n    this.setName &#x3D; function (name) &#123;\n      this.name &#x3D; name\n    &#125;\n    &#x2F;&#x2F; 讀取名字\n    this.getName &#x3D; () &#x3D;&gt; &#123;\n      console.log(this.name)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 實例對像，獲得了構造函數中封裝的所有邏輯\n  let p1 &#x3D; new Person()\n  p1.setName(&#39;小明&#39;)\n  console.log(p1.name)\n\n  &#x2F;&#x2F; 實例物件\n  let p2 &#x3D; new Person()\n  console.log(p2.name)\n&lt;&#x2F;script&gt;\n\n封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。\n同樣的將變數和函數組合到了一起並能通過 this 實現資料的共用，所不同的是借助構造函數創建出來的實例物件之\n間是彼此不影響的\n\n\n\n\n\n\n\n\n\n總結：\n\n構造函數體現了物件導向的封裝特性\n構造函數實例創建的物件彼此獨立、互不影響\n\n封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。\n前面我們學過的構造函數方法很好用，但是 存在浪費記憶體的問題\n原型物件構造函數通過原型分配的函數是所有物件所 共用的。\n\nJavaScript 規定，每一個構造函數都有一個 prototype 屬性，指向另一個物件，所以我們也稱為原型物件\n這個物件可以掛載函數，物件產生實體不會多次創建原型上函數，節約記憶體\n我們可以把那些不變的方法，直接定義在 prototype 物件上，這樣所有物件的實例就可以共用這些方法。\n構造函數和原型物件中的this 都指向 產生實體的物件\n\n&lt;script&gt;\n  function Person() &#123;\n    \n  &#125;\n\n  &#x2F;&#x2F; 每個函數都有 prototype 屬性\n  console.log(Person.prototype)\n&lt;&#x2F;script&gt;\n\n\n瞭解了 JavaScript 中構造函數與原型物件的關係後，再來看原型物件具體的作用，如下代碼所示：\n&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處未定義任何方法\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n  \n  &#x2F;&#x2F; 產生實體\n  let p1 &#x3D; new Person();\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 Hi~\n&lt;&#x2F;script&gt;\n\n\n構造函數 Person 中未定義任何方法，這時實例物件調用了原型物件中的方法 sayHi，接下來改動一下代碼：\n&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處定義同名方法 sayHi\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;嗨!&#39;);\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39;);\n  &#125;\n\n  let p1 &#x3D; new Person();\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 嗨!\n&lt;&#x2F;script&gt;\n\n構造函數 Person 中定義與原型物件中相同名稱的方法，這時實例物件調用則是構造函中的方法 sayHi。\n通過以上兩個簡單示例不難發現 JavaScript 中物件的工作機制：當訪問物件的屬性或方法時，先在當前實例物件是查找，然後再去原型物件查找，並且原型物件被所有實例共用。\n&lt;script&gt;\n  function Person() &#123;\n    &#x2F;&#x2F; 此處定義同名方法 sayHi\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;嗨!&#39; + this.name)\n    &#125;\n  &#125;\n\n  &#x2F;&#x2F; 為構造函數的原型物件添加方法\n  Person.prototype.sayHi &#x3D; function () &#123;\n    console.log(&#39;Hi~&#39; + this.name)\n  &#125;\n  &#x2F;&#x2F; 在構造函數的原型物件上添加屬性\n  Person.prototype.name &#x3D; &#39;小明&#39;\n\n  let p1 &#x3D; new Person()\n  p1.sayHi(); &#x2F;&#x2F; 輸出結果為 嗨!\n  \n  let p2 &#x3D; new Person()\n  p2.sayHi()\n&lt;&#x2F;script&gt;\n\n總結：結合構造函數原型的特徵，實際開發重往往會將封裝的功能函數添加到原型物件中。\nconstructor 屬性在哪裡？ 每個原型物件裡面都有個constructor 屬性（constructor 構造函數）\n作用：該屬性指向該原型物件的構造函數， 簡單理解，就是指向我的爸爸，我是有爸爸的孩子\n使用場景：\n如果有多個物件的方法，我們可以給原型物件採取物件形式賦值.\n但是這樣就會覆蓋構造函數原型物件原來的內容，這樣修改後的原型物件 constructor 就不再指向當前構造函數了\n此時，我們可以在修改後的原型物件中，添加一個 constructor 指向原來的構造函數。\n物件原型物件都會有一個屬性 proto 指向構造函數的 prototype 原型物件，之所以我們物件可以使用構造函數 prototype \n原型物件的屬性和方法，就是因為物件有 proto 原型的存在。\n注意：\n\nproto 是JS非標準屬性\n[[prototype]]和__proto__意義相同\n用來表明當前實例物件指向哪個原型物件prototype\n__proto__物件原型裡面也有一個 constructor屬性，指向創建該實例物件的構造函數\n\n原型繼承繼承是物件導向程式設計的另一個特徵，通過繼承進一步提升代碼封裝的程度，JavaScript 中大多是借助原型物件實現繼承\n的特性。\n龍生龍、鳳生鳳、老鼠的兒子會打洞描述的正是繼承的含義。\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 繼續抽取   公共的部分放到原型上\n    &#x2F;&#x2F; const Person1 &#x3D; &#123;\n    &#x2F;&#x2F;   eyes: 2,\n    &#x2F;&#x2F;   head: 1\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; const Person2 &#x3D; &#123;\n    &#x2F;&#x2F;   eyes: 2,\n    &#x2F;&#x2F;   head: 1\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; 構造函數  new 出來的物件 結構一樣，但是物件不一樣\n    function Person() &#123;\n      this.eyes &#x3D; 2\n      this.head &#x3D; 1\n    &#125;\n    &#x2F;&#x2F; console.log(new Person)\n    &#x2F;&#x2F; 女人  構造函數   繼承  想要 繼承 Person\n    function Woman() &#123;\n\n    &#125;\n    &#x2F;&#x2F; Woman 通過原型來繼承 Person\n    &#x2F;&#x2F; 父構造函數（父類）   子構造函數（子類）\n    &#x2F;&#x2F; 子類的原型 &#x3D;  new 父類  \n    Woman.prototype &#x3D; new Person()   &#x2F;&#x2F; &#123;eyes: 2, head: 1&#125; \n    &#x2F;&#x2F; 指回原來的構造函數\n    Woman.prototype.constructor &#x3D; Woman\n\n    &#x2F;&#x2F; 給女人添加一個方法  生孩子\n    Woman.prototype.baby &#x3D; function () &#123;\n      console.log(&#39;寶貝&#39;)\n    &#125;\n    const red &#x3D; new Woman()\n    console.log(red)\n    &#x2F;&#x2F; console.log(Woman.prototype)\n    &#x2F;&#x2F; 男人 構造函數  繼承  想要 繼承 Person\n    function Man() &#123;\n\n    &#125;\n    &#x2F;&#x2F; 通過 原型繼承 Person\n    Man.prototype &#x3D; new Person()\n    Man.prototype.constructor &#x3D; Man\n    const pink &#x3D; new Man()\n    console.log(pink)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n原型鏈基於原型物件的繼承使得不同構造函數的原型物件關聯在一起，並且這種關聯的關係是一種鏈狀的結構，我們將原型對\n象的鏈狀結構關係稱為原型鏈\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; function Objetc() &#123;&#125;\n    console.log(Object.prototype)\n    console.log(Object.prototype.__proto__)\n\n    function Person() &#123;\n\n    &#125;\n    const ldh &#x3D; new Person()\n    &#x2F;&#x2F; console.log(ldh.__proto__ &#x3D;&#x3D;&#x3D; Person.prototype)\n    &#x2F;&#x2F; console.log(Person.prototype.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype)\n    console.log(ldh instanceof Person)\n    console.log(ldh instanceof Object)\n    console.log(ldh instanceof Array)\n    console.log([1, 2, 3] instanceof Array)\n    console.log(Array instanceof Object)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n① 當訪問一個物件的屬性（包括方法）時，首先查找這個物件自身有沒有該屬性。\n② 如果沒有就查找它的原型（也就是 __proto__指向的 prototype 原型物件）\n③ 如果還沒有就查找原型物件的原型（Object的原型物件）\n④ 依此類推一直找到 Object 為止（null）\n⑤ __proto__物件原型的意義就在於為物件成員查找機制提供一個方向，或者說一條路線\n⑥ 可以使用 instanceof 運算子用於檢測構造函數的 prototype 屬性是否出現在某個實例物件的原型鏈上\n","slug":"20230331JavaScript 進階 - 第3天","date":"2023-03-31T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"b57064d0869ba36d27730b8b11beee0b","title":"JavaScript 進階 - 第2天","content":"\n\n\n\n\n\n\n\n\n瞭解物件導向程式設計的基礎概念及構造函數的作用，體會 JavaScript 一切皆物件的語言特徵，掌握常見的物件屬性和方法的使用。\n\n瞭解物件導向程式設計中的一般概念\n能夠基於構造函數創建物件\n理解 JavaScript 中一切皆物件的語言特徵\n理解引用物件類型值存儲的的特徵\n掌握包裝類型物件常見方法的使用\n\n深入對象\n\n\n\n\n\n\n\n\n瞭解物件導向的基礎概念，能夠利用構造函數創建物件。\n構造函數構造函數是專門用於創建物件的函數，如果一個函數使用 new 關鍵字調用，那麼這個函數就是構造函數。\n&lt;script&gt;\n  &#x2F;&#x2F; 定義函數\n  function foo() &#123;\n    console.log(&#39;通過 new 也能調用函數...&#39;);\n  &#125;\n  &#x2F;&#x2F; 調用函數\n  new foo;\n&lt;&#x2F;script&gt;\n\n總結：\n\n使用 new 關鍵字調用函數的行為被稱為產生實體\n產生實體構造函數時沒有參數時可以省略 ()\n構造函數的返回值即為新創建的物件\n構造函數內部的 return 返回的值無效！\n\n注：實踐中為了從視覺上區分構造函數和普通函數，習慣將構造函數的首字母大寫。\n實例成員通過構造函數創建的物件稱為實例物件，實例物件中的屬性和方法稱為實例成員。\n&lt;script&gt;\n  &#x2F;&#x2F; 構造函數\n  function Person() &#123;\n    &#x2F;&#x2F; 構造函數內部的 this 就是實例物件\n    &#x2F;&#x2F; 實例物件中動態添加屬性\n    this.name &#x3D; &#39;小明&#39;\n    &#x2F;&#x2F; 實例物件動態添加方法\n    this.sayHi &#x3D; function () &#123;\n      console.log(&#39;大家好~&#39;)\n    &#125;\n  &#125;\n  &#x2F;&#x2F; 產生實體，p1 是實例物件\n  &#x2F;&#x2F; p1 實際就是 構造函數內部的 this\n  const p1 &#x3D; new Person()\n  console.log(p1)\n  console.log(p1.name) &#x2F;&#x2F; 訪問實例屬性\n  p1.sayHi() &#x2F;&#x2F; 調用實例方法\n&lt;&#x2F;script&gt;\n\n總結：\n\n構造函數內部 this 實際上就是實例物件，為其動態添加的屬性和方法即為實例成員\n為構造函數傳入參數，動態創建結構相同但值不同的物件\n\n注：構造函數創建的實例物件彼此獨立互不影響。\n靜態成員在 JavaScript 中底層函數本質上也是物件類型，因此允許直接為函數動態添加屬性或方法，構造函數的屬性和方法被稱為靜態成員。\n&lt;script&gt;\n  &#x2F;&#x2F; 構造函數\n  function Person(name, age) &#123;\n    &#x2F;&#x2F; 省略實例成員\n  &#125;\n  &#x2F;&#x2F; 靜態屬性\n  Person.eyes &#x3D; 2\n  Person.arms &#x3D; 2\n  &#x2F;&#x2F; 靜態方法\n  Person.walk &#x3D; function () &#123;\n    console.log(&#39;^_^人都會走路...&#39;)\n    &#x2F;&#x2F; this 指向 Person\n    console.log(this.eyes)\n  &#125;\n&lt;&#x2F;script&gt;\n\n總結：\n\n靜態成員指的是添加到構造函數本身的屬性和方法\n一般公共特徵的屬性或方法靜態成員設置為靜態成員\n靜態成員方法中的 this 指向構造函數本身\n\n內置構造函數\n\n\n\n\n\n\n\n\n掌握各參考類型和包裝類型物件屬性和方法的使用。\n在 JavaScript 中最主要的資料類型有 6 種，分別是字串、數值、布林、undefined、null 和 物件，常見的物件類型資料包括陣列和普通物件。其中字串、數值、布林、undefined、null 也被稱為簡單類型或基礎類型，物件也被稱為參考類型。\n在 JavaScript 內置了一些構造函數，絕大部的資料處理都是基於這些構造函數實現的，JavaScript 基礎階段學習的 Date 就是內置的構造函數。\n&lt;script&gt;\n  &#x2F;&#x2F; 產生實體\n  let date &#x3D; new Date();\n  \n  &#x2F;&#x2F; date 即為實例物件\n  console.log(date);\n&lt;&#x2F;script&gt;\n\n甚至字串、數值、布林、陣列、普通物件也都有專門的構造函數，用於創建對應類型的資料。\nObjectObject 是內置的構造函數，用於創建普通物件。\n&lt;script&gt;\n  &#x2F;&#x2F; 通過構造函數創建普通物件\n  const user &#x3D; new Object(&#123;name: &#39;小明&#39;, age: 15&#125;)\n\n  &#x2F;&#x2F; 這種方式聲明的變數稱為【字面量】\n  let student &#x3D; &#123;name: &#39;杜子騰&#39;, age: 21&#125;\n  \n  &#x2F;&#x2F; 物件語法簡寫\n  let name &#x3D; &#39;小紅&#39;;\n  let people &#x3D; &#123;\n    &#x2F;&#x2F; 相當於 name: name\n    name,\n    &#x2F;&#x2F; 相當於 walk: function () &#123;&#125;\n    walk () &#123;\n      console.log(&#39;人都要走路...&#39;);\n    &#125;\n  &#125;\n\n  console.log(student.constructor);\n  console.log(user.constructor);\n  console.log(student instanceof Object);\n&lt;&#x2F;script&gt;\n\n。\n總結：\n\n推薦使用字面量方式聲明物件，而不是 Object 構造函數\nObject.assign 靜態方法創建新的物件\nObject.keys 靜態方法獲取物件中所有屬性\nObject.values 表態方法獲取物件中所有屬性值\n\nArrayArray 是內置的構造函數，用於創建陣列。\n&lt;script&gt;\n  &#x2F;&#x2F; 構造函數創建陣列\n  let arr &#x3D; new Array(5, 7, 8);\n\n  &#x2F;&#x2F; 字面量方式創建陣列\n  let list &#x3D; [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n\n&lt;&#x2F;script&gt;\n\n陣列賦值後，無論修改哪個變數另一個物件的資料值也會相當發生改變。\n總結：\n\n推薦使用字面量方式聲明陣列，而不是 Array 構造函數\n\n實例方法 forEach 用於遍歷陣列，替代 for 迴圈 (重點)\n\n實例方法 filter 過濾陣列單元值，生成新陣列(重點)\n\n實例方法 map 反覆運算原陣列，生成新陣列(重點)\n\n實例方法 join 陣列元素拼接為字串，返回字串(重點)\n\n實例方法  find  查找元素， 返回符合測試條件的第一個陣列元素值，如果沒有符合條件的則返回 undefined(重點)\n\n實例方法every 檢測陣列所有元素是否都符合指定條件，如果所有元素都通過檢測返回 true，否則返回 false(重點)\n\n實例方法some 檢測陣列中的元素是否滿足指定條件   如果陣列中有元素滿足條件返回 true，否則返回 false\n\n實例方法 concat  合併兩個陣列，返回生成新陣列\n\n實例方法 sort 對原陣列單元值排序\n\n實例方法 splice 刪除或替換原陣列單元\n\n實例方法 reverse 反轉陣列\n\n實例方法 findIndex  查找元素的索引值\n\n\n包裝類型在 JavaScript 中的字串、數值、布林具有物件的使用特徵，如具有屬性和方法，如下代碼舉例：\n&lt;script&gt;\n  &#x2F;&#x2F; 字串類型\n  const str &#x3D; &#39;hello world!&#39;\n  &#x2F;&#x2F; 統計字元的長度（字元數量）\n  console.log(str.length)\n  \n  &#x2F;&#x2F; 數數值型別\n  const price &#x3D; 12.345\n  &#x2F;&#x2F; 保留兩位小數\n  price.toFixed(2) &#x2F;&#x2F; 12.34\n&lt;&#x2F;script&gt;\n\n之所以具有物件特徵的原因是字串、數值、布林類型資料是 JavaScript 底層使用 Object 構造函數“包裝”來的，被稱為包裝類型。\nStringString 是內置的構造函數，用於創建字串。\n&lt;script&gt;\n  &#x2F;&#x2F; 使用構造函數創建字串\n  let str &#x3D; new String(&#39;hello world!&#39;);\n\n  &#x2F;&#x2F; 字面量創建字串\n  let str2 &#x3D; &#39;你好，世界！&#39;;\n\n  &#x2F;&#x2F; 檢測是否屬於同一個構造函數\n  console.log(str.constructor &#x3D;&#x3D;&#x3D; str2.constructor); &#x2F;&#x2F; true\n  console.log(str instanceof String); &#x2F;&#x2F; false\n&lt;&#x2F;script&gt;\n\n總結：\n\n實例屬性 length 用來獲取字串的度長(重點)\n實例方法 split(&#39;分隔符號&#39;) 用來將字串拆分成陣列(重點)\n實例方法 substring（需要截取的第一個字元的索引[,結束的索引號]） 用於字串截取(重點)\n實例方法 startsWith(檢測字串[, 檢測位置索引號]) 檢測是否以某字元開頭(重點)\n實例方法 includes(搜索的字串[, 檢測位置索引號]) 判斷一個字串是否包含在另一個字串中，根據情況返回 true 或 false(重點)\n實例方法 toUpperCase 用於將字母轉換成大寫\n實例方法 toLowerCase 用於將就轉換成小寫\n實例方法 indexOf  檢測是否包含某字元\n實例方法 endsWith 檢測是否以某字元結尾\n實例方法 replace 用於替換字串，支援正則匹配\n實例方法 match 用於查找字串，支援正則匹配\n\n注：String 也可以當做普通函數使用，這時它的作用是強制轉換成字串資料型別。\nNumberNumber 是內置的構造函數，用於創建數值。\n&lt;script&gt;\n  &#x2F;&#x2F; 使用構造函數創建數值\n  let x &#x3D; new Number(&#39;10&#39;)\n  let y &#x3D; new Number(5)\n\n  &#x2F;&#x2F; 字面量創建數值\n  let z &#x3D; 20\n\n&lt;&#x2F;script&gt;\n\n總結：\n\n推薦使用字面量方式聲明數值，而不是 Number 構造函數\n實例方法 toFixed 用於設置保留小數位的長度\n\n","slug":"20230330JavaScript 進階 - 第2天","date":"2023-03-30T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"35ba1b013b453118df98cec61f2a93fb","title":"JavaScript 進階 - 第1天","content":"\n\n\n\n\n\n\n\n\n學習作用域、變數提升、閉包等語言特徵，加深對 JavaScript 的理解，掌握變數賦值、函式宣告的簡潔語法，降低代碼的冗餘度。\n\n理解作用域對程式執行的影響\n能夠分析程式執行的作用域範圍\n理解閉包本質，利用閉包創建隔離作用域\n瞭解什麼變數提升及函數提升\n掌握箭頭函數、解析剩餘參數等簡潔語法\n\n作用域\n\n\n\n\n\n\n\n\n瞭解作用域對程式執行的影響及作用域鏈的查找機制，使用閉包函數創建隔離作用域避免全域變數污染。\n作用域（scope）規定了變數能夠被訪問的“範圍”，離開了這個“範圍”變數便不能被訪問，作用域分為全域作用域和局部作用域。\n局部作用域局部作用域分為函數作用域和塊作用域。\n函數作用域在函數內部聲明的變數只能在函數內部被訪問，外部無法直接訪問。\n&lt;script&gt;\n  &#x2F;&#x2F; 聲明 counter 函數\n  function counter(x, y) &#123;\n    &#x2F;&#x2F; 函數內部聲明的變數\n    const s &#x3D; x + y\n    console.log(s) &#x2F;&#x2F; 18\n  &#125;\n  &#x2F;&#x2F; 設用 counter 函數\n  counter(10, 8)\n  &#x2F;&#x2F; 訪問變數 s\n  console.log(s)&#x2F;&#x2F; 報錯\n&lt;&#x2F;script&gt;\n\n總結：\n\n函數內部聲明的變數，在函數外部無法被訪問\n函數的參數也是函數內部的區域變數\n不同函數內部聲明的變數無法互相訪問\n函數執行完畢後，函數內部的變數實際被清空了\n\n塊作用域在 JavaScript 中使用 &#123;&#125; 包裹的代碼稱為代碼塊，代碼塊內部聲明的變數外部將【有可能】無法被訪問。\n&lt;script&gt;\n  &#123;\n    &#x2F;&#x2F; age 只能在該代碼塊中被訪問\n    let age &#x3D; 18;\n    console.log(age); &#x2F;&#x2F; 正常\n  &#125;\n  \n  &#x2F;&#x2F; 超出了 age 的作用域\n  console.log(age) &#x2F;&#x2F; 報錯\n  \n  let flag &#x3D; true;\n  if(flag) &#123;\n    &#x2F;&#x2F; str 只能在該代碼塊中被訪問\n    let str &#x3D; &#39;hello world!&#39;\n    console.log(str); &#x2F;&#x2F; 正常\n  &#125;\n  \n  &#x2F;&#x2F; 超出了 age 的作用域\n  console.log(str); &#x2F;&#x2F; 報錯\n  \n  for(let t &#x3D; 1; t &lt;&#x3D; 6; t++) &#123;\n    &#x2F;&#x2F; t 只能在該代碼塊中被訪問\n    console.log(t); &#x2F;&#x2F; 正常\n  &#125;\n  \n  &#x2F;&#x2F; 超出了 t 的作用域\n  console.log(t); &#x2F;&#x2F; 報錯\n&lt;&#x2F;script&gt;\n\nJavaScript 中除了變數外還有常量，常量與變數本質的區別是【常量必須要有值且不允許被重新賦值】，常量值為物件時其屬性和方法允許重新賦值。\n&lt;script&gt;\n  &#x2F;&#x2F; 必須要有值\n  const version &#x3D; &#39;1.0.0&#39;;\n\n  &#x2F;&#x2F; 不能重新賦值\n  &#x2F;&#x2F; version &#x3D; &#39;1.0.1&#39;;\n\n  &#x2F;&#x2F; 常量值為對象類型\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;\n\n  &#x2F;&#x2F; 不能重新賦值\n  user &#x3D; &#123;&#125;;\n\n  &#x2F;&#x2F; 屬性和方法允許被修改\n  user.name &#x3D; &#39;小小明&#39;;\n  user.gender &#x3D; &#39;男&#39;;\n&lt;&#x2F;script&gt;\n\n總結：\n\nlet 聲明的變數會產生塊作用域，var 不會產生塊作用域\nconst 聲明的常量也會產生塊作用域\n不同代碼塊之間的變數無法互相訪問\n推薦使用 let 或 const\n\n注：開發中 let 和 const 經常不加區分的使用，如果擔心某個值會不小被修改時，則只能使用 const 聲明成常量。\n全域作用域&lt;script&gt; 標籤和 .js 檔的【最外層】就是所謂的全域作用域，在此聲明的變數在函數內部也可以被訪問。\n&lt;script&gt;\n  &#x2F;&#x2F; 此處是全域\n  \n  function sayHi() &#123;\n    &#x2F;&#x2F; 此處為局部\n  &#125;\n\n  &#x2F;&#x2F; 此處為全域\n&lt;&#x2F;script&gt;\n\n全域作用域中聲明的變數，任何其它作用域都可以被訪問，如下代碼所示：\n&lt;script&gt;\n    &#x2F;&#x2F; 全域變數 name\n    const name &#x3D; &#39;小明&#39;\n  \n    &#x2F;&#x2F; 函數作用域中訪問全域\n    function sayHi() &#123;\n      &#x2F;&#x2F; 此處為局部\n      console.log(&#39;你好&#39; + name)\n    &#125;\n\n    &#x2F;&#x2F; 全域變數 flag 和 x\n    const flag &#x3D; true\n    let x &#x3D; 10\n  \n    &#x2F;&#x2F; 塊作用域中訪問全域\n    if(flag) &#123;\n      let y &#x3D; 5\n      console.log(x + y) &#x2F;&#x2F; x 是全域的\n    &#125;\n&lt;&#x2F;script&gt;\n\n總結：\n\n為 window 物件動態添加的屬性預設也是全域的，不推薦！\n函數中未使用任何關鍵字聲明的變數為全域變數，不推薦！！！\n盡可能少的聲明全域變數，防止全域變數被污染\n\nJavaScript 中的作用域是程式被執行時的底層機制，瞭解這一機制有助於規範代碼書寫習慣，避免因作用域導致的語法錯誤。\n作用域鏈在解釋什麼是作用域鏈前先來看一段代碼：\n&lt;script&gt;\n  &#x2F;&#x2F; 全域作用域\n  let a &#x3D; 1\n  let b &#x3D; 2\n  &#x2F;&#x2F; 局部作用域\n  function f() &#123;\n    let c\n    &#x2F;&#x2F; 局部作用域\n    function g() &#123;\n      let d &#x3D; &#39;yo&#39;\n    &#125;\n  &#125;\n&lt;&#x2F;script&gt;\n\n函數內部允許創建新的函數，f 函數內部創建的新函數 g，會產生新的函數作用域，由此可知作用域產生了嵌套的關係。\n如下圖所示，父子關係的作用域關聯在一起形成了鏈狀的結構，作用域鏈的名字也由此而來。\n作用域鏈本質上是底層的變數查找機制，在函數被執行時，會優先查找當前函數作用域中查找變數，如果當前作用域查找不到則會依次逐級查找父級作用域直到全域作用域，如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 全域作用域\n  let a &#x3D; 1\n  let b &#x3D; 2\n\n  &#x2F;&#x2F; 局部作用域\n  function f() &#123;\n    let c\n    &#x2F;&#x2F; let a &#x3D; 10;\n    console.log(a) &#x2F;&#x2F; 1 或 10\n    console.log(d) &#x2F;&#x2F; 報錯\n    \n    &#x2F;&#x2F; 局部作用域\n    function g() &#123;\n      let d &#x3D; &#39;yo&#39;\n      &#x2F;&#x2F; let b &#x3D; 20;\n      console.log(b) &#x2F;&#x2F; 2 或 20\n    &#125;\n    \n    &#x2F;&#x2F; 調用 g 函數\n    g()\n  &#125;\n\n  console.log(c) &#x2F;&#x2F; 報錯\n  console.log(d) &#x2F;&#x2F; 報錯\n  \n  f();\n&lt;&#x2F;script&gt;\n\n總結：\n\n嵌套關係的作用域串聯起來形成了作用域鏈\n相同作用域鏈中按著從小到大的規則查找變數\n子作用域能夠訪問父作用域，父級作用域無法訪問子級作用域\n\nJS垃圾回收機制垃圾回收機制(Garbage Collection) 簡稱 GCJS中內存的分配和回收都是自動完成的，內存在不使用的時候會被垃圾回收器自動回收。 **如果不了解JS的內存管理機制，我們同樣非常容易成內存洩漏（內存無法被回收）的情況不再用到的內存，沒有及時釋放，就叫做**內存洩漏\n\n內存的生命週期JS環境中分配的內存, 一般有如下生命週期：\n\n內存分配：當我們聲明變量、函數、對象的時候，系統會自動為他們分配內存\n內存使用：即讀寫內存，也就是使用變量、函數等\n內存回收：使用完畢，由垃圾回收自動回收不再使用的內存\n\n\n\n\n\n\n\n\n\n\n說明：\n\n全局變量一般不會回收(關閉頁面回收)；\n一般情況下局部變量的值, 不用了, 會被自動回收掉\n\n\n算法說明堆棧空間分配區別：\n\n棧（操作系統）: 由操作系統自動分配釋放函數的參數值、局部變量等，基本數據類型放到棧裡面。\n堆（操作系統）: 一般由程序員分配釋放，若程序員不釋放，由垃圾回收機制回收。複雜數據類型放到堆裡面。\n\n\n常見的瀏覽器垃圾回收算法: 引用計數法 和 標記清除法\n引用計數IE採用的引用計數算法, 定義“內存不再使用”，就是看一個對像是否有指向它的引用，沒有引用了就回收對象\n\n跟踪記錄被引用的次數\n如果被引用了一次，那麼就記錄次數1,多次引用會累加 ++\n如果減少一個引用就減1 –\n如果引用次數是0 ，則釋放內存\n\n標記清除法現代的瀏覽器已經不再使用引用計數算法了。現代瀏覽器通用的大多是基於標記清除算法的某些改進算法，總體思想都是一致的。核心：\n\n標記清除算法將“不再使用的對象”定義為“無法達到的對象”。\n就是從根部（在JS中就是全局對象）出發定時掃描內存中的對象。凡是能從根部到達的對象，都是還需要使用的。\n那些無法由根部出發觸及到的對像被標記為不再使用，稍後進行回收。\n\n閉包閉包是一種比較特殊和函數，使用閉包能夠訪問函數作用域中的變數。從代碼形式上看閉包是一個做為返回值的函數，如下代碼所示：\n\n\n\n\n\n\n\n\n\n閉包 : 內層函數 + 外層函數變數\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 閉包 : 內層函數 + 外層函數變數\n    &#x2F;&#x2F; function outer() &#123;\n        &#x2F;&#x2F;外層函數變數\n    &#x2F;&#x2F;   const a &#x3D; 1\n        &#x2F;&#x2F;內層函數\n    &#x2F;&#x2F;   function f() &#123;\n    &#x2F;&#x2F;     console.log(a)\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F;   f()\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; outer()\n\n    &#x2F;&#x2F; 2. 閉包的應用： 統計函數的調用次數\n    &#x2F;&#x2F; let count &#x3D; 1\n    &#x2F;&#x2F; function fn() &#123;\n    &#x2F;&#x2F;   count++\n    &#x2F;&#x2F;   console.log(&#96;函數被調用$&#123;count&#125;次&#96;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F;  因为 count 是全局變量，容易被修改\n\n    &#x2F;&#x2F; 3. 閉包的升級寫法 實現資料的私有。 統計函數的調用次數\n    function outer() &#123;\n      let count &#x3D; 1\n      function fn() &#123;\n        count++\n        console.log(&#96;函數被調用$&#123;count&#125;次&#96;)\n      &#125;\n      return fn\n    &#125;\n    &#x2F;&#x2F;全局~\n    const re &#x3D; outer()\n    &#x2F;&#x2F; const re &#x3D; function fn() &#123;\n    &#x2F;&#x2F;   count++\n    &#x2F;&#x2F;   console.log(&#96;函數被調用$&#123;count&#125;次&#96;)\n    &#x2F;&#x2F; &#125;\n    re()\n    re()\n    &#x2F;&#x2F; const fn &#x3D; function() &#123; &#125;  函數運算式\n    &#x2F;&#x2F; 4. 閉包存在的問題： 可能會造成記憶體洩漏\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n總結：\n1.怎麼理解閉包？\n\n閉包 &#x3D; 內層函數 + 外層函數的變數\n\n2.閉包的作用？\n\n封閉資料，實現資料私有，外部也可以訪問函數內部的變數\n閉包很有用，因為它允許將函數與其所操作的某些資料（環境）關聯起來\n\n3.閉包可能引起的問題？\n\n記憶體洩漏\n\n變數提升變數提升是 JavaScript 中比較“奇怪”的現象，它允許在變數聲明之前即被訪問，\n&lt;script&gt;\n  &#x2F;&#x2F; 訪問變數 str\n  console.log(str + &#39;world!&#39;);\n\n  &#x2F;&#x2F; 聲明變數 str\n  var str &#x3D; &#39;hello &#39;;\n&lt;&#x2F;script&gt;\n\n總結：\n\n變數在未聲明即被訪問時會報語法錯誤\n變數在聲明之前即被訪問，變數的值為 undefined\nlet 聲明的變數不存在變數提升，推薦使用 let\n變數提升出現在相同作用域當中\n實際開發中推薦先聲明再訪問變數\n\n注：關於變數提升的原理分析會涉及較為複雜的詞法分析等知識，而開發中使用 let 可以輕鬆規避變數的提升，因此在此不做過多的探討，有興趣可查閱資料。\n函數\n\n\n\n\n\n\n\n\n知道函數參數預設值、動態參數、剩餘參數的使用細節，提升函數應用的靈活度，知道箭頭函數的語法及與普通函數的差異。\n函數提升函數提升與變數提升比較類似，是指函數在聲明之前即可被調用。\n&lt;script&gt;\n  &#x2F;&#x2F; 調用函數\n  foo()\n  &#x2F;&#x2F; 聲明函數\n  function foo() &#123;\n    console.log(&#39;聲明之前即被調用...&#39;)\n  &#125;\n\n  &#x2F;&#x2F; 不存在提升現象\n  bar()  &#x2F;&#x2F; 錯誤\n  var bar &#x3D; function () &#123;\n    console.log(&#39;函數運算式不存在提升現象...&#39;)\n  &#125;\n&lt;&#x2F;script&gt;\n\n總結：\n\n函數提升能夠使函數的聲明調用更靈活\n函數運算式不存在提升的現象\n函數提升出現在相同作用域當中\n\n函數參數函數參數的使用細節，能夠提升函數應用的靈活度。\n預設值&lt;script&gt;\n  &#x2F;&#x2F; 設置參數預設值\n  function sayHi(name&#x3D;&quot;小明&quot;, age&#x3D;18) &#123;\n    document.write(&#96;&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;歲了。&lt;&#x2F;p&gt;&#96;);\n  &#125;\n  &#x2F;&#x2F; 調用函數\n  sayHi();\n  sayHi(&#39;小紅&#39;);\n  sayHi(&#39;小剛&#39;, 21);\n&lt;&#x2F;script&gt;\n\n總結：\n\n聲明函數時為形參賦值即為參數的預設值\n如果參數未自訂預設值時，參數的預設值為 undefined\n調用函數時沒有傳入對應實參時，參數的預設值被當做實參傳入\n\n動態參數arguments 是函數內部內置的偽陣列變數，它包含了調用函數時傳入的所有實參。\n&lt;script&gt;\n  &#x2F;&#x2F; 求生函數，計算所有參數的和\n  function sum() &#123;\n    &#x2F;&#x2F; console.log(arguments)\n    let s &#x3D; 0\n    for(let i &#x3D; 0; i &lt; arguments.length; i++) &#123;\n      s +&#x3D; arguments[i]\n    &#125;\n    console.log(s)\n  &#125;\n  &#x2F;&#x2F; 調用求和函數\n  sum(5, 10)&#x2F;&#x2F; 兩個參數\n  sum(1, 2, 4) &#x2F;&#x2F; 兩個參數\n&lt;&#x2F;script&gt;\n\n總結：\n\narguments 是一個偽陣列\narguments 的作用是動態獲取函數的實參\n\n剩餘參數 (與 展開運算符 相似)&lt;script&gt;\n  function config(baseURL, ...other) &#123;\n    console.log(baseURL) &#x2F;&#x2F; 得到 &#39;http:&#x2F;&#x2F;baidu.com&#39;\n    console.log(other)  &#x2F;&#x2F; other  得到 [&#39;get&#39;, &#39;json&#39;]\n  &#125;\n  &#x2F;&#x2F; 調用函數\n  config(&#39;http:&#x2F;&#x2F;baidu.com&#39;, &#39;get&#39;, &#39;json&#39;);\n&lt;&#x2F;script&gt;\n\n總結：\n\n... 是語法符號，置於最末函數形參之前，用於獲取多餘的實參\n借助 ... 獲取的剩餘實參，是個真陣列\n\n展開運算符 or 剩餘參數剩餘參數：函數參數使用，得到真數組展開運算符：數組中使用，數組展開\n箭頭函數箭頭函數是一種聲明函數的簡潔語法，它與普通函數並無本質的區別，差異性更多體現在語法格式上，更適用於那些本來需要匿名函數的地方。\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; const fn &#x3D; function () &#123;\n    &#x2F;&#x2F;   console.log(123)\n    &#x2F;&#x2F; &#125;\n\n    &#x2F;&#x2F; 1. 箭頭函數 基本語法\n    &#x2F;&#x2F; const fn &#x3D; () &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(123)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; fn()\n\n    &#x2F;&#x2F; const fn &#x3D; (x) &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(x)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; fn(1)\n\n    &#x2F;&#x2F; 2. 只有一個形參的時候，可以省略小括弧\n    &#x2F;&#x2F; const fn &#x3D; x &#x3D;&gt; &#123;\n    &#x2F;&#x2F;   console.log(x)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; fn(1)\n\n    &#x2F;&#x2F; &#x2F;&#x2F; 3. 只有一行代碼的時候，我們可以省略大括弧\n    &#x2F;&#x2F; const fn &#x3D; x &#x3D;&gt; console.log(x)\n    &#x2F;&#x2F; fn(1)\n\n    &#x2F;&#x2F; 4. 只有一行代碼的時候，可以省略return\n    &#x2F;&#x2F; const fn &#x3D; x &#x3D;&gt; x + x\n    &#x2F;&#x2F; console.log(fn(1))\n\n    &#x2F;&#x2F; 5. 箭頭函數可以直接返回一個物件\n    &#x2F;&#x2F; const fn &#x3D; (uname) &#x3D;&gt; (&#123; uname: uname &#125;)\n    &#x2F;&#x2F; console.log(fn(&#39;劉德華&#39;))\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n總結：\n\n箭頭函數屬於運算式函數，因此不存在函數提升\n箭頭函數只有一個參數時可以省略圓括號 ()\n箭頭函數函數體只有一行代碼時可以省略花括弧 &#123;&#125;，並自動做為返回值被返回\n\n箭頭函數參數箭頭函數中沒有動態參數 arguments，只能使用剩餘參數 ... 動態獲取實參\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 利用箭頭函數來求和\n    const getSum &#x3D; (...arr) &#x3D;&gt; &#123;\n      let sum &#x3D; 0\n      for (let i &#x3D; 0; i &lt; arr.length; i++) &#123;\n        sum +&#x3D; arr[i]\n      &#125;\n      return sum\n    &#125;\n    const result &#x3D; getSum(2, 3, 4)\n    console.log(result) &#x2F;&#x2F; 9\n  &lt;&#x2F;script&gt;\n\n箭頭函數 this箭頭函數不會創建自己的this,它只會從自己的作用域鏈的上一層沿用this。\n&lt;script&gt;\n   &#x2F;&#x2F; 以前this的指向：  誰調用的這個函數，this 就指向誰\n   &#x2F;&#x2F; console.log(this)  &#x2F;&#x2F; window\n   &#x2F;&#x2F; &#x2F;&#x2F; 普通函數\n   &#x2F;&#x2F; function fn() &#123;\n   &#x2F;&#x2F;   console.log(this)  &#x2F;&#x2F; window\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; window.fn()\n   &#x2F;&#x2F; &#x2F;&#x2F; 物件方法裡面的this\n   &#x2F;&#x2F; const obj &#x3D; &#123;\n   &#x2F;&#x2F;   name: &#39;andy&#39;,\n   &#x2F;&#x2F;   sayHi: function () &#123;\n   &#x2F;&#x2F;     console.log(this)  &#x2F;&#x2F; obj\n   &#x2F;&#x2F;   &#125;\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; obj.sayHi()\n\n   &#x2F;&#x2F; 2. 箭頭函數的this  是上一層作用域的this 指向\n   &#x2F;&#x2F; const fn &#x3D; () &#x3D;&gt; &#123;\n   &#x2F;&#x2F;   console.log(this)  &#x2F;&#x2F; window\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; fn()\n   &#x2F;&#x2F; 物件方法箭頭函數 this\n   &#x2F;&#x2F; const obj &#x3D; &#123;\n   &#x2F;&#x2F;   uname: &#39;pink老師&#39;,\n   &#x2F;&#x2F;   sayHi: () &#x3D;&gt; &#123;\n   &#x2F;&#x2F;     console.log(this)  &#x2F;&#x2F; this 指向誰？ window\n   &#x2F;&#x2F;   &#125;\n   &#x2F;&#x2F; &#125;\n   &#x2F;&#x2F; obj.sayHi()\n\n   const obj &#x3D; &#123;\n     uname: &#39;老師&#39;,\n     sayHi: function () &#123;\n       console.log(this)  &#x2F;&#x2F; obj\n       let i &#x3D; 10\n       const count &#x3D; () &#x3D;&gt; &#123;\n         console.log(this)  &#x2F;&#x2F; obj \n       &#125;\n       count()\n     &#125;\n   &#125;\n   obj.sayHi()\n\n &lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n箭頭函數不會創建自己的this,它只會從自己的作用域鏈的上一層沿用thisDOM事件回調函數不推薦使用箭頭函數嗎，特別是需要用到this的時候事件回調函數使用箭頭函數時，this 為全局的 window\n解構賦值\n\n\n\n\n\n\n\n\n知道解構的語法及分類，使用解構簡潔語法快速為變數賦值。\n解構賦值是一種快速為變數賦值的簡潔語法，本質上仍然是為變數賦值，分為陣列解構、物件解構兩大類型。\nconsole [變量1,變量2,變量3] &#x3D; [單元值1, 單元值2, 單元值3]\n\n陣列解構陣列解構是將陣列的單元值快速批量賦值給一系列變數的簡潔語法，如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 普通的陣列\n  let arr &#x3D; [1, 2, 3]\n  &#x2F;&#x2F; 批量聲明變數 a b c \n  &#x2F;&#x2F; 同時將陣列單元值 1 2 3 依次賦值給變數 a b c\n  let [a, b, c] &#x3D; arr\n  console.log(a); &#x2F;&#x2F; 1\n  console.log(b); &#x2F;&#x2F; 2\n  console.log(c); &#x2F;&#x2F; 3\n&lt;&#x2F;script&gt;\n\n&lt;script&gt;\n  &#x2F;&#x2F; const arr &#x3D; [100, 60, 80]\n  &#x2F;&#x2F; 數組解構 賦值\n  &#x2F;&#x2F; &#x2F;&#x2F; const [max, min, avg] &#x3D; arr\n  const [max, min, avg] &#x3D; [100, 60, 80]\n  &#x2F;&#x2F; &#x2F;&#x2F; const max &#x3D; arr[0]\n  &#x2F;&#x2F; &#x2F;&#x2F; const min &#x3D; arr[1]\n  &#x2F;&#x2F; &#x2F;&#x2F; const avg &#x3D; arr[2]\n  console.log(max) &#x2F;&#x2F; 100\n  console.log(avg) &#x2F;&#x2F; 80\n\n  &#x2F;&#x2F; 交換2個變量的值\n  let a &#x3D; 1\n  let b &#x3D; 2;\n  [b, a] &#x3D; [a, b]\n  console.log(a, b)\n  &lt;&#x2F;script&gt;\n&lt;script&gt;\n    &#x2F;&#x2F; 1. 立即执行函数要加\n    &#x2F;&#x2F; (function () &#123; &#125;)();\n    &#x2F;&#x2F; (function () &#123; &#125;)();\n    &#x2F;&#x2F; 2. 使用数组的时候\n    &#x2F;&#x2F; const arr &#x3D; [1, 2, 3]\n    const str &#x3D; &#39;pink&#39;;\n    [1, 2, 3].map(function (item) &#123;\n      console.log(item)\n    &#125;)\n\n    let a &#x3D; 1\n    let b &#x3D; 2\n      ;[b, a] &#x3D; [a, b]\n\n    console.log(a, b)\n  &lt;&#x2F;script&gt;\n&lt;script&gt;\n    &#x2F;&#x2F; const pc &#x3D; [&#39;海爾&#39;, &#39;聯想&#39;, &#39;小米&#39;, &#39;方正&#39;];\n    &#x2F;&#x2F; [hr, lx, mi, fz] &#x3D; pc\n    &#x2F;&#x2F; console.log(hr, lx, mi, fz);\n\n\n    &#x2F;&#x2F; function getValue() &#123;\n    &#x2F;&#x2F;   return [100, 60]\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; [max, min] &#x3D; getValue()\n    &#x2F;&#x2F; console.log(max, min);\n\n\n\n    &#x2F;&#x2F; const pc &#x3D; [&#39;海爾&#39;, &#39;聯想&#39;, &#39;小米&#39;, &#39;方正&#39;]\n    &#x2F;&#x2F; const [hr, lx, mi, fz] &#x3D; [&#39;海爾&#39;, &#39;聯想&#39;, &#39;小米&#39;, &#39;方正&#39;]\n    &#x2F;&#x2F; console.log(hr)\n    &#x2F;&#x2F; console.log(lx)\n    &#x2F;&#x2F; console.log(mi)\n    &#x2F;&#x2F; console.log(fz)\n\n    &#x2F;&#x2F; &#x2F;&#x2F; 請將最大值和最小值函數返回值解構 max 和min 兩個變量\n    &#x2F;&#x2F; function getValue() &#123;\n    &#x2F;&#x2F;   return [100, 60]\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; const [max, min] &#x3D; getValue()\n    &#x2F;&#x2F; console.log(max)\n    &#x2F;&#x2F; console.log(min)\n    \n    &#x2F;&#x2F; 1. 變量多， 單元值少 ， undefined\n    &#x2F;&#x2F; const [a, b, c, d] &#x3D; [1, 2, 3]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; 3\n    &#x2F;&#x2F; console.log(d) &#x2F;&#x2F; undefined\n    &#x2F;&#x2F; 2. 變量少， 單元值多\n    &#x2F;&#x2F; const [a, b] &#x3D; [1, 2, 3]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; 3.  剩餘參數 變量少， 單元值多\n    &#x2F;&#x2F; const [a, b, ...c] &#x3D; [1, 2, 3, 4]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; [3, 4]  真數組\n    &#x2F;&#x2F; 4.  防止 undefined 傳遞\n    &#x2F;&#x2F; const [a &#x3D; 0, b &#x3D; 0] &#x3D; [1, 2]\n    &#x2F;&#x2F; const [a &#x3D; 0, b &#x3D; 0] &#x3D; []\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; 5.  按需導入賦值\n    &#x2F;&#x2F; const [a, b, , d] &#x3D; [1, 2, 3, 4]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(d) &#x2F;&#x2F; 4\n\n    &#x2F;&#x2F; const arr &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; console.log(arr[0])  &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(arr[1])  &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(arr[2])  &#x2F;&#x2F; [3,4]\n    &#x2F;&#x2F; console.log(arr[2][0])  &#x2F;&#x2F; 3\n\n    &#x2F;&#x2F; 多維數組解構\n    &#x2F;&#x2F; const arr &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; const [a, b, c] &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; [3,4]\n\n    &#x2F;&#x2F; const [a, b, [c, d]] &#x3D; [1, 2, [3, 4]]\n    &#x2F;&#x2F; console.log(a) &#x2F;&#x2F; 1\n    &#x2F;&#x2F; console.log(b) &#x2F;&#x2F; 2\n    &#x2F;&#x2F; console.log(c) &#x2F;&#x2F; 3\n    &#x2F;&#x2F; console.log(d) &#x2F;&#x2F; 4\n  &lt;&#x2F;script&gt;\n總結：\n\n設定運算子 = 左側的 [] 用於批量聲明變數，右側陣列的單元值將被賦值給左側的變數\n變數的順序對應陣列單元值的位置依次進行賦值操作\n變數的數量大於單元值數量時，多餘的變數將被賦值為  undefined\n變數的數量小於單元值數量時，可以通過 ... 獲取剩餘單元值，但只能置於最末位\n允許初始化變數的預設值，且只有單元值為 undefined 時預設值才會生效\n\n注：支持多維解構賦值，比較複雜後續有應用需求時再進一步分析\n對象解構 (重要)\n\n\n\n\n\n\n\n\n複習: 數組中括號[]，對象大括號{}\n物件解構是將物件屬性和方法快速批量賦值給一系列變數的簡潔語法，如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 普通對象\n  const user &#x3D; &#123;\n    name: &#39;小明&#39;,\n    age: 18\n  &#125;;\n  &#x2F;&#x2F; 批量聲明變數 name age\n  &#x2F;&#x2F; 同時將陣列單元值 小明  18 依次賦值給變數 name  age\n\n  &#x2F;&#x2F;解構的語法\n  const &#123;name, age&#125; &#x3D; user\n  &#x2F;&#x2F; const &#123;name, age&#125; &#x3D; &#123;name: &#39;小明&#39;,age: 18&#125; 亦可\n  &#x2F;&#x2F; 等價於 const name &#x3D;  obj.name\n  \n  &#x2F;&#x2F; 要求屬性名和變量名必須一直才可以\n  console.log(name) &#x2F;&#x2F; 小明\n  console.log(age) &#x2F;&#x2F; 18\n&lt;&#x2F;script&gt;\n\n總結：\n\n設定運算子 = 左側的 &#123;&#125; 用於批量聲明變數，右側物件的屬性值將被賦值給左側的變數\n物件屬性的值將被賦值給與屬性名相同的變數\n物件中找不到與變數名一致的屬性時變數值為 undefined\n允許初始化變數的預設值，屬性不存在或單元值為 undefined 時預設值才會生效\n\n&lt;script&gt;\n    &#x2F;&#x2F; 1. 對象解構的變量名 可以重新改名  舊變量名: 新變量名\n    &#x2F;&#x2F; const &#123; uname: username, age &#125; &#x3D; &#123; uname: &#39;老師&#39;, age: 18 &#125;\n\n    &#x2F;&#x2F; &#x2F;&#x2F; console.log(username)\n    &#x2F;&#x2F; &#x2F;&#x2F; console.log(age)\n\n    &#x2F;&#x2F; 2. 解構數組對象\n    const pig &#x3D; [\n      &#123;\n        uname: &#39;佩奇&#39;,\n        age: 6\n      &#125;\n    ]\n    const [&#123; uname, age &#125;] &#x3D; pig\n    console.log(uname)\n    console.log(age)\n  &lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n\n注：支持多維解構賦值\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 這是後臺傳遞過來的資料\n    const msg &#x3D; &#123;\n      &quot;code&quot;: 200,\n      &quot;msg&quot;: &quot;獲取新聞列表成功&quot;,\n      &quot;data&quot;: [\n        &#123;\n          &quot;id&quot;: 1,\n          &quot;title&quot;: &quot;5G商用自己，三大運用商收入下降&quot;,\n          &quot;count&quot;: 58\n        &#125;,\n        &#123;\n          &quot;id&quot;: 2,\n          &quot;title&quot;: &quot;國際媒體頭條速覽&quot;,\n          &quot;count&quot;: 56\n        &#125;,\n        &#123;\n          &quot;id&quot;: 3,\n          &quot;title&quot;: &quot;烏克蘭和俄羅斯持續衝突&quot;,\n          &quot;count&quot;: 1669\n        &#125;,\n\n      ]\n    &#125;\n\n    &#x2F;&#x2F; 需求1： 請將以上msg物件  採用物件解構的方式 只選出  data 方面後面使用渲染頁面\n    &#x2F;&#x2F; const &#123; data &#125; &#x3D; msg\n    &#x2F;&#x2F; console.log(data)\n    &#x2F;&#x2F; 需求2： 上面msg是後臺傳遞過來的資料，我們需要把data選出當做參數傳遞給 函數\n    &#x2F;&#x2F; const &#123; data &#125; &#x3D; msg\n    &#x2F;&#x2F; msg 雖然很多屬性，但是我們利用解構只要 data值\n    function render(&#123; data &#125;) &#123;\n      &#x2F;&#x2F; const &#123; data &#125; &#x3D; arr\n      &#x2F;&#x2F; 我們只要 data 資料\n      &#x2F;&#x2F; 內部處理\n      console.log(data)\n    &#125;\n    render(msg)\n\n    &#x2F;&#x2F;給新的變量名賦值(冒號表示 “ 什麼值：賦值給誰 ”)\n    &#x2F;&#x2F; 需求3， 為了防止msg裡面的data名字混淆，要求渲染函數裡面的資料名改為 myData\n    function render(&#123; data: myData &#125;) &#123;\n      &#x2F;&#x2F; 要求將 獲取過來的 data資料 更名為 myData\n      &#x2F;&#x2F; 內部處理\n      console.log(myData)\n\n    &#125;\n    render(msg)\n\n  &lt;&#x2F;script&gt;\n\n綜合案例forEach遍歷陣列forEach() 方法用於調用陣列的每個元素，並將元素傳遞給回呼函數\n語法:\n被遍歷的數組.forEach(function (當前數組元素, 當前元素索引號) &#123;\n  &#x2F;&#x2F;函數體\n&#125;)\n\n\n\n\n\n\n\n\n\n\n注意：  \n1.forEach 主要是遍歷陣列\n2.參數當前陣列元素是必須要寫的， 索引號可選。\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; forEach 就是遍歷  加強版的for迴圈  適合於遍歷陣列物件\n    const arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;pink&#39;]\n    const result &#x3D; arr.forEach(function (item, index) &#123;\n      console.log(item)  &#x2F;&#x2F; 陣列元素 red  green pink\n      console.log(index) &#x2F;&#x2F; 索引號\n    &#125;)\n    &#x2F;&#x2F; console.log(result)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\nfilter篩選陣列filter() 方法創建一個新的陣列，新陣列中的元素是通過檢查指定陣列中符合條件的所有元素\n語法:\n被遍歷的數組.filter(function (参數, index) &#123;\n  return 篩選條件\n&#125;)\n\n主要使用場景： 篩選陣列符合條件的元素，並返回篩選之後元素的新陣列\n&lt;body&gt;\n  &lt;script&gt;\n    const arr &#x3D; [10, 20, 30]\n    &#x2F;&#x2F; const newArr &#x3D; arr.filter(function (item, index) &#123;\n    &#x2F;&#x2F;   &#x2F;&#x2F; console.log(item)\n    &#x2F;&#x2F;   &#x2F;&#x2F; console.log(index)\n    &#x2F;&#x2F;   return item &gt;&#x3D; 20\n    &#x2F;&#x2F; &#125;)\n    &#x2F;&#x2F; 返回的符合條件的新陣列\n\n    const newArr &#x3D; arr.filter(item &#x3D;&gt; item &gt;&#x3D; 20)\n    console.log(newArr)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\n\n","slug":"20230329JavaScript 進階 - 第1天","date":"2023-03-29T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"1359ad702c466c1bb96b6c62885f8401","title":"JavaScript Web APIs - 第6天","content":"\n\n\n\n\n\n\n\n\n目標：能夠利用規則運算式完成小兔鮮註冊頁面的表單驗證，具備常見的表單驗證能力\n\n規則運算式\n綜合案例\n階段案例\n\n規則運算式規則運算式（Regular Expression）是一種字串匹配的模式（規則）\n使用場景：\n\n例如驗證表單：手機號表單要求用戶只能輸入11位元的數字 (匹配)\n過濾掉頁面內容中的一些敏感詞(替換)，或從字串中獲取我們想要的特定部分(提取)等\n\n正則基本使用\n\n\n\n\n\n\n\n\n作用:表單驗證(匹配)、過濾敏感字(替換)、字符串提取想要的部分(提取)\n\n定義規則\nconst reg &#x3D;  &#x2F;運算式&#x2F;\n\n\n其中/   /是規則運算式字面量\n規則運算式也是物件 \n\n\n使用正則-判斷是否有符合規則的字符串\n\ntest()方法   用來查看規則運算式與指定的字串是否匹配\n如果規則運算式與指定的字串匹配 ，返回true，否則false\n\n\n\n\n\n\n\n\n\n\n\n\nreg.test(被檢測的字符串)\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 規則運算式的基本使用\n    const str &#x3D; &#39;web前端開發&#39;\n    &#x2F;&#x2F; 1. 定義規則\n    const reg &#x3D; &#x2F;web&#x2F;\n\n    &#x2F;&#x2F; 2. 使用正則  test()\n    console.log(reg.test(str))  &#x2F;&#x2F; true  如果符合規則匹配上則返回true\n    console.log(reg.test(&#39;java開發&#39;))  &#x2F;&#x2F; false  如果不符合規則匹配上則返回 false\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n使用正則-檢索（查找）符合規則的字符串\nexec() 方法 在一個指定字符串中執行一個搜索匹配\n如果匹配成功，exec() 方法返回一個數組，否則返回null\n\n\n\n\n\n\n\n\n\n\n\n\nreg.exec(被檢測的字符串)\n&lt;body&gt;\n  &lt;script&gt;\n    const str &#x3D; &#39;學習前端&#39;\n    &#x2F;&#x2F; 正則表達式使用：\n    &#x2F;&#x2F; 1. 定義規則\n    const reg &#x3D; &#x2F;前端&#x2F;\n    &#x2F;&#x2F; 2. exec()\n    console.log(reg.exec(str))  &#x2F;&#x2F; 返回數組\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n正則表達式檢測查找 test方法和exec方法有什麼區別？\ntest方法 用於判斷是否有符合規則的字符串，返回的是  布爾值 找到返回true，否則false\nexec方法 用於檢索（查找）符合規則的字符串，找到返回數組，否則為 null\n\n\n\n元字元\n普通字元:\n\n\n大多數的字元僅能夠描述它們本身，這些字元稱作普通字元，例如所有的字母和數位。\n普通字元只能夠匹配字串中與它們相同的字元。    \n比如，規定用戶只能輸入英文26個英文字母，普通字元的話  &#x2F;[abcdefghijklmnopqrstuvwxyz]&#x2F;\n\n\n元字元(特殊字元)\n\n\n是一些具有特殊含義的字元，可以極大提高了靈活性和強大的匹配功能。\n比如，規定用戶只能輸入英文26個英文字母，換成元字元寫法： &#x2F;[a-z]&#x2F;\n\n邊界符規則運算式中的邊界符（位置符）用來提示字元所處的位置，主要有兩個字元\n\n\n\n邊界符\n說明\n\n\n\n^\n表示匹配行首的文本(以誰開始)\n\n\n$\n表示匹配行尾的文本(以誰結束)\n\n\n\n\n\n\n\n\n\n\n\n如果 ^ 和 $ 在一起，表示必須是精確匹配\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 前面正則  test()\n    console.log(&#x2F;web&#x2F;.test(&#39;web&#39;))  &#x2F;&#x2F; true\n    console.log(&#x2F;web&#x2F;.test(&#39;前端web&#39;))  &#x2F;&#x2F; true\n    console.log(&#x2F;web&#x2F;.test(&#39;前端web學習&#39;))  &#x2F;&#x2F; true\n\n    &#x2F;&#x2F; 元字元之邊界符\n    &#x2F;&#x2F; 1. 匹配開頭的位置 ^\n    const reg &#x3D; &#x2F;^web&#x2F;\n    console.log(reg.test(&#39;web前端&#39;))  &#x2F;&#x2F; true\n    console.log(reg.test(&#39;前端web&#39;))  &#x2F;&#x2F; false\n    console.log(reg.test(&#39;前端web學習&#39;))  &#x2F;&#x2F; false\n    console.log(reg.test(&#39;we&#39;))  &#x2F;&#x2F; false\n\n    &#x2F;&#x2F; 2. 匹配結束的位置 $\n    const reg1 &#x3D; &#x2F;web$&#x2F;\n    console.log(reg1.test(&#39;web前端&#39;))  &#x2F;&#x2F;  false\n    console.log(reg1.test(&#39;前端web&#39;))  &#x2F;&#x2F; true\n    console.log(reg1.test(&#39;前端web學習&#39;))  &#x2F;&#x2F; false\n    console.log(reg1.test(&#39;we&#39;))  &#x2F;&#x2F; false  \n\n    &#x2F;&#x2F; 3. 精確匹配 ^ $\n    const reg2 &#x3D; &#x2F;^web$&#x2F;\n    console.log(reg2.test(&#39;web前端&#39;))  &#x2F;&#x2F;  false\n    console.log(reg2.test(&#39;前端web&#39;))  &#x2F;&#x2F; false\n    console.log(reg2.test(&#39;前端web學習&#39;))  &#x2F;&#x2F; false\n    console.log(reg2.test(&#39;we&#39;))  &#x2F;&#x2F; false \n    console.log(reg2.test(&#39;web&#39;))  &#x2F;&#x2F; true\n    console.log(reg2.test(&#39;webweb&#39;))  &#x2F;&#x2F; flase \n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n量詞量詞用來設定某個模式重複次數\n\n\n\n量詞\n說明\n\n\n\n*\n重複0次或更多次\n\n\n+\n重複1次或更多次\n\n\n?\n重複0次或1次\n\n\n&#123;n&#125;\n重複n次\n\n\n&#123;n,&#125;\n重複n次或更多次\n\n\n&#123;n,m&#125;\n重複n次到m次\n\n\n\n\n\n\n\n\n\n\n\n注意： 逗號左右兩側千萬不要出現空格\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 元字元之量詞\n    &#x2F;&#x2F; 1. * 重複次數 &gt;&#x3D; 0 次\n    const reg1 &#x3D; &#x2F;^w*$&#x2F;\n    console.log(reg1.test(&#39;&#39;))  &#x2F;&#x2F; true\n    console.log(reg1.test(&#39;w&#39;))  &#x2F;&#x2F; true\n    console.log(reg1.test(&#39;ww&#39;))  &#x2F;&#x2F; true\n    console.log(&#39;-----------------------&#39;)\n\n    &#x2F;&#x2F; 2. + 重複次數 &gt;&#x3D; 1 次\n    const reg2 &#x3D; &#x2F;^w+$&#x2F;\n    console.log(reg2.test(&#39;&#39;))  &#x2F;&#x2F; false\n    console.log(reg2.test(&#39;w&#39;))  &#x2F;&#x2F; true\n    console.log(reg2.test(&#39;ww&#39;))  &#x2F;&#x2F; true\n    console.log(&#39;-----------------------&#39;)\n\n    &#x2F;&#x2F; 3. ? 重複次數  0 || 1 \n    const reg3 &#x3D; &#x2F;^w?$&#x2F;\n    console.log(reg3.test(&#39;&#39;))  &#x2F;&#x2F; true\n    console.log(reg3.test(&#39;w&#39;))  &#x2F;&#x2F; true\n    console.log(reg3.test(&#39;ww&#39;))  &#x2F;&#x2F; false\n    console.log(&#39;-----------------------&#39;)\n\n    &#x2F;&#x2F; 4. &#123;n&#125; 重複 n 次\n    const reg4 &#x3D; &#x2F;^w&#123;3&#125;$&#x2F;\n    console.log(reg4.test(&#39;&#39;))  &#x2F;&#x2F; false\n    console.log(reg4.test(&#39;w&#39;))  &#x2F;&#x2F; flase\n    console.log(reg4.test(&#39;ww&#39;))  &#x2F;&#x2F; false\n    console.log(reg4.test(&#39;www&#39;))  &#x2F;&#x2F; true\n    console.log(reg4.test(&#39;wwww&#39;))  &#x2F;&#x2F; false\n    console.log(&#39;-----------------------&#39;)\n\n    &#x2F;&#x2F; 5. &#123;n,&#125; 重複次數 &gt;&#x3D; n \n    const reg5 &#x3D; &#x2F;^w&#123;2,&#125;$&#x2F;\n    console.log(reg5.test(&#39;&#39;))  &#x2F;&#x2F; false\n    console.log(reg5.test(&#39;w&#39;))  &#x2F;&#x2F; false\n    console.log(reg5.test(&#39;ww&#39;))  &#x2F;&#x2F; true\n    console.log(reg5.test(&#39;www&#39;))  &#x2F;&#x2F; true\n    console.log(&#39;-----------------------&#39;)\n\n    &#x2F;&#x2F; 6. &#123;n,m&#125;   n &#x3D;&lt; 重複次數 &lt;&#x3D; m\n    const reg6 &#x3D; &#x2F;^w&#123;2,4&#125;$&#x2F;\n    console.log(reg6.test(&#39;w&#39;))  &#x2F;&#x2F; false\n    console.log(reg6.test(&#39;ww&#39;))  &#x2F;&#x2F; true\n    console.log(reg6.test(&#39;www&#39;))  &#x2F;&#x2F; true\n    console.log(reg6.test(&#39;wwww&#39;))  &#x2F;&#x2F; true\n    console.log(reg6.test(&#39;wwwww&#39;))  &#x2F;&#x2F; false\n\n    &#x2F;&#x2F; 7. 注意事項： 逗號兩側千萬不要加空格否則會匹配失敗\n\n  &lt;&#x2F;script&gt;\n\n範圍表示字元的範圍，定義的規則限定在某個範圍，比如只能是英文字母，或者數位等等，用表示範圍\n\n\n\n範圍\n說明\n\n\n\n[abc]\n匹配方括號中的任意一個字符，也就是說可以匹配 a、b 或 c 這三個字母中的任意一個。 多選1\n\n\n[a-z]\n匹配所有小寫字母中的任意一個字符，從 a 到 z。單個\n\n\n[^a-z]\n取反符，匹配不在小寫字母 a 到 z 中的任何一個字符，換句話說，就是匹配除了小寫字母 a 到 z 以外的所有字符。\n\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 元字元之範圍  []  \n    &#x2F;&#x2F; 1. [abc] 匹配包含的單個字元， 多選1\n    const reg1 &#x3D; &#x2F;^[abc]$&#x2F;\n    console.log(reg1.test(&#39;a&#39;))  &#x2F;&#x2F; true\n    console.log(reg1.test(&#39;b&#39;))  &#x2F;&#x2F; true\n    console.log(reg1.test(&#39;c&#39;))  &#x2F;&#x2F; true\n    console.log(reg1.test(&#39;d&#39;))  &#x2F;&#x2F; false\n    console.log(reg1.test(&#39;ab&#39;))  &#x2F;&#x2F; false\n\n    &#x2F;&#x2F; 2. [a-z] 連字號 單個\n    const reg2 &#x3D; &#x2F;^[a-z]$&#x2F;\n    console.log(reg2.test(&#39;a&#39;))  &#x2F;&#x2F; true\n    console.log(reg2.test(&#39;p&#39;))  &#x2F;&#x2F; true\n    console.log(reg2.test(&#39;0&#39;))  &#x2F;&#x2F; false\n    console.log(reg2.test(&#39;A&#39;))  &#x2F;&#x2F; false\n    &#x2F;&#x2F; 想要包含小寫字母，大寫字母 ，數位\n    const reg3 &#x3D; &#x2F;^[a-zA-Z0-9]$&#x2F;\n    console.log(reg3.test(&#39;B&#39;))  &#x2F;&#x2F; true\n    console.log(reg3.test(&#39;b&#39;))  &#x2F;&#x2F; true\n    console.log(reg3.test(9))  &#x2F;&#x2F; true\n    console.log(reg3.test(&#39;,&#39;))  &#x2F;&#x2F; flase\n\n    &#x2F;&#x2F; 用戶名可以輸入英文字母，數位，可以加底線，要求 6~16位\n    const reg4 &#x3D; &#x2F;^[a-zA-Z0-9_]&#123;6,16&#125;$&#x2F;\n    console.log(reg4.test(&#39;abcd1&#39;))  &#x2F;&#x2F; false \n    console.log(reg4.test(&#39;abcd12&#39;))  &#x2F;&#x2F; true\n    console.log(reg4.test(&#39;ABcd12&#39;))  &#x2F;&#x2F; true\n    console.log(reg4.test(&#39;ABcd12_&#39;))  &#x2F;&#x2F; true\n\n    &#x2F;&#x2F; 3. [^a-z] 取反符\n    const reg5 &#x3D; &#x2F;^[^a-z]$&#x2F;\n    console.log(reg5.test(&#39;a&#39;))  &#x2F;&#x2F; false \n    console.log(reg5.test(&#39;A&#39;))  &#x2F;&#x2F; true\n    console.log(reg5.test(8))  &#x2F;&#x2F; true\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\n\n\n\n\n\n\n\n身分證字號：^[A-Z][1-2][0-9]&#123;8&#125;$\n字元類字符類 . (點)代表什麼意思？\n\n\n\n\n\n\n\n\n\nA.匹配除換行符之外的任何單個字符\n某些常見模式的簡寫方式，區分字母和數位\n\n\n\n字符類\n說明\n\n\n\n\\d\n代表一個數字字符，等價於 [0-9]。\n\n\n\\D\n代表一個非數字字符，等價於 [^0-9]。\n\n\n\\w\n代表一個單字字符（即字母、數字或底線），等價於 [a-zA-Z0-9_]。\n\n\n\\W\n代表一個非單字字符，等價於 [^a-zA-Z0-9_]。\n\n\n\\s\n代表一個空白字符（包括空格、製表符、換行符等），等價於 [\\t\\n\\f\\r\\p{Z}]。\n\n\n\\S\n代表一個非空白字符，等價於 [^\\t\\n\\f\\r\\p{Z}]。\n\n\n日期格式：&#x2F;^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$&#x2F;\n替換和修飾符replace 替換方法，可以完成字元的替換\n字符串.replace(&#x2F;正則表達式&#x2F;, &#39;替換的文本&#39;)\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 替換和修飾符\n    const str &#x3D; &#39;學習前端，成為前端大神&#39;\n    &#x2F;&#x2F; 1. 替換  replace  需求：把前端替換為 web\n    &#x2F;&#x2F; 1.1 replace 返回值是替換完畢的字串\n    &#x2F;&#x2F; const strEnd &#x3D; str.replace(&#x2F;前端&#x2F;, &#39;web&#39;) 只能替換一個\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n修飾符約束正則執行的某些細節行為，如是否區分大小寫、是否支持多行匹配等\n\ni 是單詞 ignore 的縮寫，正則匹配時字母不區分大小寫\ng 是單詞 global 的縮寫，匹配所有滿足規則運算式的結果\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 替換和修飾符\n    const str &#x3D; &#39;歡迎大家學習前端，相信大家一定能學好前端，都成為前端大神&#39;\n    &#x2F;&#x2F; 1. 替換  replace  需求：把前端替換為 web\n    &#x2F;&#x2F; 1.1 replace 返回值是替換完畢的字串\n    &#x2F;&#x2F; const strEnd &#x3D; str.replace(&#x2F;前端&#x2F;, &#39;web&#39;) 只能替換一個\n\n    &#x2F;&#x2F; 2. 修飾符 g 全部替換\n    const strEnd &#x3D; str.replace(&#x2F;前端&#x2F;g, &#39;web&#39;)\n    console.log(strEnd) \n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n正則外掛程式 \nchange 事件給input註冊 change 事件，值被修改並且失去焦點後觸發\n判斷是否有類&#x2F;&#x2F;添加類名\n元素.classList.contains()\n&#x2F;&#x2F;刪除類名\n元素.classList.contains()\n&#x2F;&#x2F;切換類名\n元素.classList.contains()\n&#x2F;&#x2F;判斷是否包含某個類名，如果有則返回true，沒有則返回false\n元素.classList.contains() \n\n\n\n","slug":"20230328JavaScript Web APIs - 第6天","date":"2023-03-28T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"ba21313bf340a72e13573e85234fd6fe","title":"JavaScript Web APIs - 第5天","content":"\n\n\n\n\n\n\n\n\n目標： 能夠利用JS操作流覽器,具備利用本機存放區實現學生就業表的能力\n\nBOM操作\n綜合案例\n\njs組成JavaScript的組成\n\nECMAScript:\n\n規定了js基礎語法核心知識。\n比如：變數、分支語句、迴圈語句、物件等等\n\n\nWeb APIs :\n\nDOM   文檔物件模型， 定義了一套操作HTML文檔的API\nBOM   流覽器物件模型，定義了一套操作流覽器視窗的API\n\n\n\n \nwindow對象BOM (Browser Object Model ) 是流覽器物件模型\n\nwindow物件是一個全域物件，也可以說是JavaScript中的頂級物件\n像document、alert()、console.log()這些都是window的屬性，基本BOM的屬性和方法都是window的\n所有通過var定義在全域作用域中的變數、函數都會變成window物件的屬性和方法\nwindow物件下的屬性和方法調用的時候可以省略window\n\n \n計時器-延遲函數JavaScript 內置的一個用來讓代碼延遲執行的函數，叫 setTimeout\n語法：\nsetTimeout(回呼函數, 延遲時間)\n\nsetTimeout 僅僅只執行一次，所以可以理解為就是把一段代碼延遲執行, 平時省略window\n間歇函數 setInterval : 每隔一段時間就執行一次， , 平時省略window\n清除延時函數：\nclearTimeout(timerId)\n\n\n\n\n\n\n\n\n\n\n注意點\n\n延時函數需要等待,所以後面的代碼先執行\n返回值是一個正整數，表示計時器的編號\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 計時器之延遲函數\n\n    &#x2F;&#x2F; 1. 開啟延遲函數\n    let timerId &#x3D; setTimeout(function () &#123;\n      console.log(&#39;我只執行一次&#39;)\n    &#125;, 3000)\n\n    &#x2F;&#x2F; 1.1 延遲函數返回的還是一個正整數數位，表示延遲函數的編號\n    console.log(timerId)\n\n    &#x2F;&#x2F; 1.2 延遲函數需要等待時間，所以下面的代碼優先執行\n\n    &#x2F;&#x2F; 2. 關閉延遲函數\n    clearTimeout(timerId)\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\nlocation對象location (位址) 它拆分並保存了 URL 位址的各個組成部分， 它是一個物件\n\n\n\n屬性&#x2F;方法\n說明\n\n\n\nhref\n屬性，獲取完整的 URL 位址，賦值時用於地址的跳轉\n\n\nsearch\n屬性，獲取位址中攜帶的參數，符號 ？後面部分\n\n\nhash\n屬性，獲取位址中的啥希值，符號 # 後面部分\n\n\nreload()\n方法，用來刷新當前頁面，傳入參數 true 時表示強制刷新\n\n\n&lt;body&gt;\n  &lt;form&gt;\n    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;search&quot;&gt; &lt;button&gt;搜索&lt;&#x2F;button&gt;\n  &lt;&#x2F;form&gt;\n  &lt;a href&#x3D;&quot;#&#x2F;music&quot;&gt;音樂&lt;&#x2F;a&gt;\n  &lt;a href&#x3D;&quot;#&#x2F;download&quot;&gt;下載&lt;&#x2F;a&gt;\n\n  &lt;button class&#x3D;&quot;reload&quot;&gt;刷新頁面&lt;&#x2F;button&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; location 對象  \n    &#x2F;&#x2F; 1. href屬性 （重點） 得到完整地址，賦值則是跳轉到新地址\n    console.log(location.href)\n    &#x2F;&#x2F; location.href &#x3D; &#39;http:&#x2F;&#x2F;www.itcast.cn&#39;\n\n    &#x2F;&#x2F; 2. search屬性  得到 ? 後面的地址 \n    console.log(location.search)  &#x2F;&#x2F; ?search&#x3D;筆記本\n\n    &#x2F;&#x2F; 3. hash屬性  得到 # 後面的地址\n    console.log(location.hash)\n\n    &#x2F;&#x2F; 4. reload 方法  刷新頁面\n    const btn &#x3D; document.querySelector(&#39;.reload&#39;)\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; location.reload() &#x2F;&#x2F; 頁面刷新\n      location.reload(true) &#x2F;&#x2F; 強制頁面刷新 ctrl+f5\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\nnavigator對象navigator是物件，該物件下記錄了流覽器自身的相關資訊\n常用屬性和方法：\n\n通過 userAgent 檢測流覽器的版本及平臺\n\n&#x2F;&#x2F; 檢測 userAgent（流覽器資訊）\n(function () &#123;\n  const userAgent &#x3D; navigator.userAgent\n  &#x2F;&#x2F; 驗證是否為Android或iPhone\n  const android &#x3D; userAgent.match(&#x2F;(Android);?[\\s\\&#x2F;]+([\\d.]+)?&#x2F;)\n  const iphone &#x3D; userAgent.match(&#x2F;(iPhone\\sOS)\\s([\\d_]+)&#x2F;)\n  &#x2F;&#x2F; 如果是Android或iPhone，則跳轉至移動網站\n  if (android || iphone) &#123;\n    location.href &#x3D; &#39;http:&#x2F;&#x2F;google.com&#39;\n  &#125;&#125;)();\n\nhistroy對象history (歷史)是物件，主要管理歷史記錄， 該物件與流覽器位址欄的操作相對應，如前進、後退等\n使用場景\nhistory物件一般在實際開發中比較少用\n常見方法：\n\n\n\nhistory對象方法\n作用\n\n\n\nback()\n後退功能\n\n\nforward()\n前進功能\n\n\ngo(參數)\n前進後退功能，如果參數是1前進1個頁面，-1則後退1個頁面\n\n\n&lt;body&gt;\n  &lt;button class&#x3D;&quot;back&quot;&gt;←後退&lt;&#x2F;button&gt;\n  &lt;button class&#x3D;&quot;forward&quot;&gt;前進→&lt;&#x2F;button&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; histroy對象\n\n    &#x2F;&#x2F; 1.前進\n    const forward &#x3D; document.querySelector(&#39;.forward&#39;)\n    forward.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; history.forward() \n      history.go(1)\n    &#125;)\n    &#x2F;&#x2F; 2.後退\n    const back &#x3D; document.querySelector(&#39;.back&#39;)\n    back.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; history.back()\n      history.go(-1)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n本機存放區（今日重點）本機存放區：將資料存儲在本地流覽器中\n常見的使用場景：\nhttps://todomvc.com/examples/vanilla-es6/    頁面刷新資料不丟失\n好處：\n1、頁面刷新或者關閉不丟失資料，實現資料持久化\n2、容量較大，sessionStorage和 localStorage 約 5M 左右\nlocalStorage（重點）作用: 資料可以長期保留在本地流覽器中，刷新頁面和關閉頁面，資料也不會丟失，除非手動刪除。\n特性：以鍵值對的形式存儲，並且存儲的是字串， 省略了window\n\n\n\n\n\n\n\n\n\n語法:儲存數據 localStorage.setItem(&#39;key&#39;, value)讀取數據 localStorage.getItem(&#39;key&#39;)刪除數據 localStorage.removeItem(&#39;key&#39;)\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;本機存放區-localstorage&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 本機存放區 - localstorage 存儲的是字串 \n    &#x2F;&#x2F; 1. 存儲\n    localStorage.setItem(&#39;age&#39;, 18)\n\n    &#x2F;&#x2F; 2. 獲取\n    console.log(typeof localStorage.getItem(&#39;age&#39;))\n\n    &#x2F;&#x2F; 3. 刪除\n    localStorage.removeItem(&#39;age&#39;)\n\n    &#x2F;&#x2F; 4. 改(重新存)\n    localStorage.setItem(&#39;age&#39;, 19999)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\nsessionStorage（瞭解）特性：\n\n用法跟localStorage基本相同\n區別是：當頁面流覽器被關閉時，存儲在 sessionStorage 的資料會被清除\n\n存儲：sessionStorage.setItem(key,value)\n獲取：sessionStorage.getItem(key)\n刪除：sessionStorage.removeItem(key)\nlocalStorage 存儲複雜資料類型問題：本地只能存儲字串,無法存儲複雜資料類型.\n解決：需要將複雜資料類型轉換成 JSON字串,在存儲到本地\n語法：JSON.stringify(複雜資料類型)\nJSON字串：\n\n首先是1個字串\n屬性名使用雙引號引起來，不能單引號\n屬性值如果是字串型也必須雙引號\n\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 本機存放區複雜資料類型\n    const goods &#x3D; &#123;\n      name: &#39;小米&#39;,\n      price: 1999\n    &#125;\n    &#x2F;&#x2F; 存储 複雜數據類型  -無法直接使用，不能直接使用對象\n    &#x2F;&#x2F; localStorage.setItem(&#39;goods&#39;, goods)\n    &#x2F;&#x2F; 取\n    &#x2F;&#x2F; console.log(localStorage.getItem(&#39;goods&#39;))\n\n    &#x2F;&#x2F; 1. 把物件轉換為JSON字串  JSON.stringify\n    localStorage.setItem(&#39;goods&#39;, JSON.stringify(goods))\n    &#x2F;&#x2F; console.log(typeof localStorage.getItem(&#39;goods&#39;))\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n問題：因為本機存放區裡面取出來的是字串，不是物件，無法直接使用\n**解決： **把取出來的字串轉換為物件\n語法：JSON.parse(JSON字串)\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 本機存放區複雜資料類型\n    const goods &#x3D; &#123;\n      name: &#39;小米&#39;,\n      price: 1999\n    &#125;\n    &#x2F;&#x2F; 存储 複雜數據類型    -無法直接使用，不能直接使用對象\n    &#x2F;&#x2F; localStorage.setItem(&#39;goods&#39;, goods)\n    &#x2F;&#x2F; 取\n    &#x2F;&#x2F; console.log(localStorage.getItem(&#39;goods&#39;))\n\n    &#x2F;&#x2F; 1. 把物件轉換為JSON字串  JSON.stringify\n    localStorage.setItem(&#39;goods&#39;, JSON.stringify(goods))\n    &#x2F;&#x2F; console.log(typeof localStorage.getItem(&#39;goods&#39;))\n\n    &#x2F;&#x2F; 2. 把JSON字串轉換為物件  JSON.parse\n    console.log(JSON.parse(localStorage.getItem(&#39;goods&#39;)))\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n綜合案例陣列map 方法使用場景：\nmap 可以遍歷陣列處理資料，並且返回新的陣列\n語法：\n&lt;body&gt;\n  &lt;script&gt;\n  const arr &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;pink&#39;]\n  &#x2F;&#x2F; 1. 陣列 map方法 處理資料並且 返回一個陣列\n   const newArr &#x3D; arr.map(function (ele, index) &#123;\n    &#x2F;&#x2F; console.log(ele)  &#x2F;&#x2F; 陣列元素\n    &#x2F;&#x2F; console.log(index) &#x2F;&#x2F; 索引號\n    return ele + &#39;顏色&#39;  &#x2F;&#x2F;讓數組中每個元素添加&#39;顏色&#39;\n  &#125;)\n  console.log(newArr)  &#x2F;&#x2F;[&#39;red顏色&#39;, &#39;blue顏色&#39;, &#39;pink顏色&#39;] \n&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\n\n\n\n\n\n\n\nmap 也稱為映射。映射是個術語，指兩個元素的集之間元素相互“對應”的關係。\nmap重點在於有返回值，forEach沒有返回值（undefined）\n陣列join方法作用：join() 方法用於把陣列中的所有元素轉換一個字串\n語法：\n&lt;body&gt;\n  &lt;script&gt;\n    const arr &#x3D; [&#39;red&#39;, &#39;blue&#39;, &#39;pink&#39;]\n\n    &#x2F;&#x2F; 1. 陣列 map方法 處理資料並且 返回一個陣列\n    const newArr &#x3D; arr.map(function (ele, index) &#123;\n      &#x2F;&#x2F; console.log(ele)  &#x2F;&#x2F; 陣列元素\n      &#x2F;&#x2F; console.log(index) &#x2F;&#x2F; 索引號\n      return ele + &#39;顏色&#39;\n    &#125;)\n    console.log(newArr)\n\n    &#x2F;&#x2F; 2. 陣列join方法  把陣列轉換為字串\n    &#x2F;&#x2F; 小括弧為空則逗號分割\n    console.log(newArr.join())  &#x2F;&#x2F; red顏色,blue顏色,pink顏色\n    &#x2F;&#x2F; 小括弧是空字串，則元素之間沒有分隔符號\n    console.log(newArr.join(&#39;&#39;))  &#x2F;&#x2F;red顏色blue顏色pink顏色\n    console.log(newArr.join(&#39;|&#39;))  &#x2F;&#x2F;red顏色|blue顏色|pink顏色\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\n\n\n\n\n\n\n\n","slug":"20230327JavaScript Web APIs - 第5天","date":"2023-03-27T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"00643405d99d1bca34738d1b7609799a","title":"JavaScript Web APIs - 第4天","content":"\n\n\n\n\n\n\n\n\n進一步學習 DOM 相關知識，實現可交互的網頁特效\n\n能夠插入、刪除和替換元素節點\n能夠依據元素節點關係查找節點\n\n日期對象掌握 Date 日期物件的使用，動態獲取當前電腦的時間。\nECMAScript 中內置了獲取系統時間的物件 Date，使用 Date 時與之前學習的內置物件 console 和 Math 不同，它需要借助 new 關鍵字才能使用。\n產生實體&#x2F;&#x2F; 1. 產生實體\n&#x2F;&#x2F; const date &#x3D; new Date(); &#x2F;&#x2F; 系統預設時間\nconst date &#x3D; new Date(&#39;2020-05-01&#39;) &#x2F;&#x2F; 指定時間\n&#x2F;&#x2F; date 變數即所謂的時間物件\n\nconsole.log(typeof date)\n\n\n\n方法  &#x2F;&#x2F; 1. 產生實體\nconst date &#x3D; new Date();\n&#x2F;&#x2F; 2. 調用時間物件方法\n&#x2F;&#x2F; 通過方法分別獲取年、月、日，時、分、秒\nconst year &#x3D; date.getFullYear(); &#x2F;&#x2F; 四位年份\nconst month &#x3D; date.getMonth(); &#x2F;&#x2F; 0 ~ 11\n\n\n\n方法\n作用\n說明\n\n\n\ngetFullYear()\n獲取年份\n獲取四位年份\n\n\ngetMonth()\n獲取月份\n取值為 0 ~ 11\n\n\ngetDate()\n獲取月份中的每一天\n不同月份取值也不相同\n\n\ngetDay()\n獲取星期\n取值為 0 ~ 6\n\n\ngetHours()\n獲取小時\n取值為 0 ~ 23\n\n\ngetMinutes()\n獲取分鐘\n取值為 0 ~ 59\n\n\ngetSeconds()\n獲取秒\n取值為 0 ~ 59\n\n\n時間戳記時間戳記是指1970年01月01日00時00分00秒起至現在的總秒數或毫秒數，它是一種特殊的計量時間的方式。\n注：ECMAScript 中時間戳記是以毫秒計的。\n&#x2F;&#x2F; - 產生實體\nconst date &#x3D; new Date()\n&#x2F;&#x2F; 法1. getTime()法，獲取時間戳記\n  console.log(date.getTime())\n&#x2F;&#x2F; 法2. 簡寫 +new Date()，獲取時間戳記\n&#x2F;&#x2F; 可以返回當前時間戳或者指定的時間戳\n  console.log(+new Date())\n&#x2F;&#x2F; 法3. Date.now()，獲取時間戳記的方法\n&#x2F;&#x2F;但是只能得到當前的時間戳， 而前面兩種可以返回指定時間的時間戳\n  console.log(Date.now())\n\n獲取時間戳記的方法，分別為 getTime 和  +new Date()和 Date.now\n\n通過時間戳得到是毫秒，需要轉換為秒在計算\n轉換公式：\nd &#x3D; parseInt(總秒數&#x2F; 60&#x2F;60 &#x2F;24); &#x2F;&#x2F; 計算天數\nh &#x3D; parseInt(總秒數&#x2F; 60&#x2F;60 %24) &#x2F;&#x2F; 計算小時\nm &#x3D; parseInt(總秒數 &#x2F;60 %60 ); &#x2F;&#x2F; 計算分數\ns &#x3D; parseInt(總秒數%60); &#x2F;&#x2F; 計算當前秒數\n\n\n\nDOM 節點操作\n\n\n\n\n\n\n\n\n掌握元素節點創建、複製、插入、刪除等操作的方法，能夠依據元素節點的結構關係查找節點\n\n節點類型\n元素節點\n所有的標籤 比如 body、 div\nhtml 是根節點\n\n\n屬性節點\n所有的屬性 比如 href\n\n\n文本節點\n所有的文本\n\n\n其他\n\n\n\n回顧之前 DOM 的操作都是針對元素節點的屬性或文本的，除此之外也有專門針對元素節點本身的操作，如插入、複製、刪除、替換等。\n查找節點DOM 樹中的任意節點都不是孤立存在的，它們要麼是父子關係，要麼是兄弟關係，不僅如此，我們可以依據節點之間的關係查找節點。\n父子關係&lt;body&gt;\n  &lt;button class&#x3D;&quot;btn1&quot;&gt;所有的子節點&lt;&#x2F;button&gt;\n  &lt;!-- 獲取 ul 的子節點 --&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;&#x2F;li&gt;\n    &lt;li&gt;CSS&lt;&#x2F;li&gt;\n    &lt;li&gt;JavaScript 基礎&lt;&#x2F;li&gt;\n    &lt;li&gt;Web APIs&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n  &lt;script&gt;\n    const btn1 &#x3D; document.querySelector(&#39;.btn1&#39;)\n    btn1.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; 父節點\n      const ul &#x3D; document.querySelector(&#39;ul&#39;)\n\n      &#x2F;&#x2F; 所有的子節點\n      console.log(ul.childNodes)\n      &#x2F;&#x2F; 只包含元素子節點\n      console.log(ul.children)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：\n\nchildNodes 獲取全部的子節點，回車換行會被認為是空白文本節點\nchildren 只獲取元素類型節點\n\n&lt;body&gt;\n  &lt;table&gt;\n    &lt;tr&gt;\n      &lt;td width&#x3D;&quot;60&quot;&gt;序號&lt;&#x2F;td&gt;\n      &lt;td&gt;課程名&lt;&#x2F;td&gt;\n      &lt;td&gt;難度&lt;&#x2F;td&gt;\n      &lt;td width&#x3D;&quot;80&quot;&gt;操作&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;1&lt;&#x2F;td&gt;\n      &lt;td&gt;&lt;span&gt;HTML&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;\n      &lt;td&gt;初級&lt;&#x2F;td&gt;\n      &lt;td&gt;&lt;button&gt;變色&lt;&#x2F;button&gt;&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;2&lt;&#x2F;td&gt;\n      &lt;td&gt;&lt;span&gt;CSS&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;\n      &lt;td&gt;初級&lt;&#x2F;td&gt;\n      &lt;td&gt;&lt;button&gt;變色&lt;&#x2F;button&gt;&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;3&lt;&#x2F;td&gt;\n      &lt;td&gt;&lt;span&gt;Web APIs&lt;&#x2F;span&gt;&lt;&#x2F;td&gt;\n      &lt;td&gt;中級&lt;&#x2F;td&gt;\n      &lt;td&gt;&lt;button&gt;變色&lt;&#x2F;button&gt;&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n  &lt;&#x2F;table&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取所有 button 節點，並添加事件監聽\n    const buttons &#x3D; document.querySelectorAll(&#39;table button&#39;)\n    for(let i &#x3D; 0; i &lt; buttons.length; i++) &#123;\n      buttons[i].addEventListener(&#39;click&#39;, function () &#123;\n        &#x2F;&#x2F; console.log(this.parentNode); &#x2F;&#x2F; 父節點 td\n        &#x2F;&#x2F; this.parentNode.style.color &#x3D; &#39;red&#39;\n        &#x2F;&#x2F; console.log(this.parentNode.parentNode); &#x2F;&#x2F; 爺爺節點 tr\n        this.parentNode.parentNode.style.color &#x3D; &#39;red&#39;\n      &#125;)\n    &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：parentNode 獲取父節點，以相對位置查找節點，實際應用中非常靈活。\n兄弟關係&lt;body&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;&#x2F;li&gt;\n    &lt;li&gt;CSS&lt;&#x2F;li&gt;\n    &lt;li&gt;JavaScript 基礎&lt;&#x2F;li&gt;\n    &lt;li&gt;Web APIs&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取所有 li 節點\n    const lis &#x3D; document.querySelectorAll(&#39;ul li&#39;)\n\n    &#x2F;&#x2F; 對所有的 li 節點添加事件監聽\n    for(let i &#x3D; 0; i &lt; lis.length; i++) &#123;\n      lis[i].addEventListener(&#39;click&#39;, function () &#123;\n        &#x2F;&#x2F; 前一個節點\n        console.log(this.previousSibling)\n        &#x2F;&#x2F; 下一下節點\n        console.log(this.nextSibling)\n      &#125;)\n    &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：\n\npreviousSibling 獲取前一個節點，以相對位置查找節點，實際應用中非常靈活。\nnextSibling 獲取後一個節點，以相對位置查找節點，實際應用中非常靈活。\n\n增加節點在已有的 DOM 節點中插入新的 DOM 節點時，需要關注兩個關鍵因素：首先要得到新的 DOM 節點，其次在哪個位置插入這個節點。\n\n創建節點 document.createElement(&#39;標籤名&#39;)\n追加節點\n父元素.appendChild(要插入的元素)    &#x2F;&#x2F;插入到父元素的最後一個子元素\n父元素.insertBefore(要插入的元素,在哪個元素之前)  &#x2F;&#x2F;插入到父元素中某個子元素的前面\n\n\n\n如下代碼演示：\n&lt;body&gt;\n  &lt;h3&gt;插入節點&lt;&#x2F;h3&gt;\n  &lt;p&gt;在現有 dom 結構基礎上插入新的元素節點&lt;&#x2F;p&gt;\n  &lt;hr&gt;\n  &lt;!-- 普通盒子 --&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;!-- 點擊按鈕向 box 盒子插入節點 --&gt;\n  &lt;button class&#x3D;&quot;btn&quot;&gt;插入節點&lt;&#x2F;button&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 點擊按鈕，在網頁中插入節點\n    const btn &#x3D; document.querySelector(&#39;.btn&#39;)\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; 1. 獲得一個 DOM 元素節點\n      const p &#x3D; document.createElement(&#39;p&#39;)\n      p.innerText &#x3D; &#39;創建的新的p標籤&#39;\n      p.className &#x3D; &#39;info&#39;\n      \n      &#x2F;&#x2F; 複製原有的 DOM 節點\n      const p2 &#x3D; document.querySelector(&#39;p&#39;).cloneNode(true)\n      p2.style.color &#x3D; &#39;red&#39;\n\n      &#x2F;&#x2F; 2. 插入盒子 box 盒子\n      document.querySelector(&#39;.box&#39;).appendChild(p)\n      document.querySelector(&#39;.box&#39;).appendChild(p2)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：\n\ncreateElement 動態創建任意 DOM 節點\n\ncloneNode 複製現有的 DOM 節點，傳入參數 true 會複製所有子節點\n\nappendChild 在末尾（結束標籤前）插入節點\n\n\n再來看另一種情形的代碼演示：\n&lt;body&gt;\n  &lt;h3&gt;插入節點&lt;&#x2F;h3&gt;\n  &lt;p&gt;在現有 dom 結構基礎上插入新的元素節點&lt;&#x2F;p&gt;\n  &lt;hr&gt;\n  &lt;button class&#x3D;&quot;btn1&quot;&gt;在任意節點前插入&lt;&#x2F;button&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;&#x2F;li&gt;\n    &lt;li&gt;CSS&lt;&#x2F;li&gt;\n    &lt;li&gt;JavaScript&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 點擊按鈕，在已有 DOM 中插入新節點\n    const btn1 &#x3D; document.querySelector(&#39;.btn1&#39;)\n    btn1.addEventListener(&#39;click&#39;, function () &#123;\n\n      &#x2F;&#x2F; 第 2 個 li 元素\n      const relative &#x3D; document.querySelector(&#39;li:nth-child(2)&#39;)\n\n      &#x2F;&#x2F; 1. 動態創建新的節點\n      const li1 &#x3D; document.createElement(&#39;li&#39;)\n      li1.style.color &#x3D; &#39;red&#39;\n      li1.innerText &#x3D; &#39;Web APIs&#39;\n\n      &#x2F;&#x2F; 複製現有的節點\n      const li2 &#x3D; document.querySelector(&#39;li:first-child&#39;).cloneNode(true)\n      li2.style.color &#x3D; &#39;blue&#39;\n\n      &#x2F;&#x2F; 2. 在 relative 節點前插入\n      document.querySelector(&#39;ul&#39;).insertBefore(li1, relative)\n      document.querySelector(&#39;ul&#39;).insertBefore(li2, relative)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：\n\ncreateElement 動態創建任意 DOM 節點\n\ncloneNode 複製現有的 DOM 節點，傳入參數 true 會複製所有子節點\n\ninsertBefore 在父節點中任意子節點之前插入新節點\n\n\n\n\n\n\n\n\n\n\n\n\ncloneNode會克隆出一個跟原標籤一樣的元素，括號內傳入布爾值\n若為true，則代表克隆時會包含後代節點一起克隆\n若為false，則代表克隆時不包含後代節點\n默認為false\n\n\n\n刪除節點刪除現有的 DOM 節點，也需要關注兩個因素：首先由父節點刪除子節點，其次是要刪除哪個子節點。\n&lt;body&gt;\n  &lt;!-- 點擊按鈕刪除節點 --&gt;\n  &lt;button&gt;刪除節點&lt;&#x2F;button&gt;\n  &lt;ul&gt;\n    &lt;li&gt;HTML&lt;&#x2F;li&gt;\n    &lt;li&gt;CSS&lt;&#x2F;li&gt;\n    &lt;li&gt;Web APIs&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n\n  &lt;script&gt;\n    const btn &#x3D; document.querySelector(&#39;button&#39;)\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; 獲取 ul 父節點\n      let ul &#x3D; document.querySelector(&#39;ul&#39;)\n      &#x2F;&#x2F; 待刪除的子節點\n      let lis &#x3D; document.querySelectorAll(&#39;li&#39;)\n\n      &#x2F;&#x2F; 刪除節點\n      ul.removeChild(lis[0])\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：removeChild 刪除節點時一定是由父子關係。\n\n\n\n\n\n\n\n\n\n\n注：\n如不存在父子關係則刪除不成功\n刪除節點和隱藏節點（display:none） 有區別的： 隱藏節點還是存在的，但是刪除，則從html中刪除節點\n\n\n\nM端事件目標：了解M端常見的事件\n\n\n\n\n\n\n\n\n\n移動端也有自己獨特的地方。比如觸屏事件 touch（也稱觸摸事件），Android 和 IOS 都有。\n\n觸屏事件 touch（也稱觸摸事件），Android 和 IOS 都有。\ntouch 對象代表一個觸摸點。觸摸點可能是一根手指，也可能是一根觸摸筆。觸屏事件可響應用戶手指（或觸控筆）對屏幕或者觸控板操作。常見的觸屏事件如下：\n\n\n觸屏touch事件\n說明\n\n\n\ntouchstart\n手指觸碰到一個DOM元素時觸發\n\n\ntouchmove\n手指在一個DOM元素上滑動時觸發\n\n\ntouchend\n手指在一個DOM元素上移開時觸發\n\n\n\n\nJS插件就是別人寫好的一些代碼,我們只需要復制對應的代碼,就可以直接實現對應的效果\n","slug":"20230326JavaScript Web APIs - 第4天","date":"2023-03-26T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"4c656a1bef12133b7e372d516df2e64e","title":"JavaScript Web APIs - 第3天","content":"\n\n\n\n\n\n\n\n\n進一步學習 事件進階，實現更多交互的網頁特效，結合事件流的特徵優化事件執行的效率\n\n掌握阻止事件冒泡的方法\n理解事件委託的實現原理\n\n事件流事件流是對事件執行過程的描述，瞭解事件的執行過程有助於加深對事件的理解，提升開發實踐中對事件運用的靈活度。\n\n如上圖所示，任意事件被觸發時總會經歷兩個階段：【捕獲階段】和【冒泡階段】。\n簡言之，捕獲階段是【從父到子】的傳導過程，冒泡階段是【從子向父】的傳導過程。\n捕獲和冒泡\n\n\n\n\n\n\n\n\n事件捕獲語法DOM.addEventListener(&#39;事件類型&#39;, 事件處理函數, 是否使用捕獲機制)\n\n事件捕獲概念：\n\n從DOM的根項目開始去執行對應的事件 (從外到裡)\n\n\n說明：\n\naddEventListener第三個參數傳入 true 代表是捕獲階段觸發（很少使用）\n若傳入false代表冒泡階段觸發，默認就是false\n若是用 L0 事件監聽，則只有冒泡階段，沒有捕獲\n\n\n事件冒泡概念:\n\n當一個元素的事件被觸發時，同樣的事件將會在該元素的所有父項目中依次被觸發。這一過程被稱為事件冒泡\n\n\n簡單理解：當一個元素觸發事件後，會依次向上調用所有父級元素的 同名事件\n\n事件冒泡是默認存在的\n\nL2事件監聽第三個參數是 false，或者默認都是冒泡\n\n\n事件流是如何影響事件執行的：\n&lt;body&gt;\n  &lt;h3&gt;事件流&lt;&#x2F;h3&gt;\n  &lt;p&gt;事件流是事件在執行時的底層機制，主要體現在父子盒子之間事件的執行上。&lt;&#x2F;p&gt;\n  &lt;div class&#x3D;&quot;outer&quot;&gt;\n    &lt;div class&#x3D;&quot;inner&quot;&gt;\n      &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取嵌套的3個節點\n    const outer &#x3D; document.querySelector(&#39;.outer&#39;);\n    const inner &#x3D; document.querySelector(&#39;.inner&#39;);\n    const child &#x3D; document.querySelector(&#39;.child&#39;);\n    \n    &#x2F;&#x2F; html 元素添加事件\n    document.documentElement.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;html...&#39;)\n    &#125;)\n    \n    &#x2F;&#x2F; body 元素添加事件\n    document.body.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;body...&#39;)\n    &#125;)\n\n    &#x2F;&#x2F; 外層的盒子添加事件\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;outer...&#39;)\n    &#125;)\n    \n    &#x2F;&#x2F; 中間的盒子添加事件\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;inner...&#39;)\n    &#125;)\n    \n    &#x2F;&#x2F; 內層的盒子添加事件\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;child...&#39;)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n執行上述代碼後發現，當按一下事件觸發時，其父項目的按一下事件也【相繼觸發】，這是為什麼呢？\n結合事件流的特徵，我們知道當某個元素的事件被觸發時，事件總是會先經過其祖先才能到達當前元素，然後再由當前元素向祖先傳遞，事件在流動的過程中遇到相同的事件便會被觸發。\n再來關注一個細節就是事件相繼觸發的【執行順序】，事件的執行順序是可控制的，即可以在捕獲階段被執行，也可以在冒泡階段被執行。\n如果事件是在冒泡階段執行的，我們稱為冒泡模式，它會先執行子盒子事件再去執行父盒子事件，預設是冒泡模式。\n如果事件是在捕獲階段執行的，我們稱為捕獲模式，它會先執行父盒子事件再去執行子盒子事件。\n&lt;body&gt;\n  &lt;h3&gt;事件流&lt;&#x2F;h3&gt;\n  &lt;p&gt;事件流是事件在執行時的底層機制，主要體現在父子盒子之間事件的執行上。&lt;&#x2F;p&gt;\n  &lt;div class&#x3D;&quot;outer&quot;&gt;\n    &lt;div class&#x3D;&quot;inner&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取嵌套的3個節點\n    const outer &#x3D; document.querySelector(&#39;.outer&#39;)\n    const inner &#x3D; document.querySelector(&#39;.inner&#39;)\n\n    &#x2F;&#x2F; 外層的盒子\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;outer...&#39;)\n    &#125;, true) &#x2F;&#x2F; true 表示在捕獲階段執行事件\n    \n    &#x2F;&#x2F; 中間的盒子\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;inner...&#39;)\n    &#125;, true)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：\n\naddEventListener 第3個參數決定了事件是在捕獲階段觸發還是在冒泡階段觸發\naddEventListener 第3個參數為  true 表示捕獲階段觸發，false 表示冒泡階段觸發，預設值為 false\n事件流只會在父子元素具有相同事件類型時才會產生影響\n絕大部分場景都採用預設的冒泡模式（其中一個原因是早期 IE 不支援捕獲）\n\n阻止冒泡\n\n\n\n\n\n\n\n\n語法:事件對象.stopPropagation()阻止冒泡是指阻斷事件的流動，保證事件只在當前元素被執行，而不再去影響到其對應的父項目。\n&lt;body&gt;\n  &lt;h3&gt;阻止冒泡&lt;&#x2F;h3&gt;\n  &lt;p&gt;阻止冒泡是指阻斷事件的流動，保證事件只在當前元素被執行，而不再去影響到其對應的父項目。&lt;&#x2F;p&gt;\n  &lt;div class&#x3D;&quot;outer&quot;&gt;\n    &lt;div class&#x3D;&quot;inner&quot;&gt;\n      &lt;div class&#x3D;&quot;child&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取嵌套的3個節點\n    const outer &#x3D; document.querySelector(&#39;.outer&#39;)\n    const inner &#x3D; document.querySelector(&#39;.inner&#39;)\n    const child &#x3D; document.querySelector(&#39;.child&#39;)\n\n    &#x2F;&#x2F; 外層的盒子\n    outer.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;outer...&#39;)\n    &#125;)\n\n    &#x2F;&#x2F; 中間的盒子\n    inner.addEventListener(&#39;click&#39;, function (ev) &#123;\n      console.log(&#39;inner...&#39;)\n\n      &#x2F;&#x2F; 阻止事件冒泡\n      ev.stopPropagation()\n    &#125;)\n\n    &#x2F;&#x2F; 內層的盒子\n    child.addEventListener(&#39;click&#39;, function (ev) &#123;\n      console.log(&#39;child...&#39;)\n\n      &#x2F;&#x2F; 借助事件物件，阻止事件向上冒泡\n      ev.stopPropagation()\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n結論：事件物件中的 ev.stopPropagation 方法，專門用來阻止事件冒泡。\n\n\n\n\n\n\n\n\n\n滑鼠經過事件：\nmouseover 和 mouseout 會有冒泡效果\nmouseenter  和 mouseleave   沒有冒泡效果 (推薦)\n解綁事件1. on事件方式直接使用null覆蓋偶就可以實現事件的解綁\n&lt;button&gt;點擊&lt;&#x2F;button&gt;\n  &lt;script&gt;\n    const btn &#x3D; document.querySelector(&#39;button&#39;)\n    &#x2F;&#x2F;綁定事件\n    btn.onclick &#x3D; function () &#123;\n      alert(&#39;點擊了&#39;)\n      &#x2F;&#x2F; L0 事件移除解綁\n      btn.onclick &#x3D; null\n    &#125;\n    \n  &lt;&#x2F;script&gt;\naddEventListener方式，必須使用：removeEventListener(事件類型, 事件處理函數, [獲取捕獲或者冒泡階段])\n&lt;button&gt;點擊&lt;&#x2F;button&gt;\n  &lt;script&gt;\n    const btn &#x3D; document.querySelector(&#39;button&#39;)\n    function fn() &#123;\n      alert(&#39;點擊了&#39;)\n    &#125;\n    &#x2F;&#x2F;綁定事件\n    btn.addEventListener(&#39;click&#39;, fn)\n    &#x2F;&#x2F; L2 事件移除解綁\n    btn.removeEventListener(&#39;click&#39;, fn)\n  &lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n注意：匿名函數無法被解綁\n兩種註冊事件的區別\n傳統on註冊（L0）\n同一個對象,後面註冊的事件會覆蓋前面註冊(同一個事件)\n直接使用null覆蓋偶就可以實現事件的解綁\n都是冒泡階段執行的\n\n\n事件監聽註冊（L2）\n語法: addEventListener(事件類型, 事件處理函數, 是否使用捕獲)\n後面註冊的事件不會覆蓋前面註冊的事件(同一個事件)\n可以通過第三個參數去確定是在冒泡或者捕獲階段執行\n必須使用removeEventListener(事件類型, 事件處理函數, 獲取捕獲或者冒泡階段)\n匿名函數無法被解綁\n\n\n\n鼠標經過事件的區別\n鼠標經過事件：\nmouseover 和 mouseout 會有冒泡效果\nmouseenter 和 mouseleave 沒有冒泡效果 (推薦)\n\n\n\n事件委託\n\n\n\n\n\n\n\n\n事件委託是利用事件流的特徵解決一些現實開發需求的知識技巧，主要的作用是提升程式效率。\n\n事件委託是利用事件流的特徵解決一些開發需求的知識技巧\n優點：減少註冊次數，可以提高程式性能\n原理：事件委託其實是利用事件冒泡的特點。\n給父元素註冊事件，當我們觸發子元素的時候，會冒泡到父元素身上，從而觸發父元素的事件\n\n\n實現：事件對象.target.tagName ===&#39;標籤名&#39; 可以獲得真正觸發事件的元素ev.target.tagName &#x3D;&#x3D;&#x3D; ‘BUTTON’大量的事件監聽是比較耗費性能的，如下代碼所示\n\n\n\n&lt;script&gt;\n  &#x2F;&#x2F; 假設頁面中有 10000 個 button 元素\n  const buttons &#x3D; document.querySelectorAll(&#39;table button&#39;);\n\n  for(let i &#x3D; 0; i &lt;&#x3D; buttons.length; i++) &#123;\n    &#x2F;&#x2F; 為 10000 個 button 元素添加了事件\n    buttons.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; 省略具體執行邏輯...\n    &#125;)\n  &#125;\n&lt;&#x2F;script&gt;\n\n利用事件流的特徵，可以對上述的代碼進行優化，事件的的冒泡模式總是會將事件流向其父元素的，如果父元素監聽了相同的事件類型，那麼父元素的事件就會被觸發並執行，正是利用這一特徵對上述代碼進行優化，如下代碼所示：\n&lt;script&gt;\n  &#x2F;&#x2F; 假設頁面中有 10000 個 button 元素\n  let buttons &#x3D; document.querySelectorAll(&#39;table button&#39;);\n  \n  &#x2F;&#x2F; 假設上述的 10000 個 buttom 元素共同的父項目是 table\n  let parents &#x3D; document.querySelector(&#39;table&#39;);\n  parents.addEventListener(&#39;click&#39;, function () &#123;\n    console.log(&#39;點擊任意子元素都會觸發事件...&#39;);\n  &#125;)\n&lt;&#x2F;script&gt;\n\n我們的最終目的是保證只有點擊 button 子元素才去執行事件的回呼函數，如何判斷用戶點擊是哪一個子元素呢？\n事件物件中的屬性 target 或 srcElement屬性工作表示真正觸發事件的元素，它是一個元素類型的節點。\n&lt;script&gt;\n  &#x2F;&#x2F; 假設頁面中有 10000 個 button 元素\n  const buttons &#x3D; document.querySelectorAll(&#39;table button&#39;)\n  \n  &#x2F;&#x2F; 假設上述的 10000 個 buttom 元素共同的父項目是 table\n  const parents &#x3D; document.querySelector(&#39;table&#39;)\n  parents.addEventListener(&#39;click&#39;, function (ev) &#123;\n    &#x2F;&#x2F; console.log(ev.target);\n    &#x2F;&#x2F; 只有 button 元素才會真正去執行邏輯\n    if(ev.target.tagName &#x3D;&#x3D;&#x3D; &#39;BUTTON&#39;) &#123;\n      &#x2F;&#x2F; 執行的邏輯\n    &#125;\n  &#125;)\n&lt;&#x2F;script&gt;\n\n優化過的代碼只對父項目添加事件監聽，相比對 10000 個元素添加事件監聽執行效率要高許多！！！\n其他事件頁面載入事件載入外部資源（如圖片、外聯CSS和JavaScript等）載入完畢時觸發的事件\n有些時候需要等頁面資源全部處理完了做一些事情\nload 事件監聽頁面所有資源載入完畢：\n\n\n\n\n\n\n\n\n\n\n監聽整個頁面資源給 window 加\n\nwindow.addEventListener(&#39;load&#39;, function() &#123;\n    &#x2F;&#x2F; 執行的操作~~~~~\n&#125;)\n\nDOMContentLoaded\n\n\n\n\n\n\n\n\n\n\n給 document 加\n無需等待樣式表、圖像等完全加載\n\ndocument.addEventListener(&#39;DOMContentLoaded&#39;, function () &#123;\n  &#x2F;&#x2F; 執行的操作~~~~~\n&#125;)\n\n\n元素滾動事件很多網頁需要檢測用戶把頁面滾動到某個區域後做一些處理， 比如固定導航欄，比如返回頂部\n\n\n\n\n\n\n\n\n\n捲軸在滾動的時候持續觸發的事件\nscroll 事件\nwindow.addEventListener(&#39;scroll&#39;, function() &#123;\n    &#x2F;&#x2F; 執行的操作~~~~~\n&#125;)\n監聽某個元素的內部滾動直接給某個元素加即可\n頁面滾動事件-獲取位置\nscrollLeft和scrollTop （屬性）\n獲取被卷去的大小\n獲取元素內容往左、往上滾出去看不到的距離\n這兩個值是可讀寫的\n\n\n\ndiv滾動\nconst div &#x3D; document.querySelector(&#39;div&#39;)\ndiv.addEventListener(&#39;scroll&#39;, function () &#123;\n  &#x2F;&#x2F; console.log(111)\n  &#x2F;&#x2F; scrollTop 被卷去的頭部\n  console.log(div.scrollTop)\n&#125;)\n頁面滾動\nconst div &#x3D; document.querySelector(&#39;div&#39;)\n&#x2F;&#x2F; 頁面滾動事件\nwindow.addEventListener(&#39;scroll&#39;, function () &#123;\n  &#x2F;&#x2F; console.log(&#39;我滾了&#39;)\n  &#x2F;&#x2F; 我想知道頁面到底滾動了多少圖元， 被卷去了多少  scrollTop\n  &#x2F;&#x2F; 獲取html元素寫法  \n  &#x2F;&#x2F; document.documentElement  \n  &#x2F;&#x2F; console.log(document.documentElement.scrollTop)\n  const n &#x3D; document.documentElement.scrollTop\n  if (n &gt;&#x3D; 100) &#123;\n    div.style.display &#x3D; &#39;block&#39;\n  &#125; else &#123;\n    div.style.display &#x3D; &#39;none&#39;\n  &#125;\n&#125;)\n細節注意\ndocument.documentElement.scrollTop &#x3D; 800\nwindow.addEventListener(&#39;scroll&#39;, function () &#123;\n  &#x2F;&#x2F; 必須寫到裡面\n  const n &#x3D; document.documentElement.scrollTop\n  &#x2F;&#x2F; 得到是什麼資料   數字型 不帶單位\n  &#x2F;&#x2F; console.log(n)\n&#125;)\n\n頁面滾動事件-滾動到指定的坐標\n\n\n\n\n\n\n\n\nscrollTo() 方法可把內容滾動到指定的坐標\n\n語法：元素.scrollTo(x, y)\n\n頁面尺寸事件會在視窗尺寸改變的時候觸發事件：\nwindow.addEventListener(&#39;resize&#39;, function() &#123;\n    &#x2F;&#x2F; 執行的操作~~~~~\n&#125;)\n\n元素尺寸與位置\n獲取寬高\n\n獲取元素的自身寬高、包含元素自身設置的寬高、padding、border\noffsetWidth和offsetHeight  \n獲取出來的是數值,方便計算\n注意: 獲取的是可視寬高, 如果盒子是隱藏的,獲取的結果是0\n\n\n獲取位置：\n\n獲取元素距離自己定位父級元素的左、上距離\noffsetLeft和offsetTop \n注意是只讀屬性\n\n\nelement.getBoundingClientRect()\n方法返回元素的大小及其相對於視口的位\n\n\n\n\n\n\noffsetWidth和offsetHeight是得到元素什麼的寬高？\n\n\n內容 + padding + border\n\n\noffsetTop和offsetLeft 得到位置以誰為準？\n\n\n帶有定位的父級\n如果都沒有則以 文檔左上角 為準\n\n\n\n\n屬性\n作用\n說明\n\n\n\nscrollLeft和scrollTop\n被捲去的頭部和左側\n配合頁面滾動來用，可讀寫\n\n\nclientWidth 和 clientHeight\n獲得元素寬度和高度\n不包含border,margin，滾動條 用於js獲取元素大小，只讀屬性\n\n\noffsetWidth和offsetHeight\n獲得元素寬度和高度\n包含border、padding，滾動條等，只讀\n\n\noffsetLeft和offsetTop\n獲取元素距離自己定位父級元素的左、上距離\n獲取元素位置的時候使用，只讀屬性\n\n\n","slug":"20230325JavaScript Web APIs - 第3天","date":"2023-03-25T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"b74e92afe19531c6070a34e8d8d93dcd","title":"JavaScript Web APIs - 第2天","content":"\n\n\n\n\n\n\n\n\n學會通過為DOM註冊事件來實現可交互的網頁特效。\n\n能夠判斷函數運行的環境並確字 this 所指代的物件\n理解事件的作用，知道應用事件的 3 個步驟\n\n\n\n\n\n\n\n\n\n\n學習會為 DOM 註冊事件，實現簡單可交互的網頁特交。\n事件事件是程式設計語言中的術語，它是用來描述程式的行為或狀態的，一旦行為或狀態發生改變，便立即調用一個函數。\n例如：使用者使用【滑鼠點擊】網頁中的一個按鈕、使用者使用【滑鼠拖拽】網頁中的一張圖片\n事件監聽\n\n\n\n\n\n\n\n\n語法: 元素對象.addEventListener(‘事件類型’, 要執行的函數)\n結合 DOM 使用事件時，需要為 DOM 物件添加事件監聽，等待事件發生（觸發）時，便立即調用一個函數。\naddEventListener 是 DOM 物件專門用來添加事件監聽的方法，它的兩個參數分別為【事件類型】和【事件回檔】。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;事件監聽&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;h3&gt;事件監聽&lt;&#x2F;h3&gt;\n  &lt;p id&#x3D;&quot;text&quot;&gt;為 DOM 元素添加事件監聽，等待事件發生，便立即執行一個函數。&lt;&#x2F;p&gt;\n  &lt;button id&#x3D;&quot;btn&quot;&gt;點擊改變文字顏色&lt;&#x2F;button&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 獲取 button 對應的 DOM 對象\n    const btn &#x3D; document.querySelector(&#39;#btn&#39;)\n\n    &#x2F;&#x2F; 2. 添加事件監聽\n    btn.addEventListener(&#39;click&#39;, function () &#123;\n      console.log(&#39;等待事件被觸發...&#39;)\n      &#x2F;&#x2F; 改變 p 標籤的文字顏色\n      let text &#x3D; document.getElementById(&#39;text&#39;)\n      text.style.color &#x3D; &#39;red&#39;\n    &#125;)\n\n    &#x2F;&#x2F; 3. 只要使用者點擊了按鈕，事件便觸發了！！！\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n完成事件監聽分成3個步驟：\n\n獲取 DOM 元素\n通過 addEventListener 方法為 DOM 節點添加事件監聽\n等待事件觸發，如使用者點擊了某個按鈕時便會觸發 click 事件類型\n事件觸發後，相對應的回呼函數會被執行\n\n大白話描述：所謂的事件無非就是找個機會（事件觸發）調用一個函數（回呼函數）。\n事件類型click 譯成中文是【點擊】的意思，它的含義是監聽（等著）使用者滑鼠的按一下操作，除了【按一下】還有【按兩下】dblclick\n&lt;script&gt;\n  &#x2F;&#x2F; 按兩下事件類型\n  btn.addEventListener(&#39;dblclick&#39;, function () &#123;\n    console.log(&#39;等待事件被觸發...&#39;);\n    &#x2F;&#x2F; 改變 p 標籤的文字顏色\n    const text &#x3D; document.querySelector(&#39;.text&#39;)\n    text.style.color &#x3D; &#39;red&#39;\n  &#125;)\n\n  &#x2F;&#x2F; 只要使用者按兩下擊了按鈕，事件便觸發了！！！\n&lt;&#x2F;script&gt;\n\n結論：【事件類型】決定了事件被觸發的方式，如 click 代表滑鼠按一下，dblclick 代表滑鼠按兩下。\n\n\n\n名稱\n說明\n舉例\n\n\n\n鼠標事件\n鼠標觸發\nclick 鼠標點擊、mouseenter鼠標經過、mouseleave 鼠標離開\n\n\n焦點事件\n表單獲得光標\nfocus 獲得焦點、blur 失去焦點\n\n\n鍵盤事件\n鍵盤觸發\nKeydown 鍵盤按下觸發、Keyup 鍵盤抬起觸發\n\n\n文本事件\n表單輸入觸發\ninput 用戶輸入事件\n\n\n事件處理常式addEventListener 的第2個參數是函數，這個函數會在事件被觸發時立即被調用，在這個函數中可以編寫任意邏輯的代碼，如改變 DOM 文本顏色、文本內容等。\n&lt;script&gt;\n  &#x2F;&#x2F; 按兩下事件類型\n  btn.addEventListener(&#39;dblclick&#39;, function () &#123;\n    console.log(&#39;等待事件被觸發...&#39;)\n    \n    const text &#x3D; document.querySelector(&#39;.text&#39;)\n    &#x2F;&#x2F; 改變 p 標籤的文字顏色\n    text.style.color &#x3D; &#39;red&#39;\n    &#x2F;&#x2F; 改變 p 標籤的文本內容\n    text.style.fontSize &#x3D; &#39;20px&#39;\n  &#125;)\n&lt;&#x2F;script&gt;\n\n結論：【事件處理常式】決定了事件觸發後應該執行的邏輯。\n事件類型將眾多的事件類型分類可分為：滑鼠事件、鍵盤事件、表單事件、焦點事件等，我們逐一展開學習。\n滑鼠事件滑鼠事件是指跟滑鼠操作相關的事件，如按一下、按兩下、移動等。\n\n&#96;mouseenter 監聽滑鼠是否移入 DOM 元素\n\n&lt;body&gt;\n  &lt;h3&gt;滑鼠事件&lt;&#x2F;h3&gt;\n  &lt;p&gt;監聽與滑鼠相關的操作&lt;&#x2F;p&gt;\n  &lt;hr&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 需要事件監聽的 DOM 元素\n    const box &#x3D; document.querySelector(&#39;.box&#39;);\n\n    &#x2F;&#x2F; 監聽滑鼠是移入當前 DOM 元素\n    box.addEventListener(&#39;mouseenter&#39;, function () &#123;\n      &#x2F;&#x2F; 修改文本內容\n      this.innerText &#x3D; &#39;滑鼠移入了...&#39;;\n      &#x2F;&#x2F; 修改游標的風格\n      this.style.cursor &#x3D; &#39;move&#39;;\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n&#96;mouseleave 監聽滑鼠是否移出 DOM 元素\n\n&lt;body&gt;\n  &lt;h3&gt;滑鼠事件&lt;&#x2F;h3&gt;\n  &lt;p&gt;監聽與滑鼠相關的操作&lt;&#x2F;p&gt;\n  &lt;hr&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 需要事件監聽的 DOM 元素\n    const box &#x3D; document.querySelector(&#39;.box&#39;);\n\n    &#x2F;&#x2F; 監聽滑鼠是移出當前 DOM 元素\n    box.addEventListener(&#39;mouseleave&#39;, function () &#123;\n      &#x2F;&#x2F; 修改文本內容\n      this.innerText &#x3D; &#39;滑鼠移出了...&#39;;\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n焦點事件\n\n\n\n\n\n\n\n\nfocus  獲得焦點blur 失去焦點\n&lt;input type&#x3D;&quot;text&quot;&gt;\n  &lt;script&gt;\n    const input &#x3D; document.querySelector(&#39;input&#39;)\n    input.addEventListener(&#39;focus&#39;, function () &#123;\n      console.log(&#39;有焦點觸發&#39;)\n    &#125;)\n    input.addEventListener(&#39;blur&#39;, function () &#123;\n      console.log(&#39;失去焦點觸發&#39;)\n    &#125;)\n  &lt;&#x2F;script&gt;\n鍵盤事件\n\n\n\n\n\n\n\n\nkeydown   鍵盤按下觸發keyup   鍵盤抬起觸發\n&lt;input type&#x3D;&quot;text&quot;&gt;\n  &lt;script&gt;\n    const input &#x3D; document.querySelector(&#39;input&#39;)\n    &#x2F;&#x2F; 鍵盤事件\n    input.addEventListener(&#39;keydown&#39;, function () &#123;\n       console.log(&#39;鍵盤按下了&#39;)\n     &#125;)\n    input.addEventListener(&#39;keyup&#39;, function () &#123;\n      console.log(&#39;鍵盤談起了&#39;)\n     &#125;)\n  &lt;&#x2F;script&gt;\n文字方塊輸入事件\n\n\n\n\n\n\n\n\ninput\n&lt;input type&#x3D;&quot;text&quot;&gt;\n  &lt;script&gt;\n    const input &#x3D; document.querySelector(&#39;input&#39;)\n    &#x2F;&#x2F; 用戶輸入文本事件  input\n    input.addEventListener(&#39;input&#39;, function () &#123;\n      console.log(input.value)\n    &#125;)\n  &lt;&#x2F;script&gt;\n\n事件(對象)物件任意事件類型被觸發時與事件相關的資訊會被以物件的形式記錄下來，我們稱這個物件為事件物件。\n\n事件對像是什麼\n也是個對象，這個對象裡有事件觸發時的相關信息\n例如：鼠標點擊事件中，事件對象就存了鼠標點在哪個位置等信息\n使用場景\n可以判斷用戶按下哪個鍵，比如按下回車鍵可以發布新聞\n可以判斷鼠標點擊了哪個元素，從而做相應的操作\n\n\n\n\n\n\n\n\n語法元素.addEventListener(&#39;click&#39;, function (e)&#123;&#125;)\n&lt;body&gt;\n  &lt;h3&gt;事件物件&lt;&#x2F;h3&gt;\n  &lt;p&gt;任意事件類型被觸發時與事件相關的資訊會被以物件的形式記錄下來，我們稱這個物件為事件物件。&lt;&#x2F;p&gt;\n  &lt;hr&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;&lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取 .box 元素\n    const box &#x3D; document.querySelector(&#39;.box&#39;)\n\n    &#x2F;&#x2F; 添加事件監聽\n    box.addEventListener(&#39;click&#39;, function (e) &#123;\n      console.log(&#39;任意事件類型被觸發後，相關資訊會以物件形式被記錄下來...&#39;);\n\n      &#x2F;&#x2F; 事件回呼函數的第1個參數即所謂的事件物件\n      console.log(e)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n\n\n\n\n\n\n\n\n\n事件回呼函數的【第1個參數】即所謂的事件物件通常習慣性的將這個對數命名為 event、ev 、ev 。\n接下來簡單看一下事件物件中包含了哪些有用的資訊：\n\nev.type 當前事件的類型\nev.clientX/Y 游標相對流覽器窗口的位置\nev.offsetX/Y 游標相於當前 DOM 元素的位置\n\n\n補充 key 用户按下的鍵盤鍵的值\n\n注：在事件回呼函數內部通過 window.event 同樣可以獲取事件物件。\n&lt;input type&#x3D;&quot;text&quot;&gt;\n  &lt;script&gt;\n    const input &#x3D; document.querySelector(&#39;input&#39;)\n    input.addEventListener(&#39;keyup&#39;, function (e) &#123;\n      if (e.key &#x3D;&#x3D;&#x3D; &#39;Enter&#39;) &#123;\n        console.log(&#39;我按下了Enter&#39;)\n      &#125;\n    &#125;)\n  &lt;&#x2F;script&gt;\n環境(對象)物件\n\n\n\n\n\n\n\n\n能夠分析判斷函數運行在不同環境中 this 所指代的物件。\n環境物件指的是函數內部特殊的變數 this ，它代表著當前函數運行時所處的環境。\n&lt;script&gt;\n  &#x2F;&#x2F; 聲明函數\n  function sayHi() &#123;\n    &#x2F;&#x2F; this 是一個變數\n    console.log(this);\n  &#125;\n\n  &#x2F;&#x2F; 聲明一個物件\n  let user &#x3D; &#123;\n    name: &#39;張三&#39;,\n    sayHi: sayHi &#x2F;&#x2F; 此處把 sayHi 函數，賦值給 sayHi 屬性\n  &#125;\n  \n  let person &#x3D; &#123;\n    name: &#39;李四&#39;,\n    sayHi: sayHi\n  &#125;\n\n  &#x2F;&#x2F; 直接調用\n  sayHi() &#x2F;&#x2F; window\n  window.sayHi() &#x2F;&#x2F; window\n\n  &#x2F;&#x2F; 做為物件方法調用\n  user.sayHi()&#x2F;&#x2F; user\n  person.sayHi()&#x2F;&#x2F; person\n&lt;&#x2F;script&gt;\n\n結論：\n\nthis 本質上是一個變數，資料類型為物件\n函數的調用方式不同 this 變數的值也不同\n【誰調用 this 就是誰】是判斷 this 值的粗略規則\n函數直接調用時實際上 window.sayHi() 所以 this 的值為 window\n\n回呼函數如果將函數 A 做為參數傳遞給函數 B 時，我們稱函數 A 為回呼函數。\n&lt;script&gt;\n  &#x2F;&#x2F; 聲明 foo 函數\n  function foo(arg) &#123;\n    console.log(arg);\n  &#125;\n\n  &#x2F;&#x2F; 普通的值做為參數\n  foo(10);\n  foo(&#39;hello world!&#39;);\n  foo([&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]);\n\n  function bar() &#123;\n    console.log(&#39;函數也能當參數...&#39;);\n  &#125;\n  &#x2F;&#x2F; 函數也可以做為參數！！！！\n  foo(bar);\n&lt;&#x2F;script&gt;\n\n函數 bar 做參數傳給了 foo 函數，bar 就是所謂的回呼函數了！！！\n回顧一下間歇函數 setInterval \n&lt;script&gt;\n  function fn() &#123;\n    console.log(&#39;我是回呼函數...&#39;);\n  &#125;\n  &#x2F;&#x2F; 調用計時器\n  setInterval(fn, 1000);\n&lt;&#x2F;script&gt;\n\nfn 函數做為參數傳給了 setInterval ，這便是回呼函數的實際應用了，結合剛剛學習的函數運算式上述代碼還有另一種更常見寫法。\n&lt;script&gt;\n  &#x2F;&#x2F; 調用計時器，匿名函數做為參數\n  setInterval(function () &#123;\n    console.log(&#39;我是回呼函數...&#39;);\n  &#125;, 1000);\n&lt;&#x2F;script&gt;\n\n結論：\n\n回呼函數本質還是函數，只不過把它當成參數使用\n使用匿名函數做為回呼函數比較常見\n把函數当做另外一个函数的参數傳遞，这个函數就叫回调函數\n\n輪播圖練習&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n  &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot; &#x2F;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot; &#x2F;&gt;\n  &lt;title&gt;輪播圖點擊切換&lt;&#x2F;title&gt;\n  &lt;style&gt;\n    * &#123;\n      box-sizing: border-box;\n    &#125;\n\n    .slider &#123;\n      width: 560px;\n      height: 400px;\n      overflow: hidden;\n    &#125;\n\n    .slider-wrapper &#123;\n      width: 100%;\n      height: 320px;\n    &#125;\n\n    .slider-wrapper img &#123;\n      width: 100%;\n      height: 100%;\n      display: block;\n    &#125;\n\n    .slider-footer &#123;\n      height: 80px;\n      background-color: rgb(100, 67, 68);\n      padding: 12px 12px 0 12px;\n      position: relative;\n    &#125;\n\n    .slider-footer .toggle &#123;\n      position: absolute;\n      right: 0;\n      top: 12px;\n      display: flex;\n    &#125;\n\n    .slider-footer .toggle button &#123;\n      margin-right: 12px;\n      width: 28px;\n      height: 28px;\n      appearance: none;\n      border: none;\n      background: rgba(255, 255, 255, 0.1);\n      color: #fff;\n      border-radius: 4px;\n      cursor: pointer;\n    &#125;\n\n    .slider-footer .toggle button:hover &#123;\n      background: rgba(255, 255, 255, 0.2);\n    &#125;\n\n    .slider-footer p &#123;\n      margin: 0;\n      color: #fff;\n      font-size: 18px;\n      margin-bottom: 10px;\n    &#125;\n\n    .slider-indicator &#123;\n      margin: 0;\n      padding: 0;\n      list-style: none;\n      display: flex;\n      align-items: center;\n    &#125;\n\n    .slider-indicator li &#123;\n      width: 8px;\n      height: 8px;\n      margin: 4px;\n      border-radius: 50%;\n      background: #fff;\n      opacity: 0.4;\n      cursor: pointer;\n    &#125;\n\n    .slider-indicator li.active &#123;\n      width: 12px;\n      height: 12px;\n      opacity: 1;\n    &#125;\n  &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;slider&quot;&gt;\n    &lt;div class&#x3D;&quot;slider-wrapper&quot;&gt;\n      &lt;img src&#x3D;&quot;.&#x2F;images&#x2F;slider01.jpg&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;slider-footer&quot;&gt;\n      &lt;p&gt;對人類來說會不會太超前了？ &lt;&#x2F;p&gt;\n      &lt;ul class&#x3D;&quot;slider-indicator&quot;&gt;\n        &lt;li class&#x3D;&quot;active&quot;&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n      &lt;div class&#x3D;&quot;toggle&quot;&gt;\n        &lt;button class&#x3D;&quot;prev&quot;&gt;&lt;&lt;&#x2F;button&gt;\n        &lt;button class&#x3D;&quot;next&quot;&gt;&gt;&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 初始數據\n    const data &#x3D; [\n      &#123; url: &#39;.&#x2F;images&#x2F;slider01.jpg&#39;, title: &#39;對人類來說會不會太超前了？ &#39;, color: &#39;rgb(100, 67, 68)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider02.jpg&#39;, title: &#39;開啟劍與雪的黑暗傳說！ &#39;, color: &#39;rgb(43, 35, 26)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider03.jpg&#39;, title: &#39;真正的jo廚出現了！ &#39;, color: &#39;rgb(36, 31, 33)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider04.jpg&#39;, title: &#39;李玉剛：讓世界通過B站看到東方大國文化&#39;, color: &#39;rgb(139, 98, 66)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider05.jpg&#39;, title: &#39;快來分享你的寒假日常吧~&#39;, color: &#39;rgb(67, 90, 92)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider06.jpg&#39;, title: &#39;嗶哩嗶哩小年YEAH&#39;, color: &#39;rgb(166, 131, 143)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider07.jpg&#39;, title: &#39;一站式解決你的電腦配置問題！ ！ ！ &#39;, color: &#39;rgb(53, 29, 25)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider08.jpg&#39;, title: &#39;誰不想和小貓咪貼貼呢！ &#39;, color: &#39;rgb(99, 72, 114)&#39; &#125;,\n    ]\n    &#x2F;&#x2F; 獲取元素\n    const img &#x3D; document.querySelector(&#39;.slider-wrapper img&#39;)\n    const p &#x3D; document.querySelector(&#39;.slider-footer p&#39;)\n    const footer &#x3D; document.querySelector(&#39;.slider-footer&#39;)\n    &#x2F;&#x2F; 1. 右按鈕業務\n    &#x2F;&#x2F; 1.1 獲取右側按鈕 \n    const next &#x3D; document.querySelector(&#39;.next&#39;)\n    let i &#x3D; 0  &#x2F;&#x2F; 信號量 控製播放圖片張數\n    &#x2F;&#x2F; 1.2 註冊點擊事件\n\n    next.addEventListener(&#39;click&#39;, function () &#123;\n      &#x2F;&#x2F; console.log(11)\n      i++\n      &#x2F;&#x2F; 1.6判斷條件  如果大於8 就復原為 0\n      &#x2F;&#x2F; if (i &gt;&#x3D; 8) &#123;\n      &#x2F;&#x2F;   i &#x3D; 0\n      &#x2F;&#x2F; &#125;\n      i &#x3D; i &gt;&#x3D; data.length ? 0 : i\n      &#x2F;&#x2F; 1.3 得到對應的對象\n      &#x2F;&#x2F; console.log(data[i])\n      &#x2F;&#x2F; 調用函數\n      toggle()\n    &#125;)\n\n    &#x2F;&#x2F; 2. 左側按鈕業務\n    &#x2F;&#x2F; 2.1 獲取左側按鈕 \n    const prev &#x3D; document.querySelector(&#39;.prev&#39;)\n    &#x2F;&#x2F; 1.2 註冊點擊事件\n    prev.addEventListener(&#39;click&#39;, function () &#123;\n      i--\n      &#x2F;&#x2F; 判斷條件  如果小於0  則爬到最後一張圖片索引號是 7\n      &#x2F;&#x2F; if (i &lt; 0) &#123;\n      &#x2F;&#x2F;   i &#x3D; 7\n      &#x2F;&#x2F; &#125;\n      i &#x3D; i &lt; 0 ? data.length - 1 : i\n      &#x2F;&#x2F; 1.3 得到對應的對象\n      &#x2F;&#x2F; console.log(data[i])\n      &#x2F;&#x2F; 調用函數\n      toggle()\n    &#125;)\n\n    &#x2F;&#x2F; 聲明一個渲染的函數作為複用\n    function toggle() &#123;\n      &#x2F;&#x2F; 1.4 渲染對應的數據\n      img.src &#x3D; data[i].url\n      p.innerHTML &#x3D; data[i].title\n      footer.style.backgroundColor &#x3D; data[i].color\n      &#x2F;&#x2F; 1.5 更換小圓點    先移除原來的類名， 當前li再添加 這個 類名\n      document.querySelector(&#39;.slider-indicator .active&#39;).classList.remove(&#39;active&#39;)\n      document.querySelector(&#96;.slider-indicator li:nth-child($&#123;i + 1&#125;)&#96;).classList.add(&#39;active&#39;)\n    &#125;\n\n\n&#x2F;&#x2F; 3. 自動播放模塊\n    let timerId &#x3D; setInterval(function () &#123;\n      &#x2F;&#x2F; 利用js自動調用點擊事件  click()  一定加小括號調用函數\n      next.click()\n    &#125;, 1000)\n\n\n    &#x2F;&#x2F; 4. 鼠標經過大盒子，停止定時器\n    const slider &#x3D; document.querySelector(&#39;.slider&#39;)\n    &#x2F;&#x2F; 註冊事件\n    slider.addEventListener(&#39;mouseenter&#39;, function () &#123;\n      &#x2F;&#x2F; 停止定時器\n      clearInterval(timerId)\n    &#125;)\n\n    &#x2F;&#x2F; 5. 鼠標離開大盒子，開啟定時器\n    &#x2F;&#x2F; 註冊事件\n    slider.addEventListener(&#39;mouseleave&#39;, function () &#123;\n      &#x2F;&#x2F; 停止定時器\n      if (timerId) clearInterval(timerId)\n      &#x2F;&#x2F; 開啟定時器\n      timerId &#x3D; setInterval(function () &#123;\n        &#x2F;&#x2F; 利用js自動調用點擊事件  click()  一定加小括号调用函数\n        next.click()\n      &#125;, 1000)\n    &#125;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n","slug":"20230324JavaScript Web APIs - 第2天","date":"2023-03-24T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"468fda7622aa68c04257bd1e3309f9c2","title":"photoshop","content":"ps基本操作以及常用快速鍵：因為網頁美工大部分效果圖都是利用ps 來做的，所以，以後我們大部分切圖工作都是在ps裡面完成。\n\n檔–打開 –  可以打開 我們要測量的圖片\nctrl+r 可以打開尺規  或者  視圖 –  尺規\n右擊尺規，  把裡面的單位改為  圖元  \nctrl+ 加號 鍵  可以 放大  視圖  ctrl+ 減號 縮小視圖\n按住空白鍵，  滑鼠可以 變成小手 ，拖動 ps 視圖\n用選區 拖動  可以 測量 大小 \nctrl+ d  可以取消選區  或者旁邊空白處點擊一下也可以取消選區\n\n3. Photoshop 切圖常見的圖片格式\n1. jpg圖像格式： \nJPEG（.JPG）對色彩的資訊保留較好，高清，顏色較多，我們產品類的圖片經常用jpg格式的\n2. gif圖像格式：\nGIF格式最多只能儲存256色，所以通常用來顯示簡單圖形及字體，但是可以保存透明背景和動畫效果\n3. png圖像格式\n是一種新興的網路圖形格式，結合了GIF和JPEG的優點，具有存儲形式豐富的特點，能夠保持透明背景\n4. PSD圖像格式\nPSD格式是Photoshop的專用格式，裡面可以存放圖層、通道、遮罩等多種設計草稿。 \n\nPS切圖   可以 分為   利用切片工具切圖 以及   利用PS的外掛程式快速切圖。\n1). PS切片工具 \nps切圖片，分兩大步：\n1). 用切片選中圖片\n\n利用切片工具手動劃出\n\n圖層菜單—新建基於圖層的切片\n\n利用輔助線 來切圖 –    基於輔助線的切片 \n  \n\n\n2). 匯出切片\n  檔功能表   – 存儲為web設備所用格式 —-   選擇  我們要的圖片格式 —-  點存儲  —   別忘了選中的切片\n輔助線和切片使用及清除視圖菜單– 清除 輔助線&#x2F; 清除切片\n2). 切圖外掛程式Cutterman是一款運行在photoshop中的外掛程式，能夠自動將你需要的圖層進行輸出， 以替代傳統的手工 “匯出web所用格式” 以及使用切片工具進行挨個切圖的繁瑣流程。 它支援各種各樣的圖片尺寸、格式、形態輸出，方便你在pc、ios、Android等端上使用。 它不需要你記住一堆的語法、規則，純點擊操作，方便、快捷，易於上手。\n官網: http://www.cutterman.cn/zh/cutterman\n注意： cutterman外掛程式要求你的ps 必須是完整版，不能是綠色版，所以大家需要從新安裝完整版本。\n\n   ","slug":"photoshop","date":"2023-03-23T15:55:04.000Z","categories_index":"photoshop","tags_index":"photoshop","author_index":"Hsu's Blog"},{"id":"0a48fb7912b57657825a8de1e5528e6f","title":"JavaScript Web APIs - 第1天","content":"複習：splice() 方法用於添加或刪除陣列中的元素。\n注意：這種方法會改變原始陣列。\n\n刪除陣列：\n\nsplice(起始位置， 刪除的個數)\n比如：1\nlet arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]\narr.splice(1,1) &#x2F;&#x2F; 刪除green元素\nconsole.log(arr) &#x2F;&#x2F; [&#39;red, &#39;blue&#39;]\n\n\n添加元素\n\nsplice(起始位置，刪除個數，添加陣列元素)\nlet arr &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]\n&#x2F;&#x2F;arr.splice(1, 0, &#39;pink&#39;) &#x2F;&#x2F; 在索引號是1的位置添加 pink\n&#x2F;&#x2F;console.log(arr) &#x2F;&#x2F; [&#39;red&#39;, &#39;pink&#39;, &#39;green&#39;, &#39;blue&#39;]\narr.splice(1, 0, &#39;pink&#39;, &#39;hotpink&#39;) &#x2F;&#x2F; 在索引號是1的位置添加 pink  hotpink\nconsole.log(arr) &#x2F;&#x2F; [&#39;red&#39;, &#39;pink&#39;, &#39;hotpink&#39;, &#39;green&#39;, &#39;blue&#39;]\n\n聲明變數優先使用哪個？\n\n\n\n\n\n\n\n\nconst有了變數先給const，如果發現它後面是要被修改的，再改為let\n為什麼const聲明的物件可以修改裡面的屬性？\n\n\n\n\n\n\n\n\nconst 聲明的值不能更改，而且const聲明變量的時候需要裡面進行初始化， 但是對於引用數據類型，const聲明的變量，裡面存的不是”值”是”地址”。因為物件是參考類型，裡面存儲的是位址，只要位址不變，就不會報錯建議陣列和物件使用 const 來聲明\n什麼時候使用let聲明變數？\n\n\n\n\n\n\n\n\n如果基本資料型別的值或者參考類型的位址發生變化的時候，需要用let比如 一個變數進行加減運算，比如 for迴圈中的 i++\nWeb APIs - 第1天筆記\n\n\n\n\n\n\n\n\n瞭解 DOM 的結構並掌握其基本的操作，體驗 DOM 的在開發中的作用\n\n知道 ECMAScript 與 JavaScript 的關係\n瞭解 DOM 的相關概念及DOM 的本質是一個物件\n掌握查找節點的基本方法\n掌握節點屬性和文本的操作\n能夠使用間歇函數創建定時任務\n\n介紹\n\n\n\n\n\n\n\n\n知道 ECMAScript 與 JavaScript 的關係，Web APIs 是流覽器擴展的功能。\n嚴格意義上講，我們在 JavaScript 階段學習的知識絕大部分屬於 ECMAScript 的知識體系，ECMAScript 簡稱 ES 它提供了一套語言標準規範，如變數、資料類型、運算式、語句、函數等語法規則都是由 ECMAScript 規定的。流覽器將 ECMAScript 大部分的規範加以實現，並且在此基礎上又擴展一些實用的功能，這些被擴展出來的內容我們稱為 Web APIs。\nECMAScript 運行在流覽器中然後再結合 Web APIs 才是真正的 JavaScript，Web APIs 的核心是 DOM 和 BOM。\n擴展閱讀：ECMAScript 規範在不斷的更新中，存在多個不同的版本，早期的版本號採用數位順序編號如 ECMAScript3、ECMAScript5，後來由於更新速度較快便採用年份做為版本號，如 ECMAScript2017、ECMAScript2018 這種格式，ECMAScript6 是 2015 年發佈的，常叫做 EMCAScript2015。\n關於 JavaScript 歷史的擴展閱讀。\n\n\n\n\n\n\n\n\n\n知道 DOM 相關的概念，建立對 DOM 的初步認識，學習 DOM 的基本操作，體會 DOM 的作用\n\n\n\n\n\n\n\n\n\nDOM（Document Object Model）是將整個 HTML 文檔的每一個標籤元素視為一個物件，這個物件下包含了許多的屬性和方法，通過操作這些屬性或者調用這些方法實現對 HTML 的動態更新，為實現網頁特效以及用戶交互提供技術支撐。\n簡言之 DOM 是用來動態修改 HTML 的，其目的是開發網頁特效及用戶交互。\n例如 當用戶分分別點擊【開始】或【結束】按鈕後，通過調試視窗可以觀察到 html 標籤的內容在不斷的發生改變，這便是通過 DOM 實現的。\n概念DOM 樹&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;標題&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  文本\n  &lt;a href&#x3D;&quot;&quot;&gt;連結名&lt;&#x2F;a&gt;\n  &lt;div id&#x3D;&quot;&quot; class&#x3D;&quot;&quot;&gt;文本&lt;&#x2F;div&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n將 HTML 文檔以樹狀結構直觀的表現出來，我們稱之為文檔樹或 DOM 樹，文檔樹直觀的體現了標籤與標籤之間的關係。\nDOM 節點節點是文檔樹的組成部分，每一個節點都是一個 DOM 物件，主要分為元素節點、屬性節點、文本節點等。\n\n【元素節點】其實就是 HTML 標籤，如上圖中 head、div、body 等都屬於元素節點。\n【屬性節點】是指 HTML 標籤中的屬性，如上圖中 a 標籤的 href 屬性、div 標籤的 class 屬性。\n【文本節點】是指 HTML 標籤的文字內容，如 title 標籤中的文字。\n【根節點】特指 html 標籤。\n其它…\n\ndocument\n\n\n\n\n\n\n\n\n網頁所有内容都在document里面document 是 JavaScript 內置的專門用於 DOM 的物件，該物件包含了若干的屬性和方法，document 是學習 DOM 的核心。\n&lt;script&gt;\n  &#x2F;&#x2F; document 是內置的對象\n  &#x2F;&#x2F; console.log(typeof document);\n\n  &#x2F;&#x2F; 1. 通過 document 獲取根節點\n  console.log(document.documentElement); &#x2F;&#x2F; 對應 html 標籤\n\n  &#x2F;&#x2F; 2. 通過 document 節取 body 節點\n  console.log(document.body); &#x2F;&#x2F; 對應 body 標籤\n\n  &#x2F;&#x2F; 3. 通過 document.write 方法向網頁輸出內容\n  document.write(&#39;Hello World!&#39;);\n&lt;&#x2F;script&gt;\n\n上述列舉了 document 物件的部分屬性和方法，我們先對 document 有一個整體的認識。\n獲取DOM對象\n\n\n\n\n\n\n\n\ndocument.querySelector(‘css選擇器’) &#x2F;&#x2F;css選擇器須加引號瀏覽器根據html標籤生成的 JS對象（DOM對象）DOM的核心就是把內容當對象來處理\n\nquerySelector   滿足條件的第一個元素\nquerySelectorAll  滿足條件的元素集合 返回偽陣列\n瞭解其他方式\ngetElementById\ngetElementsByTagName\n\n\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;DOM - 查找節點&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;h3&gt;查找元素類型節點&lt;&#x2F;h3&gt;\n  &lt;p&gt;從整個 DOM 樹中查找 DOM 節點是學習 DOM 的第一個步驟。&lt;&#x2F;p&gt;\n  &lt;ul&gt;\n      &lt;li&gt;元素&lt;&#x2F;li&gt;\n      &lt;li&gt;元素&lt;&#x2F;li&gt;\n      &lt;li&gt;元素&lt;&#x2F;li&gt;\n      &lt;li&gt;元素&lt;&#x2F;li&gt;\n  &lt;&#x2F;ul&gt;\n  &lt;script&gt;\n    const p &#x3D; document.querySelector(&#39;p&#39;)  &#x2F;&#x2F; 獲取第一個p元素\n    const lis &#x3D; document.querySelectorAll(&#39;li&#39;)  &#x2F;&#x2F; 獲取第一個p元素\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n總結：\n\ndocument.getElementById 專門獲取元素類型節點，根據標籤的 id  屬性查找\n任意 DOM 物件都包含 nodeType 屬性，用來檢檢測節點類型\n\n操作元素內容通過修改 DOM 的文本內容，動態改變網頁的內容。\n\ninnerText 將文本內容添加&#x2F;更新到任意標籤位置，文本中包含的標籤不會被解析。\n\n&lt;script&gt;\n  &#x2F;&#x2F; innerText 將文本內容添加&#x2F;更新到任意標籤位置\n  const intro &#x3D; document.querySelector(&#39;.intro&#39;)\n  &#x2F;&#x2F; intro.innerText &#x3D; &#39;嗨~ 我叫李雷！&#39;\n  &#x2F;&#x2F; intro.innerText &#x3D; &#39;&lt;h4&gt;嗨~ 我叫李雷！&lt;&#x2F;h4&gt;&#39;\n&lt;&#x2F;script&gt;\n\n\ninnerHTML 將文本內容添加&#x2F;更新到任意標籤位置，文本中包含的標籤會被解析。\n\n&lt;script&gt;\n  &#x2F;&#x2F; innerHTML 將文本內容添加&#x2F;更新到任意標籤位置\n  const intro &#x3D; document.querySelector(&#39;.intro&#39;)\n  intro.innerHTML &#x3D; &#39;嗨~ 我叫韓梅梅！&#39;\n  intro.innerHTML &#x3D; &#39;&lt;h4&gt;嗨~ 我叫韓梅梅！&lt;&#x2F;h4&gt;&#39;\n&lt;&#x2F;script&gt;\n\n總結：如果文本內容中包含 html 標籤時推薦使用 innerHTML，否則建議使用 innerText 屬性。\n\n\n\n\n\n\n\n\n\n元素.innerText 屬性 只識別文本，不能解析標籤元素.innerHTML 屬性 能識別文本，能夠解析標籤\n操作元素屬性有3種方式可以實現對屬性的修改：\n常用屬性修改\n直接能過屬性名修改，最簡潔的語法\n\n&lt;script&gt;\n  &#x2F;&#x2F; 1. 獲取 img 對應的 DOM 元素\n  const pic &#x3D; document.querySelector(&#39;.pic&#39;)\n  &#x2F;&#x2F; 2. 修改屬性\n  pic.src &#x3D; &#39;.&#x2F;images&#x2F;lion.webp&#39;\n  pic.width &#x3D; 400;\n  pic.alt &#x3D; &#39;圖片不見了...&#39;\n&lt;&#x2F;script&gt;\n\n控制樣式屬性\n應用【修改樣式】，通過修改行內樣式 style 屬性，實現對樣式的動態修改。\n\n通過元素節點獲得的 style 屬性本身的資料類型也是物件，如 box.style.color、box.style.width 分別用來獲取元素節點 CSS 樣式的 color 和 width 的值。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;練習 - 修改樣式&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;隨便一些文本內容&lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取 DOM 節點\n    const box &#x3D; document.querySelector(&#39;.intro&#39;)\n    box.style.color &#x3D; &#39;red&#39;\n    box.style.width &#x3D; &#39;300px&#39;\n    &#x2F;&#x2F; css 屬性的 - 連接子與 JavaScript 的 減運算子\n    &#x2F;&#x2F; 衝突，所以要改成駝峰法\n    box.style.backgroundColor &#x3D; &#39;pink&#39;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n任何標籤都有 style 屬性，通過 style 屬性可以動態更改網頁標籤的樣式，如要遇到 css 屬性中包含字元 - 時，要將 - 去掉並將其後面的字母改成大寫，如 background-color 要寫成 box.style.backgroundColor\n\n操作類名(className) 操作CSS\n\n\n\n\n\n\n\n\n\n\n如果修改的樣式比較多，直接通過style屬性修改比較繁瑣，我們可以通過借助於css類名的形式。直接使用 className 賦值會覆盖以前的類名\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n  &lt;title&gt;練習 - 修改樣式&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        .pink &#123;\n            background: pink;\n            color: hotpink;\n        &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;div class&#x3D;&quot;box&quot;&gt;隨便一些文本內容&lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 獲取 DOM 節點\n    const box &#x3D; document.querySelector(&#39;.intro&#39;)\n    box.className &#x3D; &#39;pink&#39;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n注意：\n1.由於class是關鍵字, 所以使用className去代替\n2.className是使用新值換舊值, 如果需要添加一個類,需要保留之前的類名\n\n通過 classList 操作類控制CSS\n\n\n\n\n\n\n\n\n\n\n為了解決className 容易覆蓋以前的類名，我們可以通過classList方式追加和刪除類名\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n    &lt;style&gt;\n        div &#123;\n            width: 200px;\n            height: 200px;\n            background-color: pink;\n        &#125;\n\n        .active &#123;\n            width: 300px;\n            height: 300px;\n            background-color: hotpink;\n            margin-left: 100px;\n        &#125;\n    &lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n\n    &lt;div class&#x3D;&quot;one&quot;&gt;&lt;&#x2F;div&gt;\n    &lt;script&gt;\n        &#x2F;&#x2F; 1.獲取元素\n        &#x2F;&#x2F; let box &#x3D; document.querySelector(&#39;css選擇器&#39;)\n        let box &#x3D; document.querySelector(&#39;div&#39;)\n        &#x2F;&#x2F; add是個方法 添加  追加\n        &#x2F;&#x2F; box.classList.add(&#39;active&#39;)\n        &#x2F;&#x2F; remove() 移除 類\n        &#x2F;&#x2F; box.classList.remove(&#39;one&#39;)\n        &#x2F;&#x2F; 切換類\n        box.classList.toggle(&#39;one&#39;)\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n動作表單元素屬性表單很多情況，也需要修改屬性，比如點擊眼睛，可以看到密碼，本質是把表單類型轉換為文字方塊\n正常的有屬性有取值的跟其他的標籤屬性沒有任何區別\n獲取:DOM對象.屬性名\n設置:DOM對象.屬性名&#x3D; 新值\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n    &lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;請輸入&quot;&gt;\n    &lt;button disabled&gt;按鈕&lt;&#x2F;button&gt;\n    &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; class&#x3D;&quot;agree&quot;&gt;\n    &lt;script&gt;\n        &#x2F;&#x2F; 1. 獲取元素\n        let input &#x3D; document.querySelector(&#39;input&#39;)\n        &#x2F;&#x2F; 2. 取值或者設置值  得到input裡面的值可以用 value\n        &#x2F;&#x2F; console.log(input.value)\n        input.value &#x3D; &#39;小米手機&#39;\n        input.type &#x3D; &#39;password&#39;\n\n        &#x2F;&#x2F; 2. 啟用按鈕\n        let btn &#x3D; document.querySelector(&#39;button&#39;)\n        &#x2F;&#x2F; disabled 不可用   &#x3D;  false  這樣可以讓按鈕啟用\n        btn.disabled &#x3D; false\n        &#x2F;&#x2F; 3. 勾選核取方塊\n        let checkbox &#x3D; document.querySelector(&#39;.agree&#39;)\n        checkbox.checked &#x3D; false\n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n自訂屬性標準屬性: 標籤天生自帶的屬性 比如class id title等, 可以直接使用點語法操作比如： disabled、checked、selected\n自訂屬性：\n在html5中推出來了專門的data-自訂屬性  \n在標籤上一律以data-開頭\n在DOM物件上一律以dataset物件方式獲取\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;IE&#x3D;edge&quot;&gt;\n    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n\n&lt;&#x2F;head&gt;\n\n&lt;body&gt;\n   &lt;div data-id&#x3D;&quot;1&quot;&gt; 自訂屬性 &lt;&#x2F;div&gt;\n    &lt;script&gt;\n        &#x2F;&#x2F; 1. 獲取元素\n        let div &#x3D; document.querySelector(&#39;div&#39;)\n        &#x2F;&#x2F; 2. 獲取自訂屬性值\n         console.log(div.dataset.id)\n      \n    &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n\n&lt;&#x2F;html&gt;\n\n間歇函數\n\n\n\n\n\n\n\n\n知道間歇函數的作用，利用間歇函數創建定時任務。\nsetInterval 是 JavaScript 中內置的函數，它的作用是間隔固定的時間自動重複執行另一個函數，也叫計時器函數。\n定時器函數可以開啟和關閉定時器\n\n開啟定時器setInterval(函數, 間隔時間)\n\n\n作用：每隔一段時間調用這個函數\n間隔時間單位是毫秒\n\n&lt;script&gt;\n  &#x2F;&#x2F; 1. 定義一個普通函數\n  function repeat() &#123;\n    console.log(&#39;不知疲倦的執行下去....&#39;)\n  &#125;\n\n  &#x2F;&#x2F; 2. 使用 setInterval 調用 repeat 函數\n  &#x2F;&#x2F; 間隔 1000 毫秒，重複調用 repeat\n  setInterval(repeat, 1000)\n&lt;&#x2F;script&gt;\n\n關閉定時器let 變量名 &#x3D; setInterval(函數, 間隔時間)\nclearInterval(變量名)\n\n\n\n\n\n\n\n\n\n\n注意：\n函數名字不需要加括號\n定時器返回的是一個id數字\n\n\n\n\n&lt;script&gt;\n  &#x2F;&#x2F; setInterval(函數名, 間隔時間)  函數名不要加小括號\n  let n &#x3D; setInterval(fn, 1000)\n  &#x2F;&#x2F; setInterval(&#39;fn()&#39;, 1000)\n  console.log(n)\n  &#x2F;&#x2F; 關閉定時器\n  clearInterval(n)\n&lt;&#x2F;script&gt;\n\n用戶註冊倒計時(範例)&lt;textarea name&#x3D;&quot;&quot; id&#x3D;&quot;&quot; cols&#x3D;&quot;30&quot; rows&#x3D;&quot;10&quot;&gt;\n        用戶註冊協議\n        歡迎註冊成為京東用戶！在您註冊過程中，您需要完成我們的註冊流程並通過點擊同意的形式在線簽署以下協議，請您務必仔細閱讀、充分理解協議中的條款內容後再點擊同意（尤其是以粗體或下劃線標識的條款，因為這些條款可能會明確您應履行的義務或對您的權利有所限制）。\n        【請您注意】如果您不同意以下協議全部或任何條款約定，請您停止註冊。您停止註冊後將僅可以瀏覽我們的商品信息但無法享受我們的產品或服務。如您按照註冊流程提示填寫信息，閱讀並點擊同意上述協議且完成全部註冊流程後，即表示您已充分閱讀、理解並接受協議的全部內容，並表明您同意我們可以依據協議內容來處理您的個人信息，並同意我們將您的訂單信息共享給為完成此訂單所必須的第三方合作方（詳情查看\n    &lt;&#x2F;textarea&gt;\n    &lt;br&gt;\n    &lt;button class&#x3D;&quot;btn&quot; disabled&gt;我已經閱讀用戶協議(5)&lt;&#x2F;button&gt;\n    &lt;script&gt;\n        &#x2F;&#x2F; 1. 獲取元素\n        const btn &#x3D; document.querySelector(&#39;.btn&#39;)\n        &#x2F;&#x2F; console.log(btn.innerHTML)  butto按鈕特殊用innerHTML\n        &#x2F;&#x2F; 2. 倒計時\n        let i &#x3D; 5\n        &#x2F;&#x2F; 2.1 開啟定時器\n        let n &#x3D; setInterval(function () &#123;\n            i--\n            btn.innerHTML &#x3D; &#96;我已經閱讀用戶協議($&#123;i&#125;)&#96;\n            if (i &#x3D;&#x3D;&#x3D; 0) &#123;\n                clearInterval(n)  &#x2F;&#x2F; 關閉定時器\n                &#x2F;&#x2F; 定時器停了，我就可以開按鈕\n                btn.disabled &#x3D; false\n                btn.innerHTML &#x3D; &#39;同意&#39;\n            &#125;\n        &#125;, 1000)\n\n    &lt;&#x2F;script&gt;\n輪波圖計時器範例&lt;style&gt;\n  * &#123;\n    box-sizing: border-box;\n  &#125;\n\n  .slider &#123;\n    width: 560px;\n    height: 400px;\n    overflow: hidden;\n  &#125;\n\n  .slider-wrapper &#123;\n    width: 100%;\n    height: 320px;\n  &#125;\n\n  .slider-wrapper img &#123;\n    width: 100%;\n    height: 100%;\n    display: block;\n  &#125;\n\n  .slider-footer &#123;\n    height: 80px;\n    background-color: rgb(100, 67, 68);\n    padding: 12px 12px 0 12px;\n    position: relative;\n  &#125;\n\n  .slider-footer .toggle &#123;\n    position: absolute;\n    right: 0;\n    top: 12px;\n    display: flex;\n  &#125;\n\n  .slider-footer .toggle button &#123;\n    margin-right: 12px;\n    width: 28px;\n    height: 28px;\n    appearance: none;\n    border: none;\n    background: rgba(255, 255, 255, 0.1);\n    color: #fff;\n    border-radius: 4px;\n    cursor: pointer;\n  &#125;\n\n  .slider-footer .toggle button:hover &#123;\n    background: rgba(255, 255, 255, 0.2);\n  &#125;\n\n  .slider-footer p &#123;\n    margin: 0;\n    color: #fff;\n    font-size: 18px;\n    margin-bottom: 10px;\n  &#125;\n\n  .slider-indicator &#123;\n    margin: 0;\n    padding: 0;\n    list-style: none;\n    display: flex;\n    align-items: center;\n  &#125;\n\n  .slider-indicator li &#123;\n    width: 8px;\n    height: 8px;\n    margin: 4px;\n    border-radius: 50%;\n    background: #fff;\n    opacity: 0.4;\n    cursor: pointer;\n  &#125;\n\n  .slider-indicator li.active &#123;\n    width: 12px;\n    height: 12px;\n    opacity: 1;\n  &#125;\n&lt;&#x2F;style&gt;\n&lt;div class&#x3D;&quot;slider&quot;&gt;\n    &lt;div class&#x3D;&quot;slider-wrapper&quot;&gt;\n      &lt;img src&#x3D;&quot;.&#x2F;images&#x2F;slider01.jpg&quot; alt&#x3D;&quot;&quot; &#x2F;&gt;\n    &lt;&#x2F;div&gt;\n    &lt;div class&#x3D;&quot;slider-footer&quot;&gt;\n      &lt;p&gt;對人類來說會不會太超前了？ &lt;&#x2F;p&gt;\n      &lt;ul class&#x3D;&quot;slider-indicator&quot;&gt;\n        &lt;li class&#x3D;&quot;active&quot;&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n        &lt;li&gt;&lt;&#x2F;li&gt;\n      &lt;&#x2F;ul&gt;\n      &lt;div class&#x3D;&quot;toggle&quot;&gt;\n        &lt;button class&#x3D;&quot;prev&quot;&gt;&lt;&lt;&#x2F;button&gt;\n        &lt;button class&#x3D;&quot;next&quot;&gt;&gt;&lt;&#x2F;button&gt;\n      &lt;&#x2F;div&gt;\n    &lt;&#x2F;div&gt;\n  &lt;&#x2F;div&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 1. 初始數據\n    const sliderData &#x3D; [\n      &#123; url: &#39;.&#x2F;images&#x2F;slider01.jpg&#39;, title: &#39;對人類來說會不會太超前了？ &#39;, color: &#39;rgb(100, 67, 68)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider02.jpg&#39;, title: &#39;開啟劍與雪的黑暗傳說！ &#39;, color: &#39;rgb(43, 35, 26)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider03.jpg&#39;, title: &#39;真正的jo廚出現了！ &#39;, color: &#39;rgb(36, 31, 33)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider04.jpg&#39;, title: &#39;李玉剛：讓世界通過B站看到東方大國文化&#39;, color: &#39;rgb(139, 98, 66)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider05.jpg&#39;, title: &#39;快來分享你的寒假日常吧~&#39;, color: &#39;rgb(67, 90, 92)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider06.jpg&#39;, title: &#39;嗶哩嗶哩小年YEAH&#39;, color: &#39;rgb(166, 131, 143)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider07.jpg&#39;, title: &#39;一站式解決你的電腦配置問題！ ！ ！ &#39;, color: &#39;rgb(53, 29, 25)&#39; &#125;,\n      &#123; url: &#39;.&#x2F;images&#x2F;slider08.jpg&#39;, title: &#39;誰不想和小貓咪貼貼呢！ &#39;, color: &#39;rgb(99, 72, 114)&#39; &#125;,\n    ]\n    &#x2F;&#x2F; 1. 獲取元素 \n    const img &#x3D; document.querySelector(&#39;.slider-wrapper img&#39;)\n    const p &#x3D; document.querySelector(&#39;.slider-footer p&#39;)\n    let i &#x3D; 0  &#x2F;&#x2F; 信號量 控製圖片的張數\n    &#x2F;&#x2F; 2. 開啟定時器\n    &#x2F;&#x2F; console.log(sliderData[i])  拿到對應的對象啦\n    setInterval(function () &#123;\n      i++\n      &#x2F;&#x2F; 無縫銜接位置  一共八張圖片，到了最後一張就是 8， 數組的長度就是 8\n      if (i &gt;&#x3D; sliderData.length) &#123;\n        i &#x3D; 0\n      &#125;\n      &#x2F;&#x2F; console.log(i)\n      &#x2F;&#x2F; console.log(sliderData[i])\n      &#x2F;&#x2F; 更換圖片路徑  \n      img.src &#x3D; sliderData[i].url\n      &#x2F;&#x2F; 把字寫到 p裡面\n      p.innerHTML &#x3D; sliderData[i].title\n      &#x2F;&#x2F; 小圓點\n      &#x2F;&#x2F; 先刪除以前的active\n      document.querySelector(&#39;.slider-indicator .active&#39;).classList.remove(&#39;active&#39;)\n      &#x2F;&#x2F; 只讓當前li添加active\n      document.querySelector(&#96;.slider-indicator li:nth-child($&#123;i + 1&#125;)&#96;).classList.add(&#39;active&#39;)\n    &#125;, 1000)\n\n  &lt;&#x2F;script&gt;\n\n分析：\n\n①：準備一個數組對象，裡麵包含詳細信息（素材包含）\n②：獲取元素\n③：設置定時器函數\n設置一個變量++\n找到變量對應的對象\n更改圖片、文字信息\n激活小圓點：移除上一個高亮的類名，當前變量對應的小圓點添加類\n\n\n④：處理圖片自動復原從頭播放（放到變量++後面，緊挨）\n如果圖片播放到最後一張， 就是大於等於數組的長度\n則把變量重置為0\n\n\n\n","slug":"20230323JavaScript Web APIs - 第1天","date":"2023-03-23T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"866ec5a135e50f1f3d3c59488d09d968","title":"JavaScript 基礎 - 第5天","content":"\n\n\n\n\n\n\n\n\n知道物件資料類型的特徵，能夠利用陣列物件渲染頁面\n\n理解什麼是物件，掌握定義物件的語法\n掌握數學物件的使用\n\n對象\n\n\n\n\n\n\n\n\n物件為無序的資料的集合，是 JavaScript 資料類型的一種，之前已經學習了數數值型別、字串類型、布林類型、undefined。物件資料類型可以被理解成是一種資料集合。它由屬性和方法兩部分構成。\n語法聲明一個物件類型的變數與之前聲明一個數值或字串類型的變數沒有本質上的區別。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 聲明字串類型變數\n    let str &#x3D; &#39;hello world!&#39;\n    \n    &#x2F;&#x2F; 聲明數數值型別變數\n    let num &#x3D; 199\n\n    &#x2F;&#x2F; 聲明物件類型變數，使用一對花括弧\n    &#x2F;&#x2F; user 便是一個物件了，目前它是一個空物件\n    let user &#x3D; &#123;&#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n物件使用-增刪改查&#x2F;&#x2F;聲明let 對象名 &#x3D; {  uname: ‘ben’,  age: 18,  gender: ‘男’}&#x2F;&#x2F; console.log(ben)\n&#x2F;&#x2F; 改 把性別的女改為男對象名.屬性 &#x3D; ‘男’console.log(對象名)\n  &#x2F;&#x2F; 增 對象名.屬性 &#x3D; ‘足球’console.log(對象名)\n  &#x2F;&#x2F; 刪 (瞭解) delete 對象名.屬性console.log(對象名)\n屬性和訪問資料描述性的資訊稱為屬性，如人的姓名、身高、年齡、性別等，一般是名詞性的。\n\n屬性都是成 對出現的，包括屬性名和值，它們之間使用英文 : 分隔\n多個屬性之間使用英文 , 分隔\n屬性就是依附在物件上的變數\n屬性名可以使用 &quot;&quot; 或 &#39;&#39;，一般情況下省略，除非名稱遇到特殊符號如空格、中橫線等\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 通過物件描述一個人的資料資訊\n    &#x2F;&#x2F; person 是一個物件，它包含了一個屬性 name\n    &#x2F;&#x2F; 屬性都是成對出現的，屬性名 和 值，它們之間使用英文 : 分隔\n    let person &#x3D; &#123;\n      name: &#39;小明&#39;, &#x2F;&#x2F; 描述人的姓名\n      age: 18, &#x2F;&#x2F; 描述人的年齡\n      stature: 185, &#x2F;&#x2F; 描述人的身高\n      gender: &#39;男&#39;, &#x2F;&#x2F; 描述人的性別\n    &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n聲明物件，並添加了若干屬性後，可以使用 . 或 [] 獲得物件中屬性對應的值，我稱之為屬性訪問。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 通過物件描述一個人的資料資訊\n    &#x2F;&#x2F; person 是一個物件，它包含了一個屬性 name\n    &#x2F;&#x2F; 屬性都是成對出現的，屬性名 和 值，它們之間使用英文 : 分隔\n    let person &#x3D; &#123;\n      name: &#39;小明&#39;, &#x2F;&#x2F; 描述人的姓名\n      age: 18, &#x2F;&#x2F; 描述人的年齡\n      stature: 185, &#x2F;&#x2F; 描述人的身高\n      gender: &#39;男&#39;, &#x2F;&#x2F; 描述人的性別\n    &#125;;\n    \n    &#x2F;&#x2F; 訪問人的名字\n    console.log(person.name) &#x2F;&#x2F; 結果為 小明\n    &#x2F;&#x2F; 訪問人性別\n    console.log(person.gender) &#x2F;&#x2F; 結果為 男\n    &#x2F;&#x2F; 訪問人的身高\n    console.log(person[&#39;stature&#39;]) &#x2F;&#x2F; 結果為 185\n   &#x2F;&#x2F; 或者\n    console.log(person.stature) &#x2F;&#x2F; 結果同為 185\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n擴展：也可以動態為物件添加屬性，動態添加與直接定義是一樣的，只是語法上更靈活。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 聲明一個空的物件（沒有任何屬性）\n  let user &#x3D; &#123;&#125;\n    &#x2F;&#x2F; 動態追加屬性\n    user.name &#x3D; &#39;小明&#39;\n    user[&#39;age&#39;] &#x3D; 18\n    \n    &#x2F;&#x2F; 動態添加與直接定義是一樣的，只是語法上更靈活\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n方法和調用資料行為性的資訊稱為方法，如跑步、唱歌等，一般是動詞性的，其本質是函數。\n\n方法是由方法名和函數兩部分構成，它們之間使用 : 分隔\n多個屬性之間使用英文 , 分隔\n方法是依附在物件中的函數\n方法名可以使用 &quot;&quot; 或 &#39;&#39;，一般情況下省略，除非名稱遇到特殊符號如空格、中橫線等\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件方法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 方法是依附在物件上的函數\n    let person &#x3D; &#123;\n      name: &#39;小紅&#39;,\n      age: 18,\n      &#x2F;&#x2F; 方法是由方法名和函數兩部分構成，它們之間使用 : 分隔\n      singing: function () &#123;\n        console.log(&#39;兩隻老虎，兩隻老虎，跑的快，跑的快...&#39;)\n      &#125;,\n      run: function () &#123;\n        console.log(&#39;我跑的非常快...&#39;)\n      &#125;\n    &#125;\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n聲明物件，並添加了若干方法後，可以使用 . 或 [] 調用物件中函數，我稱之為方法調用。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件方法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 方法是依附在物件上的函數\n    let person &#x3D; &#123;\n      name: &#39;小紅&#39;,\n      age: 18,\n      &#x2F;&#x2F; 方法是由方法名和函數兩部分構成，它們之間使用 : 分隔\n      singing: function () &#123;\n        console.log(&#39;兩隻老虎，兩隻老虎，跑的快，跑的快...&#39;)\n      &#125;,\n      run: function () &#123;\n        console.log(&#39;我跑的非常快...&#39;)\n      &#125;\n    &#125;\n    \n    &#x2F;&#x2F; 調用物件中 singing 方法\n    person.singing()\n    &#x2F;&#x2F; 調用物件中的 run 方法\n    person.run()\n\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n擴展：也可以動態為物件添加方法，動態添加與直接定義是一樣的，只是語法上更靈活。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 物件方法&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 聲明一個空的物件（沒有任何屬性，也沒有任何方法）\n  let user &#x3D; &#123;&#125;\n    &#x2F;&#x2F; 動態追加屬性\n    user.name &#x3D; &#39;小明&#39;\n    user.[&#39;age&#39;] &#x3D; 18\n    \n    &#x2F;&#x2F; 動態添加方法\n    user.move &#x3D; function () &#123;\n      console.log(&#39;移動一點距離...&#39;)\n    &#125;\n    \n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n注：無論是屬性或是方法，同一個物件中出現名稱一樣的，後面的會覆蓋前面的。\nnullnull 也是 JavaScript 中資料類型的一種，通常只用它來表示不存在的物件。使用 typeof 檢測類型它的類型時，結果為 object。\n遍歷對象\n\n\n\n\n\n\n\n\n目標：能夠遍歷輸出物件裡面的元素for 遍歷物件的問題：Ø 物件沒有像陣列一樣的length屬性,所以無法確定長度Ø 物件裡面是無序的鍵值對, 沒有規律. 不像陣列裡面有規律的下標\nlet obj &#x3D; &#123;\n    uname: &#39;pink&#39;\n&#125;\nfor(let k in obj) &#123;\n    &#x2F;&#x2F; k 屬性名  字串  帶引號    obj.&#39;uname&#39;     k &#x3D;&#x3D;&#x3D;  &#39;uname&#39;\n    &#x2F;&#x2F; obj[k]  屬性值    obj[&#39;uname&#39;]   obj[k]\n&#125;\n\n\n\n\n\n\n\n\n\n\nfor in 不提倡遍歷陣列 因為 k 是 字串for in語法中的 k 是一個變數, 在迴圈的過程中依次代表物件的屬性名由於 k 是變數, 所以必須使用 [ ] 語法解析一定記住： k 是獲得物件的屬性名， 物件名[k] 是獲得 屬性值\n內置對象回想一下我們曾經使用過的 console.log，console其實就是 JavaScript 中內置的物件，該物件中存在一個方法叫 log，然後調用 log 這個方法，即 console.log()。\n除了 console 物件外，JavaScritp 還有其它的內置的物件\nMathMath 是 JavaScript 中內置的物件，稱為數學物件，這個物件下即包含了屬性，也包含了許多的方法。\n屬性\nMath.PI，獲取圓周率\n\n&#x2F;&#x2F; 圓周率\nconsole.log(Math.PI);\n\n方法\nMath.random，生成 0 到 1 間的亂數\n\n&#x2F;&#x2F; 0 ~ 1 之間的亂數, 包含 0 不包含 1\nMath.random()\n\n\nMath.ceil，數字向上取整\n\n&#x2F;&#x2F; 捨棄小數部分，整數部分加1\nMath.ceil(3.4)\n\n\nMath.floor，數字向下取整\n\n&#x2F;&#x2F; 捨棄小數部分，整數部分不變\nMath.floor(4.68)\n\n\nMath.round，四捨五入取整\n\n&#x2F;&#x2F; 取整，四捨五入原則\nMath.round(5.46539)\nMath.round(4.849)\n\n\nMath.max，在一組數中找出最大的\n\n&#x2F;&#x2F; 找出最大值\nMath.max(10, 21, 7, 24, 13)\n\n\nMath.min，在一組數中找出最小的\n\n&#x2F;&#x2F; 找出最小值\nMath.min(24, 18, 6, 19, 21)\n\n\nMath.pow，冪方法\n\n&#x2F;&#x2F; 求某個數的多少次方\nMath.pow(4, 2) &#x2F;&#x2F; 求 4 的 2 次方\nMath.pow(2, 3) &#x2F;&#x2F; 求 2 的 3 次方\n\n\nMath.sqrt，平方根\n\n&#x2F;&#x2F; 求某數的平方根\nMath.sqrt(16)\n\n數學物件提供了比較多的方法，這裡不要求強記，通過演示數學物件的使用，加深對物件的理解。拓展- 基底資料型別和引用資料類型\n\n\n\n術語\n解釋\n舉例\n\n\n\n關鍵字\n在JavaScript中有特殊意義的詞彙\nlet、var、function、if、else、switch、case、break\n\n\n保留字\n在目前的JavaScript中沒意義，但未來可能會具有特殊意義的詞彙\nint、short、long、char\n\n\n標識（識別字）\n變數名、函數名的另一種叫法\n無\n\n\n運算式\n能產生值的代碼，一般配合運算子出現\n10 + 3、age &gt;&#x3D; 18\n\n\n語句\n一段可執行的代碼\nIf () for()\n\n\n目標：瞭解基底資料型別和引用資料類型的存儲方式簡單類型又叫做基底資料型別或者數值型別，複雜類型又叫做參考類型。\n\n\n\n\n\n\n\n\n\n數值型別：單一資料型別&#x2F;基底資料型別，在存儲時變數中存儲的是值本身，因此叫做數值型別string ，number，boolean，undefined，null\n\n\n\n\n\n\n\n\n\n參考類型：複雜資料類型，在存儲時變數中存儲的僅僅是位址（引用），因此叫做引用資料類型通過 new 關鍵字創建的物件（系統物件、自訂物件），如 Object、Array、Date等\n","slug":"20230322JavaScript 基礎 - 第5天","date":"2023-03-21T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"eddf66a4e61c3de8ab537ceecfc30415","title":"JavaScript 基礎 - 第4天","content":"\n\n\n\n\n\n\n\n\n理解封裝的意義，能夠通過函數的聲明實現邏輯的封裝，知道物件資料類型的特徵，結合數學物件實現簡單計算功能。\n\n理解函數的封裝的特徵\n掌握函式宣告的語法\n理解什麼是函數的返回值\n知道並能使用常見的內置函數\n\n函數\n\n\n\n\n\n\n\n\n-理解函數的封裝特性，掌握函數的語法規則-function，是被設計為執行特定任務的代碼塊\n聲明和調用函數可以把具有相同或相似邏輯的代碼“包裹”起來，通過函式呼叫執行這些被“包裹”的代碼邏輯，這麼做的優勢是有利於精簡代碼方便複用。\n聲明（定義）\n\n\n\n\n\n\n\n\n聲明（定義）一個完整函數包括關鍵字(function)、函數名、形式參數、函數體、返回值5個部分\nfunction 函數名(形式參數)&#123;\n  函數體\n  (返回值)\n&#125;\n\n調用聲明（定義）的函數必須調用才會真正被執行，使用 () 調用函數。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 聲明和調用&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 聲明（定義）了最簡單的函數，既沒有形式參數，也沒有返回值\n    function sayHi() &#123;\n      console.log(&#39;嗨~&#39;)\n    &#125;\n    &#x2F;&#x2F; 函式呼叫，這些函數體內的代碼邏輯會被執行\n    &#x2F;&#x2F; 函數名()\n        \n    sayHi()\n    &#x2F;&#x2F; 可以重複被調用，多少次都可以\n    sayHi()\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n\n\n\n\n\n\n\n\n注：函數名的命名規則與變數是一致的，並且儘量保證函數名的語義。\n小案例： 小星星\n&lt;script&gt;\n        &#x2F;&#x2F; 函式宣告\n        function sayHi() &#123;\n            &#x2F;&#x2F; document.write(&#39;hai~&#39;)\n            document.write(&#96;*&lt;br&gt;&#96;)\n            document.write(&#96;**&lt;br&gt;&#96;)\n            document.write(&#96;***&lt;br&gt;&#96;)\n            document.write(&#96;****&lt;br&gt;&#96;)\n            document.write(&#96;*****&lt;br&gt;&#96;)\n            document.write(&#96;******&lt;br&gt;&#96;)\n            document.write(&#96;*******&lt;br&gt;&#96;)\n            document.write(&#96;********&lt;br&gt;&#96;)\n            document.write(&#96;*********&lt;br&gt;&#96;)\n        &#125;\n        &#x2F;&#x2F; 函式呼叫\n        sayHi()\n        sayHi()\n        sayHi()\n        sayHi()\n        sayHi()\n    &lt;&#x2F;script&gt;\n\n參數通過向函數傳遞參數，可以讓函數更加靈活多變，參數可以理解成是一個變數。\n聲明（定義）一個功能為打招呼的函數\n\n傳入數據清單\n聲明這個函數需要傳入幾個資料\n多個資料用逗號隔開\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 函數參數&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 聲明（定義）一個功能為打招呼的函數\n    &#x2F;&#x2F; function sayHi() &#123;\n    &#x2F;&#x2F;   console.log(&#39;嗨~&#39;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; 調用函數\n    &#x2F;&#x2F; sayHi()\n  \n\n    &#x2F;&#x2F; 這個函數似乎沒有什麼價值，除非能夠向不同的人打招呼\n    &#x2F;&#x2F; 這就需要借助參數來實現了\n    function sayHi(name) &#123;\n      &#x2F;&#x2F; 參數 name 可以被理解成是一個變數\n      console.log(name)\n      console.log(&#39;嗨~&#39; + name)\n    &#125;\n\n    &#x2F;&#x2F; 調用 sayHi 函數，括弧中多了 &#39;小明&#39;\n    &#x2F;&#x2F; 這時相當於為參數 name 賦值了\n    sayHi(&#39;小明&#39;)&#x2F;&#x2F; 結果為 小明\n\n    &#x2F;&#x2F; 再次調用 sayHi 函數，括弧中多了 &#39;小紅&#39;\n    &#x2F;&#x2F; 這時相當於為參數 name 賦值了\n    sayHi(&#39;小紅&#39;) &#x2F;&#x2F; 結果為 小紅\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n總結：\n\n聲明（定義）函數時的形參沒有數量限制，當有多個形參時使用 , 分隔\n調用函數傳遞的實參要與形參的順序一致\n\n形參和實參形參：聲明函數時寫在函數名右邊小括弧裡的叫形參（形式上的參數）\n實參：調用函數時寫在函數名右邊小括弧裡的叫實參（實際上的參數）\n形參可以理解為是在這個函數內聲明的變數（比如 num1 &#x3D; 10）實參可以理解為是給這個變數賦值\n開發中儘量保持形參和實參個數一致\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 函數參數&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;script&gt;\n    &#x2F;&#x2F; 聲明（定義）一個計算任意兩數位和的函數\n    &#x2F;&#x2F; 形參 x 和 y 分別表示任意兩個數字，它們是兩個變數\n    function count(x, y) &#123;\n      console.log(x + y);\n    &#125;\n    &#x2F;&#x2F; 調用函數，傳入兩個具體的數字做為實參\n    &#x2F;&#x2F; 此時 10 賦值給了形參 x\n    &#x2F;&#x2F; 此時 5  賦值給了形參 y\n    count(10, 5); &#x2F;&#x2F; 結果為 15\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n返回值函數的本質是封裝（包裹），函數體內的邏輯執行完畢後，函數外部如何獲得函數內部的執行結果呢？要想獲得函數內部邏輯的執行結果，需要通過 return 這個關鍵字，將內部執行結果傳遞到函數外部，這個被傳遞到外部的結果就是返回值。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 函數返回值&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n\n  &lt;script&gt;\n    &#x2F;&#x2F; 定義求和函數\n    function count(a, b) &#123;\n      let s &#x3D; a + b\n      &#x2F;&#x2F; s 即為 a + b 的結果\n      &#x2F;&#x2F; 通過 return 將 s 傳遞到外部\n      return s\n    &#125;\n\n    &#x2F;&#x2F; 調用函數，如果一個函數有返回值\n    &#x2F;&#x2F; 那麼可將這個返回值賦值給外部的任意變數\n    let total &#x3D; count(5, 12)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n總結：\n\n在函數體中使用return 關鍵字能將內部的執行結果交給函數外部使用\n\n函數內部只能出現1 次 return，並且 return 下一行代碼不會再被執行，所以return 後面的資料不要換行寫\n\nreturn會立即結束當前函數\n\n函數可以沒有return，這種情況預設返回值為 undefined\n\n#ˇ數組返回多個變量\n\n\n作用域通常來說，一段程式碼中所用到的名字並不總是有效和可用的，而限定這個名字的可用性的代碼範圍就是這個名字的作用域。\n作用域的使用提高了程式邏輯的局部性，增強了程式的可靠性，減少了名字衝突。\n全域作用域作用於所有代碼執行的環境(整個 script 標籤內部)或者一個獨立的 js 檔\n處於全域作用域內的變數，稱為全域變數\n局部作用域作用於函數內的代碼環境，就是局部作用域。 因為跟函數有關係，所以也稱為函數作用域。\n處於局部作用域內的變數稱為區域變數\n\n\n\n\n\n\n\n\n\n如果函數內部，變數沒有聲明，直接賦值，也當全域變數看，但是強烈不推薦\n但是有一種情況，函數內部的形參可以看做是區域變數。\n變數的訪問原則\n\n\n\n\n\n\n\n\n只要是代碼，就至少有一個作用域寫在函數內部的局部作用域如果函數中還有函數，那麼在這個作用域中就又可以誕生一個作用域訪問原則：在能夠訪問到的情況下 先局部， 局部沒有在找全域\n匿名函數函數可以分為具名函數和匿名函數\n具名函數function fn(){}\n匿名函數：沒有名字的函數,無法直接使用。function {}\n函數運算式&#x2F;&#x2F; 聲明\nlet fn &#x3D; function() &#123; \n   console.log(&#39;函數運算式&#39;)\n&#125;\n&#x2F;&#x2F; 調用\nfn()\n\n立即執行函數立即執行函數可 防止變數污染\n(function(形參)&#123; xxx  &#125;)(實參);\n(function(形參)&#123;xxxx&#125;(實參));\n\n\n\n\n\n\n\n\n\n\n無需調用，立即執行，其實本質已經調用了\n多個立即執行函數之間用分號隔開\n   在能夠訪問到的情況下 先局部 局部沒有在找全域\n","slug":"20230321JavaScript 基礎 - 第4天","date":"2023-03-20T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"d6326a002590bf2cbb1500ce76554880","title":"JavaScript 基礎 - 第3天","content":"if 多分支語句和 switch的區別：\n\n共同點\n\n都能實現多分支選擇， 多選1 \n大部分情況下可以互換\n\n\n區別：\n\nswitch…case語句通常處理case為比較確定值的情況，而if…else…語句更加靈活，通常用於範圍判斷(大於，等於某個範圍)。\nswitch 語句進行判斷後直接執行到程式的語句，效率更高，而if…else語句有幾種判斷條件，就得判斷多少次\nswitch 一定要注意 必須是 &#x3D;&#x3D;&#x3D;  全等，一定注意 資料類型，同時注意break否則會有穿透效果\n結論：\n當分支比較少時，if…else語句執行效率高。\n當分支比較多時，switch語句執行效率高，而且結構更清晰。\n\n\n\n\n\nfor 語句\n\n\n\n\n\n\n\n\n掌握 for 迴圈語句，讓程式具備重複執行能力\nfor 是 JavaScript 提供的另一種迴圈控制的話句，它和 while 只是語法上存在差異。\nfor語句的基本使用\n實現迴圈的 3 要素(起始值; 終止條件; 變化量)\n\n&lt;script&gt;\n  &#x2F;&#x2F; 1. 語法格式\n  &#x2F;&#x2F; for(起始值; 終止條件; 變化量) &#123;\n  &#x2F;&#x2F;   &#x2F;&#x2F; 要重複執行的代碼\n  &#x2F;&#x2F; &#125;\n\n  &#x2F;&#x2F; 2. 示例：在網頁中輸入標題標籤\n  &#x2F;&#x2F; 起始值為 1\n  &#x2F;&#x2F; 變化量 i++\n  &#x2F;&#x2F; 終止條件 i &lt;&#x3D; 6\n  for(let i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;\n    document.write(&#96;&lt;h$&#123;i&#125;&gt;迴圈控制，即重複執行&lt;h$&#123;i&#125;&gt;&#96;)\n  &#125;\n&lt;&#x2F;script&gt;\n\n\n變化量和閉環，for 迴圈和 while 一樣，如果不合理設置增量和終止條件，便會產生閉環。\n\n跳出和終止迴圈\n\n\n&lt;script&gt;\n    &#x2F;&#x2F; 1. continue \n    for (let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n        if (i &#x3D;&#x3D;&#x3D; 3) &#123;\n            continue  &#x2F;&#x2F; 結束本次迴圈，繼續下一次迴圈\n        &#125;\n        console.log(i)\n    &#125;\n    &#x2F;&#x2F; 2. break\n    for (let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n        if (i &#x3D;&#x3D;&#x3D; 3) &#123;\n            break  &#x2F;&#x2F; 退出結束整個迴圈\n        &#125;\n        console.log(i)\n    &#125;\n&lt;&#x2F;script&gt;\n\n結論：\n\nJavaScript 提供了多種語句來實現迴圈控制，但無論使用哪種語句都離不開迴圈的3個特徵，即起始值、變化量、終止條件，做為初學者應著重體會這3個特徵，不必過多糾結三種語句的區別。\n起始值、變化量、終止條件，由開發者根據邏輯需要進行設計，規避閉環的發生。\n當如果明確了迴圈的次數的時候推薦使用for迴圈,當不明確迴圈的次數的時候推薦使用while迴圈\n\n\n\n\n\n\n\n\n\n\n注意：for 的語法結構更簡潔，故 for 迴圈的使用頻次會更多。\n迴圈嵌套利用迴圈的知識來對比一個簡單的天文知識，我們知道地球在自轉的同時也在圍繞太陽公轉，如果把自轉和公轉都看成是迴圈的話，就相當於是迴圈中又嵌套了另一個迴圈。\nfor(外部聲明紀錄循環次數的變量;循環條件;變化值)&#123;\n  for(內部聲明紀錄循環次數的變量;循環條件;變化值)&#123;\n    循環體\n  &#125;\n&#125;\n\n實際上 JavaScript 中任何一種迴圈語句都支持迴圈的嵌套，如下代碼所示：\n&#x2F;&#x2F; 1. 外面的迴圈 記錄第n天 \nfor (let i &#x3D; 1; i &lt; 4; i++) &#123;\n    document.write(&#96;第$&#123;i&#125;天 &lt;br&gt;&#96;)\n    &#x2F;&#x2F; 2. 裡層的迴圈記錄 幾個單詞\n    for (let j &#x3D; 1; j &lt; 6; j++) &#123;\n        document.write(&#96;記住第$&#123;j&#125;個單詞&lt;br&gt;&#96;)\n    &#125;\n&#125;\n\n記住，外層迴圈迴圈一次，裡層迴圈迴圈全部\n倒三角 &#x2F;&#x2F; 外層列印幾行\nfor (let i &#x3D; 1; i &lt;&#x3D; 5; i++) &#123;\n    &#x2F;&#x2F; 裡層列印幾個星星\n    for (let j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;\n        document.write(&#39;★&#39;)\n    &#125;\n    document.write(&#39;&lt;br&gt;&#39;)\n&#125;\n★★★★★★★★★★★★★★★\n九九乘法表樣式css\nspan &#123;\n    display: inline-block;\n    width: 100px;\n    padding: 5px 10px;\n    border: 1px solid pink;\n    margin: 2px;\n    border-radius: 5px;\n    box-shadow: 2px 2px 2px rgba(255, 192, 203, .4);\n    background-color: rgba(255, 192, 203, .1);\n    text-align: center;\n    color: hotpink;\n&#125;\n\njavascript \n &#x2F;&#x2F; 外層列印幾行\nfor (let i &#x3D; 1; i &lt;&#x3D; 9; i++) &#123;\n    &#x2F;&#x2F; 裡層列印幾個星星\n    for (let j &#x3D; 1; j &lt;&#x3D; i; j++) &#123;\n        &#x2F;&#x2F; 只需要吧 ★ 換成  1 x 1 &#x3D; 1   \n        document.write(&#96;\n    &lt;div&gt; $&#123;j&#125; x $&#123;i&#125; &#x3D; $&#123;j * i&#125; &lt;&#x2F;div&gt;\n     &#96;)\n    &#125;\n    document.write(&#39;&lt;br&gt;&#39;)\n&#125;\n\n陣列\n\n\n\n\n\n\n\n\n知道什麼是陣列及其應用的場景，掌握陣列聲明及訪問的語法。\n陣列是什麼？陣列：(Array)是一種可以按順序保存資料的資料類型\n使用場景：如果有多個資料可以用陣列保存起來，然後放到一個變數中，管理非常方便\n陣列的基本使用定義陣列和陣列單元&lt;script&gt;\n  &#x2F;&#x2F; 1. 語法，使用 [] 來定義一個空陣列\n  &#x2F;&#x2F; 定義一個空陣列，然後賦值給變數 classes\n  &#x2F;&#x2F; let classes &#x3D; [];\n\n  &#x2F;&#x2F; 2. 定義非空陣列\n  let classes &#x3D; [&#39;小明&#39;, &#39;小剛&#39;, &#39;小紅&#39;, &#39;小麗&#39;, &#39;小米&#39;]\n&lt;&#x2F;script&gt;\n\n通過 [] 定義陣列，資料中可以存放真正的資料，如小明、小剛、小紅等這些都是陣列中的資料，我們這些資料稱為陣列單元，陣列單元之間使用英文逗號分隔。\n訪問陣列和陣列索引使用陣列存放資料並不是最終目的，關鍵是能夠隨時的訪問到陣列中的資料（單元）。其實 JavaScript 為陣列中的每一個資料單元都編了號，通過資料單元在陣列中的編號便可以輕鬆訪問到陣列中的資料單元了。\n我們將資料單元在陣列中的編號稱為索引值，也有人稱其為下標。\n索引值實際是按著資料單元在陣列中的位置依次排列的，注意是從 0 開始的\n&lt;script&gt;\n  let classes &#x3D; [&#39;小明&#39;, &#39;小剛&#39;, &#39;小紅&#39;, &#39;小麗&#39;, &#39;小米&#39;]\n  \n  &#x2F;&#x2F; 1. 訪問陣列，語法格式為：變數名[索引值]\n  document.write(classes[0]) &#x2F;&#x2F; 結果為：小明\n  document.write(classes[1]) &#x2F;&#x2F; 結果為：小剛\n  document.write(classes[4]) &#x2F;&#x2F; 結果為：小米\n  \n  &#x2F;&#x2F; 2. 通過索引值還可以為陣列單重新賦值\n  document.write(classes[3]) &#x2F;&#x2F; 結果為：小麗\n  &#x2F;&#x2F; 重新為索引值為 3 的單元賦值\n  classes[3] &#x3D; &#39;小小麗&#39;\n  document.wirte(classes[3]); &#x2F;&#x2F; 結果為： 小小麗\n&lt;&#x2F;script&gt;\n\n資料單元數值型別陣列做為資料的集合，它的單元值可以是任意資料類型\n&lt;script&gt;\n  &#x2F;&#x2F; 6. 陣列單數值型別可以是任意資料類型\n\n  &#x2F;&#x2F; a) 陣列單元值的類型為字元類型\n  let list &#x3D; [&#39;HTML&#39;, &#39;CSS&#39;, &#39;JavaScript&#39;]\n  &#x2F;&#x2F; b) 陣列單元值的類型為數值類型\n  let scores &#x3D; [78, 84, 70, 62, 75]\n  &#x2F;&#x2F; c) 混合多種類型\n  let mixin &#x3D; [true, 1, false, &#39;hello&#39;]\n&lt;&#x2F;script&gt;\n\n陣列長度屬性重申一次，陣列在 JavaScript 中並不是新的資料類型，它屬於物件類型。\n&lt;script&gt;\n  &#x2F;&#x2F; 定義一個陣列\n  let arr &#x3D; [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n  &#x2F;&#x2F; 陣列對應著一個 length 屬性，它的含義是獲取陣列的長度\n  console.log(arr.length) &#x2F;&#x2F; 3\n&lt;&#x2F;script&gt;\n\n運算元組陣列做為物件資料類型，不但有 length 屬性可以使用，還提供了許多方法：\n\npush 動態向陣列的尾部添加一個單元\nunshit 動態向陣列頭部添加一個單元\npop 刪除最後一個單元\nshift 刪除第一個單元\nsplice 動態刪除任意單元\n\n使用以上4個方法時，都是直接在原陣列上進行操作，即成功調任何一個方法，原陣列都跟著發生相應的改變。並且在添加或刪除單元時 length 並不會發生錯亂。\n&lt;script&gt;\n  &#x2F;&#x2F; 定義一個陣列\n  let arr &#x3D; [&#39;html&#39;, &#39;css&#39;, &#39;javascript&#39;]\n\n  &#x2F;&#x2F; 1. push 動態向陣列的尾部添加一個單元\n  arr.push(&#39;Nodejs&#39;)\n  console.log(arr)\n  arr.push(&#39;Vue&#39;)\n\n  &#x2F;&#x2F; 2. unshit 動態向陣列頭部添加一個單元\n  arr.unshift(&#39;VS Code&#39;)\n  console.log(arr)\n\n  &#x2F;&#x2F; 3. splice 動態刪除任意單元\n  arr.splice(2, 1) &#x2F;&#x2F; 從索引值為2的位置開始刪除1個單元\n  console.log(arr)\n\n  &#x2F;&#x2F; 4. pop 刪除最後一個單元\n  arr.pop()\n  console.log(arr)\n\n  &#x2F;&#x2F; 5. shift 刪除第一個單元\n  arr.shift()\n  console.log(arr)\n&lt;&#x2F;script&gt;\n\n\n","slug":"20230320JavaScript 基礎 - 第3天","date":"2023-03-19T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"119b4406e4e9c28d94cef591716ce0ed","title":"JavaScript 基礎 - 第2天","content":"\n\n\n\n\n\n\n\n\n理解什麼是流程控制，知道條件控制的種類並掌握其對應的語法規則，具備利用迴圈編寫簡易ATM取款機程式能力\n\n運算子\n語句\n綜合案例\n\n運算子算術運算子數字是用來計算的，比如：乘法 * 、除法 &#x2F; 、加法 + 、減法 - 等等，所以經常和算術運算子一起。\n算術運算子：也叫數學運算子，主要包括加、減、乘、除、取餘（求模）等\n\n\n\n運算子\n作用\n\n\n\n+\n求和\n\n\n-\n求差\n\n\n*\n求積\n\n\n&#x2F;\n求商\n\n\n%\n取模（取餘數），開發中經常用於作為某個數位是否被整除\n\n\n\n\n\n\n\n\n\n\n\n注意：在計算失敗時，顯示的結果是 NaN （not a number）\n&#x2F;&#x2F; 算術運算子\nconsole.log(1 + 2 * 3 &#x2F; 2) &#x2F;&#x2F;  4 \nlet num &#x3D; 10\nconsole.log(num + 10)  &#x2F;&#x2F; 20\nconsole.log(num + num)  &#x2F;&#x2F; 20\n\n&#x2F;&#x2F; 1. 取模(取餘數)  使用場景：  用來判斷某個數是否能夠被整除\nconsole.log(4 % 2) &#x2F;&#x2F;  0  \nconsole.log(6 % 3) &#x2F;&#x2F;  0\nconsole.log(5 % 3) &#x2F;&#x2F;  2\nconsole.log(3 % 5) &#x2F;&#x2F;  3\n\n&#x2F;&#x2F; 2. 注意事項 : 如果我們計算失敗，則返回的結果是 NaN (not a number)\nconsole.log(&#39;老徐&#39; - 2)\nconsole.log(&#39;老徐&#39; * 2)\nconsole.log(&#39;老徐&#39; + 2)   &#x2F;&#x2F; pink老師2\n\n設定運算子設定運算子：對變數進行賦值的運算子\n &#x3D;     將等號右邊的值賦予給左邊, 要求左邊必須是一個容器\n\n\n\n運算子\n作用\n\n\n\n+&#x3D;\n加法賦值\n\n\n-+\n減法賦值\n\n\n*&#x3D;\n乘法賦值\n\n\n&#x2F;&#x3D;\n除法賦值\n\n\n%&#x3D;\n取餘賦值\n\n\n&lt;script&gt;\nlet num &#x3D; 1\n&#x2F;&#x2F; num &#x3D; num + 1\n&#x2F;&#x2F; 採取設定運算子\n&#x2F;&#x2F; num +&#x3D; 1\nnum +&#x3D; 3\nconsole.log(num)\n&lt;&#x2F;script&gt;\n\n自增&#x2F;自減運算子\n\n\n符號\n作用\n說明\n\n\n\n++\n自增\n變數自身的值加1，例如: x++\n\n\n–\n自減\n變數自身的值減1，例如: x–\n\n\n\n++在前和++在後在單獨使用時二者並沒有差別，而且一般開發中我們都是獨立使用\n++在後（尾碼式）我們會使用更多\n\n\n\n\n\n\n\n\n\n\n注意：\n\n只有變數能夠使用自增和自減運算子\n++、– 可以在變數前面也可以在變數後面，比如: x++  或者  ++x\n\n&lt;script&gt;\n    &#x2F;&#x2F; let num &#x3D; 10\n    &#x2F;&#x2F; num &#x3D; num + 1\n    &#x2F;&#x2F; num +&#x3D; 1\n    &#x2F;&#x2F; &#x2F;&#x2F; 1. 前置自增\n    &#x2F;&#x2F; let i &#x3D; 1\n    &#x2F;&#x2F; ++i\n    &#x2F;&#x2F; console.log(i)\n\n    &#x2F;&#x2F; let i &#x3D; 1\n    &#x2F;&#x2F; console.log(++i + 1)\n    &#x2F;&#x2F; 2. 後置自增\n    &#x2F;&#x2F; let i &#x3D; 1\n    &#x2F;&#x2F; i++\n    &#x2F;&#x2F; console.log(i)\n    &#x2F;&#x2F; let i &#x3D; 1\n    &#x2F;&#x2F; console.log(i++ + 1)\n\n    &#x2F;&#x2F; 瞭解 \n    let i &#x3D; 1\n    console.log(i++ + ++i + i)\n  &lt;&#x2F;script&gt;\n\n比較運算子使用場景：比較兩個資料大小、是否相等，根據比較結果返回一個布林值（true &#x2F; false）\n\n\n\n運算子\n作用\n\n\n\n&gt;\n左邊是否大於右邊\n\n\n&lt;\n左邊是否小於右邊\n\n\n&gt;&#x3D;\n左邊是否大於或等於右邊\n\n\n&lt;&#x3D;\n左邊是否小於或等於右邊\n\n\n&#x3D;&#x3D;&#x3D;\n左右兩邊是否類型和值都相等（重點）\n\n\n&#x3D;&#x3D;\n左右兩邊值是否相等\n\n\n!&#x3D;\n左右值不相等\n\n\n!&#x3D;&#x3D;\n左右兩邊是否不全等\n\n\n&lt;script&gt;\n  console.log(3 &gt; 5)\n  console.log(3 &gt;&#x3D; 3)\n  console.log(2 &#x3D;&#x3D; 2)\n  &#x2F;&#x2F; 比較運算子有隱式轉換 把&#39;2&#39; 轉換為 2  雙等號 只判斷值\n  console.log(2 &#x3D;&#x3D; &#39;2&#39;)  &#x2F;&#x2F; true\n  &#x2F;&#x2F; console.log(undefined &#x3D;&#x3D;&#x3D; null)\n  &#x2F;&#x2F; &#x3D;&#x3D;&#x3D; 全等 判斷 值 和 資料類型都一樣才行\n  &#x2F;&#x2F; 以後判斷是否相等 請用 &#x3D;&#x3D;&#x3D;  \n  console.log(2 &#x3D;&#x3D;&#x3D; &#39;2&#39;)\n  console.log(NaN &#x3D;&#x3D;&#x3D; NaN) &#x2F;&#x2F; NaN 不等於任何人，包括他自己\n  console.log(2 !&#x3D;&#x3D; &#39;2&#39;)  &#x2F;&#x2F; true  \n  console.log(2 !&#x3D; &#39;2&#39;) &#x2F;&#x2F; false \n  console.log(&#39;-------------------------&#39;)\n  console.log(&#39;a&#39; &lt; &#39;b&#39;) &#x2F;&#x2F; true\n  console.log(&#39;aa&#39; &lt; &#39;ab&#39;) &#x2F;&#x2F; true\n  console.log(&#39;aa&#39; &lt; &#39;aac&#39;) &#x2F;&#x2F; true\n  console.log(&#39;-------------------------&#39;)\n&lt;&#x2F;script&gt;\n\n邏輯運算子使用場景：可以把多個布林值放到一起運算，最終返回一個布林值\n\n\n\n符號\n名稱\n日常讀法\n特點\n口訣\n\n\n\n&amp;&amp;\n邏輯與\n並且\n符號兩邊有一個假的結果為假\n一假則假\n\n\n||\n邏輯或\n或者\n符號兩邊有一個真的結果為真\n一真則真\n\n\n!\n邏輯非\n取反\ntrue變false  false變true\n真變假，假變真\n\n\n\n\n\nA\nB\nA &amp;&amp; B\nA || B\n!A\n\n\n\nfalse\nfalse\nfalse\nfalse\ntrue\n\n\nfalse\ntrue\nfalse\ntrue\ntrue\n\n\ntrue\nfalse\nfalse\ntrue\nfalse\n\n\ntrue\ntrue\ntrue\ntrue\nfalse\n\n\n&lt;script&gt;\n    &#x2F;&#x2F; 邏輯與 一假則假\n    console.log(true &amp;&amp; true)\n    console.log(false &amp;&amp; true)\n    console.log(3 &lt; 5 &amp;&amp; 3 &gt; 2)\n    console.log(3 &lt; 5 &amp;&amp; 3 &lt; 2)\n    console.log(&#39;-----------------&#39;)\n    &#x2F;&#x2F; 邏輯或 一真則真\n    console.log(true || true)\n    console.log(false || true)\n    console.log(false || false)\n    console.log(&#39;-----------------&#39;)\n    &#x2F;&#x2F; 邏輯非  取反\n    console.log(!true)\n    console.log(!false)\n\n    console.log(&#39;-----------------&#39;)\n\n    let num &#x3D; 6\n    console.log(num &gt; 5 &amp;&amp; num &lt; 10)\n    console.log(&#39;-----------------&#39;)\n  &lt;&#x2F;script&gt;\n\n運算子優先順序\n\n\n\n\n\n\n\n\n邏輯運算子優先順序： ！&gt; &amp;&amp; &gt;  ||  \n語句運算式和語句\n\n\n\n\n\n\n\n\n運算式:可以被求值的代碼計算出一個結果。\n3+4\nnum++\n\n\n\n\n\n\n\n\n\n語句一段可以執行的代碼，是一種行為，例如分支語句和循環語句。\nfor(let i &#x3D; 0; i &lt; 10; i++)&#123;\n  console.log(&#39;我愛程式&#39;)\n&#125;\n\n\n分支語句分支語句可以根據條件判定真假，來選擇性的執行想要的代碼\n分支語句包含：\n\nif分支語句（重點）\n三元運算子\nswitch語句\n\nif 分支語句語法：\nif(條件運算式) &#123;\n  &#x2F;&#x2F; 滿足條件要執行的語句\n&#125;\n\n小括弧內的條件結果是布林值，為 true 時，進入大括弧裡執行代碼；為false，則不執行大括弧裡面代碼\n小括弧內的結果若不是布林類型時，會發生類型轉換為布林值，類似Boolean()\n如果大括弧只有一個語句，大括弧可以省略，但是，俺們不提倡這麼做~\n&lt;script&gt;\n    &#x2F;&#x2F; 單分支語句\n    &#x2F;&#x2F; if (false) &#123;\n    &#x2F;&#x2F;   console.log(&#39;執行語句&#39;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; if (3 &gt; 5) &#123;\n    &#x2F;&#x2F;   console.log(&#39;執行語句&#39;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; if (2 &#x3D;&#x3D;&#x3D; &#39;2&#39;) &#123;\n    &#x2F;&#x2F;   console.log(&#39;執行語句&#39;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F;  1. 除了0 所有的數字都為真\n    &#x2F;&#x2F;   if (0) &#123;\n    &#x2F;&#x2F;     console.log(&#39;執行語句&#39;)\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F; 2.除了 &#39;&#39; 所有的字串都為真 true\n    &#x2F;&#x2F; if (&#39;老徐&#39;) &#123;\n    &#x2F;&#x2F;   console.log(&#39;執行語句&#39;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; if (&#39;&#39;) &#123;\n    &#x2F;&#x2F;   console.log(&#39;執行語句&#39;)\n    &#x2F;&#x2F; &#125;\n    &#x2F;&#x2F; &#x2F;&#x2F; if (&#39;&#39;) console.log(&#39;執行語句&#39;)\n\n    &#x2F;&#x2F; 1. 用戶輸入\n    let score &#x3D; +prompt(&#39;請輸入准考證號碼&#39;)\n    &#x2F;&#x2F; 2. 進行判斷輸出\n    if (score &gt;&#x3D; 700) &#123;\n      alert(&#39;恭喜上榜&#39;)\n    &#125;\n    console.log(&#39;-----------------&#39;)\n\n  &lt;&#x2F;script&gt;\n\nif雙分支語句如果有兩個條件的時候，可以使用 if else 雙分支語句\nif (條件運算式)&#123;\n  &#x2F;&#x2F; 滿足條件要執行的語句\n&#125; else &#123;\n  &#x2F;&#x2F; 不滿足條件要執行的語句\n&#125;\n\n例如：\n&lt;script&gt;\n   &#x2F;&#x2F; 1. 用戶輸入\n   let uname &#x3D; prompt(&#39;請輸入用戶名:&#39;)\n   let pwd &#x3D; prompt(&#39;請輸入密碼:&#39;)\n   &#x2F;&#x2F; 2. 判斷輸出\n   if (uname &#x3D;&#x3D;&#x3D; &#39;pink&#39; &amp;&amp; pwd &#x3D;&#x3D;&#x3D; &#39;123456&#39;) &#123;\n     alert(&#39;恭喜登錄成功&#39;)\n   &#125; else &#123;\n     alert(&#39;用戶名或者密碼錯誤&#39;)\n   &#125;\n &lt;&#x2F;script&gt;\n\nif 多分支語句使用場景： 適合於有多個條件的時候\n&lt;script&gt;\n   &#x2F;&#x2F; 1. 用戶輸入\n   let score &#x3D; +prompt(&#39;請輸入成績：&#39;)\n   &#x2F;&#x2F; 2. 判斷輸出\n   if (score &gt;&#x3D; 90) &#123;\n     alert(&#39;成績優秀，boy，你是我的驕傲&#39;)\n   &#125; else if (score &gt;&#x3D; 70) &#123;\n     alert(&#39;成績良好，boy，你要加油哦~~&#39;)\n   &#125; else if (score &gt;&#x3D; 60) &#123;\n     alert(&#39;成績及格，boy，你很危險~&#39;)\n   &#125; else &#123;\n     alert(&#39;成績不及格，boy，我不想和你說話~&#39;)\n   &#125;\n &lt;&#x2F;script&gt;\n\n三元運算子（三元運算式）使用場景： 一些簡單的雙分支，可以使用  三元運算子（三元運算式），寫起來比 if  else雙分支 更簡單\n符號：? 與 : 配合使用\n語法：\n條件 ? 運算式1 ： 運算式2\n\n例如：\n&#x2F;&#x2F; 三元運算子（三元運算式）\n&#x2F;&#x2F; 1. 語法格式\n&#x2F;&#x2F; 條件 ? 運算式1 : 運算式2 \n\n&#x2F;&#x2F; 2. 執行過程 \n&#x2F;&#x2F; 2.1 如果條件為真，則執行運算式1\n&#x2F;&#x2F; 2.2 如果條件為假，則執行運算式2\n\n&#x2F;&#x2F; 3. 驗證\n&#x2F;&#x2F; 5 &gt; 3 ? &#39;真的&#39; : &#39;假的&#39;\nconsole.log(5 &lt; 3 ? &#39;真的&#39; : &#39;假的&#39;)\n\n&#x2F;&#x2F; let age &#x3D; 18 \n&#x2F;&#x2F; age &#x3D; age + 1\n&#x2F;&#x2F;  age++\n\n&#x2F;&#x2F; 1. 用戶輸入 \nlet num &#x3D; prompt(&#39;請您輸入一個數字:&#39;)\n&#x2F;&#x2F; 2. 判斷輸出- 小於10才補0\n&#x2F;&#x2F; num &#x3D; num &lt; 10 ? 0 + num : num\nnum &#x3D; num &gt;&#x3D; 10 ? num : 0 + num\nalert(num)\n\nswitch語句（瞭解）使用場景： 適合於有多個條件的時候，也屬於分支語句，大部分情況下和 if多分支語句 功能相同\n注意：\n\nswitch case語句一般用於等值判斷, if適合於區間判斷\nswitchcase一般需要配合break關鍵字使用 沒有break會造成case穿透\nif 多分支語句開發要比switch更重要，使用也更多\n\n例如：\n&#x2F;&#x2F; switch分支語句\n&#x2F;&#x2F; 1. 語法\n&#x2F;&#x2F; switch (運算式) &#123;\n&#x2F;&#x2F;   case 值1:\n&#x2F;&#x2F;     代碼1\n&#x2F;&#x2F;     break\n\n&#x2F;&#x2F;   case 值2:\n&#x2F;&#x2F;     代碼2\n&#x2F;&#x2F;     break\n&#x2F;&#x2F;   ...\n&#x2F;&#x2F;   default:\n&#x2F;&#x2F;     代碼n\n&#x2F;&#x2F; &#125;\n\n&lt;script&gt;\n  switch (2) &#123;\n    case 1:\n    console.log(&#39;您選擇的是1&#39;)\n    break  &#x2F;&#x2F; 退出switch\n    case 2:\n    console.log(&#39;您選擇的是2&#39;)\n    break  &#x2F;&#x2F; 退出switch\n    case 3:\n    console.log(&#39;您選擇的是3&#39;)\n    break  &#x2F;&#x2F; 退出switch\n    default:\n    console.log(&#39;沒有符合條件的&#39;)\n  &#125;\n&lt;&#x2F;script&gt;\n\n中斷點調試作用：學習時可以幫助更好的理解代碼運行，工作時可以更快找到bug\n流覽器打開調試介面\n\n按F12打開開發者工具\n點到原始程式碼一欄 （ sources ）\n選擇代碼檔\n\n中斷點：在某句代碼上加的標記就叫中斷點，當程式執行到這句有標記的代碼時會暫停下來\n迴圈語句使用場景：重複執行 指定的一段代碼，比如我們想要輸出10次 ‘我學的很棒’\n學習路徑：\n1.while迴圈\n2.for 迴圈（重點）\nwhile迴圈while :  在…. 期間， 所以 while迴圈 就是在滿足條件期間，重複執行某些代碼。\n語法：\nwhile (條件運算式) &#123;\n   &#x2F;&#x2F; 循環體    \n&#125;\n\n例如：\n&#x2F;&#x2F; while迴圈: 重複執行代碼\n\n&#x2F;&#x2F; 1. 需求: 利用迴圈重複列印3次 &#39;月薪過萬不是夢，畢業時候見英雄&#39;\nlet i &#x3D; 1\nwhile (i &lt;&#x3D; 3) &#123;\n  document.write(&#39;年薪過百不是夢，畢業時候見英雄~&lt;br&gt;&#39;)\n  i++   &#x2F;&#x2F; 這裡千萬不要忘了變數自增否則造成閉環\n&#125;\n\n迴圈三要素：\n1.初始值 （經常用變數）\n2.終止條件\n3.變數的變化量\n例如：\n&lt;script&gt;\n  &#x2F;&#x2F; &#x2F;&#x2F; 1. 變數的起始值\n  &#x2F;&#x2F; let i &#x3D; 1\n  &#x2F;&#x2F; &#x2F;&#x2F; 2. 終止條件\n  &#x2F;&#x2F; while (i &lt;&#x3D; 3) &#123;\n  &#x2F;&#x2F;   document.write(&#39;我要迴圈三次 &lt;br&gt;&#39;)\n  &#x2F;&#x2F;   &#x2F;&#x2F; 3. 變數的變化量\n  &#x2F;&#x2F;   i++\n  &#x2F;&#x2F; &#125;\n  &#x2F;&#x2F; 1. 變數的起始值\n  let end &#x3D; +prompt(&#39;請輸入次數:&#39;)\nlet i &#x3D; 1\n&#x2F;&#x2F; 2. 終止條件\nwhile (i &lt;&#x3D; end) &#123;\n  document.write(&#39;我要迴圈三次 &lt;br&gt;&#39;)\n  &#x2F;&#x2F; 3. 變數的變化量\n  i++\n&#125;\n\n&lt;&#x2F;script&gt;\n\n中止迴圈break   中止整個迴圈，一般用於結果已經得到, 後續的迴圈不需要的時候可以使用（提高效率）  \ncontinue  中止本次迴圈，一般用於排除或者跳過某一個選項的時候\n&lt;script&gt;\n    &#x2F;&#x2F; let i &#x3D; 1\n    &#x2F;&#x2F; while (i &lt;&#x3D; 5) &#123;\n    &#x2F;&#x2F;   console.log(i)\n    &#x2F;&#x2F;   if (i &#x3D;&#x3D;&#x3D; 3) &#123;\n    &#x2F;&#x2F;     break  &#x2F;&#x2F; 退出迴圈\n    &#x2F;&#x2F;   &#125;\n    &#x2F;&#x2F;   i++\n\n    &#x2F;&#x2F; &#125;\n\n    let i &#x3D; 1\n    while (i &lt;&#x3D; 5) &#123;\n      if (i &#x3D;&#x3D;&#x3D; 3) &#123;\n        i++\n        continue\n      &#125;\n      console.log(i)\n      i++\n\n    &#125;\n  &lt;&#x2F;script&gt;\n\n無限迴圈1.while(true) 來構造“無限”迴圈，需要使用break退出迴圈。（常用）\n2.for(;;) 也可以來構造“無限”迴圈，同樣需要使用break退出迴圈。\n&#x2F;&#x2F; 無限迴圈  \n&#x2F;&#x2F; 需求： 頁面會一直彈窗詢問你愛我嗎？\n&#x2F;&#x2F; (1). 如果用戶輸入的是 &#39;愛&#39;，則退出彈窗\n&#x2F;&#x2F; (2). 否則一直彈窗詢問\n\n&#x2F;&#x2F; 1. while(true) 無限迴圈\n&#x2F;&#x2F; while (true) &#123;\n&#x2F;&#x2F;   let love &#x3D; prompt(&#39;你愛我嗎?&#39;)\n&#x2F;&#x2F;   if (love &#x3D;&#x3D;&#x3D; &#39;愛&#39;) &#123;\n&#x2F;&#x2F;     break\n&#x2F;&#x2F;   &#125;\n&#x2F;&#x2F; &#125;\n\n&#x2F;&#x2F; 2. for(;;) 無限迴圈\nfor (; ;) &#123;\n  let love &#x3D; prompt(&#39;你愛我嗎?&#39;)\n  if (love &#x3D;&#x3D;&#x3D; &#39;愛&#39;) &#123;\n    break\n  &#125;\n&#125;\n\n綜合案例-ATM存取款機分析：\n①：提示輸入框寫到迴圈裡面（無限迴圈）\n②：用戶輸入4則退出迴圈 break\n③：提前準備一個金額預先存儲一個數額 money\n④：根據輸入不同的值，做不同的操作\n (1)  取錢則是減法操作， 存錢則是加法操作，查看餘額則是直接顯示金額\n\n (2) 可以使用 if else if 多分支 來執行不同的操作\n\n完整代碼：\n&lt;script&gt;\n  &#x2F;&#x2F; 1. 開始迴圈 輸入框寫到 迴圈裡面\n  &#x2F;&#x2F; 3. 準備一個總的金額\n  let money &#x3D; 100\nwhile (true) &#123;\n  let re &#x3D; +prompt(&#96;\n請您選擇操作：\n1.存錢\n2.取錢\n3.查看餘額\n4.退出\n&#96;)\n  &#x2F;&#x2F; 2. 如果用戶輸入的 4 則退出迴圈， break  寫到if 裡面，沒有寫到switch裡面， 因為4需要break退出迴圈\n  if (re &#x3D;&#x3D;&#x3D; 4) &#123;\n    break\n  &#125;\n  &#x2F;&#x2F; 4. 根據輸入做操作\n  switch (re) &#123;\n    case 1:\n      &#x2F;&#x2F; 存錢\n      let cun &#x3D; +prompt(&#39;請輸入存款金額&#39;)\n      money &#x3D; money + cun\n      break\n      case 2:\n      &#x2F;&#x2F; 存錢\n      let qu &#x3D; +prompt(&#39;請輸入取款金額&#39;)\n      money &#x3D; money - qu\n      break\n      case 3:\n      &#x2F;&#x2F; 存錢\n      alert(&#96;您的銀行卡餘額是$&#123;money&#125;&#96;)\n      break\n  &#125;\n&#125;\n&lt;&#x2F;script&gt;\n\n\n\n\n\n\n\n\n\n","slug":"20230319JavaScript 基礎 - 第2天","date":"2023-03-18T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"1517f5e85f0012c69f183e7960bb5313","title":"JavaScript 基礎- 第1天","content":"\n\n\n\n\n\n\n\n\n瞭解變數、資料類型、運算子等基礎概念，能夠實現資料類型的轉換，結合四則運算體會如何程式設計。\n\n體會現實世界中的事物與電腦的關係\n理解什麼是資料並知道資料的分類\n理解變數存儲資料的“容器”\n掌握常見運算子的使用，瞭解優先順序關係\n知道 JavaScript 資料類型隱式轉換的特徵\n\n介紹\n\n\n\n\n\n\n\n\n掌握 JavaScript 的引入方式，初步認識 JavaScript 的作用\n引入方式JavaScript 程式不能獨立運行，它需要被嵌入 HTML 中，然後流覽器才能執行 JavaScript 代碼。通過 script 標籤將 JavaScript 代碼引入到 HTML 中，有兩種方式：\n內部方式通過 script 標籤包裹 JavaScript 代碼\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 引入方式&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;!-- 內聯形式：通過 script 標籤包裹 JavaScript 代碼 --&gt;\n  &lt;script&gt;\n    alert(&#39;嗨，前端技術！&#39;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n外部形式一般將 JavaScript 代碼寫在獨立的以 .js 結尾的檔中，然後通過 script 標籤的 src 屬性引入\n&#x2F;&#x2F; demo.js\ndocument.write(&#39;嗨，前端技術！&#39;)\n\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 引入方式&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;!-- 外部形式：通過 script 的 src 屬性引入獨立的 .js 文件 --&gt;\n  &lt;script src&#x3D;&quot;demo.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n如果 script 標籤使用 src 屬性引入了某 .js 檔，那麼 標籤的代碼會被忽略！！！如下代碼所示：\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 引入方式&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;!-- 外部形式：通過 script 的 src 屬性引入獨立的 .js 文件 --&gt;\n  &lt;script src&#x3D;&quot;demo.js&quot;&gt;\n    &#x2F;&#x2F; 此處的代碼會被忽略掉！！！！\n    alert(666);  \n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n注釋和結束符通過注釋可以遮罩代碼被執行或者添加備註資訊，JavaScript 支援兩種形式注釋語法：\n單行注釋使用 //  注釋單行代碼\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 注釋&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt;\n    &#x2F;&#x2F; 這種是單行注釋的語法\n    &#x2F;&#x2F; 一次只能注釋一行\n    &#x2F;&#x2F; 可以重複注釋\n    document.write(&#39;嗨，前端技術！&#39;);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n多行注釋使用 /* */ 注釋多行代碼\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 注釋&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt;\n    &#x2F;* 這種的是多行注釋的語法 *&#x2F;\n    &#x2F;*\n      更常見的多行注釋是這種寫法\n      在些可以任意換行\n      多少行都可以\n      *&#x2F;\n    document.write(&#39;嗨，來學習前端！&#39;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n注：編輯器中單行注釋的快速鍵為 ctrl + /\n結束符在 JavaScript 中 ; 代表一段代碼的結束，多數情況下可以省略 ; 使用回車（enter）替代。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 結束符&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    alert(1);\n    alert(2);\n    alert(1)\n    alert(2)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n實際開發中有許多人主張書寫 JavaScript 代碼時省略結束符 ;\n輸入和輸出輸出和輸入也可理解為人和電腦的交互，使用者通過鍵盤、滑鼠等向電腦輸入資訊，電腦處理後再展示結果給用戶，這便是一次輸入和輸出的過程。\n舉例說明：如按鍵盤上的方向鍵，向上&#x2F;下鍵可以滾動頁面，按向上&#x2F;下鍵這個動作叫作輸入，頁面發生了滾動了這便叫輸出。\n輸出JavaScript 可以接收用戶的輸入，然後再將輸入的結果輸出：\nalert()、document.wirte()\n以數字為例，向 alert() 或 document.write()輸入任意數位，他都會以彈窗形式展示（輸出）給用戶。\n輸入向 prompt() 輸入任意內容會以彈窗形式出現在流覽器中，一般提示使用者輸入一些內容。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 輸入輸出&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    &#x2F;&#x2F; 1. 輸入的任意數位，都會以彈窗形式展示\n    document.write(&#39;要輸出的內容&#39;)\n    alert(&#39;要輸出的內容&#39;);\n\n    &#x2F;&#x2F; 2. 以彈窗形式提示用戶輸入姓名，注意這裡的文字使用英文的引號\n    prompt(&#39;請輸入您的姓名:&#39;)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n變數\n\n\n\n\n\n\n\n\n理解變數是電腦存儲資料的“容器”，掌握變數的聲明方式\n變數是電腦中用來存儲資料的“容器”，它可以讓電腦變得有記憶，通俗的理解變數就是使用【某個符號】來代表【某個具體的數值】（資料）\n&lt;script&gt;\n  &#x2F;&#x2F; x 符號代表了 5 這個數值\n  x &#x3D; 5\n  &#x2F;&#x2F; y 符號代表了 6 這個數值\n  y &#x3D; 6\n    \n  &#x2F;&#x2F;舉例： 在 JavaScript 中使用變數可以將某個資料（數值）記錄下來！\n\n  &#x2F;&#x2F; 將使用者輸入的內容保存在 num 這個變數（容器）中\n  num &#x3D; prompt(&#39;請輸入一數位!&#39;)\n\n  &#x2F;&#x2F; 通過 num 變數（容器）將使用者輸入的內容輸出出來\n  alert(num)\n  document.write(num)\n&lt;&#x2F;script&gt;\n\n聲明聲明(定義)變數有兩部分構成：聲明關鍵字、變數名（標識）\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 聲明和賦值&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    &#x2F;&#x2F; let 變數名\n    &#x2F;&#x2F; 聲明(定義)變數有兩部分構成：聲明關鍵字、變數名（標識）\n    &#x2F;&#x2F; let 即關鍵字，所謂關鍵字是系統提供的專門用來聲明（定義）變數的詞語\n    &#x2F;&#x2F; age 即變數的名稱，也叫識別字\n    let age\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n關鍵字是 JavaScript 中內置的一些英文詞彙（單詞或縮寫），它們代表某些特定的含義，如 let 的含義是聲明變數的，看到 let  後就可想到這行代碼的意思是在聲明變數，如 let age; \nlet 和 var 都是 JavaScript 中的聲明變數的關鍵字，推薦使用 let 聲明變數！！！\n賦值聲明（定義）變數相當於創造了一個空的“容器”，通過賦值向這個容器中添加資料。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 聲明和賦值&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    &#x2F;&#x2F; 聲明(定義)變數有兩部分構成：聲明關鍵字、變數名（標識）\n    &#x2F;&#x2F; let 即關鍵字，所謂關鍵字是系統提供的專門用來聲明（定義）變數的詞語\n    &#x2F;&#x2F; age 即變數的名稱，也叫識別字\n    let age\n    &#x2F;&#x2F; 賦值，將 18 這個資料存入了 age 這個“容器”中\n    age &#x3D; 18\n    &#x2F;&#x2F; 這樣 age 的值就成了 18\n    document.write(age)\n    \n    &#x2F;&#x2F; 也可以聲明和賦值同時進行\n    let str &#x3D; &#39;hello world!&#39;\n    alert(str);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n關鍵字JavaScript 使用專門的關鍵字 let 和 var 來聲明（定義）變數，在使用時需要注意一些細節：\n以下是使用 let 時的注意事項：\n\n允許聲明和賦值同時進行\n不允許重複聲明\n允許同時聲明多個變數並賦值\nJavaScript 中內置的一些關鍵字不能被當做變數名\n\n以下是使用 var 時的注意事項：\n\n允許聲明和賦值同時進行\n允許重複聲明\n允許同時聲明多個變數並賦值\n\n大部分情況使用 let 和 var 區別不大，但是 let 相較 var 更嚴謹，因此推薦使用 let，後期會更進一步介紹二者間的區別。\n變數名命名規則關於變數的名稱（識別字）有一系列的規則需要遵守：\n\n只能是字母、數位、底線、$，且不能能數字開頭\n字母區分大小寫，如 Age 和 age 是不同的變數\nJavaScript 內部已佔用於單詞（關鍵字或保留字）不允許使用\n儘量保證變數具有一定的語義，見字知義\n\n注：所謂關鍵字是指 JavaScript 內部使用的詞語，如 let 和var，保留字是指 JavaScript 內部目前沒有使用的詞語，但是將來可能會使用詞語。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 變數名命名規則&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    let age &#x3D; 18 &#x2F;&#x2F; 正確\n    let age1 &#x3D; 18 &#x2F;&#x2F; 正確\n    let _age &#x3D; 18 &#x2F;&#x2F; 正確\n\n    &#x2F;&#x2F; let 1age &#x3D; 18; &#x2F;&#x2F; 錯誤，不可以數位開頭\n    let $age &#x3D; 18 &#x2F;&#x2F; 正確\n    let Age &#x3D; 24 &#x2F;&#x2F; 正確，它與小寫的 age 是不同的變數\n    &#x2F;&#x2F; let let &#x3D; 18; &#x2F;&#x2F; 錯誤，let 是關鍵字\n    let int &#x3D; 123 &#x2F;&#x2F; 不推薦，int 是保留字\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n常量概念：使用 const 聲明的變數稱為“常量”。\n使用場景：當某個變數永遠不會改變的時候，就可以使用 const 來聲明，而不是let。\n命名規範：和變數一致\nconst PI &#x3D; 3.14\n\n\n\n\n\n\n\n\n\n\n注意： 常量不允許重新賦值,聲明的時候必須賦值（初始化）\n資料類型\n\n\n\n\n\n\n\n\n電腦世界中的萬事成物都是資料。\n電腦程式可以處理大量的資料，為了方便資料的管理，將資料分成了不同的類型：\n注：通過 typeof 關鍵字檢測資料類型\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 資料類型&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    &#x2F;&#x2F; 檢測 1 是什麼類型資料，結果為 number\n    document.write(typeof 1)\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n數數值型別即我們數學中學習到的數位，可以是整數、小數、正數、負數\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 資料類型&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    let score &#x3D; 100 &#x2F;&#x2F; 正整數\n    let price &#x3D; 12.345 &#x2F;&#x2F; 小數\n    let temperature &#x3D; -40 &#x2F;&#x2F; 負數\n\n    document.write(typeof score) &#x2F;&#x2F; 結果為 number\n    document.write(typeof price) &#x2F;&#x2F; 結果為 number\n    document.write(typeof temperature) &#x2F;&#x2F; 結果為 number\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nJavaScript 中的數數值型別與數學中的數字是一樣的，分為正數、負數、小數等。\n字串類型通過單引號（ &#39;&#39;） 、雙引號（ &quot;&quot;）或反引號包裹的資料都叫字串，單引號和雙引號沒有本質上的區別，推薦使用單引號。\n注意事項：\n\n無論單引號或是雙引號必須成對使用\n單引號&#x2F;雙引號可以互相嵌套，但是不以自已嵌套自已\n必要時可以使用轉義符 \\，輸出單引號或雙引號\n\n*範本字串-使用場景-拼接字串和變數、在沒有它之前，要拼接變數比較麻煩-語法    Ø &#96;&#96; (反引號)    Ø 在英文輸入模式下按鍵盤的tab鍵上方那個鍵（1左邊那個鍵）    Ø 內容拼接變數時，用 ${ } 包住變數\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 資料類型&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    let user_name &#x3D; &#39;小徐&#39; &#x2F;&#x2F; 使用單引號\n    let gender &#x3D; &quot;男&quot; &#x2F;&#x2F; 使用雙引號\n    let str &#x3D; &#39;123&#39; &#x2F;&#x2F; 看上去是數字，但是用引號包裹了就成了字串了\n    let str1 &#x3D; &#39;&#39; &#x2F;&#x2F; 這種情況叫空字串\n    \n    documeent.write(typeof user_name) &#x2F;&#x2F; 結果為 string\n    documeent.write(typeof gender) &#x2F;&#x2F; 結果為 string\n    documeent.write(typeof str) &#x2F;&#x2F; 結果為 string\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n布林類型表示肯定或否定時在電腦中對應的是布林類型資料，它有兩個固定的值 true 和 false，表示肯定的資料用 true，表示否定的資料用 false。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 資料類型&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    &#x2F;&#x2F;  我帥不帥？回答 是 或 否\n    let isCool &#x3D; true &#x2F;&#x2F; 是的，帥死了！\n    isCool &#x3D; false &#x2F;&#x2F; 不，是個醜人！\n\n    document.write(typeof isCool) &#x2F;&#x2F; 結果為 boolean\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\nundefined未定義是比較特殊的類型，只有一個值 undefined，只聲明變數，不賦值的情況下，變數的預設值為 undefined，一般很少【直接】為某個變數賦值為 undefined。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 資料類型&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  \n  &lt;script&gt; \n    &#x2F;&#x2F; 只聲明了變數，並末賦值\n    let tmp;\n    document.write(typeof tmp) &#x2F;&#x2F; 結果為 undefined\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n注：JavaScript 中變數的值決定了變數的資料類型。\n類型轉換\n\n\n\n\n\n\n\n\n理解弱類型語言的特徵，掌握顯式類型轉換的方法\n在 JavaScript 中資料被分成了不同的類型，如數值、字串、布林值、undefined，在實際程式設計的過程中，不同資料類型之間存在著轉換的關係。\n隱式轉換某些運算子被執行時，系統內部自動將資料類型進行轉換，這種轉換稱為隱式轉換。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 隱式轉換&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;script&gt; \n    let num &#x3D; 13 &#x2F;&#x2F; 數值\n    let num2 &#x3D; &#39;2&#39; &#x2F;&#x2F; 字串\n\n    &#x2F;&#x2F; 結果為 132\n    &#x2F;&#x2F; 原因是將數值 num 轉換成了字串，相當於 &#39;13&#39;\n    &#x2F;&#x2F; 然後 + 將兩個字串拼接到了一起\n    console.log(num + num2)\n\n    &#x2F;&#x2F; 結果為 11\n    &#x2F;&#x2F; 原因是將字串 num2 轉換成了數值，相當於 2\n    &#x2F;&#x2F; 然後數值 13 減去 數值 2\n    console.log(num - num2)\n\n    let a &#x3D; prompt(&#39;請輸入一個數字&#39;)\n    let b &#x3D; prompt(&#39;請再輸入一個數字&#39;)\n\n    alert(a + b);\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n注：資料類型的隱式轉換是 JavaScript 的特徵，後續學習中還會遇到，目前先需要理解什麼是隱式轉換。\n補充介紹範本字串的拼接的使用\n顯式轉換編寫程式時過度依靠系統內部的隱式轉換是不嚴禁的，因為隱式轉換規律並不清晰，大多是靠經驗總結的規律。為了避免因隱式轉換帶來的問題，通常根邏輯需要對資料進行顯示轉換。\nNumber通過 Number 顯示轉換成數值類型，當轉換失敗時結果為 NaN（Not a Number）即不是一個數字。\n&lt;!DOCTYPE html&gt;\n&lt;html lang&#x3D;&quot;en&quot;&gt;\n&lt;head&gt;\n  &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;\n  &lt;title&gt;JavaScript 基礎 - 隱式轉換&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;script&gt;\n    let t &#x3D; &#39;12&#39;\n    let f &#x3D; 8\n\n    &#x2F;&#x2F; 顯式將字串 12 轉換成數值 12\n    t &#x3D; Number(t)\n\n    &#x2F;&#x2F; 檢測轉換後的類型\n    &#x2F;&#x2F; console.log(typeof t);\n    console.log(t + f) &#x2F;&#x2F; 結果為 20\n\n    &#x2F;&#x2F; 並不是所有的值都可以被轉成數值類型\n    let str &#x3D; &#39;hello&#39;\n    &#x2F;&#x2F; 將 hello 轉成數值是不現實的，當無法轉換成\n    &#x2F;&#x2F; 數值時，得到的結果為 NaN （Not a Number）\n    console.log(Number(str))\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n\n","slug":"20230318JavaScript 基礎 - 第1天","date":"2023-03-17T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"e6004c997fa8a9529d5026785922b3ae","title":"CSS 08-高級技巧","content":"CSS高級技巧目標\n\n理解\n元素顯示隱藏最常見的寫法\n精靈圖產生的目的\n去除圖片底側空白縫隙的方法\n\n\n應用\n寫出最常見的滑鼠樣式\n使用精靈圖技術\n用滑動門做巡覽列案例\n\n\n\n1. 元素的顯示與隱藏\n\n\n\n\n\n\n\n\n目的：讓一個元素在頁面中消失或者顯示出來\n場景：類似網站廣告，當我們點擊關閉就不見了，但是我們重新刷新頁面，會重新出現！\n1.1 display 顯示（重點）\ndisplay 設置或檢索物件是否及如何顯示。\n&#x2F;&#x2F;隱藏物件\ndisplay: none \n\n&#x2F;&#x2F;除了轉換為塊級元素之外，同時還有顯示元素的意思。\ndisplay：block \n\n特點： 隱藏之後，不再保留位置。\n\n\n實際開發場景：\n\n\n\n\n\n\n\n\n\n配合後面js做特效，比如下拉式功能表，原先沒有，滑鼠經過，顯示下拉式功能表， 應用極為廣泛\n1.2 visibility 可見性 (瞭解)\n設置或檢索是否顯示物件。\nvisibility：visible ; 　&#x2F;&#x2F;對象可視\n\nvisibility：hidden; 　  &#x2F;&#x2F;物件隱藏\n\n特點： 隱藏之後，繼續保留原有位置。（停職留薪）\n\n\n1.3 overflow 溢出(重點)\n檢索或設置當物件的內容超過其指定高度及寬度時如何管理內容。\n\n\n\n\n屬性值\n描述\n\n\n\nvisible\n不剪切內容也不添加捲軸\n\n\nhidden\n不顯示超過物件尺寸的內容，超出的部分隱藏掉\n\n\nscroll\n不管超出內容否，總是顯示捲軸\n\n\nauto\n超出自動顯示捲軸，不超出不顯示捲軸\n\n\n實際開發場景：\n\n\n\n\n\n\n\n\n\n\n清除浮動\n隱藏超出內容，隱藏掉,  不允許內容超過父盒子。\n\n1.4 顯示與隱藏總結\n\n\n屬性\n區別\n用途\n\n\n\ndisplay\n隱藏物件，不保留位置\n配合後面js做特效，比如下拉式功能表，原先沒有，滑鼠經過，顯示下拉式功能表， 應用極為廣泛\n\n\nvisibility\n隱藏物件，保留位置\n使用較少\n\n\noverflow\n只是隱藏超出大小的部分\n1. 可以清除浮動 2. 保證盒子裡面的內容不會超出該盒子範圍\n\n\n2. CSS使用者介面樣式\n所謂的介面樣式， 就是更改一些使用者操作樣式，以便提高更好的用戶體驗。\n更改使用者的滑鼠樣式 (捲軸因為相容性非常差，我們不研究) \n表單輪廓等。\n防止表單欄位拖拽\n\n\n\n2.1 滑鼠樣式cursor 設置或檢索在物件上移動的滑鼠指標採用何種系統預定義的游標形狀。\n\n\n\n屬性值\n描述\n\n\n\ndefault\n小白  默認\n\n\npointer\n小手\n\n\nmove\n移動\n\n\ntext\n文本\n\n\nnot-allowed\n禁止\n\n\n滑鼠放我身上查看效果哦：\n&lt;ul&gt;\n  &lt;li style&#x3D;&quot;cursor:default&quot;&gt;我是小白&lt;&#x2F;li&gt;\n  &lt;li style&#x3D;&quot;cursor:pointer&quot;&gt;我是小手&lt;&#x2F;li&gt;\n  &lt;li style&#x3D;&quot;cursor:move&quot;&gt;我是移動&lt;&#x2F;li&gt;\n  &lt;li style&#x3D;&quot;cursor:text&quot;&gt;我是文本&lt;&#x2F;li&gt;\n  &lt;li style&#x3D;&quot;cursor:not-allowed&quot;&gt;我是文本&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n\n2.2 輪廓線 outline 是繪製于元素周圍的一條線，位於邊框邊緣的週邊，可起到突出元素的作用。 \noutline : outline-color ||outline-style || outline-width \n\n 但是我們都不關心可以設置多少，我們平時都是去掉的。  \n最直接的寫法是 ：  outline: 0;   或者  outline: none;\n&lt;input  type&#x3D;&quot;text&quot;  style&#x3D;&quot;outline: 0;&quot;&#x2F;&gt;\n\n2.3 防止拖拽文本域resize實際開發中，我們文本域右下角是不可以拖拽： \n&lt;textarea  style&#x3D;&quot;resize: none;&quot;&gt;&lt;&#x2F;textarea&gt;\n\n2.4 使用者介面樣式總結\n\n\n屬性\n用途\n用途\n\n\n\n滑鼠樣式\n更改滑鼠樣式cursor\n樣式很多，重點記住 pointer\n\n\n輪廓線\n表單默認outline\noutline 輪廓線，我們一般直接去掉，border是邊框，我們會經常用\n\n\n防止拖拽\n主要針對文本域resize\n防止使用者隨意拖拽文本域，造成頁面配置混亂，我們resize:none\n\n\n3. vertical-align 垂直對齊\n有寬度的塊級元素居中對齊，是margin: 0 auto;\n讓文字居中對齊，是 text-align: center;\n\n但是我們從來沒有講過有垂直居中的屬性。\nvertical-align 垂直對齊，它只針對於行內元素或者行內塊元素，\nvertical-align : baseline |top |middle |bottom \n\n設置或檢索物件內容的垂直對其方式。\n\n注意：\nvertical-align 不影響塊級元素中的內容對齊，它只針對於行內元素或者行內塊元素，\n特別是行內塊元素， 通常用來控制圖片&#x2F;表單與文字的對齊。\n\n\n3.1 圖片、表單和文字對齊我們可以通過vertical-align 控制圖片和文字的垂直關係。預設的圖片會和文字基線對齊。\n3.2 去除圖片底側空白縫隙\n原因：\n圖片或者表單等行內塊元素，他的底線會和父級盒子的基線對齊。\n就是圖片底側會有一個空白縫隙。\n\n解決的方法就是：  \n\n給img vertical-align:middle | top| bottom等等。  讓圖片不要和基線對齊。\n給img 添加 display：block; 轉換為塊級元素就不會存在問題了。\n\n\n\n4. 溢出的文字省略號顯示4.1 white-space\nwhite-space設置或檢索物件內文本顯示方式。通常我們使用于強制一行顯示內容\n\nwhite-space:normal ；預設處理方式\n\nwhite-space:nowrap ；強制在同一行內顯示所有文本，直到文本結束或者遭遇br標籤物件才換行。\n\n4.2 text-overflow 文字溢出\n設置或檢索是否使用一個省略標記（…）標示物件內文本的溢出\n\ntext-overflow : clip ；不顯示省略標記（...），而是簡單的裁切 \n\ntext-overflow：ellipsis ； 當物件內文本溢出時顯示省略標記（...）\n\n\n\n\n\n\n\n\n\n\n注意：一定要首先強制一行內顯示，再次和overflow屬性  搭配使用\n4.3 總結三步曲&#x2F;*1. 先強制一行內顯示文本*&#x2F;\n    white-space: nowrap;\n&#x2F;*2. 超出的部分隱藏*&#x2F;\n    overflow: hidden;\n&#x2F;*3. 文字用省略號替代超出的部分*&#x2F;\n    text-overflow: ellipsis;\n\n5. CSS精靈技術（sprite) 重點5.1 為什麼需要精靈技術當用戶訪問一個網站時，需要向伺服器發送請求，網頁上的每張圖像都要經過一次請求才能展現給用戶。\n然而，一個網頁中往往會應用很多小的背景圖像作為修飾，當網頁中的圖像過多時，伺服器就會頻繁地接受和發送請求，這將大大降低頁面的載入速度。\n為什麼需要精靈技術：\n\n\n\n\n\n\n\n\n\n 為了有效地減少伺服器接受和發送請求的次數，提高頁面的載入速度。\n出現了CSS精靈技術（也稱CSS Sprites、CSS雪碧）。\n5.2 精靈技術講解CSS 精靈其實是將網頁中的一些背景圖像整合到一張大圖中（精靈圖），然而，各個網頁元素通常只需要精靈圖中不同位置的某個小圖，要想精確定位到精靈圖中的某個小圖。\n這樣，當使用者訪問該頁面時，只需向服務發送一次請求，網頁中的背景圖像即可全部展示出來。\n我們需要使用CSS的\n\nbackground-image\nbackground-repeat\nbackground-position屬性進行背景定位\n其中最關鍵的是使用background-position 屬性精確地定位。\n\n5.3 精靈技術使用的核心總結首先我們知道，css精靈技術主要針對於背景圖片，插入的圖片img 是不需要這個技術的。\n\n精確測量，每個小背景圖片的大小和 位置。\n給盒子指定小背景圖片時， 背景定位基本都是 負值。\n\n5.4 製作精靈圖(瞭解)CSS 精靈其實是將網頁中的一些背景圖像整合到一張大圖中（精靈圖），那我們要做的，就是把小圖拼合成一張大圖。\n大部分情況下，精靈圖都是網頁美工做。\n精靈圖上放的都是小的裝飾性質的背景圖片。 **插入圖片不能往上放**。\n可以橫向擺放也可以縱向擺放，但是每個圖片之間留有適當的空隙\n在我們精靈圖的最低端，留一片空隙，方便我們以後添加其他精靈圖。\n\n結論：小公司，背景圖片很少的情況，沒有必要使用精靈技術，維護成本太高。 如果是背景圖片比較多，可以建議使用精靈技術。\n6. 滑動門滑動門出現的背景製作網頁時，為了美觀，常常需要為網頁元素設置特殊形狀的背景，比如巡覽列，使字數不一樣多的按鈕，有凸起和凹下去的感覺，，咋辦？\n為了使各種特殊形狀的背景能夠自我調整元素中文本內容的多少，出現了CSS滑動門技術。它從新的角度構建頁面，使各種特殊形狀的背景能夠自由拉伸滑動，以適應元素內部的文本內容，可用性更強。 最常見於各種巡覽列的滑動門。\n核心技術核心技術就是利用CSS精靈（主要是背景位置）和 盒子padding撐開寬度, 以便能適應不同字數的巡覽列。\n一般的經典佈局都是這樣的：\n&lt;li&gt;\n  &lt;a href&#x3D;&quot;#&quot;&gt;\n    &lt;span&gt;巡覽列內容&lt;&#x2F;span&gt;\n  &lt;&#x2F;a&gt;\n&lt;&#x2F;li&gt;\n\ncss樣式\n* &#123;\n      padding:0;\n      margin:0;\n\n    &#125;\n    body&#123;\n      background: url(images&#x2F;wx.jpg) repeat-x;\n    &#125;\n    .father &#123;\n      padding-top:20px;\n    &#125;\n    li &#123;\n      padding-left: 16px;\n      height: 33px;\n      float: left;\n      line-height: 33px;\n      margin:0  10px;\n      background: url(.&#x2F;images&#x2F;to.png) no-repeat left ;\n    &#125;\n    a &#123;\n      padding-right: 16px;\n      height: 33px;\n      display: inline-block;\n      color:#fff;\n      background: url(.&#x2F;images&#x2F;to.png) no-repeat right ;\n      text-decoration: none;\n    &#125;\n    li:hover,\n    li:hover a &#123;\n      background-image:url(.&#x2F;images&#x2F;ao.png);\n    &#125;\n\n\n總結： \n\na 設置 背景左側，padding撐開合適寬度。    \nspan 設置背景右側， padding撐開合適寬度 剩下由文字繼續撐開寬度。\n之所以a包含span就是因為 整個導航都是可以點擊的。\n\n7. 拓展@7.1 margin負值之美負邊距+定位：水準垂直居中\n一個絕對定位的盒子， 利用  父級盒子的 50%，  然後 往左(上) 走 自己寬度的一半 ，可以實現盒子水準垂直居中。\n7.2 CSS三角形之美div &#123;\n\n width: 0; \n\n   height: 0;\n   line-height:0；\n   font-size: 0;\n border-top: 10px solid red;\n\n border-right: 10px solid green;\n\n border-bottom: 10px solid blue;\n\n border-left: 10px solid #000; \n\n&#125;\n\n\n\n用css 邊框可以模擬三角效果\n寬度高度為0\n4個邊框都要寫， 只保留需要的邊框顏色，其餘的不能省略，都改為 transparent 透明就好了\n為了照顧相容性 低版本的流覽器，加上 font-size: 0;  line-height: 0;\n\n","slug":"20230317CSS 08-高級技巧","date":"2023-03-17T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"a80bc05c620a4e285b16be71646cc7c5","title":"CSS 07-定位(position)","content":"定位(position)目標\n理解\n為什麼要用定位\n定位的4種分類\n4種定位的各自特點\n為什麼常用子絕父相佈局\n\n\n\n1. CSS 佈局的三種機制\n\n\n\n\n\n\n\n\n網頁佈局的核心 —— 就是用 CSS 來擺放盒子位置。\nCSS 提供了 3 種機制來設置盒子的擺放位置，分別是普通流、浮動和定位，其中：\n\n普通流（標準流）\n\n浮動\n\n讓盒子從普通流中浮起來 —— 讓多個盒子(div)水準排列成一行。\n\n\n定位\n\n將盒子定在某一個位置  自由的漂浮在其他盒子的上面  —— CSS 離不開定位，特別是後面的 js 特效。\n\n\n\n2. 為什麼使用定位\n\n\n\n\n\n\n\n\n將盒子定在某一個位置，自由的漂浮在其他盒子(包括標準流和浮動)的上面 \n所以，我們腦海應該有三種佈局機制的上下順序\n定位的盒子在最上層  （天空） 浮動的盒子在中間層  (海面)   標準流在最底層 (海底) \n3. 定位詳解定位也是用來佈局的，它有兩部分組成：\n\n\n\n\n\n\n\n\n\n定位 = 定位模式 + 邊偏移\n3.1 邊偏移簡單說， 我們定位的盒子，是通過邊偏移來移動位置的。\n在 CSS 中，通過 top、bottom、left 和 right 屬性定義元素的邊偏移：（方位名詞）\n\n\n\n邊偏移屬性\n示例\n描述\n\n\n\ntop\ntop: 10px\n頂端偏移量，定義元素相對于其父元素上邊線的距離。\n\n\nbottom\nbottom: 10px\n底部偏移量，定義元素相對于其父元素下邊線的距離。\n\n\nleft\nleft: 10px\n左側偏移量，定義元素相對于其父元素左邊線的距離。\n\n\nright\nright: 10px\n右側偏移量，定義元素相對于其父元素右邊線的距離\n\n\n定位的盒子有了邊偏移才有價值。 一般情況下，凡是有定位地方必定有邊偏移。\n3.2  定位模式 (position)在 CSS 中，通過 position 屬性定義元素的定位模式，語法如下：\n選擇器 &#123; position: 屬性值; &#125;\n定位模式是有不同分類的，在不同情況下，我們用到不同的定位模式。\n\n\n\n值\n語義\n\n\n\nstatic\n靜態定位\n\n\nrelative\n相對定位\n\n\nabsolute\n絕對定位\n\n\nfixed\n固定定位\n\n\n3.2.1 靜態定位(static) - 瞭解\n靜態定位是元素的預設定位方式，無定位的意思。它相當於 border 裡面的none， 不要定位的時候用。\n靜態定位 按照標準流特性擺放位置，它沒有邊偏移。\n靜態定位在佈局時我們幾乎不用的\n\n3.2.1 相對定位(relative) - 重要\n相對定位是元素相對于它  原來在標準流中的位置 來說的。（自戀型）\n\n相對定位的特點：（務必記住）\n\n相對于 自己原來在標準流中位置來移動的\n原來在標準流的區域繼續佔有，後面的盒子仍然以標準流的方式對待它。\n\n3.2.3 絕對定位(absolute) - 重要絕對定位是元素以帶有定位的父級元素來移動位置 （拼爹型）\n\n完全脫標 —— 完全不占位置；  \n\n父元素沒有定位，則以流覽器為准定位（Document 文檔）。\n\n父元素要有定位\n\n將元素依據最近的已經定位（絕對、固定或相對定位）的父元素（祖先）進行定位。\n\n\n\n絕對定位的特點：（務必記住）\n\n絕對是以帶有定位的父級元素來移動位置 （拼爹型） 如果父級都沒有定位，則以流覽器文檔為准移動位置\n不保留原來的位置，完全是脫標的。\n\n因為絕對定位的盒子是拼爹的，所以要和父級搭配一起來使用。\n定位口訣 —— 子絕父相剛才咱們說過，絕對定位，要和帶有定位的父級搭配使用，那麼父級要用什麼定位呢？\n子絕父相 —— 子級是絕對定位，父級要用相對定位。\n\n\n\n\n\n\n\n\n\n子絕父相是使用絕對定位的口訣，要牢牢記住！\n疑問：為什麼在佈局時，子級元素使用絕對定位時，父級元素就要用相對定位呢？\n分析：\n\n方向箭頭疊加在其他圖片上方，應該使用絕對定位，因為絕對定位完全脫標，完全不占位置。\n父級盒子應該使用相對定位，因為相對定位不脫標，後續盒子仍然以標準流的方式對待它。\n如果父級盒子也使用絕對定位，會完全脫標，那麼下方的廣告盒子會上移，這顯然不是我們想要的。\n\n\n\n結論：父級要佔有位置，子級要任意擺放，這就是子絕父相的由來。\n3.2.4 固定定位(fixed) - 重要固定定位是絕對定位的一種特殊形式： （認死理型）   如果說絕對定位是一個矩形 那麼 固定定位就類似於正方形\n\n完全脫標 —— 完全不占位置；\n只認流覽器的可視窗口 —— 流覽器可視視窗 + 邊偏移屬性 來設置元素的位置；\n跟父元素沒有任何關係；單獨使用的\n不隨捲軸滾動。\n\n\n\n提示：IE 6 等低版本流覽器不支援固定定位。\n4. 定位(position)的擴展4.1 絕對定位的盒子居中\n\n\n\n\n\n\n\n\n注意：絕對定位&#x2F;固定定位的盒子不能通過設置 margin: auto 設置水準居中。\n在使用絕對定位時要想實現水準居中，可以按照以下的方法：\n\nleft: 50%;：讓盒子的左側移動到父級元素的水準中心位置；\nmargin-left: -100px;：讓盒子向左移動自身寬度的一半。\n\n4.2 堆疊順序（z-index）在使用定位佈局時，可能會出現盒子重疊的情況。\n加了定位的盒子，默認後來者居上， 後面的盒子會壓住前面的盒子。\n應用 z-index 層疊等級屬性可以調整盒子的堆疊順序。\nz-index 的特性如下：\n\n屬性值：正整數、負整數或 0，預設值是 0，數值越大，盒子越靠上；\n如果屬性值相同，則按照書寫順序，後來居上；\n數位後面不能加單位。\n\n注意：z-index 只能應用於相對定位、絕對定位和固定定位的元素，其他標準流、浮動和靜態定位無效。\n4.3 定位改變display屬性 前面我們講過， display 是 顯示模式， 可以改變顯示模式有以下方式:\n\n可以用inline-block  轉換為行內塊\n可以用浮動 float 默認轉換為行內塊（類似，並不完全一樣，因為浮動是脫標的）\n絕對定位和固定定位也和浮動類似， 默認轉換的特性 轉換為行內塊。\n\n所以說， 一個行內的盒子，如果加了浮動、固定定位和絕對定位，不用轉換，就可以給這個盒子直接設置寬度和高度等。\n同時注意：\n浮動元素、絕對定位(固定定位）元素的都不會觸發外邊距合併的問題。 （我們以前是用padding border overflow解決的）\n也就是說，我們給盒子改為了浮動或者定位，就不會有垂直外邊距合併的問題了。\n5. 定位小結\n\n\n定位模式\n是否脫標佔有位置\n移動位置基準\n模式轉換（行內塊）\n使用情況\n\n\n\n靜態static\n不脫標，正常模式\n正常模式\n不能\n幾乎不用\n\n\n相對定位relative\n不脫標，佔有位置\n相對自身位置移動\n不能\n基本單獨使用\n\n\n絕對定位absolute\n完全脫標，不佔有位置\n相對于定位父級移動位置\n能\n要和定位父級元素搭配使用\n\n\n固定定位fixed\n完全脫標，不佔有位置\n相對於流覽器移動位置\n能\n單獨使用，不需要父級\n\n\n注意：\n\n邊偏移需要和定位模式聯合使用，單獨使用無效；\ntop 和 bottom 不要同時使用；\nleft 和 right 不要同時使用。\n\n6. 網頁佈局總結一個完整的網頁，有標準流 、 浮動 、 定位 一起完成佈局的。每個都有自己的專門用法。\n1). 標準流可以讓盒子上下排列 或者 左右排列的\n2). 浮動可以讓多個塊級元素一行顯示  或者 左右對齊盒子   浮動的盒子就是按照順序左右排列 \n3). 定位定位最大的特點是有層疊的概念，就是可以讓多個盒子 前後 疊壓來顯示。 但是每個盒子需要測量數值。\n","slug":"20230316CSS 07-定位(position)","date":"2023-03-16T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"9ff528d9337f78a8c4f9529b9dd287e6","title":"CSS 06-浮動(float)","content":"1. 浮動(float)目標\n記憶\nCSS 的佈局的三種機制\n\n\n理解\n普通流在佈局中的特點\n為什麼用浮動\n為什麼要清除浮動\n\n\n應用\n利用浮動完成巡覽列案例\n清除浮動\n\n\n\n1.1 CSS 佈局的三種機制\n\n\n\n\n\n\n\n\n網頁佈局的核心——就是用 CSS 來擺放盒子。\nCSS 提供了 3 種機制來設置盒子的擺放位置，分別是普通流（標準流）、浮動和定位，其中： \n\n普通流（標準流）\n塊級元素會獨佔一行，從上向下順序排列；\n常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table\n\n\n行內元素會按照順序，從左到右順序排列，碰到父元素邊緣則自動換行；\n常用元素：span、a、i、em等\n\n\n\n\n浮動\n讓盒子從普通流中浮起來,主要作用讓多個塊級盒子一行顯示。\n\n\n定位\n將盒子定在流覽器的某一個位置——CSS 離不開定位，特別是後面的 js 特效。\n\n\n\n1.2 為什麼需要浮動？思考題：\n 首先要思考以下2個佈局中最常見的問題？\n\n如何讓多個盒子(div)水準排列成一行？\n\n如何實現盒子的左右對齊？\n\n\n雖然學過行內塊（inline-block） 但是他卻有自己的缺陷：\n\n它可以實現多個元素一行顯示，但是中間會有空白縫隙，不能滿足以上第一個問題。\n它不能實現以上第二個問題，盒子左右對齊\n\n總結\n\n\n\n\n\n\n\n\n\n因為一些網頁佈局要求，標準流不能滿足我們的需要了，因此我們需要浮動來完成網頁佈局。\n1.3  什麼是浮動(float)概念：元素的浮動是指設置了浮動屬性的元素會\n\n脫離標準普通流的控制\n移動到指定位置。\n\n作用\n讓多個盒子(div)水準排列成一行，使得浮動成為佈局的重要手段。\n可以實現盒子的左右對齊等等..\n浮動最早是用來控制圖片，實現文字環繞圖片的效果。\n\n語法在 CSS 中，通過 float  屬性定義浮動，語法如下：\n選擇器 &#123; float: 屬性值; &#125;\n\n\n\n\n屬性值\n描述\n\n\n\nnone\n元素不浮動（預設值）\n\n\nleft\n元素向左浮動\n\n\nright\n元素向右浮動\n\n\n記法 float   —  浮 漏 特\n1). 浮動口訣之 浮浮動——浮浮浮~~~漂浮在普通流的上面。  脫離標準流。 俗稱 “脫標”   \n.box1 &#123;\n    width: 200px;\n    height: 200px;\n    background-color: rgba(255, 0, 0, 0.5);\n    float: left;\n&#125;\n.box2 &#123;\n    width: 150px;\n    height: 300px;\n    background-color: skyblue;\n&#125;\n\n小結：\n\nfloat 屬性會讓盒子漂浮在標準流的上面，所以第二個標準流的盒子跑到浮動盒子的底下了。\n\n2).  浮動口訣之 漏浮動——漏漏漏~  浮動的盒子，把自己原來的位置漏給下面標準流的盒子，就是不佔有原來位置，是脫離標準流的，我們俗稱 “脫標”。\n.box1 &#123;\n    width: 200px;\n    height: 200px;\n    background-color: rgba(255, 0, 0, 0.5);\n    &#x2F;* 讓第 1 個盒子漂浮起來，不占位置 *&#x2F;\n    float: left;\n&#125;\n.box2 &#123;\n    width: 150px;\n    height: 300px;\n    background-color: skyblue;\n&#125;\n\n 所以，box2下面的其實就是跑到box1盒子下面了， 被box1給壓住了，遮擋起來了\n3). 浮動口訣之 特浮動——特性  float屬性會改變元素display屬性。\n任何元素都可以浮動。浮動元素會生成一個塊級框，而不論它本身是何種元素。 生成的塊級框和我們前面的行內塊極其相似。\n案例——div 水準排列\ndiv &#123;\n    width: 200px;\n    height: 200px;\n    background-color: pink;\n\n    &#x2F;* 轉換為行內塊元素，可以水準顯示，不過 div 之間有間隙，不方便處理 *&#x2F;\n    &#x2F;* display: inline-block; *&#x2F;\n    &#x2F;* 設置浮動屬性，可以讓 div 水準排列，並且沒有間隙 *&#x2F;\n    float: left;\n&#125;\n\n.two &#123;\n    background-color: hotpink;\n&#125;\n\n注意： 浮動的元素互相貼靠一起的，但是如果父級寬度裝不下這些浮動的盒子， 多出的盒子會另起一行對齊\n1.4 浮動(float)小結\n\n\n\n\n\n\n\n\n我們使用浮動的核心目的——讓多個塊級盒子在同一行顯示。 因為這是我們最常見的一種佈局方式\nfloat —— 浮漏特\n\n\n\n特點\n說明\n\n\n\n浮\n加了浮動的盒子是浮起來的，漂浮在其他標準流盒子的上面。\n\n\n漏\n加了浮動的盒子是不占位置的，它原來的位置漏給了標準流的盒子。\n\n\n特\n特別注意：浮動元素會改變display屬性， 類似轉換為了行內塊，但是元素之間沒有空白縫隙\n\n\n1.5 浮動(float)的應用（重要）浮動和標準流的父盒子搭配我們知道，浮動是脫標的，會影響下面的標準流元素，此時，我們需要給浮動的元素添加一個標準流的父親，這樣，最大化的減小了對其他標準流的影響。\n\n\n\n\n\n\n\n\n\n一個完整的網頁，是 標準流 +  浮動 +  我們後面要講的定位 一起完成的。\n注意，實際重要的巡覽列中，我們不會直接用連結a 而是用 li  包含連結(li+a)的做法。\n\nli+a 語義更清晰，一看這就是有條理的清單型內容。\n如果直接用a，搜尋引擎容易辨別為有堆砌關鍵字嫌疑（故意堆砌關鍵字容易被搜尋引擎有降權的風險），從而影響網站排名\n\n1.6  浮動(float)的擴展1). 浮動元素與父盒子的關係\n子盒子的浮動參照父盒子對齊\n不會與父盒子的邊框重疊，也不會超過父盒子的內邊距\n\n2). 浮動元素與兄弟盒子的關係在一個父級盒子中，如果前一個兄弟盒子是：\n\n浮動的，那麼當前盒子會與前一個盒子的頂部對齊；\n普通流的，那麼當前盒子會顯示在前一個兄弟盒子的下方。\n\n\n\n\n\n\n\n\n\n\n\n浮動只會影響當前的或者是後面的標準流盒子，不會影響前面的標準流。\n建議\n如果一個盒子裡面有多個子盒子，如果其中一個盒子浮動了，其他兄弟也應該浮動。防止引起問題\n2. 清除浮動2.1 為什麼要清除浮動因為父級盒子很多情況下，不方便給高度，但是子盒子浮動就不佔有位置，最後父級盒子高度為0，就影響了下面的標準流盒子。\n\n總結：\n由於浮動元素不再佔用原文檔流的位置，所以它會對後面的元素排版產生影響\n準確地說，並不是清除浮動，而是清除浮動後造成的影響\n\n\n\n2.2 清除浮動本質 清除浮動主要為了解決父級元素因為子級浮動引起內部高度為0 的問題。 清除浮動之後， 父級就會根據浮動的子盒子自動檢測高度。 父級有了高度，就不會影響下面的標準流了\n2.3 清除浮動的方法在CSS中，clear屬性用於清除浮動，在這裡，我們先記住清除浮動的方法，具體的原理，等我們學完css會再回頭分析。\n\n語法：\n\n選擇器&#123;clear:屬性值;&#125;   clear 清除  \n\n\n\n\n屬性值\n描述\n\n\n\nleft\n不允許左側有浮動元素（清除左側浮動的影響）\n\n\nright\n不允許右側有浮動元素（清除右側浮動的影響）\n\n\nboth\n同時清除左右兩側浮動的影響\n\n\n但是我們實際工作中， 幾乎只用 clear: both;\n1).額外標籤法(隔牆法)是W3C推薦的做法是通過在浮動元素末尾添加一個空的標籤\n例如 &lt;div style&#x3D;”clear:both”&gt;&lt;&#x2F;div&gt;，或則其他標籤br等亦可。\n\n\n優點： 通俗易懂，書寫方便\n缺點： 添加許多無意義的標籤，結構化較差。\n\n2).父級添加overflow屬性方法可以給父級添加： overflow為 hidden| auto| scroll  都可以實現。\n\n優點：  代碼簡潔\n缺點：  內容增多時候容易造成不會自動換行導致內容被隱藏掉，無法顯示需要溢出的元素。\n3).使用after偽元素清除浮動:after 方式為空元素額外標籤法的升級版，好處是不用單獨加標籤了 \n使用方法：\n.clearfix:after &#123;  \n   content: &quot;&quot;; \n   display: block; \n   height: 0; \n   clear: both; \n   visibility: hidden;  \n &#125;   \n\n.clearfix &#123;*zoom: 1;&#125;   &#x2F;* IE6、7 專有 *&#x2F;\n\n\n優點： 符合閉合浮動思想  結構語義化正確\n缺點： 由於IE6-7不支持:after，使用 zoom:1觸發 hasLayout。\n\n4).使用雙偽元素清除浮動使用方法：\n.clearfix:before,.clearfix:after &#123; \n  content:&quot;&quot;;\n  display:table; \n&#125;\n.clearfix:after &#123;\n clear:both;\n&#125;\n.clearfix &#123;\n  *zoom:1;\n&#125;\n\n\n優點：  代碼更簡潔\n\n缺點：  由於IE6-7不支持:after，使用 zoom:1觸發 hasLayout。\n\n\n2.4 清除浮動總結什麼時候用清除浮動？\n\n父級沒高度\n子盒子浮動了\n影響下面佈局了，我們就應該清除浮動了。\n\n\n\n\n清除浮動的方式\n優點\n缺點\n\n\n\n額外標籤法（隔牆法）\n通俗易懂，書寫方便\n添加許多無意義的標籤，結構化較差。\n\n\n父級overflow:hidden;\n書寫簡單\n溢出隱藏\n\n\n父級after偽元素\n結構語義化正確\n由於IE6-7不支持:after，相容性問題\n\n\n父級雙偽元素\n結構語義化正確\n由於IE6-7不支持:after，相容性問題\n\n\n","slug":"20230315CSS 06-浮動(float)","date":"2023-03-15T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"8c021a3b84d7a0602ad12ca159c8b3ca","title":"CSS 05-盒子模型+拓展規範","content":"盒子模型（CSS重點）\n\n\n\n\n\n\n\n\ncss學習三大重點： css 盒子模型   、  浮動  、  定位  \n目標： \n\n理解：\n盒子模型有那四部分組成\n內邊距的作用以及對盒子的影響\npadding設置不同數值個數分別代表的意思\n塊級盒子居中對齊需要的2個條件\n外邊距合併的解決方法\n\n\n應用：\n利用邊框複合寫法給元素添加邊框\n計算盒子的實際大小\n利用盒子模型佈局模組案例\n\n\n\n1.看透網頁佈局的本質網頁佈局中，如何把裡面的文字，圖片，按照美工給的效果圖排列的整齊有序呢？\n\n看透網頁佈局的本質：\n首先利用CSS設置盒子大小，然後擺放盒子的位置。\n最後把網頁元素比如文字圖片等等，放入盒子裡面。\n以上兩步 就是網頁佈局的本質\n\n\n\n盒子是網頁佈局的關鍵點，所以需要弄明白盒子有什麼特點。\n2. 盒子模型（Box Model）\n所謂盒子模型：\n\n就是把HTML頁面中的佈局元素看作是一個矩形的盒子，也就是一個盛裝內容的容器。\n\n總結：\n\n盒子模型有元素的內容、邊框（border）、內邊距（padding）、和外邊距（margin）組成。\n盒子裡面的文字和圖片等元素是內容區域\n盒子的厚度 成為 盒子的邊框 \n盒子內容與邊框的距離是內邊距（類似儲存格的 cellpadding）\n盒子與盒子之間的距離是外邊距（類似儲存格的 cellspacing）\n\n\n\n3. 盒子邊框（border）\n語法：\n\nborder : border-width || border-style || border-color \n\n\n\n\n屬性\n作用\n\n\n\nborder-width\n定義邊框粗細，單位是px\n\n\nborder-style\n邊框的樣式\n\n\nborder-color\n邊框顏色\n\n\n\n邊框的樣式：\nnone：沒有邊框即忽略所有邊框的寬度（預設值）\nsolid：邊框為單實線(最為常用的)\ndashed：邊框為虛線  \ndotted：邊框為點線\n\n\n\n3.1 邊框綜合設置border : border-width || border-style || border-color \n\n例如：\nborder: 1px solid red;  沒有順序  \n\n\n3.2 盒子邊框寫法總結表很多情況下，我們不需要指定4個邊框，我們是可以單獨給4個邊框分別指定的。\n\n\n\n上邊框\n下邊框\n左邊框\n右邊框\n\n\n\nborder-top-style:樣式;\nborder-bottom-style:樣式;\nborder-left-style:樣式;\nborder-right-style:樣式;\n\n\nborder-top-width:寬度;\nborder- bottom-width:寬度;\nborder-left-width:寬度;\nborder-right-width:寬度;\n\n\nborder-top-color:顏色;\nborder- bottom-color:顏色;\nborder-left-color:顏色;\nborder-right-color:顏色;\n\n\nborder-top:寬度 樣式 顏色;\nborder-bottom:寬度 樣式 顏色;\nborder-left:寬度 樣式 顏色;\nborder-right:寬度 樣式 顏色;\n\n\n3.3 表格的細線邊框\n通過表格的cellspacing=&quot;0&quot;,將儲存格與儲存格之間的距離設置為0，\n\n但是兩個儲存格之間的邊框會出現重疊，從而使邊框變粗\n\n通過css屬性：\ntable&#123; border-collapse:collapse; &#125;  \n\n\ncollapse 單詞是合併的意思\nborder-collapse:collapse; 表示相鄰邊框合併在一起。\n\n\n\n&lt;style&gt;\n  table &#123;\n    width: 500px;\n    height: 300px;\n    border: 1px solid red;\n  &#125;\n  td &#123;\n    border: 1px solid red;\n    text-align: center;\n  &#125;\n  table, td &#123;\n    border-collapse: collapse;  &#x2F;*合併相鄰邊框*&#x2F;\n  &#125;\n&lt;&#x2F;style&gt;\n\n4. 內邊距（padding）4.1 內邊距： padding屬性用於設置內邊距。 是指 邊框與內容之間的距離\n4.2 設置\n\n\n屬性\n作用\n\n\n\npadding-left\n左內邊距\n\n\npadding-right\n右內邊距\n\n\npadding-top\n上內邊距\n\n\npadding-bottom\n下內邊距\n\n\n當給盒子指定padding值之後， 會發生2件事情：\n\n內容和邊框有了距離，添加了內邊距。\n盒子會變大了。\n\n多項值簡寫方法：\n\n\n\n值的個數\n表達意思\n\n\n\n1個值\npadding：上下左右內邊距;\n\n\n2個值\npadding: 上下內邊距    左右內邊距 ；\n\n\n3個值\npadding：上內邊距   左右內邊距   下內邊距；\n\n\n4個值\npadding: 上內邊距 右內邊距 下內邊距 左內邊距 ；\n\n\n4.3內盒尺寸計算（元素實際大小）\n寬度\nElement Height &#x3D; content height + padding + border （Height為內容高度）\n\n高度\n Element Width &#x3D; content width + padding + border （Width為內容寬度）\n\n盒子的實際的大小 &#x3D;   內容的寬度和高度 +  內邊距   +  邊框\n\n\n\n\n\n\n\n\n\n\n\n問：一個盒子寬度為100， padding為 10， 邊框為5圖元，問這個盒子實際的寬度的是（）\n\n \n(A) 130\n\n \n(B) 135 \n\n \n(C) 125\n\n \n(D) 115\n100 +  20 + 10\n\n\n\n\n\n\n\n\n\n\n\n問：關於根據下列代碼計算 盒子寬高下列說法正確的是（）\ndiv &#123;\n\n    width: 200px;\n\n         height: 200px;\n\n    border: 1px solid #000000;\n\n    border-top: 5px solid blue;\n\n    padding: 50px;\n\n    padding-left: 100px;\n\n    &#125;\n\n\n (A) 寬度為200px 高度為200px\n (B) 寬度為352px 高度為306px\n (C) 寬度為302px 高度為307px\n (D) 寬度為302px 高度為252px\n\nw&#x3D;200 +   150   + 2   &#x3D;  352h&#x3D;   200 +  100 +  6   &#x3D;  306\n4.4 padding不影響盒子大小情況\n\n\n\n\n\n\n\n\n如果沒有給一個盒子指定寬度， 此時，如果給這個盒子指定padding， 則不會撐開盒子。\n5. 外邊距（margin）5.1 外邊距 margin屬性用於設置外邊距。  margin就是控制盒子和盒子之間的距離\n5.2 設置：\n\n\n屬性\n作用\n\n\n\nmargin-left\n左外邊距\n\n\nmargin-right\n右外邊距\n\n\nmargin-top\n上外邊距\n\n\nmargin-bottom\n下外邊距\n\n\nmargin值的簡寫 （複合寫法）代表意思  跟 padding 完全相同。\n5.3 塊級盒子水準居中\n可以讓一個塊級盒子實現水準居中必須：\n盒子必須指定了寬度（width）\n然後就給左右的外邊距都設置為auto，\n\n\n\n實際常用這種方式進行網頁佈局，示例代碼如下：\n.header&#123; width:960px; margin:0 auto;&#125;\n\n常見的寫法，以下下三種都可以。\n\nmargin-left: auto;   margin-right: auto;\nmargin: auto;\nmargin: 0 auto;\n\n5.4 文字居中和盒子居中區別\n盒子內的文字水準居中是  text-align: center,  而且還可以讓 行內元素和行內塊居中對齊\n塊級盒子水準居中  左右margin 改為 auto\n\ntext-align: center;&#x2F;*  文字 行內元素 行內塊元素水準居中 *&#x2F;\nmargin: 10px auto; &#x2F;* 塊級盒子水準居中 左右margin改為auto 上下margin都可以 *&#x2F;\n\n5.5 插入圖片和背景圖片區別\n插入圖片 我們用的最多，比如產品展示類、移動位置只能靠盒模型 padding margin\n背景圖片 我們一般用於小圖示背景，或者 超大背景圖片、背景圖片 只能通過  background-position\n\nimg &#123;  \n   width: 200px;&#x2F;* 插入圖片更改大小 width 和 height *&#x2F;\n   height: 210px;\n   margin-top: 30px;  &#x2F;* 插入圖片更改位置 可以用margin 或padding  盒模型 *&#x2F;\n   margin-left: 50px; &#x2F;* 插入當圖片也是一個盒子 *&#x2F;\n &#125;\n\ndiv &#123;\n   width: 400px;\n   height: 400px;\n   border: 1px solid purple;\n   background: #fff url(images&#x2F;sun.jpg) no-repeat;\n   background-position: 30px 50px; &#x2F;* 背景圖片更改位置 我用 background-position *&#x2F;\n &#125;\n\n5.6 清除元素的預設內外邊距(重要)為了更靈活方便地控制網頁中的元素，製作網頁時，我們需要將元素的預設內外邊距清除\n代碼： \n* &#123;\n   padding:0;         &#x2F;* 清除內邊距 *&#x2F;\n   margin:0;          &#x2F;* 清除外邊距 *&#x2F;\n&#125;\n\n注意：  \n\n行內元素為了照顧相容性， 儘量只設置左右內外邊距， 不要設置上下內外邊距。\n\n5.7 外邊距合併使用margin定義塊元素的垂直外邊距時，可能會出現外邊距的合併。\n(1). 相鄰塊元素垂直外邊距的合併\n當上下相鄰的兩個塊元素相遇時，如果上面的元素有下外邊距margin-bottom\n下面的元素有上外邊距margin-top，則他們之間的垂直間距不是margin-bottom與margin-top之和\n取兩個值中的較大者這種現象被稱為相鄰塊元素垂直外邊距的合併（也稱外邊距塌陷）。\n\n\n\n\n\n\n\n\n\n\n解決方案：儘量給只給一個盒子添加margin值。\n(2). 嵌套塊元素垂直外邊距的合併（塌陷）\n對於兩個嵌套關係的塊元素，如果父元素沒有上內邊距及邊框\n父元素的上外邊距會與子元素的上外邊距發生合併\n合併後的外邊距為兩者中的較大者\n\n\n\n\n\n\n\n\n\n\n解決方案：\n\n為父元素定義上邊框\n為父元素定義上內邊距\n為父元素添加overflow:hidden\n\n還有其他方法，比如浮動、固定、絕對定位的盒子不會有問題\n6. 盒子模型佈局穩定性\n什麼情況下用內邊距，什麼情況下用外邊距？\n\n大部分情況下是可以混用的。  就是說，你用內邊距也可以，用外邊距也可以。 覺得哪個方便，就用哪個。\n\n\n\n根據穩定性來分，建議如下：\n按照 優先使用  寬度 （width）  其次 使用內邊距（padding）    再次  外邊距（margin）。   \nwidth &gt;  padding  &gt;   margin   \n\n\n原因：\nmargin 會有外邊距合併 還有 ie6下面margin 加倍的bug（討厭）所以最後使用。\npadding  會影響盒子大小， 需要進行加減計算（麻煩） 其次使用。\nwidth   沒有問題（嗨皮）我們經常使用寬度剩餘法 高度剩餘法來做。\n\n\n\n拓展@以下我們講的CSS3部分新屬性， 但是我們遵循的原則是，以下內容，不會影響我們頁面配置， 只是樣式更好看了而已。\n1.圓角邊框(CSS3)\n語法：\n\nborder-radius:length;  \n\n\n其中每一個值可以為 數值或百分比的形式。 \n\n技巧： 讓一個正方形  變成圓圈 \nborder-radius: 50%;\n\n2. 盒子陰影(CSS3)\n語法:\n\nbox-shadow:水準陰影 垂直陰影 模糊距離（虛實）  陰影尺寸（影子大小）  陰影顏色  內&#x2F;外陰影；\n\n\n前兩個屬性是必須寫的。其餘的可以省略。\n外陰影 (outset) 是默認的 但是不能寫           \n想要內陰影可以寫  inset\n\ndiv &#123;\n      width: 200px;\n      height: 200px;\n      border: 10px solid red;\n      &#x2F;* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  *&#x2F;\n      &#x2F;* box-shadow:水準位置 垂直位置 模糊距離 陰影尺寸（影子大小） 陰影顏色  內&#x2F;外陰影； *&#x2F;\n      box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);\n      \n&#125;\n\n空格規範\n\n\n\n\n\n\n\n\n【強制】 選擇器 與 { 之間必須包含空格。\n示例： \n.selector &#123;\n&#125;\n\n\n\n\n\n\n\n\n\n\n【強制】 屬性名 與之後的 : 之間不允許包含空格， : 與 屬性值 之間必須包含空格。\n示例：\nfont-size: 12px;\n\n選擇器規範\n\n\n\n\n\n\n\n\n【強制】 並集選擇器，每個選擇器聲明必須獨佔一行。\n示例：\n&#x2F;* good *&#x2F;\n.post,\n.page,\n.comment &#123;\n    line-height: 1.5;\n&#125;\n\n&#x2F;* bad *&#x2F;\n.post, .page, .comment &#123;\n    line-height: 1.5;\n&#125;\n\n\n\n\n\n\n\n\n\n\n【建議】 一般情況情況下，選擇器的嵌套層級應不大於 3 級，位置靠後的限定條件應盡可能精確。\n示例：\n&#x2F;* good *&#x2F;\n#username input &#123;&#125;\n.comment .avatar &#123;&#125;\n\n&#x2F;* bad *&#x2F;\n.page .header .login  input &#123;&#125;\n.comment div * &#123;&#125;\n\n屬性規範\n\n\n\n\n\n\n\n\n【強制】 屬性定義必須另起一行。\n示例：\n&#x2F;* good *&#x2F;\n.selector &#123;\n    margin: 0;\n    padding: 0;\n&#125;\n\n&#x2F;* bad *&#x2F;\n.selector &#123; margin: 0; padding: 0; &#125;\n\n\n\n\n\n\n\n\n\n\n【強制】 屬性定義後必須以分號結尾。\n示例：\n&#x2F;* good *&#x2F;\n.selector &#123;\n    margin: 0;\n&#125;\n\n&#x2F;* bad *&#x2F;\n.selector &#123;\n    margin: 0\n&#125;\n\n\n","slug":"20230314CSS 05-盒子模型+拓展規範","date":"2023-03-14T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"494b4979132be1c92e421450a897b835","title":"CSS 04-複合選擇器+三大特性","content":"1. CSS複合選擇器目標\n\n理解\n\n理解css複合選擇器分別的應用場景\n\n\n應用\n\n使用後代選擇器給元素添加樣式\n使用並集選擇器給元素添加樣式\n使用偽類別選取器\n\n\n\n為什麼要學習css複合選擇器\n\n目的是為了可以選擇更準確更精細的目標元素標籤。\n複合選擇器是由兩個或多個基礎選擇器，通過不同的方式組合而成的\n\n\n\n\n\n\n\n\n\n\nCSS選擇器分為 基礎選擇器 和 複合選擇器 ，但是基礎選擇器不能滿足我們實際開發中，快速高效的選擇標籤。\n1.1 後代選擇器（重點）\n概念：\n後代選擇器又稱為包含選擇器\n\n作用：\n用來選擇元素或元素組的子孫後代\n\n其寫法就是把外層標籤寫在前面，內層標籤寫在後面，中間用空格分隔，先寫父親爺爺，在寫兒子孫子。\n\n\n父級 子級&#123;屬性:屬性值;屬性:屬性值;&#125;\n\n\n語法：\n\n.class h3&#123;color:red;font-size:16px;&#125;\n\n\n當標籤發生嵌套時，內層標籤就成為外層標籤的後代。\n子孫後代都可以這麼選擇。 或者說，它能選擇任何包含在內的標籤。\n\n1.2 子元素選擇器\n作用：\n子元素選擇器只能選擇作為某元素子元素的元素。\n\n其寫法就是把父級標籤寫在前面，子級標籤寫在後面，中間跟一個 &gt; 進行連接\n\n語法：\n\n\n.class&gt;h3&#123;color:red;font-size:14px;&#125;\n\n\n\n\n\n\n\n\n\n\n這裡的子 指的是 親兒子  不包含孫子 重孫子之類。\n比如：  \n.demo &gt; h3 &#123;color: red;&#125;   \n說明  h3 一定是demo 親兒子。  demo 元素包含著h3。\n\n1.3 交集選擇器\n條件：\n交集選擇器由兩個選擇器構成，找到的標籤必須滿足：既有標籤一的特點，也有標籤二的特點。\n\n語法：\n\n其中第一個為標籤選擇器，第二個為class選擇器，兩個選擇器之間不能有空格\n\n如 h3.special。\n\n\n記憶技巧：\n交集選擇器 是 並且的意思。  即…又…的意思\n比如： p.one   \n選擇的是： 類名為 .one  的 段落標籤。  \n\n用的相對來說比較少，不太建議使用。\n1.4 並集選擇器（重點）\n應用：\n\n如果某些選擇器定義的相同樣式，就可以利用並集選擇器，可以讓代碼更簡潔。\n\n\n並集選擇器（CSS選擇器分組）是各個選擇器通過,連接而成的，通常用於集體聲明。\n\n語法：\n\n任何形式的選擇器（包括標籤選擇器、class類別選取器id選擇器等），都可以作為並集選擇器的一部分。\n\n記憶技巧：\n並集選擇器通常用於集體聲明  ，逗號隔開的，所有選擇器都會執行後面樣式，逗號可以理解為 和的意思。\n\n\n.one, p , #test &#123;color: #F00;&#125;\n表示.one 和 p  和 #test 這三個選擇器都會執行顏色為紅色。 \n通常用於集體聲明。  \n\n1.5  連結偽類別選取器（重點） 偽類別選取器：\n為了和類別選取器相區別，類別選取器是一個點 比如 .demo {}而偽類用 2個點就是冒號 比如  :link{} \n作用：\n用於向某些選擇器添加特殊的效果。比如給連結添加特殊效果， 比如可以選擇 第1個，第n個元素。因為偽類別選取器很多，比如連結偽類，結構偽類等等。\n連結偽類別選取器\n- a:link      &#x2F;* 未訪問的連結 *&#x2F;\n- a:visited   &#x2F;* 已訪問的連結 *&#x2F;\n- a:hover     &#x2F;* 滑鼠移動到連結上 *&#x2F;\n- a:active    &#x2F;* 選定的連結 *&#x2F;\n\n\n\n  注意\n\n寫的時候，他們的順序儘量不要顛倒，按照lvha 的順序。否則可能引起錯誤。  \n記憶法love   hate     \n因為叫連結偽類，所以都是 利用交集選擇器  a:link    a:hover  \n因為a連結流覽器具有預設樣式，所以我們實際工作中都需要給連結單獨指定樣式。\n實際工作開發中很少寫全四個狀態，一般寫法如下：\n\na &#123;   &#x2F;* a是標籤選擇器  所有的連結 *&#x2F;\n      font-weight: 700;\n      font-size: 16px;\n      color: gray;\n&#125;\na:hover &#123;   &#x2F;* :hover 是連結偽類別選取器 滑鼠經過 *&#x2F;\n      color: red; &#x2F;*  滑鼠經過的時候，由原來的 灰色 變成了紅色 *&#x2F;\n&#125;\n\n1.6 複合選擇器總結\n\n\n選擇器\n作用\n特徵\n使用情況\n隔開符號及用法\n\n\n\n後代選擇器\n用來選擇元素後代\n是選擇所有的子孫後代\n較多\n符號是空格 .nav a\n\n\n子代選擇器\n選擇 最近一級元素\n只選親兒子\n較少\n符號是&gt;   .nav&gt;p\n\n\n交集選擇器\n選擇兩個標籤交集的部分\n既是 又是\n較少\n沒有符號  p.one\n\n\n並集選擇器\n選擇某些相同樣式的選擇器\n可以用於集體聲明\n較多\n符號是逗號 .nav, .header\n\n\n連結偽類別選取器\n給連結更改狀態\n\n較多\n重點記住 a{} 和 a:hover  實際開發的寫法\n\n\n2. 標籤顯示模式（display）重點目標：\n\n理解\n標籤的三種顯示模式\n三種顯示模式的特點以及區別\n理解三種顯示模式的相互轉化\n\n\n應用\n實現三種顯示模式的相互轉化\n\n\n\n2.1 什麼是標籤顯示模式\n什麼是標籤的顯示模式？\n標籤以什麼方式進行顯示，比如div 自己占一行， 比如span 一行可以放很多個\n\n作用： \n我們網頁的標籤非常多，再不同地方會用到不同類型的標籤，以便更好的完成我們的網頁。\n\n標籤的類型(分類)\nHTML標籤一般分為塊標籤和行內標籤兩種類型，它們也稱塊元素和行內元素。\n\n\n2.2 塊級元素(block-level)常見的塊元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，\n其中&lt;div&gt;標籤是最典型的塊元素。\n\n\n塊級元素的特點\n\n（1）比較霸道，自己獨佔一行\n（2）高度，寬度、外邊距以及內邊距都可以控制。\n（3）寬度默認是容器（父級寬度）的100%\n（4）是一個容器及盒子，裡面可以放行內或者塊級元素。\n\n注意：\n只有文字才能組成段落，因此p裡面不能放塊級元素，特別是p 不能放div \n同理還有這些標籤h1,h2,h3,h4,h5,h6,dt，他們都是文字類塊級標籤，裡面不能放其他塊級元素。\n\n\n\n2.3 行內元素(inline-level)\n例：\n\n常見的行內元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等\n其中&lt;span&gt;標籤為最典型的行內元素。有些地方也成內聯元素\n\n\n行內元素的特點：\n\n（1）相鄰行內元素在一行上，一行可以顯示多個。\n（2）高、寬直接設置是無效的。\n（3）預設寬度就是它本身內容的寬度。\n（4）行內元素只能容納文本或則其他行內元素。\n注意：\n\n連結裡面不能再放連結。\n特殊情況a裡面可以放塊級元素，但是給a轉換一下塊級模式最安全。\n\n2.4 行內塊元素（inline-block）\n例：\n\n在行內元素中有幾個特殊的標籤——&lt;img &#x2F;&gt;、&lt;input &#x2F;&gt;、&lt;td&gt;，\n可以對它們設置寬高和對齊屬性，有些資料可能會稱它們為行內塊元素。\n\n\n行內塊元素的特點：\n（1）和相鄰行內元素（行內塊）在一行上,但是之間會有空白縫隙。一行可以顯示多個（2）預設寬度就是它本身內容的寬度。（3）高度，行高、外邊距以及內邊距都可以控制。\n\n\n2.5 三種模式總結區別\n\n\n元素模式\n元素排列\n設置樣式\n預設寬度\n包含\n\n\n\n塊級元素\n一行只能放一個塊級元素\n可以設置寬度高度\n容器的100%\n容器級可以包含任何標籤\n\n\n行內元素\n一行可以放多個行內元素\n不可以直接設置寬度高度\n它本身內容的寬度\n容納文本或則其他行內元素\n\n\n行內塊元素\n一行放多個行內塊元素\n可以設置寬度和高度\n它本身內容的寬度\n\n\n\n2.6 標籤顯示模式轉換 display\n塊轉行內：display:inline;\n行內轉塊：display:block;\n塊、行內元素轉換為行內塊： display: inline-block;\n\n此階段，我們只需關心這三個，其他的是後面的工作。\n3. 行高那些事（line-height）目標\n\n理解\n能說出 行高  和 高度  三種關係\n能簡單理解為什麼行高等於高度單行文字會垂直居中\n\n\n應用\n使用行高實現單行文字垂直居中\n能會測量行高\n\n\n\n3.1 行高測量\n行高的測量方法：\n行高 &#x3D; 基線與基線之間的距離\n\n\n\n3.2 單行文本垂直居中 行高我們利用最多的一個地方是： 可以讓單行文本在盒子中垂直居中對齊。\n\n\n\n\n\n\n\n\n\n文字的行高等於盒子的高度。\n\n行高   &#x3D;  上距離 +  內容高度  + 下距離\n\n上距離和下距離總是相等的，因此文字看上去是垂直居中的。\n行高和高度的三種關係\n\n如果行高等於高度，文字會垂直居中\n如果行高大於高度，文字會偏下 \n如果行高小於高度，文字會偏上\n\n4. CSS 背景(background)目標\n\n理解\n背景的作用\ncss背景圖片和插入圖片的區別\n\n\n應用\n通過css背景屬性，給頁面元素添加背景樣式\n能設置不同的背景圖片位置\n\n\n\n4.1 背景顏色(color)\n語法：\nbackground-color:顏色值;   默認的值是 transparent  透明的\n\n4.2 背景圖片(image)\n語法：\n\nbackground-image : none | url (url) \n\n\n\n\n參數\n作用\n\n\n\nnone\n無背景圖（默認的）\n\n\nurl\n使用絕對或相對位址指定背景圖像\n\n\nbackground-image : url(images&#x2F;demo.png);\n\n\n小技巧： 背景圖片後面的位址，url不要加引號。\n\n4.3 背景平鋪（repeat）\n語法：\n\nbackground-repeat : repeat | no-repeat | repeat-x | repeat-y \n\n\n\n\n參數\n作用\n\n\n\nrepeat\n背景圖像在縱向和橫向上平鋪（默認的）\n\n\nno-repeat\n背景圖像不平鋪\n\n\nrepeat-x\n背景圖像在橫向上平鋪\n\n\nrepeat-y\n背景圖像在縱向平鋪\n\n\n4.4 背景位置(position) 重點\n語法：\n\nbackground-position : length || length\n\nbackground-position : position || position \n\n\n\n\n參數\n值\n\n\n\nlength\n百分數 | 由浮點數位和單位識別字組成的長度值\n\n\nposition\ntop | center | bottom | left | center | right   方位名詞\n\n\n\n注意：\n必須先指定background-image屬性\nposition 後面是x座標和y座標。 可以使用方位名詞或者 精確單位。\n如果指定兩個值，兩個值都是方位名字，則兩個值前後順序無關，比如left  top和top  left效果一致\n如果只指定了一個方位名詞，另一個值默認居中對齊。\n如果position 後面是精確座標， 那麼第一個，肯定是 x  第二的一定是y\n如果只指定一個數值,那該數值一定是x座標，另一個默認垂直居中\n如果指定的兩個值是 精確單位和方位名字混合使用，則第一個值是x座標，第二個值是y座標\n\n\n\n實際用的最多，是背景圖片居中對齊了。\n4.5 背景附著\n背景附著就是解釋背景是滾動的還是固定的\n\n語法： \nbackground-attachment : scroll | fixed \n\n\n\n\n參數\n作用\n\n\n\nscroll\n背景圖像是隨物件內容滾動\n\n\nfixed\n背景圖像固定\n\n\n4.6 背景簡寫\nbackground：屬性的值的書寫順序官方並沒有強制標準的。為了可讀性，建議大家如下寫：\nbackground: 背景顏色 背景圖片位址 背景平鋪 背景滾動 背景位置;\n語法：\n\nbackground: transparent url(image.jpg) repeat-y  scroll center top ;\n\n\n4.7 背景透明(CSS3)\n語法：\n\nbackground: rgba(0, 0, 0, 0.3);\n\n\n最後一個參數是alpha透明度  取值範圍 0~1之間\n習慣把0.3 的 0 省略掉  這樣寫  background: rgba(0, 0, 0, .3);\n注意：  背景半透明是指盒子背景半透明， 盒子裡面的內容不受影響\n因為是CSS3 ，所以 低於 ie9 的版本是不支持的。\n\n4.8 背景總結\n\n\n屬性\n作用\n值\n\n\n\nbackground-color\n背景顏色\n預定義的顏色值&#x2F;十六進位&#x2F;RGB代碼\n\n\nbackground-image\n背景圖片\nurl(圖片路徑)\n\n\nbackground-repeat\n是否平鋪\nrepeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y\n\n\nbackground-position\n背景位置\nlength&#x2F;position    分別是x  和 y座標， 切記 如果有 精確數值單位，則必須按照先X 後Y 的寫法\n\n\nbackground-attachment\n背景固定還是滾動\nscroll&#x2F;fixed\n\n\n背景簡寫\n更簡單\n背景顏色 背景圖片位址 背景平鋪 背景滾動 背景位置;  他們沒有順序\n\n\n背景透明\n讓盒子半透明\nbackground: rgba(0,0,0,0.3);   後面必須是 4個值\n\n\n5. CSS 三大特性目標：\n\n理解\n能說出css樣式衝突採取的原則\n能說出那些常見的樣式會有繼承\n\n\n應用\n能寫出CSS優先順序的演算法\n能會計算常見選擇器的疊加值\n\n\n\n5.1 CSS層疊性\n概念：\n所謂層疊性是指多種CSS樣式的疊加。\n是流覽器處理衝突的一個能力,如果一個屬性通過兩個相同選擇器設置到同一個元素上，那麼這個時候一個屬性就會將另一個屬性層疊掉\n\n原則：\n\n樣式衝突，遵循的原則是就近原則。 那個樣式離著結構近，就執行那個樣式。\n樣式不衝突，不會層疊\n\n\n\nCSS層疊性最後的執行口訣：  長江後浪推前浪，前浪死在沙灘上。\n\n5.2 CSS繼承性\n概念：\n子標籤會繼承父標籤的某些樣式，如文本顏色和字型大小。\n 想要設置一個可繼承的屬性，只需將它應用于父元素即可。\n\n\n\n\n\n\n\n\n\n\n\n簡單的理解就是： 子承父業。\n\n注意：\n恰當地使用繼承可以簡化代碼，降低CSS樣式的複雜性。比如有很多子級孩子都需要某個樣式，可以給父級指定一個，這些孩子繼承過來就好了。\n子元素可以繼承父元素的樣式（text-，font-，line-這些元素開頭的可以繼承，以及color屬性）\n\n\n\nCSS繼承性口訣：  龍生龍，鳳生鳳，老鼠生的孩子會打洞。\n5.3 CSS優先順序（重點）\n概念：\n定義CSS樣式時，經常出現兩個或更多規則應用在同一元素上，此時，\n\n選擇器相同，則執行層疊性\n選擇器不同，就會出現優先順序的問題。\n\n\n\n1). 權重計算公式關於CSS權重，需要一套計算公式來去計算，這個就是 CSS Specificity（特殊性）\n\n\n\n標籤選擇器\n計算權重公式\n\n\n\n繼承或者 *\n0,0,0,0\n\n\n每個元素（標籤選擇器）\n0,0,0,1\n\n\n每個類，偽類\n0,0,1,0\n\n\n每個ID\n0,1,0,0\n\n\n每個行內樣式 style&#x3D;””\n1,0,0,0\n\n\n每個!important  重要的\n∞ 無窮大\n\n\n\n值從左到右，左面的最大，一級大於一級，數位之間沒有進制，級別之間不可超越。 \n關於CSS權重，我們需要一套計算公式來去計算，這個就是 CSS Specificity（特殊性）div &#123;\n     color: pink!important;  \n &#125;\n\n2). 權重疊加經常用交集選擇器，後代選擇器等，若有多個基礎選擇器組合而成，那麼此時，就會出現權重疊加。\n就是一個簡單的加法計算\n\ndiv ul  li   ——&gt;      0,0,0,3\n.nav ul li   ——&gt;      0,0,1,2\na:hover      —–—&gt;   0,0,1,1\n.nav a       ——&gt;      0,0,1,1\n\n注意： \n\n數位之間沒有進制 比如說： 0,0,0,5 + 0,0,0,5 &#x3D;0,0,0,10 而不是 0,0, 1, 0， 所以不會存在10個div能趕上一個類別選取器的情況。\n\n3). 繼承的權重是0這個不難，但是忽略很容易繞暈。其實，修改樣式，一定要看該標籤有沒有被選中。\n1） 如果選中了，那麼以上面的公式來計權重。誰大聽誰的。2） 如果沒有選中，那麼權重是0，因為繼承的權重為0.\n6. CSS注釋CSS注釋規則：\n&#x2F;*需要注釋的內容*&#x2F;  ←注釋方式，\n即在需要注釋的內容前使用 &#x2F;* 標記開始注釋，在內容的結尾使用 *&#x2F; 結束。\n\n   例如：\np &#123;\n &#x2F;* 所有的字體是14圖元大小*&#x2F;\n  font-size: 14px;                 \n&#125;\n\n","slug":"20230313CSS 04-複合選擇器+三大特性","date":"2023-03-13T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"d86c07d9a08e828d31cdbce6c02ea3bd","title":"CSS 03-文本樣式屬性調試工具","content":"\n應用\n使用css字體樣式完成對字體的設置\n使用css外觀屬性給頁面元素添加樣式\n使用常用的emment語法\n能夠使用開發人員工具代碼調試\n\n\n\n1.font字體1.1 font-size:大小\n作用：font-size屬性用於設置字型大小\np &#123;  \n    font-size:20px; \n&#125;\n\n單位：\n\n可以使用相對長度單位，也可以使用絕對長度單位。\n相對長度單位比較常用，推薦使用圖元單位px，絕對長度單位使用較少。\n\n\n\n\n\n\n相對長度單位\n說明\n\n\n\nem\n相對於當前對象文本的字體尺寸\n\n\npx\n像素(最常用)\n\n\n\n\n\n絕對長度單位\n說明\n\n\n\nin\n英吋\n\n\ncm\n公分\n\n\nmm\n毫米\n\n\npt\n點\n\n\n注意：\n\n文字大小基本就用px了，其他單位很少使用\ngoogle流覽器預設的文字大小為16px\n但是不同流覽器可能預設顯示的字型大小大小不一致，需要儘量給一個明確值大小。\n\n1.2 font-family:字體\n作用：\nfont-family屬性用於設置哪一種字體。\n\n\np&#123; font-family:&quot;微軟雅黑&quot;;&#125;\n\n\n網頁中常用的字體有宋體、微軟雅黑、黑體等，例如將網頁中所有段落文本的字體設置為微軟雅黑\n可以同時指定多個字體，中間以逗號隔開，表示如果流覽器不支援第一個字體，則會嘗試下一個，直到找到合適的字體， 如果都沒有，則以我們電腦預設的字體為准。\n\np&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微軟雅黑&quot;;&#125;\n\n1. 各種字體之間必須使用英文狀態下的逗號隔開。\n2. 中文字體需要加英文狀態下的引號，英文字體一般不需要加引號。當需要設置英文字體時，英文字體名必須位於中文字體名之前。\n3. 如果字體名中包含空格、#、$等符號，則該字體必須加英文狀態下的單引號或雙引號，例如font-family: &quot;Times New Roman&quot;;。\n4. 儘量使用系統預設字體，保證在任何使用者的流覽器中都能正確顯示。\n\nCSS Unicode字體\n為什麼使用 Unicode字體\n\n在 CSS 中設置字體名稱，直接寫中文是可以的。但是在檔編碼（GB2312、UTF-8 等）不匹配時會產生亂碼的錯誤。\n\n\n解決：\n\n方案一： 你可以使用英文來替代。 比如 font-family:&quot;Microsoft Yahei&quot;。\n\n方案二： 在 CSS 直接使用 Unicode 編碼來寫字體名稱可以避免這些錯誤。使用 Unicode 寫中文字體名稱，流覽器是可以正確的解析的。\nfont-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;;   &#x2F;&#x2F;表示設置字體為“微軟雅黑”。\n\n\n\n\n\n\n字體名稱\n英文名稱\nUnicode 編碼\n\n\n\n宋體\nSimSun\n\\5B8B\\4F53\n\n\n新宋體\nNSimSun\n\\65B0\\5B8B\\4F53\n\n\n黑體\nSimHei\n\\9ED1\\4F53\n\n\n微軟雅黑\nMicrosoft YaHei\n\\5FAE\\8F6F\\96C5\\9ED1\n\n\n楷體_GB2312\nKaiTi_GB2312\n\\6977\\4F53_GB2312\n\n\n隸書\nLiSu\n\\96B6\\4E66\n\n\n幼園\nYouYuan\n\\5E7C\\5706\n\n\n華文細黑\nSTXihei\n\\534E\\6587\\7EC6\\9ED1\n\n\n細明體\nMingLiU\n\\7EC6\\660E\\4F53\n\n\n新細明體\nPMingLiU\n\\65B0\\7EC6\\660E\\4F53\n\n\n為了照顧不同電腦的字體安裝問題，儘量只使用宋體和微軟雅黑中文字體\n1.3 font-weight:字體粗細\n在html中如何將字體加粗我們可以用標籤來實現\n使用b和strong標籤是文本加粗。\n\n\n可以使用CSS 來實現，但是CSS 是沒有語義的。\n\n\n\n\n屬性值\n描述\n\n\n\nnormal\n預設值（不加粗的）\n\n\nbold\n定義粗體（加粗的）\n\n\n100~900\n400 等同於 normal，而 700 等同於 bold  我們重點記住這句話\n\n\n提倡：  平時更喜歡用數字來表示加粗和不加粗。\n1.4 font-style:字體風格\n在html中如何將字體傾斜我們可以用標籤來實現\n字體傾斜除了用i和 em 標籤，\n\n\n可以使用CSS 來實現，但是CSS 是沒有語義的\n\nfont-style屬性用於定義字體風格，如設置斜體、傾斜或正常字體，其可用屬性值如下：\n\n\n\n屬性\n作用\n\n\n\nnormal\n預設值，流覽器會顯示標準的字體樣式  font-style: normal;\n\n\nitalic\n流覽器會顯示斜體的字體樣式。\n\n\n平時我們很少給文字加斜體，反而喜歡給斜體標籤（em，i）改為普通模式。\n\n1.5 font:綜合設置字體樣式 (重點)font屬性用於對字體樣式進行綜合設置\n\n基本語法格式如下：\n\n選擇器 &#123; font: font-style  font-weight  font-size&#x2F;line-height  font-family;&#125;\n\n\n注意：\n使用font屬性時，必須按上面語法格式中的順序書寫，不能更換順序，各個屬性以空格隔開。\n其中不需要設置的屬性可以省略（取預設值），但必須保留font-size和font-family屬性，否則font屬性將不起作用。\n\n\n\n1.6 font總結\n\n\n屬性\n表示\n注意點\n\n\n\nfont-size\n字型大小\n我們通常用的單位是px 圖元，一定要跟上單位\n\n\nfont-family\n字體\n實際工作中按照團隊約定來寫字體\n\n\nfont-weight\n字體粗細\n加粗是 700 或者 bold  不加粗 是 normal 或者  400  記住數位不要跟單位\n\n\nfont-style\n字體樣式\n記住傾斜是 italic     不傾斜 是 normal  工作中我們最常用 normal\n\n\nfont\n字體連寫\n字體連寫是有順序的，不能隨意換位置，其中字型大小 和字體必須同時出現\n\n\n2. CSS外觀屬性2.1 color:文本顏色\n作用：\ncolor屬性用於定義文本的顏色，\n\n其取值方式有如下3種：\n\n\n\n\n\n表示表示\n屬性值\n\n\n\n預定義的顏色值\nred，green，blue\n\n\n十六進位\n#FF0000，#FF6600，#29D794\n\n\nRGB代碼\nrgb(255,0,0)或rgb(100%,0%,0%)\n\n\n\n注意實際工作中， 用 16進制的寫法是最多的，其中更喜歡簡寫方式比如  #f00 代表紅色\n\n2.2 text-align:文本水準對齊方式\n作用：\ntext-align屬性用於設置文本內容的水準對齊，相當於html中的align對齊屬性\n\n其可用屬性值如下：\n\n\n\n\n\n屬性\n解釋\n\n\n\nleft\n左對齊（預設值）\n\n\nright\n右對齊\n\n\ncenter\n居中對齊\n\n\n\n注意：\n是讓盒子裡面的內容水準居中， 而不是讓盒子居中對齊\n\n\n2.3 line-height:行間距\n作用：\nline-height屬性用於設置行間距，就是行與行之間的距離，即字元的垂直間距，一般稱為行高。\n\n單位：\n\nline-height常用的屬性值單位有三種，分別為圖元px，相對值em和百分比%，實際中使用最多的是圖元px\n\n\n技巧：\n\n\n一般情況下，行距比字型大小大7.8圖元左右就可以了。\nline-height: 24px;\n\n2.4 text-indent:首行縮進\n作用：\ntext-indent屬性用於設置首行文本的縮進，\n\n屬性值\n\n其屬性值可為不同單位的數值、em字元寬度的倍數、或相對於流覽器視窗寬度的百分比%，允許使用負值,\n建議使用em作為設置單位。\n\n\n\n1em 就是一個字的寬度   如果是漢字的段落， 1em 就是一個漢字的寬度\np &#123;\n      &#x2F;*行間距*&#x2F;\n      line-height: 25px;\n      &#x2F;*首行縮進2個字  em  1個em 就是1個字的大小*&#x2F;\n      text-indent: 2em;  \n &#125;\n\n2.5 text-decoration 文本的裝飾text-decoration   通常我們用於給連結修改裝飾效果\n\n\n\n值\n描述\n\n\n\nnone\n默認。定義標準的文本。 取消底線（最常用）\n\n\nunderline\n定義文本下的一條線。底線 也是我們連結自帶的（常用）\n\n\noverline\n定義文本上的一條線。（不用）\n\n\nline-through\n定義穿過文本下的一條線。（不常用）\n\n\n2.6 CSS外觀屬性總結\n\n\n屬性\n表示\n注意點\n\n\n\ncolor\n顏色\n我們通常用  十六進位   比如 而且是簡寫形式 #fff\n\n\nline-height\n行高\n控制行與行之間的距離\n\n\ntext-align\n水準對齊\n可以設定文字水準的對齊方式\n\n\ntext-indent\n首行縮進\n通常我們用於段落首行縮進2個字的距離   text-indent: 2em;\n\n\ntext-decoration\n文本修飾\n記住 添加 底線  underline  取消底線  none\n\n\n3.開發者工具（chrome）此工具是必備工具，以後代碼出了問題\n首先第一反應就是：\n\n“按F12”或者是 “shift+ctrl+i”   打開 開發者工具。\n菜單： 右擊網頁空白出—檢查↓\n通過開發人員工具小指標工具，查找頁面元素↓\n左側是html頁面結構，右側是css樣式\n\n\nctrl+滾輪 可以 放大開發者工具代碼大小。\n左邊是HTML元素結構   右邊是CSS樣式。\n右邊CSS樣式可以改動數值和顏色查看更改後效果。\nctrl + 0  復原流覽器大小\n\n4. sublime快捷操作emmet語法Emmet的前身是Zen coding,它使用縮寫,來提高html&#x2F;css的編寫速度。\n\n生成標籤 直接輸入標籤名 按tab鍵即可   比如  div   然後tab 鍵， 就可以生成 \n\n如果想要生成多個相同標籤  加上* 就可以了 比如   div*3  就可以快速生成3個div\n\n如果有父子級關係的標籤，可以用 &gt;  比如   ul &gt; li就可以了\n\n如果有兄弟關係的標籤，用  +  就可以了 比如 div+p  \n\n如果生成帶有類名或者id名字的，  直接寫  .demo  或者#two tab鍵就可以了\n\n如果生成的div 類名是有順序的， 可以用 自增符號 $   \n.demo$*3        \n&lt;div class&#x3D;&quot;demo1&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;demo2&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;demo3&quot;&gt;&lt;&#x2F;div&gt;\n如果想在生成的標籤内部寫内容，可以用&#123;&#125;表示\n\n\n5.拓展閱讀emment語法\n","slug":"20230312CSS 03-文本樣式屬性調試工具","date":"2023-03-12T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"fe80011ed56b79e3fb28c137c216c8eb","title":"CSS 02-基礎選擇器","content":"CSS選擇器\n\n\n\n\n\n\n\n\n找到特定的HTML頁面元素能夠使用基礎選擇器給頁面元素添加樣式\n1. CSS選擇器作用（重點）選擇器的作用css 只做兩件事 選人，做事 \nh3 &#123; \n  color: red;\n&#125;\n\n這段代碼就是2件事， 把  h3選出來， 然後 把它變成了 紅色。 \n選擇器分為基礎選擇器和 複合選擇器，我們這裡先講解一下 基礎選擇器。\n2. CSS基礎選擇器2.1 標籤選擇器\n概念：\n標籤選擇器（元素選擇器）是指用HTML標籤名稱作為選擇器，按標籤名稱分類，為頁面中某一類標籤指定統一的CSS樣式。\n\n語法：\n\n\n標籤名&#123;屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3; &#125; \n\n\n作用：標籤選擇器 可以把某一類標籤全部選擇出來  比如所有的div標籤  和 所有的 span標籤\n\n優點：是能快速為頁面中同類型的標籤統一樣式\n\n缺點：不能設計差異化樣式。\n\n\n總結 口訣：\n   標籤選擇器，   頁面同選起。   直接寫標籤，   全部不放棄。\n2.2 class選取器class選取器使用“.”（英文點號）進行標識，後面緊跟類名.\n\n語法：\n\n類名選擇器\n\n.類名  &#123;   \n    屬性1:屬性值1; \n    屬性2:屬性值2; \n    屬性3:屬性值3;     \n&#125;\n\n\n標籤\n\n&lt;p class&#x3D;&#39;類名&#39;&gt;&lt;&#x2F;p&gt;\n\n優點：\n\n可以為元素物件定義單獨或相同的樣式。 可以選擇一個或者多個標籤\n\n\n注意\n\n類別(class)選取器使用“.”（英文點號）進行標識，後面緊跟類名(自訂，我們自己命名的)\n長名稱或片語可以使用中橫線來為選擇器命名。\n不要純數位、中文等命名， 儘量使用英文字母來表示。\n\n\n\n命名規範：  見附件（Web前端開發規範手冊.doc）\n命名是我們通俗約定的，但是沒有規定必須用這些常用的命名。\n\n記憶口訣\n差異化選擇一個或多個上麵點定義類名別寫錯誰用誰調用class來做。\n嘿嘿，工作類最多。\n\n\n2.3 類別選取器特殊用法- 多類名我們可以給標籤指定多個類名，從而達到更多的選擇目的。\n\n\n\n\n\n\n\n\n\n....\n注意：\n\n各個類名中間用空格隔開。\n多類名選擇器在後期佈局比較複雜的情況下，還是較多使用的。\n\n&lt;div class&#x3D;&quot;pink fontWeight font20&quot;&gt;亞瑟&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;font20&quot;&gt;劉備&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;font14 pink&quot;&gt;安其拉&lt;&#x2F;div&gt;\n&lt;div class&#x3D;&quot;font14&quot;&gt;貂蟬&lt;&#x2F;div&gt;\n\n2.4 id選擇器id選擇器使用#進行標識，後面緊跟id名\n\n其基本語法格式如下：\n\nid選擇器\n#id名 &#123;屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3; &#125;\n\n標籤\n&lt;p id&#x3D;&quot;id名&quot;&gt;&lt;&#x2F;p&gt;\n\n\n元素的id值是唯一的，只能對應于文檔中某一個具體的元素。\n\n用法基本和類別選取器相同。\n\n\nid選擇器和class選取器區別\n在同一個頁面內，不允許有相同名字的id物件出現，但是允許相同名字的class。\n類別選取器（class） 好比人的名字，  是可以多次重複使用的， 比如  徐生  王生  李生  李生\nid選擇器     好比人的身份證號碼，  全國是唯一的， 不得重複。 只能使用一次。\n\n\n\nid選擇器和class選取器最大的不同在於 使用次數上。\n總結\n\nclass選取器我們在修改樣式中，用的最多。\nid選擇器一般用於頁面唯一性的元素身上，經常和我們後面學習的javascript 搭配使用。\n\n2.6 萬用字元選擇器\n概念\n萬用字元選擇器用*號表示，  *   就是 選擇所有的標籤      他是所有選擇器中作用範圍最廣的，能匹配頁面中所有的元素。\n\n其基本語法格式如下：\n\n\n* &#123; 屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3; &#125;\n\n例如下面的代碼，使用萬用字元選擇器定義CSS樣式，清除所有HTML標記的預設邊距。\n* &#123;\n  margin: 0;                    &#x2F;* 定義外邊距*&#x2F;\n  padding: 0;                   &#x2F;* 定義內邊距*&#x2F;\n&#125;\n\n\n注意：\n  會匹配頁面所有的元素，降低頁面回應速度，不建議隨便使用\n\n\n2.7 基礎選擇器總結\n\n\n選擇器\n作用\n缺點\n使用情況\n用法\n\n\n\n標籤選擇器\n可以選出所有相同的標籤，比如p\n不能差異化選擇\n較多\np { color：red;}\n\n\n類別選取器\n可以選出1個或者多個標籤\n可以根據需求選擇\n非常多\n.nav { color: red; }\n\n\nid選擇器\n一次只能選擇器1個標籤\n只能使用一次\n不推薦使用\n#nav {color: red;}\n\n\n萬用字元選擇器\n選擇所有的標籤\n選擇的太多，有部分不需要\n不推薦使用\n* {color: red;}\n\n\n基礎選擇器我們一共學了4個，  每個都有自己的價值， 可能再某個地方都能用到。但是如果說，一定要找個最常用的，那麼，肯定是類別選取器。\n2.8 團隊約定選擇器\n\n儘量少用通用選擇器 *\n儘量少用 ID 選擇器\n不使用無具體語義定義的標籤選擇器 div span\n\n&#x2F;* 推薦 *&#x2F;\n.jdc &#123;&#125;\nli &#123;&#125;\np&#123;&#125;\n\n&#x2F;* 不推薦 *&#x2F;\n*&#123;&#125;\n#jdc &#123;&#125;\ndiv&#123;&#125;   因為div 沒有語義，我們儘量少用\n\n\n","slug":"20230311CSS 02-基礎選擇器","date":"2023-03-11T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"e201a2a619b1945f4ef64af1b2319404","title":"CSS 01-層疊樣式表","content":"學習目標\n理解\ncss的目的作用\ncss的三種引入方式\n\n\n應用\ncss三種引用方式的書寫\n通過樣式規則給標籤添加簡單的樣式\n\n\n\n1.HTML的局限性HTML非常單純， 只關注內容的語義， \n比如:\n&lt;h1&gt;表明這是一個大標題，&lt;p&gt; 表明這是一個段落，\n&lt;img&gt; 表明這兒有一個圖片， &lt;a&gt; 表示此處有連結。\n\n以至於早期的網站雖然很多，但都有一個共同的特點醜但要改變高度或者變一個顏色，就需要大量重複操作\n總結：\n\nHTML滿足不了設計者的需求\n操作html屬性不方便\nHTML裡面添加樣式帶來的是無盡的臃腫和繁瑣\n\n2.CSS 網頁的美容師\n讓網頁更加豐富多彩，佈局更加靈活自如。   \nCSS的貢獻是:讓 HTML 從樣式中脫離，實現了HTML專注去做結構呈現，樣式交給css\n\n\n\n\n\n\n\n\n\n\n理想中的結果： 結構(html)與樣式(css)相分離  \n如果JavaScript是網頁的魔法師，那麼CSS它是我們網頁的美容師\n3.CSS初識\n概念：\n CSS(Cascading Style Sheets)  ，通常稱為CSS樣式表或層疊樣式表（階層式樣式表）\n\n作用：\n\n主要用於設置 HTML頁面中的文本內容（字體、大小、對齊方式等）、圖片的外形（寬高、邊框樣式、邊距等）以及版面的佈局和外觀顯示樣式。\nCSS以HTML為基礎，提供了豐富的功能，如字體、顏色、背景的控制及整體排版等，而且還可以針對不同的流覽器設置不同的樣式。\n\n\n\n4. 引入CSS樣式表（書寫位置）要書寫css樣式，那css樣式書寫的位置在哪呢？\n\n4.1 行內式（內聯樣式）\n概念：\n 稱行內樣式、行間樣式.\n 是通過標籤的style屬性來設置元素的樣式\n\n其基本語法格式如下：\n\n\n&lt;標籤名 style&#x3D;&quot;屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3;&quot;&gt; \n  內容 \n&lt;&#x2F;標籤名&gt;\n\n實際上任何HTML標籤都擁有style屬性，用來設置行內式。\n\n案例：\n\n&lt;div style&#x3D;&quot;color: red; font-size: 12px;&quot;&gt;\n  青春不常在，抓緊談戀愛\n&lt;&#x2F;div&gt;\n\n\n注意：\nstyle其實就是標籤的屬性\n樣式屬性和值中間是:\n多組屬性值之間用;隔開。\n只能控制當前的標籤和以及嵌套在其中的字標籤，造成代碼冗餘\n\n\n缺點：\n沒有實現樣式和結構相分離\n\n\n\n4.2 內部樣式表（內嵌樣式表）\n概念：\n 稱內嵌式\n 是將CSS代碼集中寫在HTML文檔的head頭部標籤中，並且用style標籤定義\n\n其基本語法格式如下：\n\n\n&lt;head&gt;\n&lt;style type&#x3D;&quot;text&#x2F;CSS&quot;&gt;\n    選擇器（選擇的標籤） &#123; \n      屬性1: 屬性值1;\n      屬性2: 屬性值2; \n      屬性3: 屬性值3;\n    &#125;\n&lt;&#x2F;style&gt;\n&lt;&#x2F;head&gt;\n\n&lt;style&gt;\n   div &#123;\n    color: red;\n    font-size: 12px;\n   &#125;\n&lt;&#x2F;style&gt;\n\n\n注意：\n\nstyle標籤一般位於head標籤中，當然理論上他可以放在HTML文檔的任何地方。\ntype&#x3D;”text&#x2F;css”  在html5中可以省略。\n只能控制當前的頁面\n\n\n缺點：\n  沒有徹底分離\n\n\n綜合案例&lt;style&gt;\n   &#x2F;*選擇器&#123;屬性:值；&#125;*&#x2F;\n   p &#123;\n      color:#06C; \n      font-size:14px;  \n    &#125;  &#x2F;*文字的顏色是 藍色*&#x2F;\n   h4 &#123;\n     color:#900;\n   &#125;\n   h1 &#123;\n     color:#090; \n     font-size:16px; \n    &#125;\n   body &#123; \n     background:url(bg2.jpg);\n   &#125;\n&lt;&#x2F;style&gt;\n\n4.3 外部樣式表（外鏈式）\n概念：\n 稱鏈入式\n 是將所有的樣式放在一個或多個以**.CSS**為副檔名的外部樣式表檔中，\n 通過link標籤將外部樣式表檔連結到HTML文檔中\n\n其基本語法格式如下：\n\n\n&lt;head&gt;\n  &lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;css檔路徑&quot;&gt;\n&lt;&#x2F;head&gt;\n\n\n注意：  \nlink 是個單標籤\nlink標籤需要放在head頭部標籤中，並且指定link標籤的三個屬性\n\n\n\n\n\n\n屬性\n作用\n\n\n\nrel\n定義當前文檔與被連結文檔之間的關係，在這裡需要指定為“stylesheet”，表示被連結的文檔是一個樣式表檔。\n\n\ntype\n定義所連結文檔的類型，在這裡需要指定為“text&#x2F;CSS”，表示連結的外部檔為CSS樣式表。我們都可以省略\n\n\nhref\n定義所連結外部樣式表檔的URL，可以是相對路徑，也可以是絕對路徑。\n\n\n4.4 三種樣式表總結（位置）\n\n\n樣式表\n優點\n缺點\n使用情況\n控制範圍\n\n\n\n行內樣式表\n書寫方便，權重高\n沒有實現樣式和結構相分離\n較少\n控制一個標籤（少）\n\n\n內部樣式表\n部分結構和樣式相分離\n沒有徹底分離\n較多\n控制一個頁面（中）\n\n\n外部樣式表\n完全實現結構和樣式相分離\n需要引入\n最多，強烈推薦\n控制整個網站（多）\n\n\n團隊約定-代碼風格樣式書寫一般有兩種：\n\n一種是緊湊格式 (Compact)\n\nh3 &#123; color: deeppink;font-size: 20px;&#125;\n\n\n一種是展開格式（推薦）\n\nh3 &#123;\n  color: deeppink;\n  font-size: 20px;    \n&#125;\n\n團隊約定-代碼大小寫樣式選擇器，屬性名，屬性值關鍵字全部使用小寫字母書寫，屬性字串允許使用大小寫。\n&#x2F;* 推薦 *&#x2F;\nh3&#123;\n  color: pink;\n&#125;\n  \n&#x2F;* 不推薦 *&#x2F;\nH3&#123;\n  COLOR: PINK;\n&#125;\n\n\n5. 總結CSS樣式規則使用HTML時，需要遵從一定的規範。CSS亦如此，要想熟練地使用CSS對網頁進行修飾，首先需要瞭解CSS樣式規則，\n\n\n\n\n\n\n\n\n\n選擇器 {屬性:值;}\n總結：\n\n選擇器用於指定CSS樣式作用的HTML標籤，花括弧內是對該物件設置的具體樣式。\n屬性和屬性值以鍵值對的形式出現。\n屬性是對指定的物件設置的樣式屬性，例如字體大小、文本顏色等。\n屬性和屬性值之間用英文**:**連接。\n多個“鍵值對”之間用英文**;**進行區分。\n\n@拓展閱讀CSS的發展史\n","slug":"20230310CSS 01-層疊樣式表","date":"2023-03-10T02:00:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"c280a2edc22e967ceed619afcdbab7b6","title":"Html列表和表單","content":"1. 列表標籤（重點）學習目標\n理解\n無序列表的應用場景\n自訂列表的應用場景\n\n\n應用\n無序列表語法\n自訂清單語法\n\n\n\n\n\n\n\n\n\n\n\n\n容器裡面裝載著結構，樣式一致的文字或圖表的一種形式，叫列表\n\n特點：列表最大的特點就是  整齊 、整潔、 有序，跟表格類似，但是他可組合自由度會更高。\n\n1.1 無序列表 ul （重點）無序列表的各個清單項之間沒有順序級別之分，是並列的。其基本語法格式如下：\n&lt;ul&gt;\n  &lt;li&gt;列表項1&lt;&#x2F;li&gt;\n  &lt;li&gt;列表項2&lt;&#x2F;li&gt;\n  &lt;li&gt;列表項3&lt;&#x2F;li&gt;\n  ......\n&lt;&#x2F;ul&gt;\n\n腳下留心：\n1. &lt;ul&gt;&lt;&#x2F;ul&gt;中只能嵌套&lt;li&gt;&lt;&#x2F;li&gt;，直接在&lt;ul&gt;&lt;&#x2F;ul&gt;標籤中輸入其他標籤或者文字的做法是不被允許的。\n2. &lt;li&gt;與&lt;&#x2F;li&gt;之間相當於一個容器，可以容納所有元素。\n3. 無序列表會帶有自己樣式屬性\n\n1.2  有序列表 ol （瞭解）有序列表即為有排列順序的清單，其各個清單項按照一定的順序排列定義，有序列表的基本語法格式如下：\n&lt;ol&gt;\n  &lt;li&gt;列表項1&lt;&#x2F;li&gt;\n  &lt;li&gt;列表項2&lt;&#x2F;li&gt;\n  &lt;li&gt;列表項3&lt;&#x2F;li&gt;\n  ......\n&lt;&#x2F;ol&gt;\n\n  所有特性基本與ul 一致。  但是實際中比 無序列表 用的少很多。\n1.3 自訂列表（理解）定義列表常用於對術語或名詞進行解釋和描述，定義列表的列表項前沒有任何專案符號。其基本語法如下：\n&lt;dl&gt;\n  &lt;dt&gt;名詞1&lt;&#x2F;dt&gt;\n  &lt;dd&gt;名詞1解釋1&lt;&#x2F;dd&gt;\n  &lt;dd&gt;名詞1解釋2&lt;&#x2F;dd&gt;\n  ...\n  &lt;dt&gt;名詞2&lt;&#x2F;dt&gt;\n  &lt;dd&gt;名詞2解釋1&lt;&#x2F;dd&gt;\n  &lt;dd&gt;名詞2解釋2&lt;&#x2F;dd&gt;\n  ...\n&lt;&#x2F;dl&gt;\n\n1.4 列表總結\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;ul&gt;&lt;/ul&gt;\n無序標籤\n裡面只能包含li    沒有順序，我們以後佈局中最常用的列表\n\n\n&lt;ol&gt;&lt;/ol&gt;\n有序標籤\n裡面只能包含li    有順序， 使用情況較少\n\n\n&lt;dl&gt;&lt;/dl&gt;\n自訂列表\n裡面有2個兄弟， dt 和 dd\n\n\n\n\n\n\n\n\n\n\n\n\n學會什麼時候用無序列表， 學會什麼時候用自訂列表\n無序列表和自訂列表代碼怎麼寫？\n具體的我們剛才看的佈局，等我們學了css 在來全面佈局。\n\n2. 表單標籤(掌握)目標：\n\n能寫出最常用的註冊類表單\n能說出input表單常見屬性\n\n**作用： **\n表單目的是為了收集使用者資訊。\n在我們網頁中， 我們也需要跟使用者進行交互，收集使用者資料，此時也需要表單。\n\n\n\n\n\n\n\n\n\n在HTML中，一個完整的表單通常由表單控制項（也稱為表單元素）、提示資訊和表單欄位3個部分構成。\n  表單控制項：\n  包含了具體的表單功能項，如單行文本輸入框、密碼輸入框、核取方塊、提交按鈕、重新開機按鈕等。\n  提示資訊：\n  一個表單中通常還需要包含一些說明性的文字，提示使用者進行填寫和操作。\n  表單欄位：  \n  他相當於一個容器，用來容納所有的表單控制項和提示資訊，可以通過他定義處理表單數據所用程式的url位址，以及資料提交到伺服器的方法。  如果不定義表單欄位，表單中的資料就無法傳送到後臺伺服器。\n2.1 input 控制項(重點)\n語法：\n&lt;input type&#x3D;&quot;屬性值&quot; value&#x3D;&quot;你好&quot;&gt;\n\n\ninput 輸入的意思 \n&lt;input &#x2F;&gt;標籤為單標籤\ntype屬性設置不同的屬性值用來指定不同的控制項類型\n除了type屬性還有別的屬性\n\n\n常用屬性：\n\n\n\n\n\n屬性\n屬性值\n描述\n\n\n\ntype\ntext\n文本輸入框\n\n\n&#96;&#96;\npassword\n密碼輸入框\n\n\n&#96;&#96;\nradio\n單選按鈕\n\n\n&#96;&#96;\ncheckbox\n複選框\n\n\n&#96;&#96;\nbutton\n普通按鈕\n\n\n&#96;&#96;\nsubmit\n提交按鈕\n\n\n&#96;&#96;\nreset\n重置按鈕\n\n\n&#96;&#96;\nimage\n圖像型式按紐\n\n\n&#96;&#96;\nfile\n文件域\n\n\nname\n用戶自定義\n控件名稱\n\n\nvalue\n用戶自定義\ninput默認文本值\n\n\nsize\n正整數\ninput默認顯示寬度\n\n\nchecked\nchecked\n默認被選重的項\n\n\nmaxlength\n正整數\n允許輸入最多字數\n\n\n1. type 屬性\n這個屬性通過改變值，可以決定了你屬於那種input表單。\n比如 type &#x3D; ‘text’  就表示 文字方塊 可以做 用戶名， 昵稱等。\n比如 type &#x3D; ‘password’  就是表示密碼框   使用者輸入的內容 是不可見的。\n\n用戶名: &lt;input type&#x3D;&quot;text&quot; &#x2F;&gt; \n密  碼：&lt;input type&#x3D;&quot;password&quot; &#x2F;&gt;\n\n2. value屬性   值用戶名:&lt;input type&#x3D;&quot;text&quot;  name&#x3D;&quot;username&quot; value&#x3D;&quot;請輸入用戶名&quot;&gt; \n\n\nvalue 預設的文本值。 有些表單想剛打開頁面就預設顯示幾個文字，就可以通過這個value 來設置。\n\n3. name屬性用戶名:&lt;input type&#x3D;&quot;text&quot;  name&#x3D;“username” &#x2F;&gt;  \n\nname表單的名字， 這樣，後臺可以通過這個name屬性找到這個表單。  頁面中的表單很多，name主要作用就是用於區別不同的表單。\n\n\n\n\n\n\n\n\n\nname屬性後面的值，是我們自己定義的。\n\nradio  如果是一組，我們必須給他們命名相同的名字 name   這樣就可以多個選其中的一個啦\n\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot;  &#x2F;&gt;男\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; &#x2F;&gt;女\n\n\n\n\n\n\n\n\n\n\nname屬性，我們現在用的較少， 但是，當我們學ajax 和後臺的時候，是必須的。\n4. checked屬性\n表示預設選中狀態。  較常見於 選項按鈕和複選按鈕。\n\n性    別:\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;男&quot; checked&#x3D;&quot;checked&quot; &#x2F;&gt;男\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot; value&#x3D;&quot;女&quot; &#x2F;&gt;女 \n\n上面這個，表示就默認選中了 男 這個選項按鈕\n5. input 屬性小結\n\n\n屬性\n說明\n作用\n\n\n\ntype\n表單類型\n用來指定不同的控制項類型\n\n\nvalue\n表單值\n表單裡面預設顯示的文本\n\n\nname\n表單名字\n頁面中的表單很多，name主要作用就是用於區別不同的表單。\n\n\nchecked\n默認選中\n表示那個單選或者複選按鈕一開始就被選中了\n\n\n2.2 label標籤(理解)目標：\nlabel標籤主要目的是為了提高使用者體驗。 為使用者提高最優秀的服務。\n概念：\nlabel 標籤為 input 元素定義標注（標籤）。\n作用： \n 用於綁定一個表單元素, 當點擊label標籤的時候, 被綁定的表單元素就會獲得輸入焦點。\n如何綁定元素呢？\n\n第一種用法就是用label直接包括input表單。\n\n&lt;label&gt; 用戶名： &lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;usename&quot; value&#x3D;&quot;請輸入用戶名&quot;&gt;   &lt;&#x2F;label&gt;\n\n   適合單個表單選擇\n\n第二種用法 for 屬性規定 label 與哪個表單元素綁定。\n\n&lt;label for&#x3D;&quot;sex&quot;&gt;男&lt;&#x2F;label&gt;\n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;sex&quot;  id&#x3D;&quot;sex&quot;&gt;\n\n結論:\n\n\n\n\n\n\n\n\n\n 當我們滑鼠點擊 label標籤裡面的文字時， 游標會定位到指定的表單裡面\n2.3 textarea控制項(文本域)\n語法：\n\n&lt;textarea &gt;\n  文本內容\n&lt;&#x2F;textarea&gt;\n\n\n作用：\n通過textarea控制項可以輕鬆地創建多行文本輸入框.\ncols&#x3D;”每行中的字元數” rows&#x3D;”顯示的行數”  我們實際開發不用\n\n\n文字方塊和文本域區別\n\n\n表單\n名稱\n區別\n預設值顯示\n用於場景\n\n\n\ninput type&#x3D;”text”\n文字方塊\n只能顯示一行文本\n單標籤，通過value顯示預設值\n用戶名、昵稱、密碼等\n\n\ntextarea\n文本域\n可以顯示多行文本\n雙標籤，預設值寫到標籤中間\n留言板\n\n\n2.4 select下拉清單目的：\n如果有多個選項讓使用者選擇，為了節約空間，我們可以使用select控制項定義下拉清單.\n語法：\n&lt;select&gt;\n  &lt;option&gt;選項1&lt;&#x2F;option&gt;\n  &lt;option&gt;選項2&lt;&#x2F;option&gt;\n  &lt;option&gt;選項3&lt;&#x2F;option&gt;\n  ...\n&lt;&#x2F;select&gt;\n\n\n注意：\n\n\n&lt;select&gt;  中至少包含一對 option \n在option 中定義selected &#x3D;” selected “時，當前項即為默認選中項。\n但是我們實際開發會用的比較少\n\n3. form表單欄位\n收集的使用者資訊怎麼傳遞給伺服器？\n通過form表單欄位\n\n目的：\n在HTML中，form標籤被用於定義表單欄位，以實現使用者資訊的收集和傳遞，form中的所有內容都會被提交給伺服器。\n\n\n**語法: **\n&lt;form action&#x3D;&quot;url位址&quot; method&#x3D;&quot;提交方式&quot; name&#x3D;&quot;表單名稱&quot;&gt;\n  各種表單控制項\n&lt;&#x2F;form&gt;\n\n常用屬性：\n\n\n\n屬性\n屬性值\n作用\n\n\n\naction\nurl位址\n用於指定接收並處理表單數據的伺服器程式的url位址。\n\n\nmethod\nget&#x2F;post\n用於設置表單數據的提交方式，其取值為get或post。\n\n\nname\n名稱\n用於指定表單的名稱，以區分同一個頁面中的多個表單。\n\n\n注意:  \n每個表單都應該有自己表單欄位。我們現在做頁面，不寫看不到效果，但是 如果後面學 ajax 後臺交互的時候，必須需要 form表單欄位。\n2.6 團隊約定元素屬性\n元素屬性值使用雙引號語法\n元素屬性值可以寫上的都寫上\n\n推薦：\n&lt;input type&#x3D;&quot;text&quot; &#x2F;&gt; \n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;name&quot; checked&#x3D;&quot;checked&quot; &#x2F;&gt;\n\n不推薦：\n&lt;input type&#x3D;text  &#x2F;&gt;  \n&lt;input type&#x3D;&#39;text&#39; &#x2F;&gt; \n&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;name&quot; checked &#x2F;&gt;\n\n4. 文檔資源W3C :  http://www.w3school.com.cn/\nMDN: https://developer.mozilla.org/zh-CN/\n","slug":"20230309Html 05 列表和表單","date":"2023-03-09T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"9251ae9d685dc3ab72877b4e42919649","title":"Html表格","content":"為了讓我們頁面顯示的更加整齊，需要學習三個表（表格、表單、清單）\n表格 table(會使用)目標：\n\n理解：\n表格用來做什麼的\n表格的基本結構組成\n\n\n應用：\n寫出n行n列的表格\n簡單的合併儲存格\n\n\n\n表格作用：\n存在即是合理的。  表格的現在還是較為常用的一種標籤，但不是用來佈局，常見顯示、展示表格式資料。\n因為它可以讓資料顯示的非常的規整，可讀性非常好。\n特別是後臺展示資料的時候表格運用是否熟練就顯得很重要，一個清爽簡約的表格能夠把繁雜的資料表現得很有條理，雖然 div 佈局也可以做到，但是總沒有表格來得方便。\n1. 創建表格在HTML網頁中，要想創建表格，就需要使用表格相關的標籤。\n創建表格的基本語法：\n&lt;table&gt;\n  &lt;tr&gt;\n    &lt;td&gt;儲存格內的文字&lt;&#x2F;td&gt;\n    ...\n  &lt;&#x2F;tr&gt;\n  ...\n&lt;&#x2F;table&gt;\n\n要深刻體會表格、行、儲存格他們的構成。\n在上面的語法中包含基本的三對HTML標籤，分別為 table、tr、td，他們是創建表格的基本標籤，缺一不可，下面對他們進行具體地解釋\n\ntable用於定義一個表格標籤。\n\ntr標籤 用於定義表格中的行，必須嵌套在 table標籤中。\n\ntd 用於定義表格中的儲存格，必須嵌套在標籤中。\n\n字母 td 指表格資料（table data），即資料儲存格的內容，現在我們明白，表格最合適的地方就是用來存儲資料的。\n\n\n總結:\n\n表格的主要目的是用來顯示特殊資料的\n一個完整的表格有表格標籤（table），行標籤（tr），儲存格標籤（td）組成\n\n\n&lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 類的儲存格\n&lt;td&gt;&lt;/td&gt;標籤，他就像一個容器，可以容納所有的元素\n\n2. 表格屬性表格有部分屬性我們不常用，重點記住 cellspacing 、 cellpadding。\n我們經常有個說法，是三參為0，平時開發的我們這三個參數border 、 cellpadding 、 cellspacing  為  0\n3. 表頭儲存格標籤th\n作用：\n一般表頭儲存格位於表格的第一行或第一列，並且文本加粗居中\n\n\n語法：\n只需用表頭標籤&lt;th&gt;&lt;&#x2F;th&gt;替代相應的儲存格標籤&lt;td&gt;&lt;&#x2F;td&gt;即可。\n\n\n\n 代碼：\n&lt;table width&#x3D;&quot;500&quot; border&#x3D;&quot;1&quot; align&#x3D;&quot;center&quot; cellspacing&#x3D;&quot;0&quot; cellpadding&#x3D;&quot;0&quot;&gt;\n    &lt;tr&gt;  \n      &lt;th&gt;標題1&lt;&#x2F;th&gt; \n      &lt;th&gt;標題2&lt;&#x2F;th&gt;\n      &lt;th&gt;標題3&lt;&#x2F;th&gt;\n    &lt;&#x2F;tr&gt;    \n    &lt;tr&gt;\n      &lt;td&gt;內文1&lt;&#x2F;td&gt;\n      &lt;td&gt;內文2&lt;&#x2F;td&gt;\n      &lt;td&gt;內文3&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;內文1-2&lt;&#x2F;td&gt;\n      &lt;td&gt;內文2-2&lt;&#x2F;td&gt;\n      &lt;td&gt;內文1-2&lt;&#x2F;td&gt;\n    &lt;&#x2F;tr&gt; \n  &lt;&#x2F;table&gt;\n\n總結:\n\n\n\n\n\n\n\n\n\nth 也是一個儲存格   只不過和普通的 td儲存格不一樣，它會讓自己裡面的文字居中且加粗\n4. 表格標題caption定義和用法\n&lt;table&gt;\n   &lt;caption&gt;我是表格標題&lt;&#x2F;caption&gt;\n&lt;&#x2F;table&gt;\n\n**注意： **\n\ncaption 元素定義表格標題，通常這個標題會被居中且顯示於表格之上。\ncaption 標籤必須緊隨 table 標籤之後。\n這個標籤只存在 表格裡面才有意義。\n\n5. 合併儲存格(難點)\n\n\n\n\n\n\n\n\n合併儲存格是我們比較常用的一個操作，但是不會合併的很複雜。\n5.1 合併儲存格2種方式\n跨行合併：rowspan&#x3D;”合併儲存格的個數”      \n跨列合併：colspan&#x3D;”合併儲存格的個數”\n\n\n\n5.2 合併儲存格順序\n\n\n\n\n\n\n\n\n合併的順序我們按照先上、後下、先左、後右的順序\n跟以前學習漢字的書寫順序完全一致。\n5.3 合併儲存格三步曲\n先確定是跨行還是跨列合併\n根據 先上 後下   先左  後右的原則找到目標儲存格    然後寫上 合併方式 還有 要合併的儲存格數量  比如 ：    \n刪除多餘的儲存格 儲存格\n\n6. 總結表格\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;table&gt;&lt;/table&gt;\n表格標籤\n就是一個四方的盒子\n\n\n&lt;tr&gt;&lt;/tr&gt;\n表格行標籤\n行標籤要再table標籤內部才有意義\n\n\n&lt;td&gt;&lt;/td&gt;\n儲存格標籤\n儲存格標籤是個容器級元素，可以放任何東西\n\n\n&lt;th&gt;&lt;/th&gt;\n表頭儲存格標籤\n它還是一個儲存格，但是裡面的文字會居中且加粗\n\n\n&lt;caption&gt;&lt;/caption&gt;\n表格標題標籤\n表格的標題，跟著表格一起走，和表格居中對齊\n\n\nclospan 和 rowspan\n合併屬性\n用來合併儲存格的\n\n\n\n表格提供了HTML 中定義表格式資料的方法。\n表格中由行中的儲存格組成。\n表格中沒有列元素，列的個數取決於行的儲存格個數。\n表格不要糾結於外觀，那是CSS 的作用。\n表格的學習要求：能手寫表格結構，並且能簡單合併儲存格。\n\n7. 拓展閱讀@表格劃分結構（瞭解）對於比較複雜的表格，表格的結構也就相對的複雜了，\n所以又將表格分割成三個部分：題頭、正文和註腳。\n而這三部分分別用:thead,tbody,tfoot來標注，這樣更好的分清表格結構\n\n注意：\n\n&lt;thead&gt;&lt;/thead&gt;：用於定義表格的頭部。用來放標題之類的東西。&lt;thead&gt; 內部必須擁有 &lt;tr&gt; 標籤！\n&lt;tbody&gt;&lt;/tbody&gt;：用於定義表格的主體。放數據本體 。\n&lt;tfoot&gt;&lt;/tfoot&gt;放表格的註腳之類。\n以上標籤都是放到table標籤中。\n\n","slug":"20230308Html 04 表格","date":"2023-03-08T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"cbe5237b8ff5a57f8171e301da77c028","title":"HTML常用標籤","content":"學習目標\n理解：\n相對路徑三種形式\n\n\n應用\n排版標籤\n文本格式化標籤\n圖像標籤\n連結\n相對路徑，絕對路徑的使用\n\n\n\n1. HTML常用標籤 首先 HTML和CSS是兩種完全不同的語言，我們學的是結構，就只寫HTML標籤，認識標籤就可以了。 不會再給結構標籤指定樣式了。\n HTML標籤有很多，這裡我們學習最為常用的，後面有些較少用的，我們可以查下手冊就可以了。 \n1.1 排版標籤排版標籤主要和css搭配使用，顯示網頁結構的標籤，是網頁佈局最常用的標籤。\n1）標題標籤h (熟記) 單詞縮寫：  head   頭部. 標題       title  文檔標題\n為了使網頁更具有語義化，我們經常會在頁面中用到標題標籤，HTML提供了6個等級的標題，即\n標題標籤語義：  作為標題使用，並且依據重要性遞減\n其基本語法格式如下：\n&lt;h1&gt;   標題文本   &lt;&#x2F;h1&gt;\n&lt;h2&gt;   標題文本   &lt;&#x2F;h2&gt;\n&lt;h3&gt;   標題文本   &lt;&#x2F;h3&gt;\n&lt;h4&gt;   標題文本   &lt;&#x2F;h4&gt;\n&lt;h5&gt;   標題文本   &lt;&#x2F;h5&gt;\n&lt;h6&gt;   標題文本   &lt;&#x2F;h6&gt;\n\n小結 :\n\n加了標題的文字會變的加粗，字型大小也會依次變大\n一行是只能放一個標題的\n\n2）段落標籤p ( 熟記)單詞縮寫：  paragraph  段落  [ˈpærəgræf]    無須記這個單詞\n作用語義：\n可以把 HTML 文檔分割為若干段落\n 在網頁中要把文字有條理地顯示出來，離不開段落標籤，就如同我們平常寫文章一樣，整個網頁也可以分為若干個段落，而段落的標籤就是\n&lt;p&gt;  文本內容  &lt;&#x2F;p&gt;\n\n是HTML文檔中最常見的標籤，預設情況下，文本在一個段落中會根據流覽器視窗的大小自動換行。\n3）水平線標籤hr(認識)單詞縮寫：  horizontal  橫線    [ˌhɔrəˈzɑntl]    同上\n在網頁中常常看到一些水平線將段落與段落之間隔開，使得文檔結構清晰，層次分明。這些水平線可以通過插入圖片實現，也可以簡單地通過標籤來完成，就是創建橫跨網頁水平線的標籤。其基本語法格式如下：\n&lt;hr &#x2F;&gt;是單標籤\n\n 在網頁中顯示預設樣式的水平線。\n4）換行標籤br (熟記)單詞縮寫：  break   打斷 ,換行\n在HTML中，一個段落中的文字會從左到右依次排列，直到流覽器視窗的右端，然後自動換行。如果希望某段文本強制換行顯示，就需要使用換行標籤\n&lt;br &#x2F;&gt;\n\n5）div 和  span標籤(重點)div、span是沒有語義的，是我們網頁佈局主要的2個盒子css+div\ndiv 就是division  的縮寫，分割、分區的意思span就是跨度、跨距；範圍    \n語法格式：\n&lt;div&gt; 這是頭部 &lt;&#x2F;div&gt;    &lt;span&gt;今日價格&lt;&#x2F;span&gt;\n\n他們兩個都是盒子，用來裝我們網頁元素的， 只不過他們有區別，現在我們主要記住使用方法和特點就好了\n\ndiv標籤  用來佈局的，但是現在一行只能放一個div\nspan標籤  用來佈局的，一行上可以放好多個span\n\n排版標籤總結\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;hx&gt;&lt;/hx&gt;\n標題標籤\n作為標題使用，並且依據重要性遞減\n\n\n&lt;p&gt;&lt;/p&gt;\n段落標籤\n可以把 HTML 文檔分割為若干段落\n\n\n&lt;hr /&gt;\n水平線標籤\n沒啥可說的，就是一條線\n\n\n&lt;br /&gt;\n換行標籤\n\n\n\n&lt;div&gt;&lt;/div&gt;\ndiv標籤\n用來佈局的，但是現在一行只能放一個div\n\n\n&lt;span&gt;&lt;/span&gt;\nspan標籤\n用來佈局的，一行上可以放好多個span\n\n\n1.2 文本格式化標籤(熟記)在網頁中，有時需要為文字設置粗體、斜體或底線效果，這時就需要用到HTML中的文本格式化標籤，使文字以特殊的方式顯示。\n區別：\n b  只是加粗 strong  除了可以加粗還有 強調的意思，  語義更強烈。\n1.3 標籤屬性所謂屬性就是外在特性  比如 手機的顏色 手機的尺寸 ，總結就是手機的。。\n\n手機的顏色是黑色   \n手機的尺寸是 8寸 \n水平線的長度是 200  \n圖片的寬度 是  300\n\n使用HTML製作網頁時，如果想讓HTML標籤提供更多的資訊，可以使用HTML標籤的屬性加以設置。其基本語法格式如下：\n&lt;標籤名 屬性1&#x3D;&quot;屬性值1&quot; 屬性2&#x3D;&quot;屬性值2&quot; …&gt; 內容 &lt;&#x2F;標籤名&gt;\n&lt;手機 顏色&#x3D;&quot;紅色&quot; 大小&#x3D;&quot;5寸&quot;&gt;  &lt;&#x2F;手機&gt;\n\n\n1.4 圖像標籤img (重點)單詞縮寫：   image  圖像\n要想在網頁中顯示圖像就需要使用圖像標籤，接下來將詳細介紹圖像標籤以及和他相關的屬性。（它是一個單身狗）\n語法如下：\n&lt;img src&#x3D;&quot;圖像URL&quot; &#x2F;&gt;\n\n該語法中src屬性用於指定影像檔的路徑和檔案名，他是img標籤的必需屬性。\nborder 後面我們會用css來做，這裡童鞋們就記住這個border 單詞就好了\n**注意: **\n\n標籤可以擁有多個屬性，必須寫在開始標籤中，位於標籤名後面。\n屬性之間不分先後順序，標籤名與屬性、屬性與屬性之間均以空格分開。\n採取  鍵值對 的格式   key&#x3D;”value”  的格式\n\n比如:  \n正常的\n&lt;img src&#x3D;&quot;cz.jpg&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot; &#x2F;&gt;\n帶有邊框的\n&lt;img src&#x3D;&quot;cz.jpg&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot; border&#x3D;&quot;3&quot; &#x2F;&gt;\n有提示文本的\n&lt;img src&#x3D;&quot;cz.jpg&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot; border&#x3D;&quot;3&quot; title&#x3D;&quot;這是文字&quot; &#x2F;&gt;\n有替換文本的\n&lt;img src&#x3D;&quot;cz.jpg&quot; width&#x3D;&quot;300&quot; height&#x3D;&quot;300&quot; border&#x3D;&quot;3&quot; alt&#x3D;&quot;圖片不存在&quot; &#x2F;&gt;\n\n1.5 連結標籤(重點)單詞縮寫：  anchor 的縮寫  [ˈæŋkə(r)] 。基本解釋 錨, 鐵錨 的\n在HTML中創建超連結非常簡單，只需用標籤把文字包括起來就好。\n語法格式：\n&lt;a href&#x3D;&quot;跳轉目標&quot; target&#x3D;&quot;目標視窗的彈出方式&quot;&gt;文本或圖像&lt;&#x2F;a&gt;\n\n\n\n\n屬性\n作用\n\n\n\nhref\n用於指定連結目標的url位址，（必須屬性）當為標籤應用href屬性時，它就具有了超連結的功能\n\n\ntarget\n用於指定連結頁面的打開方式，其取值有_self和_blank兩種，其中_self為預設值，__blank為在新視窗中打開方式。\n\n\n注意：\n\n外部連結 需要添加 http:&#x2F;&#x2F; www.google.com\n內部連結 直接連結內部頁面名稱即可 比如 &lt; a href&#x3D;”index.html”&gt; 首頁 \n如果當時沒有確定連結目標時，通常將連結標籤的href屬性值定義為 “#”(即href&#x3D;”#”)，表示該連結暫時為一個空連結。\n不僅可以創建文本超連結，在網頁中各種網頁元素，如圖像、表格、音訊、視頻等都可以添加超連結。\n\n1.6 注釋標籤在HTML中還有一種特殊的標籤——注釋標籤。如果需要在HTML文檔中添加一些便於閱讀和理解但又不需要顯示在頁面中的注釋文字，就需要使用注釋標籤。\n簡單解釋：\n注釋內容不會顯示在流覽器視窗中，但是作為HTML文檔內容的一部分，也會被下載到使用者的電腦上，查看原始程式碼時就可以看到。\n語法格式：\n&lt;!-- 注釋語句 --&gt;\n快速鍵是：ctrl + &#x2F; 或者 ctrl +shift + &#x2F; \n\n\n\n\n\n\n\n\n\n\n注釋是給人看的，目的是為了更好的解釋這部分代碼是幹啥的， 程式是不執行這個代碼的\n團隊約定一般用於簡單的描述，如某些狀態描述、屬性描述等\n注釋內容前後各一個空格字元，注釋位於要注釋代碼的上面，單獨占一行\n推薦：\n&lt;!-- Comment Text --&gt;\n&lt;div&gt;...&lt;&#x2F;div&gt;\n\n不推薦：\n&lt;div&gt;...&lt;&#x2F;div&gt;&lt;!-- Comment Text --&gt; \n  \n&lt;div&gt;&lt;!-- Comment Text --&gt;\n    ...\n&lt;&#x2F;div&gt;\n\n2. 路徑(重點、難點)實際工作中，檔案不能隨便亂放，否則用起來很難快速的找到他們，因此需要一個資料夾來管理他們。\n目錄資料夾\n就是普通資料夾，裡面只不過存放了我們做頁面所需要的 相關素材，比如 html檔， 圖片 等等。\n根目錄  \n打開目錄資料夾的第一層  就是 根目錄 \n\n\n\n\n\n\n\n\n\n頁面中的圖片會非常多， 通常我們再新建一個資料夾專門用於存放影像檔（images），這時再插入圖像，就需要採用 “路徑” 的方式來指定影像檔的位置。路徑可以分為： 相對路徑和絕對路徑\n相對路徑以引用文件之網頁所在位置為參考基礎，而建立出的目錄路徑。因此，當保存於不同目錄的網頁引用同一個檔時，所使用的路徑將不相同，故稱之為相對路徑。\n\n\n\n路徑分類\n符號\n說明\n\n\n\n同一級路徑\n\n只需輸入影像檔的名稱即可，如&lt;img src&#x3D;”photo.gif” &#x2F;&gt;。\n\n\n下一級路徑\n“&#x2F;”\n影像檔位於HTML檔同級資料夾下（例如資料夾名稱為：images）                         如&lt;img src&#x3D;”images&#x2F;photo.gif” &#x2F;&gt;。\n\n\n上一級路徑\n“..&#x2F;”\n在檔案名之前加入“..&#x2F;” ，如果是上兩級，則需要使用 “..&#x2F; ..&#x2F;”，以此類推，                    如&lt;img src&#x3D;”..&#x2F;photo.gif” &#x2F;&gt;。\n\n\n**結論： **\n\n\n\n\n\n\n\n\n\n相對路徑，是從代碼所在的這個檔出發， 去尋找我們的目的檔案的，而 我們所說的 上一級 下一級 同一級  簡單說，就是 圖片 位於 HTML 頁面的位置\n絕對路徑絕對路徑以Web網站根目錄為參考基礎的目錄路徑。之所以稱為絕對，意指當所有網頁引用同一個檔時，所使用的路徑都是一樣的。\n“D:\\web\\img\\logo.gif”，或完整的網路位址，例如“http://www.photo.com/images/logo.gif”。\n注意：\n絕對路徑用的較少，我們理解下就可以了。  但是要注意，它的寫法 特別是符號  \\  並不是 相對路徑的   /    \n3. @拓展閱讀3.1 錨點定位 （難點）通過創建錨點連結，使用者能夠快速定位到目標內容。\n創建錨點連結分為兩步：\n1. 使用相應的id名標注跳轉目標的位置。 (找目標)\n  &lt;h3 id&#x3D;&quot;two&quot;&gt;第2集&lt;&#x2F;h3&gt; \n\n2. 使用&lt;a href&#x3D;&quot;#id名&quot;&gt;連結文本&lt;&#x2F;a&gt;創建連結文本（被點擊的） （拉關係）  我也有一個姓畢的姥爺..\n  &lt;a href&#x3D;&quot;#two&quot;&gt;   \n\n\n\n\n\n\n\n\n\n\n好比找個人辦事，  首先找到他，然後拉關係，最後看效果。\n3.2 base 標籤語法：\n&lt;base target&#x3D;&quot;_blank&quot; &#x2F;&gt;\n\n**總結： **\n\nbase 可以設置整體連結的打開狀態   \nbase 寫到      之間\n把所有的連接 都默認添加 target&#x3D;”_blank”\n\n總結：\n\n\n\n\n\n\n\n\n\n全體連結~ 到 ~  全體集合  所有連結 以新視窗打開頁面  ~   是 \n3.3 預格式化文字pre標籤&lt;pre&gt; 標籤可定義預格式化的文本。\n被包圍在 &lt;pre&gt; 標籤 元素中的文本通常會保留空格和分行符號。而文本也會呈現為等寬字體。\n&lt;pre&gt;\n  此例演示如何使用 pre 標籤\n    對空行和 空格\n      進行控制\n\n&lt;&#x2F;pre&gt;\n\n總結：\n\n\n\n\n\n\n\n\n\n所謂的預格式化文字就是 ，按照我們預先寫好的文字格式來顯示頁面， 保留空格和換行等。 \n有了這個標籤，裡面的文字，會按照我們書寫的模式顯示，不需要段落和換行標籤了。但是，比較少用，因為不好整體控制。\n","slug":"20230307Html 03 常用標籤","date":"2023-03-07T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"76dff37ffad444f9899a2462f98081d7","title":"Html認識HTML","content":"學習目標\n理解\nHTML的概念\nHTML標籤的分類\nHTML標籤的關係\nHTML標籤的語義化\n\n\n應用\nHTML骨架格式\nsublime基本使用\n\n\n\n1. HTML 初識\nHTML 指的是超文字標記語言 (Hyper Text Markup Language)是用來描述網頁的一種語言。\nHTML 不是一種程式設計語言，而是一種標記語言 (markup language)\n標記語言是一套標記標籤 (markup tag)\n\nhtml作用:\n\n\n\n\n\n\n\n\n\n網頁是由網頁元素組成的 ， 這些元素是利用html標籤描述出來，然後通過流覽器解析，就可以顯示給使用者了。\n所謂超文字，有2層含義： \n\n因為它可以加入圖片、聲音、動畫、多媒體等內容（**超越文本限制 **）\n不僅如此，它還可以從一個檔跳轉到另一個檔，與世界各地主機的檔連接（**超級連結文本 **）。\n\n&lt;img src&#x3D;&quot;timg.jpg&quot; &#x2F;&gt;\n\nhtml 總結:\n\nhtml 是超文字標記(標籤)語言\n學習html 主要學習html標籤\n我們用html標籤描述網頁元素。 比如 圖片標籤 、文字標籤、連結標籤等等\n標籤有自己的語法規範，所有的html標籤都是用 &lt;&gt; 表示的\n\n1.1 HTML骨架標籤日常生活的書信，我們要遵循共同的約定。 \n同理：HTML 有自己的語言語法骨架格式：（要遵循，要專業） 要求務必非常流暢的默寫下來。。\n&lt;html&gt;   \n    &lt;head&gt;     \n        &lt;title&gt;&lt;&#x2F;title&gt;\n    &lt;&#x2F;head&gt;\n    &lt;body&gt;\n    &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\nhtml骨架標籤總結\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;html&gt;&lt;/html&gt;\nHTML標籤\n頁面中最大的標籤，我們成為  根標籤\n\n\n&lt;head&gt;&lt;/head&gt;\n文檔的頭部\n注意在head標籤中我們必須要設置的標籤是title\n\n\n&lt;titile&gt;&lt;/title&gt;\n文檔的標題\n讓頁面擁有一個屬於自己的網頁標題\n\n\n&lt;body&gt;&lt;/body&gt;\n文檔的主體\n元素包含文檔的所有內容，頁面內容 基本都是放到body裡面的\n\n\n團隊約定大小寫HTML標籤名、類名、標籤屬性和大部分屬性值統一用小寫\n推薦：\n&lt;head&gt;     \n        &lt;title&gt;我的第一個頁面&lt;&#x2F;title&gt;\n &lt;&#x2F;head&gt;\n\n不推薦：\n&lt;HEAD&gt;     \n        &lt;TITLE&gt;我的第一個頁面&lt;&#x2F;TITLE&gt;\n&lt;&#x2F;HEAD&gt;\n\n1.2 HTML元素標籤分類標籤：\n在HTML頁面中，帶有“&lt; &gt;”符號的元素被稱為HTML標籤，如上面提到的 &lt;html&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架結構標籤。\n分類：\n\n常規元素（雙標籤）\n\n&lt;標籤名&gt; 內容 &lt;&#x2F;標籤名&gt;   比如 &lt;body&gt;  我是文字  &lt;&#x2F;body&gt;\n\n\n該語法中\n“&lt;標籤名&gt;”表示該標籤的作用開始，一般稱為“開始標籤（start tag）”\n“&lt;&#x2F;標籤名&gt;” 表示該標籤的作用結束，一般稱為“結束標籤（end tag）”\n\n\n和開始標籤相比，結束標籤只是在前面加了一個關閉符“&#x2F;”\n以後接觸的基本都是雙標籤\n\n\n空元素（單標籤）\n\n&lt;標籤名 &#x2F;&gt;  比如  &lt;br &#x2F;&gt;\n\n\n空元素 用單標籤來表示， 簡單點說，就是裡面不需要包含內容， 只有一個開始標籤不需要關閉。\n這種單身狗標籤非常少，一共沒多少，我們多記憶就好\n\n聯想概括：\n\n\n\n\n\n\n\n\n\n世界上單身狗畢竟是少數的， 大部分還是喜歡成雙成對，不要拉下你的另外一半，對待一個雙標籤要有始有終。\n1.3 HTML標籤關係主要針對於雙標籤 的相互關係分為兩種：  請大家務必熟悉記住這種標籤關係，因為後面我們標籤嵌套特別多，很容易弄混他們的關係。\n\n嵌套關係\n\n&lt;head&gt;  \n  &lt;title&gt; &lt;&#x2F;title&gt; \n&lt;&#x2F;head&gt;\n\n2.並列關係\n&lt;head&gt;&lt;&#x2F;head&gt;\n&lt;body&gt;&lt;&#x2F;body&gt;\n\n倡議： \n\n\n\n\n\n\n\n\n\n如果兩個標籤之間的關係是嵌套關係，\n子元素最好縮進一個tab鍵的身位（一個tab是4個空格）。\n如果是並列關係，最好上下對齊。\n聯想概括：\n\n\n\n\n\n\n\n\n\nhtml雙標籤 可以分為一種是 父子級 包含關係的標籤一種是 兄弟級 並列關係的標籤\n2. 文檔類型&lt;!DOCTYPE&gt;用法：\n&lt;!DOCTYPE html&gt; \n\n作用：\n 聲明位於文檔中的最前面的位置，處於  標籤之前。此標籤可告知流覽器文檔使用哪種 HTML 或 XHTML 規範。\n&lt;!DOCTYPE html&gt;  就是告訴流覽器按照HTML5 規範解析頁面\n團隊約定：\n\n\n\n\n\n\n\n\n\nHTML檔必須加上 DOCTYPE 聲明，並統一使用 HTML5 的文檔聲明\n3. 頁面語言lang&lt;html lang&#x3D;&quot;zh-TW&quot;&gt;  指定html 語言種類\n\n最常見的2個：\n\nen定義語言為英語\nzh-TW定義語言為繁體中文\n\n團隊約定：\n\n\n\n\n\n\n\n\n\n考慮流覽器和作業系統的相容性，目前仍然使用 zh-TW 屬性值\n@拓展閱讀：\n簡單來說，可能對於程式來說沒有太大的作用，但是它可以告訴流覽器，搜尋引擎，一些處理Html的程式對頁面語言內容來做一些對應的處理或者事情。比如可以\n\n根據根據lang屬性來設定不同語言的css樣式，或者字體\n告訴搜尋引擎做精確的識別\n讓語法檢查程式做語言識別\n幫助翻譯工具做識別\n説明網頁閱讀程式做識別\n\n4. 字元集&lt;meta charset&#x3D;&quot;UTF-8&quot; &#x2F;&gt;\n\n字元集(Character set)是多個字元的集合。\n\n電腦要準確的處理各種字元集文字，需要進行字元編碼，\n以便電腦能夠識別和存儲各種文字。\n\nutf-8是目前最常用的字元集編碼方式，常用的字元集編碼方式還有gbk和gb2312。\n\ngb2312 簡單中文  包括6763個漢字  GUO BIAO\nBIG5   繁體中文 港澳臺等用\nGBK包含全部中文字元    是GB2312的擴展，加入對繁體字的支持，相容GB2312\nUTF-8則基本包含全世界所有國家需要用到的字元\n這句代碼非常關鍵， 是必須要寫的代碼，否則可能引起亂碼的情況。\n\n\n\n\n\n\n\n\n\n\n這句話是讓 html 文件是以 UTF-8 編碼保存的， 流覽器根據編碼去解碼對應的html內容。\n團隊約定：\n\n\n\n\n\n\n\n\n\n一般情況下統一使用 &quot;UTF-8&quot; 編碼，\n請儘量統一寫成標準的 &quot;UTF-8&quot;，\n不要寫成 &quot;utf-8&quot; 或 &quot;utf8&quot; 或 &quot;UTF8&quot;。\n5. HTML標籤的語義化白話： 所謂標籤語義化，就是指標籤的含義。\n結論:\n\n\n\n\n\n\n\n\n\n根據標籤的語義，在合適的地方給一個最為合理的標籤，讓結構更清晰。\n\n方便代碼的閱讀和維護\n同時讓流覽器或是網路爬蟲可以很好地解析，從而更好分析其中的內容 \n使用語義化標籤會具有更好地搜尋引擎優化\n\n語義是否良好： 當去掉CSS之後，網頁結構依然組織有序，並且有良好的可讀性。\n遵循的原則：先確定語義的HTML ，再選合適的CSS。所以，接下來學習html標籤，要根據語義去記憶。 HTML網頁中任何元素的實現都要依靠HTML標籤。\n","slug":"20230306Html 02 認識Html","date":"2023-03-06T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"ea9f8724503553e7e983e98765f0c811","title":"Html認識WEB","content":"HTML 第一天目標  能夠寫出基本的html頁面（裡面包含圖片、連結、文字等網頁元素標籤）\n認識WEB1. 認識網頁網頁主要由文字、圖像和超連結等元素構成。\n當然，除了這些元素，網頁中還可以包含音訊、視頻以及Flash等。\n\n總結網頁有圖片、連結、文字等元素組成，就是要把這部分網頁元素用代碼寫出來。\n2. 瀏覽器（顯示代碼）瀏覽器是網頁顯示、運行的平臺，\n常用的五大瀏覽器有IE、火狐（Firefox）、google（Chrome）、Safari和Opera等。\n\n2.1 常見瀏覽器內核（瞭解）首先解釋一下瀏覽器內核是什麼東西。英文叫做：Rendering Engine，中文翻譯很多，排版引擎、解釋引擎、渲染引擎，現在流行稱為瀏覽器內核.\n負責讀取網頁內容，整理訊息，計算網頁的顯示方式並顯示頁面.\n因為瀏覽器太多啦， 但是現在主要流行的就是下面幾個：\n\n\n\n瀏覽器\n內核\n備註\n\n\n\nGoogle Chrome\nBlink\n由Google開發，市佔率最高的瀏覽器之一，支援廣泛的瀏覽器插件及擴充功能。\n\n\nMicrosoft Edge\nBlink\n由Microsoft開發，支援跨平台使用，與Windows 10系統整合，支援多種瀏覽模式。\n\n\nApple Safari\nWebKit\n由Apple開發，預設瀏覽器於iOS及macOS系統中，內建多項輔助功能。\n\n\nMozilla Firefox\nGecko\n由Mozilla基金會開發，強調開放源碼及隱私保護，支援豐富的擴充功能。\n\n\nOpera\nBlink\n由Opera Software開發，提供許多獨特的功能如：內建VPN、廣告封鎖等。\n\n\n拓展閱讀：\n在 Android 手機中，除了 WebKit 內核之外，還有其他的內核選擇，\n例如 Google 開發的 Chrome 內核、Opera 開發的 Presto 內核以及谷歌為 Android 手機推出的 Blink 內核。\n目前 iOS 中的內置瀏覽器內核主要是基於 WebKit 開發的，\n但是它與 Android 上的 WebKit 並不完全相同，\n因為 Apple 在 WebKit 基礎上進行了大量的修改和優化。\n同時，Safari 在 iOS 和 macOS 上也是使用相同的內核。\n\n3. Web標準（重點）目標\n\n記憶\n網頁中 web 標準三層組成\n\n\n理解\n結合人來表述web標準三層\n\n\n\n拓展閱讀：\n\nWeb標準不是某一個標準，而是由W3C組織和其他標準化組織制定的一系列標準的集合。\nW3C 是一個非營利的國際組織，成立於1994年，其全稱為World Wide Web Consortium（萬維網聯盟）\nW3C 旨在開發萬維網相關技術的標準，進而促進網際網路的發展和普及。該組織負責管理並維護 HTML、CSS、XML 等網頁技術的標準，並制定其他網路技術的標準。\nW3C 發佈的標準僅是建議性的，並不是強制性的法規或規範。\n然而，許多互聯網技術和產品都基於 W3C 的標準來實現。\n\n3.1 為什麼要遵循WEB標準呢？ 通過以上瀏覽器不同內核不同，其顯示頁面或者排版就有些許差異。\n3.2 Web 標準的好處遵循web標準可以讓不同我們寫的頁面更標準更統一外，還有許多優點\n1、讓Web的發展前景更廣闊2、內容能被更廣泛的設備訪問3、更容易被搜尋引擎搜索4、降低網站流量費用5、使網站更易於維護6、提高頁面流覽速度\n3.3 Web 標準構成構成： 主要包括結構（Structure）、表現（Presentation）和行為（Behavior）三個方面。\n\n\n\n標準\n說明\n備註\n\n\n\n結構\n結構用於對網頁元素進行整理和分類\nHTML。\n\n\n表現\n表現用於設置網頁元素的版式、顏色、大小等外觀樣式\nCSS\n\n\n行為\n行為是指網頁模型的定義及交互的編寫\nJavascript\n\n\n 理想狀態我們的源碼： .HTML      .css      .js \n\nweb標準小結\nweb標準有三層結構，分別是結構（html）、表現（css）和行為（javascript）  \n結構類似人的身體， 表現類似人的著裝， 行為類似人的行為動作\n理想狀態下，他們三層都是獨立的， 放到不同的檔裡面\n\n4. 拓展@\n介紹一下你對瀏覽器內核的理解？\n\n\n\n\n\n\n\n\n\n瀏覽器內核包括兩部分，渲染引擎和js引擎。\n渲染引擎負責讀取網頁內容，整理訊息，計算網頁的顯示方式並顯示頁面\njs引擎是解析執行js獲取網頁的動態效果。 \n後來 JS 引擎越來越獨立，內核就傾向於只指渲染引擎。\n\n\n\n","slug":"20230305Html 01 前言及標準","date":"2023-03-05T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"71434f06eb628cf7a92f4f3d96cc0406","title":"前端之路","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n快速入門建立新文章$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\n啟動伺服器$ hexo server\n\nMore info: Server\n產生靜態檔案$ hexo generate\n\nMore info: Generating\n部署到遠端網站$ hexo deploy\n\nMore info: Deployment\n","slug":"20230101hello-world","date":"2022-12-31T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"Hsu's Blog"}]