[{"id":"56db2cad4299ff0a006fb12b8d33d535","title":"運算子與運算式","content":"03【運算子與運算式】1. 運算子運算子：是一種將資料進行運算的特殊符號，在 PHP 中一共有十多種運算子。\n1.1 算術運算子+ - \\ * / %\n1234567$a = 10;$b = 3;echo $a + $b;  // 結果：13echo $a - $b;  // 結果：7echo $a * $b;  // 結果：30echo $a / $b;  // 結果：3.3333...echo $a % $b;  // 結果：1\n\n1.2 比較運算子\n&gt; , &gt;= , &lt; , &lt;= , == (資料大小相同即可，無需考慮資料資料型別)\n==： 比較資料大小是否相同，無需考慮資料型別。\n!= , &lt;&gt;： 檢查資料是否不相等。\n===： 全等於，要求資料大小和資料型別均相同。\n!==： 不全等於，要求資料大小或資料型別有一方不同。\n\n12345$a = &#x27;123&#x27;;  // 字符串$b = 123;  // 整型var_dump($a == $b);   // 結果： bool(true)var_dump($a === $b);   // 結果： bool(false)   不全等於\n\n1.3 邏輯運算子&amp;&amp;(左邊條件與右邊條件同時成立)\n||(有一個滿足即可) !(取反)\n123456789101112$c = &#x27;weekend&#x27;;$d = &#x27;goods&#x27;;var_dump($c == &#x27;weekend&#x27; &amp;&amp; $d == &#x27;good&#x27;);   // bool(false)// &amp;&amp; 可寫成 andvar_dump($c == &#x27;weekend&#x27; and $d == &#x27;good&#x27;);   // bool(false)var_dump($c == &#x27;weekend&#x27; || $d == &#x27;good&#x27;);   // bool(true)// || 可寫成 orvar_dump($c == &#x27;weekend&#x27; or $d == &#x27;good&#x27;);   // bool(true)var_dump(!($c == &#x27;good&#x27;));   // bool(true)\n\nxor(邏輯互斥運算子)\n\n一對一錯 true\n兩個中一個對&#x2F;錯 false\n兩個一個對 true\n\n1234567x=10 y=5var_dump($x==10 xor $y==5);//bool(false)var_dump($x==5 xor $y==10);//bool(false)var_dump($x==10 xor $y==10); //bool(true)\n\n1.4 連接運算子.(將字符串連接一起) .=(將左邊內容與右邊內容連接起來並重新賦值)\n123456$e = &#x27;hello&#x27;;$f = 123;echo $e . $f;   // hello123（注意，此處有強製型別轉換）$e .= $f;echo $e;       // hello123\n\n1.5 錯誤抑製符@(可能出錯的表達式)，在 PHP 中有一些錯誤可以提前預知，但又不想報錯，這就需要錯誤抑製符。\n123$g = 0;echo $f % $g;    // 此時會報錯echo @($f % $g); // 不會報錯\n\n1.6 三目運算子(問號表達式)表達式 1 ？ 表達式 2：表達式 3\n1echo $g ==0?1:2;\n\n1.7 自操作運算子++ --(前置或後置如果只有自操作，則效果一緻)\n12$i = $g++;    // $g = 1;  $i = 0$i = ++$g;    // $g = 2;  $i = 2;\n\n1.8 位運算子計算機碼：計算機在實際存儲資料時，採用的編碼規則(二進位規則)\n計算機碼：原碼、反碼和補碼。數值本身最左邊一位用來充當符號位：正數為 0，負數為 1；\n原碼:資料本身從十進位轉換成二進位得到的結果\n\n正數，左符號位為 0\n負數：右符號位為 1\n反碼：針對負數，符號位不變，其他位取反。\n補碼：針對負數，反碼+1.（系統中存的為補碼）\n\n\n\n\n\n\n\n\n\n\n以 0 為例，若是原碼，則+0 &#x3D; 00000000 -0 &#x3D; 10000000；二者不一樣-0 反碼 11111111 -0 補碼 00000000 與+0 一樣（正數原碼、補碼、反碼為其本身）。\n12$j = 5;      // 原碼：00000101$k = -5;     // 原碼：10000101  反碼：11111010  補碼：11111011\n\n位運算：取出計算機中最小的單位（bit）進行運算&amp; | ~(按位取反)^(按位異或)&gt;&gt;(右移)&lt;&lt;(左移)\n123456789101112131415161718192021222324// 註：1、系統進行位運算時，均是利用補碼進行運算的     2、運算結束之後，必須轉換為原碼進行顯示// 按位取與var_dump($j &amp; $k);    // int(1)/*    5  00000101     -5  11111011      &amp;  00000001  判斷：符號位為0，正數，所存即為原碼，無需操作*/// 按位取反var_dump(~ $k);       // int(4)/*     -5  11111011      ~  00000100  正數即為原碼，*/// 按位右移var_dump($k &gt;&gt; 1);   // int(-3)var_dump($k &gt;&gt; 2);   // int(-2)/*     -5  11111011    &gt;&gt;1  11111101(右移補符號位)    &gt;&gt;2  11111110(右移補符號位)*/\n\n1.9 組合比較子(太空船比較子)&lt; = &gt;\n\n$a &lt; $b：回傳 -1\n$a &#x3D; $b：回傳 0\n$a &gt; $b：回傳 1\n\n123$a=5;$b=10;echo $a&lt;=&gt;$b; //-1\n\n1.10 參考運算子(reference operator)參考運算子由 &amp; 符號表示，它允許你創建對變數的引用。\n當通過引用賦值給一個變數時，這兩個變數將引用相同的內存數據，對其中一個變數的更改將影響另一個變數。\n在某些情況下，這可以很有用，因為它允許多個變數指向相同的值，而不是創建數據的副本。\n原來：\n12345678$m=10;$n=$m; //傳值 開個新的記憶體空間給他echo &quot;m is : $m&lt;br&gt;&quot;; //10echo &quot;n is : $n&lt;br&gt;&quot;; //10$n=5; //改變n 不會影響到mecho &quot;m is : $m&lt;br&gt;&quot;; //10echo &quot;n is : $n&lt;br&gt;&quot;; //5\nreference operator :\n12345678$o = 10;$p = &amp;$o; //reference operator //記憶體是同一個echo &quot;o is : $o&lt;br&gt;&quot;; //10echo &quot;p is : $p&lt;br&gt;&quot;; //10$p = 5 ;echo &quot;o is : $o&lt;br&gt;&quot;; //5echo &quot;p is : $p&lt;br&gt;&quot;; //5\n\n1.11 運算子的優先級指定了在表達式中哪些運算子會被先執行。以下是 PHP 中一些常見的運算子按優先級由高到低的順序：\n\n**()：括號，最高優先級。\n++，--，~，!：自增、自減、按位取反、邏輯取反。\n*，/，%：乘法、除法、取餘。\n+，-，.：加法、減法、字串連接。\n&lt;&lt;，&gt;&gt;：按位左移、按位右移。\n&lt;，&lt;=，&gt;，&gt;=：比較。\n==，!=，===，!==：等於、不等於、全等於、不全等於。\n&amp;：按位與。\n^：按位異或。\n|：按位或。\n&amp;&amp;：邏輯與。\n||：邏輯或。\n? :：三元條件運算符。\n=, +=, -=, *=, /=, %=：賦值及複合賦值。\n,：逗號，用於分隔表達式。\nor &#x2F; and 看到boolean會直接return 第一個boolean\n\n2. 箭頭運算子2.1 胖箭頭 &#x3D;&gt;=&gt; 是 PHP 中的「箭頭運算子」，它通常用於表示關聯數組（Associative Arrays）中的鍵值對（key-value pair）。\n舉例來說，如果你有一個關聯數組，想要指定每個元素的鍵和值，你可以使用 =&gt; 來連接它們。以下是一個簡單的例子：\n12345$person = array(    &#x27;name&#x27; =&gt; &#x27;John&#x27;,    &#x27;age&#x27; =&gt; 30,    &#x27;occupation&#x27; =&gt; &#x27;Developer&#x27;);\n\n在這個例子中，&#39;name&#39;、&#39;age&#39; 和 &#39;occupation&#39; 是鍵，而 &#39;John&#39;、30 和 &#39;Developer&#39; 是相應的值。箭頭運算子指示了每個鍵和值之間的關係。\n2.1 瘦箭頭 -&gt;此外，箭頭運算子也常用於對象（Object）的屬性訪問，例如：\n1234$personObject = new stdClass();$personObject-&gt;name = &#x27;John&#x27;;$personObject-&gt;age = 30;$personObject-&gt;occupation = &#x27;Developer&#x27;;\n\n結論:\n\n\n\n\n\n\n\n\n\n-&gt; 用於訪問對象的屬性。\n=&gt; 主要用於創建關聯數組和訪問對象屬性。\n","slug":"PHP03【運算子與運算式】","date":"2024-11-25T05:20:05.000Z","categories_index":"PHP","tags_index":"桃園資展筆記,PHP","author_index":"Hsu's Blog"},{"id":"ac091d156862e0f366b14e38774ead02","title":"基礎語法與資料型別","content":"02【基礎語法與資料型別】1. 初步語法PHP 是一種執行在伺服器端的腳本語言，可以嵌入到 HTML 中。使客戶端被動接收結果，故而可以預防客戶端透過查看原始碼得知整個程式運作的細節。\n\n\n\n\n\n\n\n\n\nHTML 是通過瀏覽器解析，PHP 是通過 PHP 引擎解析,那麼嵌入到裡面以後如何區分什麼時候通過什麼來解析？\n1.1 PHP 代碼標記：可通過多種標記來區分 PHP 腳本\nASP 標記 &lt;% php 代碼 %&gt;；\n標準簡化標記 &lt;? 代碼 ?&gt;\n\n以上兩種基本棄用，如使用，需在配置文件中開啓\n\n腳本標記 ：也不經常用\n\n12345&lt;h1&gt;  &lt;script language=&quot;php&quot;&gt;    echo &quot;hollo world&quot;;  &lt;/script&gt;&lt;/h1&gt;\n\n\n標準標記：&lt;? php 代碼 ?&gt;\n\n12345678&lt;h1&gt;  &lt;?php echo &quot;hollo world&quot; ?&gt;&lt;/h1&gt;&lt;!-- 速寫 --&gt;&lt;h1&gt;  &lt;?= &quot;hello world&quot; ?&gt;&lt;/h1&gt;\n\n\n\n\n\n\n\n\n\n\n&lt;?= ... ?&gt; 是一種短標籤（Short Tags）或簡寫標籤，等同於 &lt;?php echo ... ?&gt;\n1.2 PHP 註釋：\n行註釋：//（雙斜杠）或#\n塊註釋：/*     */\n\n1.3 PHP 語句分隔符：1、在 PHP 中，代碼以行為單位，系統需要通過判斷行的結束，通常都用；表示結束。\n\n\n\n\n\n\n\n\n\n註：PHP 中標記結束符?&gt;有自帶語句結束符的效果，最後一行 PHP 代碼可以沒有語句結束符。\n2、PHP 中代碼的書寫並不是全嵌入到 HTML 中，而是單獨存在，所以可以不用標記結束符?&gt;\n1.3 換行1echo “&lt;br&gt;”\n\n1.4 英文大小寫差異1.php 中的設定變數與常數會因大小寫不同而不同\n2.結構控制敘述、註解、內建函式名稱則並不區分大小寫，仍然會執行功能。\n1.5 保留字\n\n\n\n\n\n\n\n\n\n\n__halt_compiler()\nabstract\nand\narray()\nas\n\n\nbreak\ncallable\ncase\ncatch\nclass\n\n\nclone\nconst\ncontinue\ndeclare\ndefault\n\n\ndie()\ndo\necho\nelse\nelseif\n\n\nempty()\nenddeclare\nendfor\nendforeach\nendif\n\n\nendswitch\nendwhile\neval()\nexit()\nextends\n\n\nfinal\nfinally\nfn（从 PHP 7.4 开始）\nfor\nforeach\n\n\nfunction\nglobal\ngoto\nif\nimplements\n\n\ninclude\ninclude_once\ninstanceof\ninsteadof\ninterface\n\n\nisset()\nlist()\nmatch（从 PHP 8.0 开始）\nnamespace new\n\n\n\nor\nprint\nprivate\nprotected\npublic\n\n\nreadonly（自 PHP 8.1.0 起）*\nrequire\nrequire_once\nreturn\nstatic\n\n\nswitch\nthrow\ntrait\ntry\nunset()\n\n\nuse\nvar\nwhile\nxor\nyield\n\n\nyield\nfrom\n\n\n\n\n\n2. 變數txt1、變數是用來存儲資料的；\n\n2、變數是存在名字的；\n\n3、變數是通過名字訪問資料的；\n\n4、變數的資料是可以改變的。2.1 變數的使用txt1、定義：在系統中增加對應的變數名字（在記憶體中開發一塊地）\n\n2、賦值：將資料賦值給變數（在定義時直接初始化）\n\n3、可通過變數名訪問資料\n\n4、變數可從記憶體中刪除12345678910// 定義時不需要關鍵字，但必須使用$符號$var1;$var2 = 1;echo $var2;   // 訪問變數，通過變數名找到資料，並顯示$var2 = 2;        // 修改變數echo &#x27;&lt;hr/&gt;&#x27;,$var2;    // hr/“ 為下劃線，分隔符unset($var2); // 刪除變數，從記憶體中剔除echo $var2;   // 此時會報錯，因為不存在變數\n\n2.2 變數命名規則1、變數名字必須以”$”開頭；\n\nsingle quote &#x2F; multiple quote 有差2、變數名可由數字、字母、下劃線命名，但必須以字母和下劃線開頭\n\n3、允許中文變數(不建議)；\n2.3 預設變數即提前定義的變數，由系統定義的變數，存儲許多要用到的資料（預定義變數都是陣列）。\n\n\n\n預設變數\n說明\n\n\n\n$_GLOBALS\n儲存全局範圍變數的資訊陣列\n\n\n$_SERVER\n儲存伺服器內或使用者環境的資訊陣列變數\n\n\n$_ENV\n儲存 PHP 環境相關的資訊陣列\n\n\n$_POST\n儲存以 POST 方式傳入的陣列變數\n\n\n$_GET\n儲存以 GET 方式傳入的陣列變數\n\n\n$_COOKIE\n儲存以 COOKIE 方式註冊的陣列變數\n\n\n$_SESSION\n儲存以 SESSION 方式註冊的陣列變數\n\n\n$_FILES\n儲存以 POST 方式傳入檔案的陣列變數\n\n\n$_REQUEST\n儲存以 POST、GET、COOKIE、FILES 方式傳入的陣列變數\n\n\n2.4 可變變數如果一個變數儲存的值剛好是另外一個變數的名字，則可直接通過訪問一個變數得到另外一個變數的值：但需在變數前多加一個$符號\n123$a = &#x27;b&#x27;;    // a變數的內容正好是b變數的名稱，故稱a為可變變數$b = &#x27;bb&#x27;;echo $$a;    // 使用時需加一個$符號\n\n2.5 變數傳值將一個變數賦值給另一個變數：值傳遞、引用傳遞\n值傳遞：將變數儲存的值複製一份，並將該值給另外一個變數儲存(兩個變數無關係)\n引用傳遞：將變數儲存值所在的記憶體地址傳遞給另外一個變數，兩個變數同指一塊記憶體（名字不一樣而已）。\n2.5 分區在內存中，通常有以下幾個分區**棧區:**程序可以操作的內存部分(不存資料，運行程序代碼)，少但是快**代碼段:**儲存程序的內存部分(不執行)**資料段:**儲存普通資料(全局區和靜態區)**堆區:**儲存複雜資料，大但是效率低\n\n\n\n\n\n\n\n\n\n註：c++中，棧區由編譯器自動釋放，存儲局部變數和函式參數；代碼區存放函式的二進位代碼，由操作系統管理；全局區存放全局變數、靜態變數、常數；堆區由程式員配置釋放。\n2.5.1 值傳遞1234567891011// 值傳遞&lt;?php// 2.1 執行此行，在棧區開闢一塊記憶體存儲$a，在資料段中開闢一塊記憶體儲存值1。然後將1所在位置賦值給a變數$a = 1;// 2.2 棧區開闢存儲$b；發現是賦值運算，故會取出$a的值，// 並在資料段重新開闢一塊記憶體並儲存，且再把新開闢地址賦值給棧區的變數b$b = $a;   // 值傳遞// 2.3 執行該行$b = 2;echo $a,$b;\n\n講解執行步驟：\n1、代碼裝載：從腳本文件中將代碼讀取出來，進行編譯，將編譯結果存放到代碼段（二進位）。\n2、代碼執行：從代碼段中一行一行執行代碼。\n3、腳本執行結束：系統會回收所有記憶體（棧區、代碼區）：因為資料段與棧區有關係，回收棧後，資料段的內容無意義，相當於回收。\n2.5.2 引用傳遞12345678910// 引用傳遞&lt;?php// 2.1 執行此行，在棧區開闢一塊記憶體存儲$a，在資料段中開闢一塊記憶體儲存值1。然後將1所在位置賦值給a變數$a = 1;// 2.2 棧區開闢存儲$b；發現是引用運算，故會取出$a的地址，並將該地址給棧區的變數b$b = $a;   // 值傳遞// 2.3 執行該行$b = 2;echo $a,$b;\n\n4. 常數\n\n\n\n\n\n\n\n\n常數與變數一樣，均是用來儲存資料的。\n4.1 常數的基本概念const&#x2F;constant:是在程式執行中，不可改變的量（資料）；常數一旦定義，通常不可更改。\n4.2 常數定義的形式4.2.1 定義方式1、使用定義常數的函式：define（’常數名’,常數值）——類似於 c++的 #define\n2、const\n123456789101112131415161718192021&lt;?php// 使用函式定義常數define(&#x27;PI&#x27;,3.1415);   // 注意此處與c++不同，#define 為預處理指令，宏定義，無需加；。。// 使用const關鍵字定義const PI1 = 3;// 定義特殊常數define(&#x27;^-^&#x27;,&#x27;smile&#x27;);// const ^-^   // 報錯// 訪問常數echo PI1;// echo ^-^   // 報錯constant(&#x27;^-^&#x27;);  // 特殊常數的訪問// 系統常數echo &#x27;&lt;hr/&gt;&#x27;,PHP_VERSION,&#x27;&lt;br/&gt;&#x27;,PHP_INI_SIZE,&#x27;&lt;br/&gt;&#x27;,PHP_INI_MAX;   // 有符號整形// 魔術常數echo &#x27;&lt;hr/&gt;&#x27;,__DIR__,&#x27;&lt;br/&gt;&#x27;,__FILE__,&#x27;&lt;br/&gt;&#x27;,__LINE__;echo __LINE__;  // 輸出的行數會變\n\n4.3 常數命名規則：1、常數不需要使用”$”符號，一旦使用被認為是變數\n2、變數名可由數字、字母、下劃線命名，但必須以字母和下劃線開頭（const 定義）\n3、常數的名字通常是以大寫字母為主（與變數以示區別）\n4、變數命名的規則比變數要鬆散，可以使用一些特殊字符（define 函式）\n5、變數通常不區分大小寫，但可以區分（define 函式的第三個參數）\n4.4 預設常數與魔術常數魔術常數：由雙下劃線+常數名+雙下劃線組成，其值會隨著環境變化而變化，用戶無法改變。\n\n\n\n預設常數\n描述\n\n\n\nPHP_VERSION\n包含當前正在運行的 PHP 版本號\n\n\nPHP_OS\n包含伺服器操作系統的名稱，例如 Linux、Windows 等\n\n\nPHP_EOL\n包含用於換行的字元序列，取決於執行 PHP 的操作系統（\\r\\n 或 \\n）\n\n\nTRUE\n代表布林值 true，表示真\n\n\nFALSE\n代表布林值 false，表示假\n\n\nNULL\n代表空值，表示變數未賦值或被清空\n\n\n\n\n\n魔術常數\n描述\n\n\n\n_ _LINE_ _\n表示使用當前行號。\n\n\n_ _FILE_ _\n表示檔案的完整路徑和檔案名。 如果它在 include 中使用，則返回包含檔案的名稱。\n\n\n_ _DIR_ _\n表示檔案的完整目錄路徑。 等同於 dirname(file)。 除非它是根目錄，否則它沒有尾部斜槓。 它還解析符號連結。\n\n\n_ _FUNCTION_ _\n表示使用它的函式名稱。如果它在任何函式之外使用，則它將返回空白。\n\n\n_ _CLASS_ _\n表示使用它的函式名稱。如果它在任何函式之外使用，則它將返回空白。\n\n\n_ _TRAIT_ _\n表示使用它的特徵名稱。 如果它在任何函式之外使用，則它將返回空白。 它包括它被宣告的名稱空間。\n\n\n_ _METHOD_ _\n表示使用它的類方法的名稱。方法名稱在有宣告時返回。\n\n\n_ _NAMESPACE_ _\n表示當前名稱空間的名稱。\n\n\n5. 資料型別資料型別：data type，在 PHP 中指的是資料本身的型別，而不是變數的型別。PHP 是一種弱型別語言，變數本身沒有資料型別。\n5.1 PHP 八大資料型別\n\n\n\n\n\n\n\n\n標量型別\n\n布林 (Boolean)\n整數 (Integer)\n浮點數 (Floating-point)\n字串 (String)\n\n\n\n\n\n\n\n\n\n\n複合型別\n\n陣列 (Array)\n物件 (Object)\n\n\n\n\n\n\n\n\n\n\n特別型別\n\n資源 (Resource)\nNULL\n\n5.2 標量型別\n布林 (Boolean): 表示 true 或 false。\n整數 (Integer): 表示整數，例如 42 或 -123。\n浮點數 (Floating-point): 表示帶有小數部分的數字，例如 3.14 或 -0.003。\n字串 (String): 表示文字，例如 ‘Hello, World!’。\n\n1234$bool_var = true;$integer_var = 42;$float_var = 3.14;$string_var = &#x27;Hello, World!&#x27;;\n\n5.2.1 布林型別5.2.2 整數型別整數不包含小數的數值，其數值範圍在正整數、零、負整數之間。\n12345678910111213141516171819202122&lt;?php/*十進位轉換二進位-----&gt;除以210  1010  註：不管結果ruhr，均需補足32位：00000000 00000000 00000000 00001010*/// php中提供了很多函式進行轉換：// Decbin(): 十進位轉二進位var_dump(decbin(107));     // 結果：string(7) &quot;1101011&quot;// Decoct(): 十進位轉八進位var_dump(decoct(107));     // 結果：string(3) &quot;153&quot;// Dechex(): 十進位轉十六進位var_dump(dechex(107));     // 結果：string(2) &quot;6b&quot;// Bindec(): 二進位轉十進位var_dump(bindec(&quot;1101011&quot;)); // 結果：int(107)*/\n\n5.2.3 浮點數型別問：為什麼浮點數和整數型別均佔用四個字節，為什麼比整數型別表示的範圍大？\n整型資料的 32 位均通過*2 轉化為十進位。而浮點型中，前八位的後七位為指數，所以表示的範圍要大。\n另，實際使用時，盡量不用浮點型數字做精確判斷，且計算機中凡是小數基本上均不準確。\n123456789101112131415&lt;?php// 浮點數的定義$f1 = 1.23;$f2 = 1.23e10;$f3 = PHP_INT_MAX+1;   // 若整型超過自身存儲的大小之後會自動改為浮點型存儲var_dump($f1,$f2,$f3);// 結果：float(1.23)float(1.2300000000) float(214748348)// 浮點數判斷$f4 = 0.7;$f5 = 2.1;$f6 = $f5/3;var_dump($f6 == $f4);      // 結果：bool(false),,因此其不能進行精確判斷\n\n5.2.4 字串型別\n\n\n\n\n\n\n\n\n表示字串的四種方法\n\n單引號： 使用單引號括起來的字串。\n\n\n單引號內的跳脫字符（例如 &#39;）將保持原樣，不會被解釋為特殊字符。\n單引號內的變數不會被解釋，將直接顯示變數名稱。\n單引號內不能直接插入換行符或特殊字符。\n\n1$string1 = &#x27;Hello, World!&#x27;;\n\n\n雙引號： 使用雙引號括起來的字串，允許在字串中使用變數。\n\n\n雙引號內的跳脫字符（例如 &quot;）將被解釋為特殊字符。\n雙引號內的變數會被解釋，其值將被插入到字符串中。\n雙引號內可以插入換行符和其他特殊字符。\n\n12$name = &#x27;John&#x27;;$string2 = &quot;Hello, $name!&quot;;\n\n\nHeredoc 語法： 用來表示多行字串，使用 &lt;&lt;&lt; 運算符。\n\n1234$變數名稱 = &lt;&lt;&lt;自訂名稱字串內容....字串內容2....自訂名稱;\n\n1234$string3 = &lt;&lt;&lt;EODThis is a multi-linestring using heredoc syntax.EOD;\n\n\n\n\n\n\n\n\n\n\n常見錯誤\n結束標籤格式錯誤：\n\n結束標籤 EOD; 必須單獨在一行，不能有任何空格或其他字符。\n結束標籤之後不能有任何字符，包括空格。\n\n變數插入錯誤：\n\n在 Heredoc 中，變數插入需要使用 $ 符號，但要確保它不被解釋為字面上的 $。\n\n混淆的引號：\n\n在 Heredoc 中，使用雙引號可以方便地處理單引號，但混淆單雙引號時要小心。\n\n12345678910111213141516171819202122232425262728293031323334353637383940// 結束標籤格式錯誤======================// 正確$string = &lt;&lt;&lt;EODContent here.EOD;// 錯誤 - 結束標籤有多餘的空格$string = &lt;&lt;&lt;EODContent here.EOD;  // 錯誤 [here. ]&lt;-有空格// 錯誤 - 結束標籤後有其他字符$string = &lt;&lt;&lt;EODContent here.EOD;extra// 變數插入錯誤======================$name = &#x27;John&#x27;;// 正確$string = &lt;&lt;&lt;EODHello, $name!EOD;// 錯誤 - $ 符號被解釋為字面上的 $$string = &lt;&lt;&lt;EODHello, \\$name!EOD;// 混淆的引號======================$name = &#x27;John&#x27;;// 正確$string = &lt;&lt;&lt;EODHello, &quot;$name&quot;!EOD;// 錯誤 - 單引號混淆$string = &lt;&lt;&lt;EODHello, &#x27;$name&#x27;!EOD;\n\n\nNowdoc 語法： 類似于 Heredoc，但是在 Nowdoc 中不會解析變數。\n\n1234$變數名稱 = &lt;&lt;&lt;&#x27;自訂名稱&#x27;字串內容....字串內容2....自訂名稱;\n\n1234$string4 = &lt;&lt;&lt;&#x27;EOD&#x27;This is a multi-linestring using nowdoc syntax.EOD;\n\n[拓展補充-跳脫字元]12345678910111213141516171819202122232425262728293031// 單引號 (&#x27; &#x27;) 舉例$single_quoted = &#x27;This is a single-quoted string. It\\&#x27;s escaped.&#x27;;echo $single_quoted . &quot;\\n&quot;;// 結果：This is a single-quoted string. It&#x27;s escaped.// 雙引號 (&quot; &quot;) 舉例$double_quoted = &quot;This is a double-quoted string. It&#x27;s not escaped.&quot;;echo $double_quoted . &quot;\\n&quot;;// 結果：This is a double-quoted string. It&#x27;s not escaped.// 換行符 (\\n) 舉例$new_line = &quot;This is a string with a new line.\\nSecond line.&quot;;echo $new_line . &quot;\\n&quot;;// 結果：// This is a string with a new line.// Second line.// 回車符 (\\r) 舉例$carriage_return = &quot;This is a string with a carriage return.\\rSecond line.&quot;;echo $carriage_return . &quot;\\n&quot;;// 結果：Second line.rriage return.// Tab 字符 (\\t) 舉例$tabbed = &quot;This is a tabbed string.\\tIndented text.&quot;;echo $tabbed . &quot;\\n&quot;;// 結果：This is a tabbed string.    Indented text.// 反斜線自身 (\\\\) 舉例$backslash = &#x27;This is a string with a backslash: \\\\&#x27;;echo $backslash . &quot;\\n&quot;;// 結果：This is a string with a backslash: \\\n\n5.3 複合型別\n陣列 (Array): 表示一組值的集合。\n物件 (Object): 表示使用者自訂的物件實例。\n\n123456$array_var = array(1, 2, 3, &#x27;apple&#x27;, &#x27;orange&#x27;);class MyClass &#123;    // class definition&#125;$object_var = new MyClass();\n\n5.4 特別型別\n資源 (Resource): 表示外部資源的參考，如資料庫連接、文件指標等。\nNULL: 表示變數未賦值或被清空。\n\n12$resource_var = fopen(&#x27;example.txt&#x27;, &#x27;r&#x27;);$null_var = null;\n\n5.5 型別轉換很多情況需要指定資料型別，需要將外部資料型別（當前 PHP 獲得的資料）轉換成目標資料型別。\n5.2.1 兩種轉化方式：1、自動轉化：系統根據自己的需求判斷，自己轉化（用的較多、但效率較低）。\n2、強製轉換（手動）：在變數之前增加一個()，並在括號裡面寫上對於的型別，其中 NULL 特殊，需用 unset。\n5.2.2 轉換說明：1、以字母開頭的字符串，永遠為 0；\n2、以數字開頭的字符串，取到碰到字符串為止。（不會同時包含兩個小數點）\n12345678910111213141516171819202122232425&lt;?php// 資料型別// 創建資料$a = &#x27;abcd1.1.1&#x27;;$b = &#x27;1.1.1abc&#x27;;// 自動轉換。算術運算，系統先轉化為數值型別，然後運算echo $a+$b;  //   結果為1.1（0+1.1）// 強製轉換echo &#x27;&lt;br/&gt;&#x27;,(float)$a,(float)$b;  // 01.1// 型別判斷echo &#x27;&lt;hr/&gt;&#x27;;var_dump(is_int($a));         // bool(FALSE)var_dump(is_string($a));      // bool(TRUE)// 獲取資料型別echo &#x27;&lt;hr/&gt;&#x27;;echo gettype($a);    // string（雖然前面強製轉換了，但並未改變本身）// 設定型別// var_dump 輸出展示展示代碼內容，結構與型別。該函式作可以窺探所有內容的型別，以及內部資訊var_dump(settype($b,&#x27;int&#x27;));    // 先將字符串轉換為int型，轉換成功返回true，var_dump判斷是否為bool型，故顯示                                 bool（true）echo gettype($b),$b;     // interger1\n\n強制轉換關鍵字舉例:\n\n(int) 或 intval(): 強制轉換為整數。\n(float) 或 floatval(): 強制轉換為浮點數。\n(string) 或 strval(): 強制轉換為字串。\n(bool) 或 boolval(): 強制轉換為布林值。\nsettype(): 使用 settype() 函數進行強制轉換。\n\n","slug":"PHP02【基礎語法與資料型別】","date":"2024-11-25T01:20:05.000Z","categories_index":"PHP","tags_index":"桃園資展筆記,PHP","author_index":"Hsu's Blog"},{"id":"aaa0ebbefcf540c7d2923da17a9fabb8","title":"Sass 的安裝使用","content":"01 【Sass 的安裝使用】1.介紹1.1 什麼是 CSS 預處理技術？CSS 預處理器是一種工具或語言，它們擴展了 CSS 的功能，讓開發者可以使用變量、嵌套規則、函數、混入（mixins）等程式碼結構來撰寫樣式表。這些功能使得 CSS 更具結構性、可維護性和可重用性。\n\n通俗的說，“CSS 預處理器用一種專門的編程語言，進行 Web 頁面樣式設計，然後再編譯成正常的 CSS 文件，以供項目使用。CSS 預處理器為 CSS 增加一些編程的特性，無需考慮瀏覽器的相容性問題”，例如你可以在 CSS 中使用變量、簡單的邏輯程序、函式（如變量$main-color）等等在編程語言中的一些基本特性，可以讓你的 CSS 更加簡潔、適應性更強、可讀性更佳，更易於代碼的維護等諸多好處。\n\n1.2 css 預處理技術的種類\nSass（SCSS）: Sass 是一種成熟且廣泛使用的 CSS 預處理器。它支援兩種語法格式：一種是以.sass 擴展名的原始 Sass 語法，另一種是以.scss 擴展名的 CSS-like 語法，也被稱為 SCSS。\n\nLESS: LESS 是另一種流行的 CSS 預處理器，它與 Sass 類似，但語法略有不同。它使用.less 擴展名。\n\nStylus: Stylus 是一種更為彈性的 CSS 預處理器，它使用簡潔的語法並支援直接使用 JavaScript。它的主要特色是簡潔性和靈活性。\n\nTurbine: Turbine 是一個基於 Ruby 的 CSS 預處理器，它受到 Sass 和 LESS 的影響，同時添加了自己的特色。\n\nSwitch CSS: Switch CSS 是一個輕量級的 CSS 預處理器，它的目標是提供一個更簡單、更快速的替代方案。\n\nCSS Cacheer: CSS Cacheer 是一個基於 PHP 的 CSS 預處理器，它使用類似於 PHP 的語法。\n\nDT CSS: DT CSS 是一個極簡的 CSS 預處理器，它專注於提供基本的變量和混入功能。\n\n\n應該選擇哪種 CSS 預處理器？\n在 CSS 預處理器的選擇中， Sass、LESS 和 Stylus 被認為是最優秀的選擇。\n1.2 什麼是 sassSass(Syntactically Awesome StyleSheets)是一種 CSS 預處理器(preprocessor)， 是一款強化 CSS 的輔助工具。可以更有效地編寫和管理樣式表，同時實現變量、嵌套、組合、繼承等編程語言功能。\n\n變量（Variables）：允許開發者定義可重複使用的值，並在整個樣式表中輕鬆地更新它們。\n\n嵌套規則（Nested Rules）：使得樣式規則可以更清晰地組織和編排，將子元素寫入父元素中，並使樣式層次結構更加直觀。\n\n混入（Mixins）：允許開發者定義可重複使用的樣式片段，並在需要時將它們引入到不同的樣式規則中。\n\n繼承（Inheritance）：允許一個樣式規則從另一個樣式規則繼承屬性和值，以促進樣式的重用和組合。\n\n函數（Functions）：提供了一些內建函數或允許開發者定義自己的函數，用於執行計算或生成樣式值。\n\n模塊化（Modularity）：支持將樣式表拆分為多個文件或模塊，並允許通過導入或組合這些模塊來構建最終的 CSS。\n\n\n\n\n\n\n\n\n\n\n\ncss 是一門非程序式語言，沒有變量、函式、scope(作用域)等概念。\n\nCSS 需要書寫大量看似沒有邏輯的代碼，冗餘度比較高\n不方便維護及擴展，難以複用\ncss 沒有很好的計算能力\n非前端工程師往往會因為缺少 CSS 編寫經驗而很難寫出組織良好且易於維護的 CSS 代碼\n\nCSS 預處理器定義了一種新的語言，其基本思想是，用一種專門的編程語言，為 CSS 增加了一些編程的特性，將 CSS 作為目標生成文件，然後開發者只要使用這種語言進行 CSS 的編碼工作就可以了。\n\n\n\n\n\n\n\n\n\n“用一種專門的編程語言，進行 Web 頁面樣式設計，再通過編譯器轉化為正常的 CSS 文件，以供項目使用。”\n2.關於 scss 和 sasssass 是最早出現的 css 預處理語言，有著比 less 更強大的功能。採用Ruby 語言編寫。\n最初版本採用的是嚴格縮進的風格（**不帶大括號( {} )和分號( ; )**，這一語法也導致一開始，sass 並不太為開發者所接受）。\n12.list  display: flex\n\n從 V3 版本開始放棄了縮進式的風格，並完全相容普通的 css 代碼，也因此從第三代開始，sass 也被稱為 scss。\n\n\n\n\n\n\n\n\n\nCSS-like 語法 : Sass 3 就是 Scss，是 Sassy CSS 的簡寫，它是 CSS3 語法的超集，也就是說所有有效的 CSS&#x2F;CSS3 樣式也同樣適合於 Sass。\n123.list &#123;  display: flex;&#125;\n\n小節: 現代的 Sass 主要使用的是 SCSS 語法，這種語法更接近原生 CSS，並且通常使用.scss作為擴展名，以區別於舊版的.sass語法。而在程式領域中通常會使用 “Sass” 一詞來指代整個 Sass 生態系統，包括 SCSS 和以前的.sass 語法格式。\n3.安裝和指令行編譯3.1 透過 npm 全局方式安裝利用終端機進行全局(-g)的安裝\n1npm install -g sass\n\n3.2 檢查是否成功安裝1sass --version\n\n3.3 編譯.scss 文件為.css 文件首先建立project資料夾，並於其中建立以下結構\n12345678project/││├─── scss/│   ││   └─── all.scss│└─── index.html\n\n\n建一個 html 文件，隨便寫個 h1 標簽：\n\n123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;!-- 錯誤 --&gt;    &lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;scss/all.scss&quot; /&gt; --&gt;    &lt;!-- 要引入css的才能使用 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/all.css&quot; /&gt;    &lt;title&gt;測試sass/scss&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1 class=&quot;text-primary&quot;&gt;Hello World!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\nSass 使用.scss 作為文件後綴名，HTML 是無法解析 *.scss 文件的，不能直接在&lt; link &gt;標簽裏使用，任何的 CSS 預處理器都得透過編譯器使之編譯成 CSS 才能被正確解析\n\n建一個.scss 後綴的文件，如 all.scss，寫點基本樣式 sass 的語法：\n\n12345$primary: blue;.text-primary &#123;  color: $primary;&#125;\n\n\n在 index.html 文件所在的路徑下打開 cmd 指令控制符，輸入：\n\n1234567//單文件轉換指令sass .\\scss\\all.scss:.\\css\\all.css// 或sass .\\scss\\all.scss .\\css\\all.css\n\n表示把名字為 all.scss 轉換成名字為 all.css 的文件。回車後，接下來發現就得到了 css 的文件。\n\n\n\n\n\n\n\n\n\n\n使用 : 編譯輸出時，前後不能有空格，即 : 前緊跟輸入的 scss 文件，: 後緊跟輸出的 css 文件。\n\n\n\n\n\n\n\n\n\n: 冒號形式的指令，常用於編譯文件夾（中的所有 sass 文件）的輸入輸出。\n​ css 文件內容如下，可以看出轉換好了：\n123456789101112 project/ │+├─── css/+│   │+│   ├─── all.css+│   └─── all.css.map │ ├─── scss/ │   │ │   └─── all.scss │ └─── index.html\n\n​ \n3.4 透過監聽進行自動編譯\n但是不可能說寫一句.scss 語句就轉換一次，太麻煩，所以可以透過監聽進行自動轉換\n\n當我在all.scss 裏寫一句，all.css 就自動生成一句。在 cmd 輸入以下：\n1sass  --watch .\\scss\\all.scss .\\css\\all.css\n\n表示監視變化，當 input.scss 一變化，output.css 就變化\n空格和冒號對應生成 css 的兩中模式，如果是一對一模式（一個 scss 生成一個 css），使用空格即可；如果是多對多模式，比如一個文件夾生成到另一個文件夾，同時一次性有多個 scss 文件生成 css 文件等。\n1234## 編譯 light.scss 和 dark.scss 到 light.css 和 dark.css.&gt; sass light.scss:light.css dark.scss:dark.csssass  --watch  fileFolder:outputFolder/css\n\n當名字為fileFolder這個文件夾裏任意一個.scss 後綴的文件變化時，就將其編譯到名字outputFolder/css這個文件夾裡面（會自動生成相應的.css 文件）\n3.5 HTML 裏用 &lt; link &gt;標簽把 css 文件引入就行。12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;!-- 要引入css的才能使用 --&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;css/all.css&quot; /&gt;    &lt;title&gt;測試sass/scss&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1 class=&quot;text-primary&quot;&gt;Hello World!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n\n4.Sass 文件編譯快覽4.1 指令行編譯配置選項可以通過 sass -h 或 sass --help 查看詳細配置項。\n配置選項可以指定編譯後的 css 的排版、是否生成調試 map、開啓 debug 等，最常用的是 --style 和 --sourcemap。\n4.2 --watch監聽文件變化sass 使用--watch選項，用於監聽 scss 文件的變化。這樣，當 scss 文件內容有改動時，會自動編譯為 css。\n\n監聽單個 scss 文件\n\n1sass  --watch .\\scss\\all.scss .\\css\\all.css\n\n\n監聽 scss 文件夾\n\n123sass --watch .\\scssdir\\ .\\cssdir\\sass --watch scssdir:cssdir\n\n可以看到，使用 : 可以指定輸出的路徑（文件夾），否則 css 將預設生成在源 scss 文件所在目錄中。\n\n結合 --style 監聽\n\n1sass --watch app/sass:public/stylesheets --style=compressed\n\n\n\n\n\n\n\n\n\n\n使用壓縮（compressed）的樣式（style）輸出 css 文件\n4.3 --style指定 css 的樣式--style 的 css 格式有兩種：expanded（預設）、compressed。\n\n\n\n\n\n\n\n\n\n舊版本的 Ruby 實現中有四種樣式，還有nested、compact。\n12// 指定編譯格式sass input.scss:output.css --style=expanded\n\n比如，一個 scss 文件如下：\n12345678.box &#123;  width: 300px;  height: 400px;  &amp;-title &#123;    height: 30px;    line-height: 30px;  &#125;&#125;\n\n下面，可以查看expanded、compressed編譯後的 css 格式。\n\nexpanded ：預設值，未壓縮的展開的 css 格式\n\n每個選擇器和聲明單獨一行。\n執行如下指令編譯：\n123sass styletest.scss styletest.css --style=expanded## 或 sass styletest.scss styletest.css\n\nexpanded 編譯過後的樣式，是標準的沒有經過任何壓縮，全部字符展開的 css 格式：\n12345678.box &#123;  width: 300px;  height: 400px;&#125;.box-title &#123;  height: 30px;  line-height: 30px;&#125;\n\n\ncompressed 去除所有的空白字符，全部 css 內容壓縮為一行\n\n生産環境中推薦的 css 格式。\n執行如下指令編譯，將 css 結果輸出在指令行中：\n123sass --style=compressed styletest.scss.box&#123;width:300px;height:400px&#125;.box-title&#123;height:30px;line-height:30px&#125;\n\n5.使用 VSCode 插件編譯5.1 基本使用live sass compiler 是 VSCode 擴展，可以實時地將 SASS &#x2F; SCSS 文件編譯&#x2F;轉換為 CSS 文件。\n\n可以自動加入 css 相容性前綴，-webkit-，-moz-，-ms，-o-等。\n可以自定義 css 文件解析後的代碼樣式（expanded 展開，compact，compressed 壓縮，nested）。\n可自定義編譯&#x2F;轉換後的文件擴展名（.css 或.min.css）。\n\n1.在 vscode 插件裏搜索 live sass compiler 安裝。\n2.安裝後，新建 scss 文件，在 vscode 底部狀態欄中點選 watch sass，此時狀態為 Watching ，即可自動解析 sass 為 css 文件。\n\n5.2 自定義設定在使用 live sass compiler 插件時，並不是所有的預設設定都如我們所願，那麼，我們來看一下如何自定義設定。\n1.編譯&#x2F;轉換後的文件格式、擴展名、儲存位置\n\n文件格式格式可以是 expanded，compact，compressed 或 nested。預設值為 expanded。\n擴展名擴展名可以是.css 或.min.css。預設值為.css。\n儲存位置預設的轉換後的 css 文件儲存在 scss 文件的同級目錄下，但實際，我們通常需要把所有 scss 文件儲存在 scss 文件夾，而 css 文件希望儲存在 css 的文件夾，如圖所示：\n\n​ 我們在配置中如下設定：\n1234567&quot;liveSassCompile.settings.formats&quot;: [  &#123;    &quot;format&quot;: &quot;expanded&quot;,    &quot;extensionName&quot;: &quot;.css&quot;,    &quot;savePath&quot;: &quot;~/../css/&quot;  &#125;]\n\nsavePath 即為匯出後的文件儲存位置。\n2.去掉編譯時出現的 css.map 文件在每個文件編譯後，預設設定下，會同時出現一個 map 格式的文件，有時並不需要該文件，那麼我們如何去掉呢？\n1&quot;liveSassCompile.settings.generateMap&quot;: false,\n\n預設值為 true，我們設定為 false 即可。\n3.設定 css 相容性前綴live sass compiler 可以在編譯時自動加入 CSS 相容性前綴（-webkit-，-moz-，-ms，-o-等），如下設定：\n1234&quot;liveSassCompile.settings.autoprefix&quot;: [  &quot;&gt; 1%&quot;,  &quot;last 3 versions&quot;],\n\n其中，\n\n“&gt;1%”是指 通過全球使用情況統計資訊選擇出的高於 1%使用率的瀏覽器版本。\n“last 3 versions”是指 每個瀏覽器的最後 3 個版本。\n\n這裏也可以設定為具體的瀏覽器，如下：\n123456&quot;liveSassCompile.settings.autoprefix&quot;: [  &quot;ie &gt;= 6&quot;,  //ie6以上  &quot;firefox &gt;= 8&quot;,  &quot;chrome &gt;= 24&quot;,  &quot;Opera&gt;=10&quot;],\n\n總結\n個人配置：\n123456789101112131415161718&quot;liveSassCompile.settings.generateMap&quot;: true,&quot;liveSassCompile.settings.autoprefix&quot;: [  &quot;ie &gt;= 6&quot;,  //ie6以上  &quot;firefox &gt;= 8&quot;,  &quot;chrome &gt;= 24&quot;,  &quot;Opera&gt;=10&quot;],&quot;liveSassCompile.settings.excludeList&quot;: [  &quot;**/node_modules/**&quot;,  &quot;.vscode/**&quot;],&quot;liveSassCompile.settings.formats&quot;: [  &#123;    &quot;format&quot;: &quot;expanded&quot;,    &quot;extensionName&quot;: &quot;.css&quot;,    &quot;savePath&quot;: &quot;~/../css/&quot;  &#125;,      &quot;liveSassCompile.settings.showOutputWindow&quot;: true]\n\n\n\n\n\n\n\n\n\n\n123456789壓縮生成min.css文件&quot;liveSassCompile.settings.formats&quot;: [    // More Complex    &#123;        &quot;format&quot;: &quot;compressed&quot;,        &quot;extensionName&quot;: &quot;.min.css&quot;,        &quot;savePath&quot;: &quot;~/../css/&quot;    &#125; ]\n\n\n\n\n\n\n\n\n\n感覺總體作用不大，還是結合 webpack 等工具，實時更新頁面內容時，實時編譯 scss，而不需要單獨使用該工具。\n6.使用 webpack 編譯在目前主流的前端項目中，一般是使用 Webpack 來建構我們的前端項目，並且大多數都跑在 Node 環境下。\n行如下指令安裝 sass-loader ：\n123npm install mini-css-extract-plugin -Dnpm install css-loader -Dnpm install sass-loader --save-dev\n\nwebpack.config.js\n123456789101112131415161718192021222324module.exports = &#123;  ...  module: &#123;    rules: [      &#123;        test: /\\.s[ac]ss$/i,        use: [          &#x27;[MiniCssExtractPlugin.loader&#x27;,          // 將 css 文件整合到 js 文件中          &#x27;css-loader&#x27;,          // 編譯 sass 文件為 css 文件          &#x27;sass-loader&#x27;        ]      &#125;    ]  &#125;,    plugins: [    // 提取css成單獨文件    new MiniCssExtractPlugin(&#123;      // 定義輸出文件名和目錄      filename: &quot;static/css/[name].css&quot;,    &#125;),    ]&#125;\n","slug":"SASS01 【Sass的安装使用】","date":"2024-02-06T05:12:05.000Z","categories_index":"Sass/SCSS","tags_index":"桃園資展筆記,Sass/SCSS","author_index":"Hsu's Blog"},{"id":"226913a9ccc4a580478e5d60de981fd1","title":"240126React零碎知識點","content":"渲染（Rendering）在軟體開發和電腦圖形領域中，”渲染” 指的是將資料或程式碼轉換為可視化的形式或格式的過程。在不同的上下文中，”渲染” 的含義可能有所不同。\n\n**瀏覽器中的渲染引擎(Rendering Engine)**：瀏覽器的渲染引擎是負責將網頁的 HTML、CSS 和 JavaScript 等前端資源轉換為使用者能夠閱讀和互動的可視化內容的核心部分。常見的瀏覽器渲染引擎包括 WebKit（Chrome 和 Safari 使用的），Gecko（Firefox 使用的），以及 Trident（舊版的 Internet Explorer 使用的）。\n\n**React 中的渲染(Render)**：在 React 中，”渲染” 是指更新虛擬 DOM 的過程，以及將虛擬 DOM 轉換為真實 DOM 的過程。React 使用虛擬 DOM 來提高效能，當應用的狀態（State）發生變化時，React 會重新渲染虛擬 DOM，然後透過比對虛擬 DOM 和實際 DOM 的變化，最小化更新真實 DOM，從而提高應用的效能。\n\nState 狀態：在 React 應用中，”State” 是指描述應用當前狀態的資料。當 State 發生變化時，React 會重新渲染相應的元件，從而更新應用的 UI。\n\n**CSR (Client-Side Rendering)**：客戶端渲染是指在網頁應用中，所有的渲染運算都在用戶的瀏覽器中完成，而不是在伺服器端完成。這意味著當用戶與應用互動時，不需要每次都向伺服器發送請求，從而提高了應用的效能和反應速度。\n\n\n在開發應用程序時，了解渲染的過程和原理對於優化應用的性能和提高用戶體驗非常重要。\nImmutability 不可改變性在 React 中，所有的狀態（state）都是不可改變的（immutable）。一旦某個值成為狀態後，它的值將無法直接改變。即使是物件的屬性值也要視為被凍結（freeze）或唯讀（read-only）不可改變。任何對狀態的改變都要透過 setState 方法傳入一個全新的值或物件。\n\n在 React 中的應用：React 鼓勵開發者使用不可改變性來管理組件的狀態。這意味著在更新狀態時，應該創建新的物件，而不是直接修改現有的狀態。這樣可以幫助 React 更有效地追蹤和處理組件的變化，並且有助於避免一些意外的行為。\n\n註：immutable 與 unchangeable 同義，都是不可改變的意思。\n註：實際上，對於元件而言，它接收到的 props（屬性）也是不可變的，不過較精確的說法是唯讀（read-only）的純函式（pure function）特性。\nPure Function（純函式）在程式設計中，一個函式如果滿足以下兩個條件，就可以被稱為純函式：\n\n相同的輸入總是產生相同的輸出：函式的執行不依賴於程式的狀態，而是只依賴於輸入參數。\n函式沒有副作用：函式的執行過程中不會修改外部的狀態，也不會產生其他可觀察到的影響，比如修改全域變數或發出網絡請求等。\n\n在 React 中，純函式通常用於渲染 UI 組件和處理資料。\nSide Effect（副作用）副作用是指函式執行過程中，除了返回值之外，還對函式外部的狀態產生了影響的行為。副作用可能包括但不限於：\n\n修改全域變數或外部狀態\n發送網絡請求\n修改 DOM\n改變了參數本身\n\n在 React 開發中，要盡量減少副作用的使用，特別是在純 UI 組件中。這有助於減少代碼的不可預測性，並使程式更容易理解和測試。通常情況下，React 應用程式的狀態和資料流都應該被視為不可改變的，以確保組件的行為是可預測的並且易於管理。\n","slug":"240126React零碎知識點","date":"2024-01-27T11:32:36.000Z","categories_index":"React","tags_index":"資策會上課筆記","author_index":"Hsu's Blog"},{"id":"2c4df57117660657820746cd0823ec89","title":"240125React零碎知識點","content":"在 React 應用程式部署前的檔案和資料夾清理在 React 應用程式的開發過程中，有一些檔案和資料夾是開發時使用的，但在最終的發布版本中並不需要包含。在進行壓縮、打包或部署到生產環境時，建議考慮刪除以下檔案和資料夾：\n1. package-lock.json：package-lock.json 是由 npm 生成的檔案，用來確保在不同開發環境中安裝相同的依賴版本。然而，在生產環境中，通常只需要 package.json 即可，而 package-lock.json 可以在發布時刪除，節省一些空間。\n2. .next：.next 資料夾通常包含由 Next.js 生成的暫存資料和編譯過的代碼。這些文件在開發過程中是有用的，但在生產環境中並不需要。在進行應用程式部署之前，可以考慮刪除 .next 資料夾，以節省空間和確保生產版本的乾淨性。這也包括 .next&#x2F;cache 資料夾，其中包含了部分快取的資料。\n3. node_modules：node_modules 是包含所有專案依賴的資料夾，其中包括開發和測試時使用的套件。在發布時，你通常不需要將這個資料夾部署到生產環境中，因為生產環境中可以通過依賴列表（package.json 和 package-lock.json）重新安裝所需的套件。因此，刪除 node_modules 可以減少最終應用程式的大小。\n\n\n\n\n\n\n\n\n\n在進行部署前，建議先進行一次最終版本的測試，確保應用程式在刪除這些檔案和資料夾後仍然能夠正常運行。\nfalsy（偽值）在 JavaScript 中，falsy（偽值）是指一個被視為布林上下文中為 false 的值。當一個值被視為偽值時，在條件判斷中會被當作 false，而在其他情況下可能被當作 true 或其他值。\n以下是 JavaScript 中被視為偽值的一些情況：\n1234567// false: 明確的布林值false。// 0: 數值零。// 空字串（&#x27;&#x27;）: 包含零個字符的字串。// NaN（Not a Number）: 表示不是一個有效的數字。// null: 表示空值或沒有物件。// undefined: 表示未定義的值。// document.all: 在老舊的瀏覽器中，document.all 在某些情況下被視為偽值。\n\n在條件判斷中，如果值是上述任何一種，則被視為偽值，否則被視為真值（truthy）。當你在條件中使用這些值時，可以利用這種偽值的特性進行簡潔的判斷。\n","slug":"240125React零碎知識點","date":"2024-01-25T12:35:16.000Z","categories_index":"React","tags_index":"資策會上課筆記","author_index":"Hsu's Blog"},{"id":"1e00bbc5a1a969d8b4414c942e9fedc9","title":"ES6 介绍","content":"03【解構賦值(Destructuring Assignment)】將陣列或物件中的資料解開擷取成為獨立變數。\n語法12345678910111213141516171819let a, b, rest;[a, b] = [10, 20];console.log(a); // 10console.log(b); // 20[a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50](&#123; a, b &#125; = &#123; a: 10, b: 20 &#125;);console.log(a); // 10console.log(b); // 20// Stage 4(finished) proposal(&#123; a, b, ...rest &#125; = &#123; a: 10, b: 20, c: 30, d: 40 &#125;);console.log(a); // 10console.log(b); // 20console.log(rest); // &#123;c: 30, d: 40&#125;\n\n\n\n\n\n\n\n\n\n\ndestructuring: 變性、破壞性。使⽤”解構”是對照de-字頭有”脫離”、”去除”的意思。assignment: 賦值、指定。賦值通常指的是程式中使⽤等號(&#x3D;)運算符的語句。\n1.陣列的解構賦值1.1 原理ES6 中的解構（Destructuring）語法允許從數組和物件中提取值，並將其賦給變量，這樣的賦值方式更加簡潔和靈活。\n以前，為變量賦值，只能直接指定值。\n123let a = 1;let b = 2;let c = 3;\n\nES6 允許寫成下面這樣。\n1let [a, b, c] = [1, 2, 3];\n\n上面代碼表示，可以從陣列中提取值，按照對應位置，對變量賦值。\n\n模式（結構）匹配 [] = [1, 2, 3];，其中方括號內的模式和賦值的陣列結構相符。\n\n索引值相同的完成賦值 const [a, b, c] = [1, 2, 3];\n\n舉例\n12const [a, [, , b], c] = [1, [2, 3, 4], 5];console.log(a, b, c); // 1 4 5\n\na被賦值為數組的第一個元素，b被賦值為巢狀數組的第三個元素，c被賦值為數組的最後一個元素。\n\n\n1.2 陣列解構賦值的預設值（1）預設值的基本用法\n123456const [a, b] = [];console.log(a, b); // undefined undefined// ---------------------------------------const [a = 1, b = 2] = [];console.log(a, b); // 1 2\n\n（2）預設值的生效條件\n只有當一個陣列成員嚴格等於 (&#x3D;&#x3D;&#x3D;) undefined 時，對應的預設值才會生效。\n1234const [a = 1, b = 2] = [3, 0]; // 3 0const [a = 1, b = 2] = [3, null]; // 3 nullconst [a = 1, b = 2] = [3, undefined]; // 3 2const [a = 1, b = 2] = [3]; // 3 2\n\n\n解構賦值 MDN 文檔\n\n（3）預設值表達式\n如果預設值是表達式，預設值表達式是延遲求值的（即：當無需用到預設值時，表達式是不會求值的）\n123456const func = () =&gt; &#123;  return 24;&#125;;const [a = func()] = [1]; // 1const [b = func()] = []; // 24\n\n1.3 陣列解構賦值的應用（1）交換變量的值\n12345678910let a = 1;let b = 3;[a, b] = [b, a];console.log(a); // 3console.log(b); // 1const arr = [1, 2, 3];[arr[2], arr[1]] = [arr[1], arr[2]];console.log(arr); // [1,3,2]\n\n（2）解析自函式回傳的陣列\n12345678function f() &#123;  return [1, 2];&#125;let a, b;[a, b] = f();console.log(a); // 1console.log(b); // 2\n\n（3）忽略某些回傳值\n在解構陣列時，可以忽略不需要解構的值，可以使用逗號對解構的陣列進行忽略操作，這樣就不需要聲明更多的變量去存值了：\n1234567function f() &#123;  return [1, 2, 2, 3];&#125;const [a, , , b] = f();console.log(a); // 1console.log(b); // 3\n\n\n上面的例子中，在 a、b 中間用逗號隔開了兩個值，這裏怎麼判斷間隔幾個值呢，可以看出逗號之間組成了多少間隔，就是間隔了多少個值。如果取值很少的情況下可以使用下標索引的方式來獲取值。\n\n也可以忽略全部回傳值\n1[, ,] = f();\n\n（4）剩餘參數中的使用\n通常情況下，需要把剩餘的陣列項作為一個單獨的陣列，這個時候我們可以借助展開語法把剩下的陣列中的值，作為一個單獨的陣列，如下：\n1234var [a, b, ...rest] = [10, 20, 30, 40, 50];console.log(a); // 10console.log(b); // 20console.log(rest); // [30, 40, 50]\n\n在 rest 的後面不能有 逗號 不然會報錯，程序會認出你後面還有值。\n\n\n\n\n\n\n\n\n\n[非常重要!]...rest 是剩餘參數的解構，所以只能放在陣列的最後，在它之後不能再有變量，否則則會報錯。\n不要跟展開運算符混在一起，要記清楚目前在做哪個\n123var rest = [10, 20, 30, 40, 50];rest = [...rest, 60];console.log(rest); // [10, 20, 30, 40, 50, 60]\n（5）從正則運算式的比對結果取值\n1234567891011121314function parseProtocol(url) &#123;  const parsedURL = /^(\\w+)\\:\\/\\/([^\\/]+)\\/(.*)$/.exec(url);  if (!parsedURL) &#123;    return false;  &#125;  console.log(parsedURL); // [&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;, &quot;https&quot;, &quot;developer.mozilla.org&quot;, &quot;en-US/Web/JavaScript&quot;]  const [, protocol, fullhost, fullpath] = parsedURL;  return protocol;&#125;console.log(  parseProtocol(&quot;https://developer.mozilla.org/en-US/Web/JavaScript&quot;)); // &quot;https&quot;\n\n（補充）arguments\n\n\n\n\n\n\n\n\n\narguments 物件是一個對應傳入函式之引數的類陣列（Array-like）物件。\n12345function func() &#123;  const [a, b] = arguments;  console.log(a, b); // 1 2&#125;func(1, 2);\n\n\n擴展閱讀-Array-like\n\n（補充）NodeList\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;NodeList&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;p&gt;1&lt;/p&gt;    &lt;p&gt;2&lt;/p&gt;    &lt;p&gt;3&lt;/p&gt;    &lt;script&gt;      const [p1, p2, p3] = document.querySelectorAll(&quot;p&quot;);      console.log(p1, p2, p3);      /*    &lt;p&gt;1&lt;/p&gt;    &lt;p&gt;2&lt;/p&gt;    &lt;p&gt;3&lt;/p&gt;    */    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n\n1.4 必須要分號的兩種情況\n立即執行函式\n\n1234// 加上分號可以避免可能的錯誤，或者，在函式定義之前加上分號，以避免這種情況。(function () &#123;  // 函式內容&#125;)();\n\n\n使用陣列解構的時候\n\n1234567891011// const arr = [1, 2, 3]const str = &quot;pink&quot;;[1, 2, 3].map(function (item) &#123;  console.log(item);&#125;);let a = 1;let b = 2;[b, a] = [a, b];console.log(a, b);\n\n2.物件的解構賦值2.1 原理物件的解構和陣列基本類似，物件解構的變量是在 &#123;&#125; 中定義的。物件沒有索引，但物件有更明確的鍵，通過鍵可以很方便地去物件中取值。在 ES6 之前直接使用鍵取值已經很方便了：\n123const obj = &#123; name: &quot;imooc&quot;, age: 7 &#125;;const name = obj.name; // imoocconst age = obj.age; // 7\n\n但是在 ES6 中通過解構的方式，更加簡潔地對取值做了簡化，不需要通過點操作增加額外的取值操作。\n12const obj = &#123; name: &quot;imooc&quot;, age: 7 &#125;;const &#123; name, age &#125; = obj; // name: imooc, age: 7\n\n在 &#123;&#125; 直接聲明 name 和 age 用逗號隔開即可得到目標物件上的值，完成聲明賦值操作。\n\n模式（結構）匹配 &#123;&#125; = &#123;&#125;;\n屬性名相同的完成賦值 const &#123;name, age&#125; = &#123;name: &#39;jerry&#39;, age: 18&#125;; 或 const &#123;age, name&#125; = &#123;name: &#39;jerry&#39;, age: 18&#125;;\n\n2.2 物件解構賦值的預設值\n物件的屬性值嚴格等於 undefined 時，對應的預設值才會生效。\n\n如果預設值是表達式，預設值表達式是惰性求值的。\n\n\n物件的預設值和陣列的預設值一樣，只能通過嚴格相等運算子（&#x3D;&#x3D;&#x3D;）來進行判斷，只有當一個物件的屬性值嚴格等於 undefined，預設值才會生效。\n123var &#123; a = 10, b = 5 &#125; = &#123; a: 3 &#125;; // a = 3, b = 5var &#123; a = 10, b = 5 &#125; = &#123; a: 3, b: undefined &#125;; // a = 3, b = 5var &#123; a = 10, b = 5 &#125; = &#123; a: 3, b: null &#125;; // a = 3, b = null\n\n所以這裏的第二項 b 的值是預設值，第三項的 null === undefined 的值為 false，所以 b 的值為 null。\n2.3 重命名屬性在物件解構出來的變量不是我們想要的變量命名，這時我們需要對它進行重命名。\n1234const &#123; a: aa = 10, b: bb = 5 &#125; = &#123; a: 3 &#125;;console.log(aa); // 3console.log(bb); // 5\n\n這裏把 a 和 b 的變量名重新命名為 aa 和 bb。\n2.4 物件解構賦值的應用（1）物件作為函式參數12345678910111213141516171819const user = &#123;  id: 42,  displayName: &quot;jdoe&quot;,  fullName: &#123;    firstName: &quot;John&quot;,    lastName: &quot;Doe&quot;,  &#125;,&#125;;function userId(&#123; id &#125;) &#123;  return id;&#125;function whois(&#123; displayName, fullName: &#123; firstName: name &#125; &#125;) &#123;  return `$&#123;displayName&#125; is $&#123;name&#125;`;&#125;console.log(userId(user)); // 42console.log(whois(user)); // &quot;jdoe is John&quot;\n\n（2）物件作為函式參數12345678910111213function drawChart(&#123;  size = &quot;big&quot;,  coords = &#123; x: 0, y: 0 &#125;,  radius = 25,&#125; = &#123;&#125;) &#123;  console.log(size, coords, radius);  // do some chart drawing&#125;drawChart(&#123;  coords: &#123; x: 18, y: 30 &#125;,  radius: 30,&#125;);\n\n\n\n\n\n\n\n\n\n備註： 在上述函式 drawChart 中，左方之解構式被指派到一個空物件: {size &#x3D; ‘big’, coords &#x3D; {x: 0, y: 0}, radius &#x3D; 25} &#x3D; {} 。你也可以略過填寫右方的指派式。不過，當你沒有使用右方指派式時，函式在呼叫時會找出最少一個參數。透過上述形式，你可以直接不使用參數的呼叫 drawChart() 。當你希望在呼叫這個函式時不傳送參數，這個設計會帶來方便。而另一個設計則能讓你確保函式必須傳上一個物件作為參數。\n[補充]設定函式參數的預設值123456789101112131415161718192021222324252627282930313233343536373839const obj = &#123;  x: 1,  y: [2, 3, 4],  z: &#123;    a: 5,    b: 6,  &#125;,&#125;;// ----------------------------------------------------const &#123; x, y, z &#125; = obj;console.log(x, y, z); // 1 [ 2, 3, 4 ] &#123; a: 5, b: 6 &#125;// ----------------------------------------------------const &#123;  y: [, y2],&#125; = obj;console.log(y2); // 3console.log(y); // 報錯// ----------------------------------------------------const &#123;  y: y,  y: [, y2],&#125; = obj;console.log(y2); // 3console.log(y); // [ 2, 3, 4 ]// ----------------------------------------------------const &#123;  y,  y: [, y2],  z,  z: &#123; b &#125;,&#125; = obj;console.log(y2); // 3console.log(y); // [ 2, 3, 4 ]console.log(z); // &#123; a: 5, b: 6 &#125;console.log(b); // 6\n\n（3）剩餘參數中的使用在物件的解構中也可以使用剩餘參數，對物件中沒有解構的剩餘屬性做聚合操作，生成一個新的物件。\n1234var &#123; a, c, ...rest &#125; = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;console.log(a); // 1console.log(c); // 3console.log(rest); // &#123; b: 2, d: 4 &#125;\n\n物件中的 b、d 沒有被解構，通過剩餘參數語法把沒有解構的物件屬性聚合到一起形成新的物件。\n2.5 注意點（1）如果要將一個已經聲明的變量用於解構賦值，必須非常小心。\n1234// 錯誤的寫法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error\n\n上面代碼的寫法會報錯，因為 JavaScript 引擎會將&#123;x&#125;理解成一個代碼區塊，從而發生語法錯誤。只有不將大括號寫在行首，避免 JavaScript 將其解釋為代碼區塊，才能解決這個問題。\n123// 正確的寫法let x;(&#123; x &#125; = &#123; x: 1 &#125;);\n\n上面代碼將整個解構賦值語句，放在一個圓括號裡面，就可以正確執行。關於圓括號與解構賦值的關係，參見下文。\n（2）解構賦值允許等號左邊的模式之中，不放置任何變量名。因此，可以寫出非常古怪的賦值表達式。\n123(&#123;&#125; = [true, false]);(&#123;&#125; = &quot;abc&quot;);(&#123;&#125; = []);\n\n上面的表達式雖然毫無意義，但是語法是合法的，可以執行。\n（3）由於陣列本質是特殊的物件，因此可以對陣列進行物件屬性的解構。\n1234let arr = [1, 2, 3];let &#123; 0: first, [arr.length - 1]: last &#125; = arr;first; // 1last; // 3\n\n上面代碼對陣列進行物件解構。陣列arr的0鍵對應的值是1，[arr.length - 1]就是2鍵，對應的值是3。\n3.字符串的解構賦值既可以用陣列的形式來解構賦值，也可以用物件的形式來解構賦值。\n1234567// 陣列形式解構賦值const [a, b, , , c] = &quot;hello&quot;;console.log(a, b, c); // h e o// 物件形式解構賦值const &#123; 0: a, 1: b, 4: o, length &#125; = &quot;hello&quot;;console.log(a, b, o, length); // h e o 5\n\n4.數值和布爾值的解構賦值只能按照物件的形式來解構賦值。\n（會先自動將等號右邊的值轉為物件）\n12345678910111213// 先來複習一下將數值和布爾值轉化為物件console.log(new Number(123)); // [Number: 123]console.log(new Boolean(true)); // [Boolean: true]// 轉化後的物件裏沒有任何的屬性（沒有 123 這個屬性，也沒有 true 這個屬性）和方法，// 所有的屬性和方法都在它的繼承 __proto__ 中，比如 toString 方法就是繼承來的。// 裡面的值只能是預設值，繼承的方法倒是可以取到const &#123; a = 1, toString &#125; = 123;console.log(a, toString); // 1 [Function: toString]// 裡面的值只能是預設值，繼承的方法倒是可以取到const &#123; b = 1, toString &#125; = true;console.log(b, toString); // 1 [Function: toString]\n\n\n\n\n\n\n\n\n\n\n以上展示了將數值和布爾值轉化為物件後，使用解構賦值的過程。需要注意的是，這種操作雖然能夠實現，但通常情況下並不常見，因為它沒有太大的實用意義。\n5.undefined 和 null 沒有解構賦值由於 undefined 和 null 無法轉為物件，所以對它們進行解構賦值，都會報錯。\n6.小結本節講解了 ES6 解構賦值的使用方法，總結下來一共有以下幾點：\n\n解構賦值一般針對物件和陣列，如果解構物件是 undefined 或是 null 都會報錯；\n預設值的生效條件是，只有當解構的物件的值是嚴格模式下的 undefined 的情況下，預設值才會生效；\n可以不借助中間變量來交換兩個值；\n在解構複雜的資料解構時，注意聲明的物件要和目標的物件有著相同的解構形式，才能去解構目標物件。\n\n","slug":"ES603【解構賦值(Destructuring Assignment)】","date":"2024-01-25T11:06:25.000Z","categories_index":"ES6","tags_index":"桃園資展筆記,ES6","author_index":"Hsu's Blog"},{"id":"60ae19ae3fed7b17d85b4bb42c8c860e","title":"React入門","content":"01 【react 入門】1. React 簡介Facebook 於 2013 年發表了 React。在發表當時 Facebook 內部早已使用 React 解決許多內部問題。技術上來說 React 並不是框架，而是一個用來渲染 UI 組件的函式庫。React 通常會配合其他函式庫來建立應用程式：例如 React 搭配 React Native 建立手機程式、React 與 ReactDOM 建立網路程式…等等。\n由於 React 與 ReactDOM 通常會搭在一起用，React 在通俗上會被理解為 JavaScript 框架。\n\n\n\n\n\n\n\n\n\n框架是個針對軟體構建，提供完整解決方案的函式庫。這些選項能讓應用程式，開始能預測和同質化。可預測性讓軟體能擴展到巨大的規模時依舊能維護；可預測性和可維護性則對軟體的健康和長壽至關重要。\n\n\n\n\n\n\n\n\n\nVue 是一個流行的 JavaScript 框架，由中國團隊維護和開發。然而，在台灣的公家單位中，可能出於安全性或政治等因素，不願意或不被允許使用來自中國的技術產品。\n1.1 react 是什麼？React 用來實作使用者操作介面的 JavaScript 函式庫 ~ reactjs.org。\nReact 用於網站或原生使用者操作介面的函式庫 ~ react.dev\n\n是一個將資料渲染為 HTML 視圖的開源 JS 庫\n它遵循基於元件的方法，有助於建構可重用的 UI 元件\n它用於開發複雜的互動式的 web 和移動 UI\n\n1.2 React 是什麼 (what is)\n由 Meta(Facebook) 創造與維護\n最早對外發佈於 2013 年，目前為 v18(2022&#x2F;3)\nReact 通常指的是瀏覽器端的網頁應用程式以 CSR 與 SPA 技術來開發\n可延伸至伺服器端的 SSR&#x2F;SSG 技術(Next)\n可延伸至手機 App 開發(React Native)\n開放原始碼授權(MIT)\n\n\n\n\n\n\n\n\n\n\nReact 不是完整的程式框架(Framework)，相當於軟體 MVC 設計模式的 View(視圖)\n1.3 React 五大特點◎ Photo by iSpan\n\n**Virtual DOM(虛擬 DOM)**：React 使用虛擬 DOM 來代表真實 DOM，提高了應用程序的性能。\n單向資料流：React 採用單向資料流，從父組件向子組件傳遞資料，使程式易於除錯和最佳化。\n宣告式程式開發：React 使用類似 HTML 的語法來撰寫元件，處理 DOM 事件，使程式易於維護與除錯。\n以元件為基礎：React 以元件為基礎，使用類別或函式來開發，並組合它們以拆分功能和介面。\nJSX：JSX 是 JavaScript 的語法擴充，用於建立虛擬 DOM，允許在 JavaScript 中嵌入類似 HTML 的標記。\n\n1.4 React Ecosystem(生態圈)\n\n\n分類\n工具&#x2F;庫\n\n\n\nSSR&#x2F;SSG\nNext\n\n\n\nRemix\n\n\nState Management(狀態管理)\nRedux Toolkit\n\n\n\nZustand\n\n\nStyling(樣式)\nStyled Components\n\n\n\nEmotion\n\n\n\nCSS Modules\n\n\n\nTailwind (整合)\n\n\nUI libraries(UI 庫)\nMUI\n\n\n\nAnt Design\n\n\n\nChakra UI\n\n\n\nReact Bootstrap (整合)\n\n\nMobile(行動裝置)\nReact Native\n\n\n為什麼學？\n1.原生 JS 操作 DOM 繁瑣，效率低\n2.使用 JS 直接操作 DOM,瀏覽器會進行大量的重繪重排\n3.原生 JS 沒有元件化編碼方案，代碼複用低\n\n\n\n\n\n\n\n\n\n前置工作~ 了解 npm 的知識：\nnpm\n2. React 基礎案例3. 虛擬 DOM（Virtual DOM）虛擬 DOM 是 React 中的一個核心概念，它在記憶體中構建了一個樹狀結構，用來表示真實 DOM 的抽象。React 使用虛擬 DOM 以最小化對實際 DOM 的操作，從而提高應用程式的性能和效能。\n工作原理\n構建虛擬 DOM： 當 React 應用程式進行渲染時，首先構建一個虛擬 DOM，這是一個 JavaScript 物件，包含整個應用程式的 UI 結構和狀態。虛擬 DOM 的構建基於 React 元件的層次結構。\n\n狀態變更引發更新： 當應用程式的狀態發生變化時，React 重新構建虛擬 DOM。新的虛擬 DOM 與之前的進行比較，找出變化的部分。\n\n虛擬 DOM 的比較： React 使用「調和（Reconciliation）」演算法，比較新的虛擬 DOM 與之前的虛擬 DOM，找出差異。這個比較是高效的，因為虛擬 DOM 是輕量級的，存在於記憶體中。\n\n\n◎ Photo by iSpan\n\n差異更新： React 計算出虛擬 DOM 的變化部分，僅更新這些部分，而不是整個真實 DOM。這節省計算資源，提高性能。\n\n產生真實 DOM 操作： 根據虛擬 DOM 的變化，React 生成對應的真實 DOM 操作，例如新增、更新或刪除元素。\n\n應用變化： React 將這些真實 DOM 操作應用到實際 DOM 上，保持 UI 與應用程式狀態同步。\n\n\n優勢\n性能優化： 透過最小化對實際 DOM 的直接操作，減少瀏覽器的重新繪製次數，提高應用程式性能。\n\n開發效率： React 開發者無需手動處理 DOM 操作，專注於應用程式狀態和 UI 邏輯，React 會自動優化和管理 DOM 更新過程。\n\n\n\n\n\n\n\n\n\n\n\n總的來說，虛擬 DOM 是 React 實現高效且快速 UI 更新的核心機制之一。\n4. 單向資料流程（One-Way Data Flow）單向資料流程是一種軟體設計模式，其中資料在應用程式中的流動方向是單一且明確的。這種模式通常應用在使用者介面（UI）的開發中，特別是在 React 等前端框架中。以下是單向資料流程的一些優缺點：\n優點：\n可預測性： 單向資料流程使應用程式的狀態變得可預測，因為資料的流動是單一方向的，不會有雙向綁定可能引起的混亂。\n易於追蹤錯誤： 因為資料流動是單一方向的，當應用程式中發生錯誤時，可以更輕鬆地追蹤錯誤的來源，不需要考慮雙向綁定可能帶來的複雜性。\n可維護性： 單向資料流程使應用程式的結構更清晰，易於維護。開發者更容易理解資料的流動路徑，並進行相應的修改。\n組件化： 單向資料流程通常與組件化的開發風格相結合，每個組件都可以被看作是一個獨立的單位，這使得代碼的重用性更強，也更容易進行單元測試。\n\n缺點：\n複雜性： 對於小型應用程式，單向資料流程可能會帶來一些不必要的複雜性。在某些情況下，雙向綁定可能更加簡單和直觀。\n學習曲線： 對於初學者來說，單向資料流程的學習曲線可能相對較陡峭。理解資料的單向流動可能需要一些時間和實踐。\n冗餘代碼： 在某些情況下，為了實現單向資料流程，可能需要寫更多的冗餘代碼，這可能會增加開發時間和代碼量。\n\n\n\n\n\n\n\n\n\n\n總的來說，單向資料流程在大型應用程式和團隊協作中通常表現得更好，因為它提供了更高的可維護性和可預測性。然而，對於較小的專案或個人開發者來說，可能需要權衡其複雜性和學習成本。\n5. JSX 語法JSX 是 JavaScript 的擴展語法，JSX 使得我們可以以類似於 HTML 的形式去使用 JS。JSX 便是 React 中聲明式程式設計的體現方式，X 有 XML 或 Extension(擴充)之意。\nJSX”不是合法的”符合 ES 標準的程式碼，需要先透過編譯工具(babel)來轉換為 JS 程式碼才能執行。\n12345const element = (  &lt;ul&gt;    &lt;li&gt;item1&lt;/li&gt;  &lt;/ul&gt;);\n\n123456// js (babel轉換後)const element = React.createElement(  &quot;ul&quot;,  null,  React.createElement(&quot;li&quot;, null, &quot;item1&quot;));\n\n聲明式程式設計，簡單理解就是以結果為導向的程式設計。使用 JSX 將我們所期望的網頁結構編寫出來，然後 React 再根據 JSX 自動生成 JS 代碼。所以我們所編寫的 JSX 代碼，最終都會轉換為以執行React.createElement()創建元素的代碼。\n5.1 創建元素與屬性：123456// JSX 允許直接使用類似 HTML 的語法創建 React 元素。const element = &lt;h1&gt;Hello, JSX!&lt;/h1&gt;;// JSX 中可以使用 HTML 一樣的屬性，屬性值可以是字符串或包含 JavaScript 表達式的括號。const imageUrl = &quot;path/to/image.jpg&quot;;const image = &lt;img src=&#123;imageUrl&#125; alt=&quot;An Example&quot; /&gt;;\n\n5.2 僅能返回單一值(單一根元素)：JSX 中的每個返回值必須包裝在一個外層元素中。這是因為 JSX 被視為一個表達式，而表達式僅能返回單一值。\n\n\n\n\n\n\n\n\n\n如果有過多層 div 或其它多餘標記，可能有樣式套用或小幅度效能影響問題。\n\n\n\n\n\n\n\n\n\n但可以包含其他 JSX 元素作為子元素，就像 HTML 一樣。\n1234567891011121314151617181920212223242526// 正確const element = (  &lt;div&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Content&lt;/p&gt;  &lt;/div&gt;);// 正確-[Fragment(片段)]const element = (  &lt;Fragment&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Content&lt;/p&gt;  &lt;/Fragment&gt;);// 正確-[Fragment(簡化片段)（僅在 React 16.2.0 以上版本支援）]const element = (  &lt;&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Content&lt;/p&gt;  &lt;/&gt;);// 錯誤 - 缺少外層包裝元素const invalidElement = &lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content&lt;/p&gt;;\n\n建議儘可能使用內建的 Fragment(片段) 元件。因為當層級多、複雜且分散時，如果有過多層 div 或其它多餘標記，可能有樣式套用或小幅度效能影響問題。&lt;&gt;&lt;/&gt;是&lt;Fragment&gt;&lt;/Fragment&gt;的簡寫法\n5.3 自閉合標籤：對於沒有子元素的標籤，應該使用自閉合的方式，以確保一致性和可讀性。\n\n\n\n\n\n\n\n\n\n⾃我封閉的元素標記，一定要有結尾封閉標籤(&#x2F;&gt;)，因為 JSX 使用的是 XHTML 標準，並非 HTML5 標準。\n1234567891011// 正確&lt;img src=&quot;sample.jpg&quot;/&gt;&lt;input type=&quot;text&quot; name=&quot;myName&quot;/&gt;&lt;br/&gt;&lt;hr/&gt;// 伺服器端(Next)&lt;meta charSet=&quot;utf-8&quot;/&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot;/&gt;// 錯誤 - 不使用自閉合const invalidTag = &lt;img src=&quot;sample.jpg&quot;&gt;&lt;/img&gt;;\n\n5.4 React 元件命名規則根據帕斯卡命名法（PascalCase） ，JSX 中 html 標籤應該小寫，React 組件應該大寫開頭。\n\n如果小寫字母開頭，就將標籤轉化為 html 同名元素，如果 html 中無該標籤對應的元素，就報錯；\n\n如果是大寫字母開頭，react 就去渲染對應的元件，如果沒有就報錯\n\n例如，&lt;h1&gt; 是 HTML 標籤，而 &lt;MyComponent&gt; 是 React 元件。\n\n\n\n\n\n\n\n\n\n在 JSX 中，自訂元件名稱應該使用 camelCase 寫法，這是為了與 HTML 的屬性區分開來。\n\n\n123456789101112131415// 範例&#123; /* 自訂元件 */ &#125;// React 元件，名稱以大寫字母開頭&lt;MyComponent /&gt;&lt;AddToCartButton color=&quot;red&quot; /&gt;&#123; /* 內建HTML元素 */ &#125;// HTML 標籤，名稱以小寫字母開頭&lt;h1&gt;  Text&lt;/h1&gt;&lt;p&gt;  Some text&lt;/p&gt;\n\n屬性名稱亦使用 camelCase：\n12345// 正確const element = &lt;input type=&quot;text&quot; maxLength=&#123;10&#125; /&gt;;// 錯誤 - 使用 kebab-caseconst invalidElement = &lt;input type=&quot;text&quot; max-length=&#123;10&#125; /&gt;;\n\n5.5 元件的事件處理屬性 onXXXX，值必為⼀個函式\n\n\n\n\n\n\n\n\n注意事件屬性是 camelCase(小駝峰)命名。\n1&lt;h1 onClick=&#123;() =&gt; setTotal(total + 1)&#125;&gt;0&lt;/h1&gt;\n\n5.6 使用 className：\n在 JSX 中，指定 HTML 元素的 class 屬性應該使用 className 而非 class。這是因為 class 是 JavaScript 中的保留字。\nlabel 標記的 for 應該使用htmlFor\n\n\n\n\n\n\n\n\n\n\n不改的話，主控台會有警告訊息，並不會影響程式運作。\n12345678// 正確&lt;h1 className=&quot;title&quot;&gt;Text&lt;/h1&gt;&lt;label htmlFor=&quot;emailInput&quot;&gt;Email&lt;/label&gt;// 錯誤 - 使用 class、for&lt;h1 class=&quot;title&quot;&gt;Text&lt;/h1&gt;&lt;label for=&quot;emailInput&quot;&gt;Email&lt;/label&gt;\n\n5.7 標籤中混入 JavaScript 變數、值或表達式的時候必需為物件值在 JSX 中，可以使用 &#123;&#125; 中括號將 JavaScript 值嵌入到 XML 或 HTML 中，方便動態數據的渲染。\n\n\n\n\n\n\n\n\n\n值可以是各種值，物件&#x2F;陣列&#x2F;函式&#x2F;基礎值(字串&#x2F;數字&#x2F;布林值)&#x2F;空(null&#x2F;undefined)\n12const name = &quot;World&quot;;const greeting = &lt;p&gt;Hello, &#123;name&#125;!&lt;/p&gt;;\n\n在 &#123;&#125; 中的表達式中，應該注意不要放置太複雜或長的邏輯，以保持可讀性。若邏輯複雜，建議在外部先定義再引用。\n1234567// 正確const greeting = &lt;p&gt;Hello, &#123;name&#125;!&lt;/p&gt;;// 錯誤 - 過於複雜的邏輯const invalidGreeting = (  &lt;p&gt;&#123;name &amp;&amp; name.length &gt; 0 ? `Hello, $&#123;name&#125;!` : &quot;Hello!&quot;&#125;&lt;/p&gt;);\n\n5.8 布林值,null,undefined，最終不會被渲染呈現\n\n\n\n\n\n\n\n\n僅僅是不渲染呈現，不代表無功能。常用於作各種控制性質的語法。\n布林值(true&#x2F;false),null,undefined，它們都會被轉換為空的 &lt;div&gt; 元素。這是因為在 JSX 中，以下值被視為空值，會被忽略或轉換為空的元素\n12345678&lt;&gt;  &lt;div /&gt;  &lt;div&gt;&lt;/div&gt;  &lt;div&gt;&#123;false&#125;&lt;/div&gt;  &lt;div&gt;&#123;true&#125;&lt;/div&gt;  &lt;div&gt;&#123;null&#125;&lt;/div&gt;  &lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;/&gt;\n\n5.9 style 屬性值必需為物件值，要使用包裹\n\n\n\n\n\n\n\n\n外層{}表示要寫 js 表達式，內層{}表示要寫物件而非陣列\nstyle 值如果使用像原本 HTML 中的字串值，將會產生程式錯誤，所以不能是字串值。建議不要⽤內聯樣式的 style 屬性，改寫為 CSS 類別，用 className 屬性指定，或其它解決方案\n1style=&#123;&#123;color:&#x27;skyblue&#x27;,fontSize:&#x27;24px&#x27;&#125;&#125;\n\n5.10 註釋寫在花括弧裡\n1234567ReactDOM.render(  &lt;div&gt;    &lt;h1&gt;小丞&lt;/h1&gt;    &#123;/*註釋...*/&#125;  &lt;/div&gt;,  document.getElementById(&quot;example&quot;));\n\n5.11 列表渲染：JSX 可以與 JavaScript 中的.map() 函數一起使用，搭配例如&lt;li&gt;、&lt;td&gt;等列表標記，作展開和調整每個項目的渲染應用。JSX 對於陣列值會直接組合為字串(類似array.join(&#39;&#39;))來渲染。\n12345&lt;ul&gt;  &#123;todos.map((value, index) =&gt; &#123;    return &lt;li key=&#123;value.id&#125;&gt;&#123;value.text&#125;&lt;/li&gt;;  &#125;)&#125;&lt;/ul&gt;\n\n\n\n\n\n\n\n\n\n\nkey 是”必要的” React 需要 key 值，在進行列表項目處理(刪除&#x2F;修改&#x2F;新增…)時的最佳化使用，它與效能最佳化、程式運作有極大關聯，不可以省略。\n5.12 條件渲染方式：可以使用 JavaScript 中的條件語句，如 if 或三元運算符，來根據不同條件渲染不同的 JSX 內容。\n使⽤邏輯與&amp;&amp;\n\n{判斷條件 &amp;&amp; &lt;A /&gt;}相當於 if 判斷條件 滿足即渲染 &lt;A /&gt;。\n注意語法中判斷條件因會使用falsy判斷，建議要讓判斷條件直接運算出布林值(使用強制轉型(!!)或比較運算子(!&#x3D;&#x3D;,&gt;…))\n\n123456789101112render() &#123;  const count = 0;  return (    &lt;div&gt;      &#123;count &amp;&amp; (        &lt;h1&gt;          Messages: &#123;count&#125;        &lt;/h1&gt;      )&#125;    &lt;/div&gt;  );&#125;\n\n使⽤三元表達式 ? :\n{判斷條件 ? &lt;A /&gt; : &lt;B /&gt;}相當於 if 判斷條件 滿足即渲染&lt;A /&gt; 否則渲染 &lt;B /&gt;。\n1234567&lt;div&gt;  &#123;isLoggedIn ? (    &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;  ) : (    &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;  )&#125;&lt;/div&gt;\n\n\n\n\n\n\n\n\n\n\n總的來說，JSX 提供了一種直觀和方便的語法，使得 React 元件的定義和渲染更加容易，同時保留了 JavaScript 的強大功能。當 React 代碼被編譯時，JSX 最終會被轉換為普通的 JavaScript 對象，並由 React DOM 使用。\n5.13 直接使用 HTML 原始字串在屬性值中不建議使用，它有可能會導致安全性漏洞(XSS)。更多參考官網資料\n123const markup = &#123; __html: &quot;&lt;p&gt;some raw html&lt;/p&gt;&quot; &#125;;return &lt;div dangerouslySetInnerHTML=&#123;markup&#125; /&gt;;\n\n5.14 使用有前後開頭與結尾的元件標記，需要用 props.children 屬性來獲得值\n\n\n\n\n\n\n\n\n注意使用時別搞混，它是元件的屬性之一。\nchildren 屬性值是一個難以確定的(opaque)資料結構，意即可能是值&#x2F;表達式&#x2F;子元件們，它有很多使用上的技巧，通常會是函式庫&#x2F;框架進階開發者使用。\n1234567&lt;&gt;  &lt;MyComponent&gt;&#123;&quot;123&quot;&#125;&lt;/MyComponent&gt;  &lt;MyContainer&gt;    &lt;MyFirstComponent /&gt;    &lt;MySecondComponent /&gt;  &lt;/MyContainer&gt;&lt;/&gt;\n\n\n以函式作為子元件(FaaC 或 FaCC)是另一種進階的語法\n\n！陷阱 Pitfall\n\n\n\n\n\n\n\n\n由於歷史原因， ［　 data-*　］（https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes） 和 ［　 aria-*　］（https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA） 屬性在 HTML 中使用破折號編寫。\n參考資料 &amp; 相關工具reactjs.org:介紹 JSXreact.dev:JSX (中),JSX (英)react.dev:條件渲染(Conditional Rendering)(中)HTML to JSX 線上轉換工具\n[擴展閱讀] “HTML in JS” 和 “CSS in JS”“HTML in JS” 和 “CSS in JS” 是指在 JavaScript 文件中直接嵌入 HTML 和 CSS 的一種開發模式。這種模式通常與一些 JavaScript 框架或庫結合使用，例如 React，Vue，或者一些 CSS-in-JS 的庫（如 Styled Components）。\nHTML in JS：在 React 中，JSX（JavaScript XML）是一種語法擴展，它允許開發者在 JavaScript 文件中直接撰寫類似 XML（或 HTML）的語法。JSX 最終會被編譯成 JavaScript。以下是一個簡單的 React 組件，展示了 HTML 在 JavaScript 文件中的使用：\n123456789101112import React from &quot;react&quot;;const MyComponent = () =&gt; &#123;  return (    &lt;div&gt;      &lt;h1&gt;Hello, JSX!&lt;/h1&gt;      &lt;p&gt;This is an example of HTML in JS using JSX.&lt;/p&gt;    &lt;/div&gt;  );&#125;;export default MyComponent;\n\n這種方式使得 UI 的結構和邏輯能夠更加緊密地結合在一起，方便了組件的定義和維護。\nCSS in JS：“CSS in JS” 是一種將 CSS 代碼嵌入到 JavaScript 文件中的模式。這種方式可以提供一些額外的好處，如範圍作用域（Scoped Styles）和動態生成樣式。以下是使用 Styled Components 库的一個簡單範例：\n12345678910111213141516import styled from &quot;styled-components&quot;;const StyledDiv = styled.div`  background-color: lightblue;  padding: 20px;`;const MyStyledComponent = () =&gt; &#123;  return (    &lt;StyledDiv&gt;      &lt;p&gt;This is a styled component with CSS in JS.&lt;/p&gt;    &lt;/StyledDiv&gt;  );&#125;;export default MyStyledComponent;\n\n這裡，styled.div 是 Styled Components 提供的函數，它接受一個包含 CSS 屬性的模板字符串。這樣的做法使得 CSS 能夠更好地與組件綁定在一起，同時避免了全局命名空間的衝突。\n\n\n\n\n\n\n\n\n\n總的來說，HTML in JS 和 CSS in JS 這兩種模式通過將不同語言的代碼放在同一個文件中，使得代碼的組織和維護更加方便，同時提供了一些額外的特性，如組件級別的樣式和動態生成樣式。\n[擴展閱讀] Accessibility (a11y)“a11y” 是 “accessibility“ 這個單詞的縮寫。它代表著網頁或應用程式的可及性（accessibility）方面，強調讓所有使用者，包括身心障礙者，都能方便地訪問和使用網頁或應用程式。\n透過可及性的設計，我們可以確保所有使用者都能獲得相同的資訊、功能和互動體驗，而不論他們是否有視力、聽力、運動能力或認知能力的障礙。提升可及性不僅是一種道德責任，還能擴大受眾並提升用戶滿意度。\n以下是一些可提升可及性的常見做法：\n\n有意義的 HTML\n\n使用正確的 HTML 標籤，確保文檔結構清晰，並使用標題標籤（&lt;h1&gt;, &lt;h2&gt;, 等等）來組織內容。\n\n\n表單可及性\n\n提供明確的表單標籤，使用標籤（&lt;label&gt;）來關聯表單元素和其標籤，以及提供適當的提示。\n\n\n鍵盤導航\n\n確保所有功能都可以使用鍵盤進行操作，而不僅僅依賴滑鼠。\n\n\n對比度\n\n使用高對比度的色彩，以確保文字和背景之間的區別明顯，有助於視力較差的使用者。\n\n\n無障礙的多媒體內容\n\n提供音訊描述（audio descriptions）和字幕（captions）來支援聽覺或視覺障礙的使用者。\n\n\n焦點可見性\n\n在焦點移動時，確保使用者可以清楚看到焦點所在的位置，這對於使用鍵盤導航的人很重要。\n\n\n動態內容的可訪問性\n\n當有動態內容（例如單頁應用程序）時，確保內容對螢幕助讀器和其他輔助技術可訪問。\n\n\n\n\n\n\n\n\n\n\n\n\n總的來說，”a11y” 的目標是讓所有使用者都能夠平等地獲得和使用網站或應用程式的功能，而不受他們的能力或特殊需求的影響。\n","slug":"REACT01【react入門】","date":"2024-01-25T04:20:05.000Z","categories_index":"React","tags_index":"桃園資展筆記,React","author_index":"Hsu's Blog"},{"id":"6587c0dcefcdc69eda60933087e365f3","title":"240124React零碎知識點","content":"單向資料流程（One-Way Data Flow）單向資料流程是一種軟體設計模式，其中資料在應用程式中的流動方向是單一且明確的。這種模式通常應用在使用者介面（UI）的開發中，特別是在 React 等前端框架中。以下是單向資料流程的一些優缺點：\n優點：\n可預測性： 單向資料流程使應用程式的狀態變得可預測，因為資料的流動是單一方向的，不會有雙向綁定可能引起的混亂。\n\n易於追蹤錯誤： 因為資料流動是單一方向的，當應用程式中發生錯誤時，可以更輕鬆地追蹤錯誤的來源，不需要考慮雙向綁定可能帶來的複雜性。\n\n可維護性： 單向資料流程使應用程式的結構更清晰，易於維護。開發者更容易理解資料的流動路徑，並進行相應的修改。\n\n組件化： 單向資料流程通常與組件化的開發風格相結合，每個組件都可以被看作是一個獨立的單位，這使得代碼的重用性更強，也更容易進行單元測試。\n\n\n缺點：\n複雜性： 對於小型應用程式，單向資料流程可能會帶來一些不必要的複雜性。在某些情況下，雙向綁定可能更加簡單和直觀。\n\n學習曲線： 對於初學者來說，單向資料流程的學習曲線可能相對較陡峭。理解資料的單向流動可能需要一些時間和實踐。\n\n冗餘代碼： 在某些情況下，為了實現單向資料流程，可能需要寫更多的冗餘代碼，這可能會增加開發時間和代碼量。\n\n\n總的來說，單向資料流程在大型應用程式和團隊協作中通常表現得更好，因為它提供了更高的可維護性和可預測性。然而，對於較小的專案或個人開發者來說，可能需要權衡其複雜性和學習成本。\nCreate React App 已經過時Create React App（CRA）是一個用於快速搭建 React 應用程式的工具。然而，由於 React 生態系統的不斷演進，Create React App 也可能會有一些更新或取代的情況。可能的替代方案包括新的 React 工具或其他較新的應用程式脚手架。\n替代方案\nVite： Vite 是一個由 Vue.js 團隊開發的快速、簡單的前端開發工具，同樣支援 React。它以其快速的啟動時間和即時編譯（Hot Module Replacement）而受到關注。\n\nSnowpack： Snowpack 是另一個現代的前端構建工具，以其快速的開發速度和模組化的特點而受到青睞。它也支援 React。\n\nWebpack + React： 如果你喜歡更精細地控制構建過程，你可以手動配置 Webpack，然後集成 React。這需要更多的配置，但可以滿足更特殊的需求。\n\n\nVue 中國團隊開發，在台灣的公家單位不可使用Vue 是一個流行的 JavaScript 框架，由中國團隊維護和開發。然而，在一些台灣的公家單位中，可能出於安全性或政治等因素，不願意或不被允許使用來自中國的技術產品。\n解決方案\nReact 或其他框架： 如果 Vue 不被接受，可以考慮使用 React 或其他前端框架，以滿足台灣公家機構的要求。\n\n技術調查和合規性： 在選擇框架之前，應進行技術調查，確保所選擇的技術符合當地法規和組織的合規性要求。\n\n\n技術渲染方式與優缺點比較CSR (Client-Side Rendering)CSR 技術是指在客戶端透過 JavaScript 等前端技術來渲染網頁內容。當用戶訪問網站時，瀏覽器會下載必要的 HTML、CSS 和 JavaScript 文件，然後在用戶的設備上執行 JavaScript 代碼以生成並渲染網頁。\n優點\n快速的初始載入速度： 由於整個應用程式不需要在伺服器上進行渲染，所以初始載入速度較快。\n動態互動性： 客戶端渲染允許在用戶與應用程序互動時即時更新內容，提供更好的用戶體驗。\n\n缺點\nSEO 不友好： 搜索引擎難以爬取動態生成的內容，對搜索引擎優化(SEO)不利。\n較長的初次載入時間： 需要下載並執行 JavaScript 代碼，因此初次載入時間可能較長。\n對於弱網絡連接不友好： 在弱網絡連接下，客戶端渲染可能導致應用程序運行緩慢。\n\nSSR (Server-Side Rendering)SSR 技術是指在伺服器端生成並渲染網頁內容，然後將整個渲染好的 HTML 送至客戶端。\n優點\nSEO 友好： 由於在伺服器端就生成了完整的 HTML，搜索引擎能夠輕鬆爬取並索引內容。\n較短的初次載入時間： 用戶收到的是伺服器端生成的 HTML，因此初次載入時間較短。\n對弱網絡連接較友好： 伺服器端已經完成了渲染，用戶在接收到 HTML 後即可顯示內容。\n\n缺點\n較差的動態互動性： 由於每次互動都需要向伺服器發送請求重新獲取 HTML，因此動態互動性可能受到限制。\n伺服器壓力增加： 伺服器需要處理更多的渲染工作，可能導致伺服器壓力增加。\n\nSSG (Static Site Generation)SSG 是指在構建時(通常是在部署之前)將所有頁面預先生成為靜態 HTML 文件。這些文件在用戶訪問網站時被提供，而不需要伺服器進行實時渲染。\n優點\n極快的初次載入速度： 所有頁面在構建時都已經生成，因此初次載入速度非常快。\nSEO 友好： 與 SSR 相似，生成的靜態 HTML 對搜索引擎友好。\n簡化伺服器需求： 由於所有內容都是靜態的，不需要伺服器進行實時渲染，減輕了伺服器壓力。\n\n缺點\n較差的動態互動性： 與 SSR 相似，動態互動性可能受到限制，需要透過客戶端 JavaScript 進行。\n\nISR (Incremental Static Regeneration)ISR 是 SSG 的一種擴展，允許在用戶訪問網站時在伺服器端重新生成特定頁面的靜態內容。\n優點\n保持靜態性能優勢： 利用 SSG 的優勢，同時在需要時動態更新特定頁面的內容。\n動態互動性： 與 CSR 相似，能夠提供更好的動態互動性。\n\n缺點\n需要伺服器處理： 重新生成靜態內容仍然需要伺服器處理，可能增加伺服器壓力。\n可能有一些延遲： 如果某些內容需要重新生成，用戶訪問時可能會有一些延遲。\n\n渲染方式比較表格\n\n\n技術方式\nCSR (客戶端渲染)\nSSR (伺服器端渲染)\nSSG (靜態網站生成)\nISR (增量靜態再生)\n\n\n\n初始載入速度\n快速\n較快\n極快\n快速（靜態內容）\n\n\nSEO 友好\n不友好\n友好\n友好\n友好\n\n\n動態互動性\n良好\n較差\n較差\n良好\n\n\n伺服器壓力\n低\n高\n低\n高（特定頁面動態更新時）\n\n\n网络连接友好性\n對弱網絡連接不友好\n對弱網絡連接較友好\n對弱網絡連接較友好\n對弱網絡連接較友好\n\n\n需要伺服器處理\n否\n是\n否\n是（ISR 時）\n\n\n延遲\n初次載入可能較長\n重新獲取 HTML 時可能有延遲\n無\n重新生成時可能有延遲\n\n\n水合作用 (Hydration) 與水合化 (Hydration)水合作用 (Hydration) 是 SSR 中的專有術語，它使用與 React 初始的瀏覽器 DOM 渲染技術相似的方法，但在伺服器端進行。相較於直接將完整的 HTML、CSS 和 JavaScript 文件發送給客戶端，SSR 先將一個已經擁有 HTML DOM 元素的網頁發送給用戶，類似於框架的灰色頁面。接著再載入相對應的 JavaScript 代碼，然後進行**水合化 (Hydration)**。\n水合化 (Hydration) 過程涉及檢查已經載入的 DOM 結構是否與伺服器端生成的結構相符。如果相符，則將相應的事件附加到元素上，使其成為 CSR (Client-Side Rendering) 元件，具有事件監聽和互動性。\n此過程確保了 SSR 的初始載入速度的優勢，同時在客戶端進行水合化，保留了後續的動態互動性。\nNext.js vs Vite vs Create React App (CRA)Next.jsNext.js 是一個 React 框架，提供了許多內建功能，使得 React 應用開發更加簡單。以下是一些 Next.js 的詳細資訊：\n\n服務端渲染 (SSR)： Next.js 支援服務端渲染，提高首次載入速度和優化搜尋引擎優化 (SEO)。\n靜態網站生成 (SSG)： 支援靜態網站生成，可以在構建時生成靜態頁面，提供更快的載入速度。\n動態路由： 允許使用動態路由，輕鬆處理動態生成的頁面。\n水合作用 (Hydration)： 提供了客戶端水合作用，保持了動態互動性。\n\nViteVite 是一個現代化的前端建構工具，專為 Vue 和 React 開發的。以下是一些 Vite 的詳細資訊：\n\n快速的開發伺服器： Vite 使用原生 ES 模塊導入，提供了快速的開發伺服器，支援 HMR (熱模塊替換)。\n即時編譯： Vite 使用即時編譯 (Instant Compilation)，加速開發過程。\nPlugin 系統： 具有豐富的 Plugin 系統，支援許多插件擴充。\n搭建靜態網站： 可以用 Vite 構建靜態網站，提供快速載入和更好的性能。\n\nCreate React App (CRA) 已經被淘汰，官網暫停更新Create React App 是一個由 React 團隊提供的官方建構工具，用於快速啟動 React 應用。以下是一些 CRA 的詳細資訊：\n\n零配置： CRA 提供了零配置的開發環境，無需手動設定 Webpack 或 Babel。\n內建功能： 包含了一些預設配置和一些內建功能，例如快速的開發伺服器和編譯工具。\n易於開始： 適合初學者，可以快速上手 React 開發。\n有限的配置選項： CRA 提供了有限的配置選項，不如其他工具靈活。\n\n比較表格\n\n\n功能&#x2F;特性\nNext.js\nVite\nCreate React App (CRA)\n\n\n\n服務端渲染 (SSR)\n是\n否\n否\n\n\n靜態網站生成 (SSG)\n是\n否\n否\n\n\n快速開發伺服器\n是\n是\n是\n\n\n即時編譯\n否（部分支援）\n是\n是\n\n\nPlugin 系統\n否\n是\n有限的配置選項\n\n\n動態路由\n是\n是\n部分支援（React Router）\n\n\n水合作用 (Hydration)\n是\n部分支援（Vue）\n部分支援（React）\n\n\n這個比較表格列舉了 Next.js、Vite 和 Create React App (CRA) 的一些功能和特性，以便您可以更容易地選擇適合您項目的工具。\nnpm start 與 npm build 補充說明npm startnpm start 是一個常見的指令，通常用於啟動應用程式的開發伺服器。在許多前端框架中，特別是像 React、Angular、Vue 等等，開發者可以使用這個指令來快速啟動本地伺服器，以便在開發過程中即時預覽應用程式的變更。\n具體來說，在 Next.js 中，npm start 可能會啟動一個本地伺服器，用於開發環境的實時預覽。這個伺服器通常會監聽在某個指定的端口，開發者可以通過瀏覽器訪問該端口以查看應用程式。\nnpm buildnpm build 則是一個用於建置應用程式的指令。在前端開發中，建置的過程通常包括將原始碼進行編譯、優化、壓縮等處理，生成最終可在生產環境中運行的代碼。\n在 Next.js 中，npm build 的執行將會生成一個或多個優化過的應用程式檔案，這些檔案通常會存放在一個特定的資料夾中，例如 /.next。這些檔案包含了編譯後的 JavaScript 代碼、CSS 樣式、圖片等資源，可以被部署到生產環境中，以提供最佳的性能和效能。\n簡單來說，npm start 是在開發階段用來啟動本地伺服器的指令，而 npm build 則是用於建置應用程式以準備部署到生產環境。\n12345# 啟動本地伺服器，用於開發預覽npm start# 建置應用程式，生成生產環境可運行的代碼npm run build\n\n使用方式\nnpm start：啟動開發伺服器\n\n打開終端機，移動到專案目錄。\n執行 npm start。\n開發伺服器啟動後，可以在瀏覽器中訪問指定的端口，預覽應用程式，並在開發過程中即時看到變更。\n\n\nnpm build：建置應用程式\n\n打開終端機，移動到專案目錄。\n執行 npm run build。\n建置過程將會生成優化過的應用程式檔案，通常存放在 /.next 資料夾中。\n這些檔案可以被部署到生產環境，以提供更快的載入速度和最佳的效能。\n\n\n\n注意事項\n在開發階段，通常使用 npm start 以便快速預覽和測試應用程式。\n在部署到生產環境之前，應當使用 npm run build 進行建置，確保應用程式的最終版本是經過優化的。\n\n這兩個指令是前端開發中常見的操作，有助於提高開發效率並確保應用程式在生產環境中運行順暢。\nReact 元件命名規則在 React 中，元件的命名有一個重要的規則：元件名稱必須以大寫字母開頭。這是由於 React 使用這種命名約定來區分 DOM 元素和 React 元件。\n為什麼要大寫開頭？\n區分 DOM 元素： React 使用大寫字母開頭的元件名稱，以便在 JSX 中區分 HTML 標籤和 React 元件。例如，&lt;div&gt; 是 HTML 標籤，而 &lt;MyComponent&gt; 是 React 元件。\n\nJSX 語法規定： 在 JSX 語法中，如果標籤名稱以小寫字母開頭，它將視為一個 HTML 標籤，而如果以大寫字母開頭，它則視為一個 React 元件。\n\n\n範例123456789// React 元件，名稱以大寫字母開頭class MyComponent extends React.Component &#123;  render() &#123;    return &lt;div&gt;Hello, I am a React component!&lt;/div&gt;;  &#125;&#125;// HTML 標籤，名稱以小寫字母開頭const myElement = &lt;div&gt;This is a regular HTML element.&lt;/div&gt;;\n\n命名風格React 元件的命名通常使用帕斯卡命名法（PascalCase），即每個單字的首字母都大寫。這有助於清晰地區分 React 元件和其他 JavaScript 變數或函數。\n虛擬 DOM 與真實 DOM 轉換過程虛擬 DOM（Virtual DOM）是 React 中的核心概念，它存在於記憶體中，用以抽象表示真實 DOM。當 React 元件的狀態（State）或屬性（Props）發生變化時，React 會進行以下虛擬 DOM 到真實 DOM 的轉換過程：\n\n虛擬 DOM 構建： 當元件的狀態或屬性發生變化時，React 會重新構建虛擬 DOM。\n\n比較： React 使用一個演算法比較新的虛擬 DOM 與之前的虛擬 DOM，找出變化的部分。這種比較通常是高效的，因為虛擬 DOM 是輕量級的，存在於記憶體中。\n\n差異更新： React 會計算出變化的部分，然後僅更新這些部分，而不是重新渲染整個真實 DOM。這使得更新過程更加高效。\n\n產生真實 DOM 操作： 根據虛擬 DOM 的變化，React 生成對應的真實 DOM 操作，例如新增、更新、或刪除元素。\n\n應用變化： React 通過 DOM Diff 算法計算出的變化，將這些變化應用到真實 DOM 上。\n\n\n這樣的過程保證了 React 在性能上的優勢，因為它只更新真正發生變化的部分，而不是整個 DOM 樹。\n在 React 中，你不需要手動進行虛擬 DOM 到真實 DOM 的轉換操作，React 會自動處理這些細節。你只需關注元件的狀態和 UI 的邏輯，React 會優化並管理 DOM 的更新過程。\nReact 四種最基本的 HooksReact Hooks 解釋React Hooks 是 React 16.8.0 版本引入的一項功能，它提供了在不使用類別（Class）的情況下使用狀態（State）和其他 React 特性的能力。Hooks 讓你在函數型元件中使用 React 的狀態和生命週期方法，從而使代碼更加簡潔且易於理解。\n1. useStateuseState 是用來在函式型元件中添加狀態的 Hook。它返回一個包含目前狀態和更新狀態的陣列。這個 Hook 的基本用法如下：\n123456789101112import React, &#123; useState &#125; from &quot;react&quot;;function ExampleComponent() &#123;  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n2. useEffectuseEffect 是用來在函式型元件中執行副作用操作（例如資料獲取、訂閱、手動修改 DOM）的 Hook。它接收兩個參數，第一個參數是一個函式，第二個參數是一個陣列，用來指定什麼條件下觸發 useEffect。若第二個參數不傳，則每次渲染都會執行 useEffect。\n123456789101112import React, &#123; useEffect, useState &#125; from &quot;react&quot;;function ExampleComponent() &#123;  const [data, setData] = useState(null);  useEffect(() =&gt; &#123;    // 執行副作用操作，例如資料獲取    fetchData();  &#125;, []); // 空陣列表示僅在初次渲染時執行  return &lt;div&gt;&#123;/* 渲染元件內容 */&#125;&lt;/div&gt;;&#125;\n\n3. useContextuseContext 是用來在函式型元件中使用 React 上下文的 Hook。它接收一個上下文對象（使用 React.createContext 創建）並返回上下文的當前值\n12345678import React, &#123; useContext &#125; from &quot;react&quot;;import MyContext from &quot;./MyContext&quot;;function ExampleComponent() &#123;  const contextValue = useContext(MyContext);  return &lt;p&gt;Context Value: &#123;contextValue&#125;&lt;/p&gt;;&#125;\n\n4. useReduceruseReducer 是一個進階的 Hook，用來管理複雜狀態邏輯。它接收一個 reducer 函式和初始狀態，返回一個包含目前狀態和 dispatch 函式的陣列。\n123456789101112131415161718192021222324import React, &#123; useReducer &#125; from &quot;react&quot;;function reducer(state, action) &#123;  switch (action.type) &#123;    case &quot;increment&quot;:      return &#123; count: state.count + 1 &#125;;    case &quot;decrement&quot;:      return &#123; count: state.count - 1 &#125;;    default:      return state;  &#125;&#125;function ExampleComponent() &#123;  const [state, dispatch] = useReducer(reducer, &#123; count: 0 &#125;);  return (    &lt;div&gt;      &lt;p&gt;Count: &#123;state.count&#125;&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;increment&quot; &#125;)&#125;&gt;Increment&lt;/button&gt;      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &quot;decrement&quot; &#125;)&#125;&gt;Decrement&lt;/button&gt;    &lt;/div&gt;  );&#125;\n\n這些是 React 中的四種最基本的 Hooks，每種 Hook 都提供了特定的功能，讓函式型元件能夠擁有狀態、副作用處理、上下文使用和複雜狀態管理等功能。\nHooks 的優勢\n更容易共用狀態邏輯： Hooks 提供了一種更好的方式來共用狀態邏輯，無需使用高階組件或渲染屬性。\n\n更容易理解和測試： 使用 Hooks 的函數型元件通常比類別型元件更加簡潔和易於理解，並且更容易進行測試。\n\n避免類別的繼承問題： Hooks 解決了類別型元件中的一些繼承問題，使代碼更加清晰。\n\n使 React 更加自然： Hooks 將 React 更加靠近函數式編程的理念，使得函數型元件的使用更加自然。\n\n\n\n\n\n\n\n\n\n\n\n總的來說，React Hooks 提供了一種更現代、簡潔且方便的方式來處理狀態和副作用，提高了 React 開發的效率和可維護性。\nAccessibility (a11y)“a11y” 是 “accessibility” 這個單詞的縮寫。它代表著網頁或應用程式的可及性（accessibility）方面，強調讓所有使用者，包括身心障礙者，都能方便地訪問和使用網頁或應用程式。\n透過可及性的設計，我們可以確保所有使用者都能獲得相同的資訊、功能和互動體驗，而不論他們是否有視力、聽力、運動能力或認知能力的障礙。提升可及性不僅是一種道德責任，還能擴大受眾並提升用戶滿意度。\n以下是一些可提升可及性的常見做法：\n1. 有意義的 HTML使用正確的 HTML 標籤，確保文檔結構清晰，並使用標題標籤（&lt;h1&gt;, &lt;h2&gt;, 等等）來組織內容。\n2. 表單可及性提供明確的表單標籤，使用標籤（&lt;label&gt;）來關聯表單元素和其標籤，以及提供適當的提示。\n3. 鍵盤導航確保所有功能都可以使用鍵盤進行操作，而不僅僅依賴滑鼠。\n4. 對比度使用高對比度的色彩，以確保文字和背景之間的區別明顯，有助於視力較差的使用者。\n5. 無障礙的多媒體內容提供音訊描述（audio descriptions）和字幕（captions）來支援聽覺或視覺障礙的使用者。\n6. 焦點可見性在焦點移動時，確保使用者可以清楚看到焦點所在的位置，這對於使用鍵盤導航的人很重要。\n7. 動態內容的可訪問性當有動態內容（例如單頁應用程序）時，確保內容對螢幕助讀器和其他輔助技術可訪問。\n\n\n\n\n\n\n\n\n\n總的來說，”a11y” 的目標是讓所有使用者都能夠平等地獲得和使用網站或應用程式的功能，而不受他們的能力或特殊需求的影響。\n“HTML in JS” 和 “CSS in JS”“HTML in JS” 和 “CSS in JS” 是指在 JavaScript 文件中直接嵌入 HTML 和 CSS 的一種開發模式。這種模式通常與一些 JavaScript 框架或庫結合使用，例如 React，Vue，或者一些 CSS-in-JS 的庫（如 Styled Components）。\nHTML in JS：在 React 中，JSX（JavaScript XML）是一種語法擴展，它允許開發者在 JavaScript 文件中直接撰寫類似 XML（或 HTML）的語法。JSX 最終會被編譯成 JavaScript。以下是一個簡單的 React 組件，展示了 HTML 在 JavaScript 文件中的使用：\n123456789101112import React from &quot;react&quot;;const MyComponent = () =&gt; &#123;  return (    &lt;div&gt;      &lt;h1&gt;Hello, JSX!&lt;/h1&gt;      &lt;p&gt;This is an example of HTML in JS using JSX.&lt;/p&gt;    &lt;/div&gt;  );&#125;;export default MyComponent;\n\n這種方式使得 UI 的結構和邏輯能夠更加緊密地結合在一起，方便了組件的定義和維護。\nCSS in JS：“CSS in JS” 是一種將 CSS 代碼嵌入到 JavaScript 文件中的模式。這種方式可以提供一些額外的好處，如範圍作用域（Scoped Styles）和動態生成樣式。以下是使用 Styled Components 库的一個簡單範例：\n12345678910111213141516import styled from &quot;styled-components&quot;;const StyledDiv = styled.div`  background-color: lightblue;  padding: 20px;`;const MyStyledComponent = () =&gt; &#123;  return (    &lt;StyledDiv&gt;      &lt;p&gt;This is a styled component with CSS in JS.&lt;/p&gt;    &lt;/StyledDiv&gt;  );&#125;;export default MyStyledComponent;\n\n這裡，styled.div 是 Styled Components 提供的函數，它接受一個包含 CSS 屬性的模板字符串。這樣的做法使得 CSS 能夠更好地與組件綁定在一起，同時避免了全局命名空間的衝突。\n\n\n\n\n\n\n\n\n\n總的來說，HTML in JS 和 CSS in JS 這兩種模式通過將不同語言的代碼放在同一個文件中，使得代碼的組織和維護更加方便，同時提供了一些額外的特性，如組件級別的樣式和動態生成樣式。\n虛擬 DOM（Virtual DOM）虛擬 DOM 是 React 中的一個核心概念，它在記憶體中構建了一個樹狀結構，用來表示真實 DOM 的抽象。React 使用虛擬 DOM 以最小化對實際 DOM 的操作，從而提高應用程式的性能和效能。\n工作原理\n構建虛擬 DOM： 當 React 應用程式進行渲染時，首先構建一個虛擬 DOM，這是一個 JavaScript 物件，包含整個應用程式的 UI 結構和狀態。虛擬 DOM 的構建基於 React 元件的層次結構。\n\n狀態變更引發更新： 當應用程式的狀態發生變化時，React 重新構建虛擬 DOM。新的虛擬 DOM 與之前的進行比較，找出變化的部分。\n\n虛擬 DOM 的比較： React 使用「調和（Reconciliation）」演算法，比較新的虛擬 DOM 與之前的虛擬 DOM，找出差異。這個比較是高效的，因為虛擬 DOM 是輕量級的，存在於記憶體中。\n\n差異更新： React 計算出虛擬 DOM 的變化部分，僅更新這些部分，而不是整個真實 DOM。這節省計算資源，提高性能。\n\n產生真實 DOM 操作： 根據虛擬 DOM 的變化，React 生成對應的真實 DOM 操作，例如新增、更新或刪除元素。\n\n應用變化： React 將這些真實 DOM 操作應用到實際 DOM 上，保持 UI 與應用程式狀態同步。\n\n\n優勢\n性能優化： 透過最小化對實際 DOM 的直接操作，減少瀏覽器的重新繪製次數，提高應用程式性能。\n\n開發效率： React 開發者無需手動處理 DOM 操作，專注於應用程式狀態和 UI 邏輯，React 會自動優化和管理 DOM 更新過程。\n\n\n\n\n\n\n\n\n\n\n\n總的來說，虛擬 DOM 是 React 實現高效且快速 UI 更新的核心機制之一。\nJSX（JavaScript XML）解釋\n\n\n\n\n\n\n\n\nJSX 使用的是 XHTML 標準，並非 HTML5 標準。JSX 是 React 中用來描述 UI 的一種語法擴展，通常與 React 框架一同使用。它允許在 JavaScript 代碼中嵌入類似 XML 或 HTML 的語法，使得 React 元件的定義和渲染更直觀和易於理解。\n主要特點和語法解釋1. 嵌入 JavaScript 表達式：在 JSX 中，可以使用 &#123;&#125; 中括號將 JavaScript 表達式嵌入到 XML 或 HTML 中，方便動態數據的渲染。\n12const name = &quot;World&quot;;const greeting = &lt;p&gt;Hello, &#123;name&#125;!&lt;/p&gt;;\n\n2. 創建元素：JSX 允許直接使用類似 HTML 的語法創建 React 元素。\n1const element = &lt;h1&gt;Hello, JSX!&lt;/h1&gt;;\n\n3. 屬性：JSX 中可以使用 HTML 一樣的屬性，屬性值可以是字符串或包含 JavaScript 表達式的括號。\n12const imageUrl = &quot;path/to/image.jpg&quot;;const image = &lt;img src=&#123;imageUrl&#125; alt=&quot;An Example&quot; /&gt;;\n\n4. 子元素：JSX 中可以包含其他 JSX 元素作為子元素，就像 HTML 一樣。\n123456const container = (  &lt;div&gt;    &lt;h1&gt;Main Title&lt;/h1&gt;    &lt;p&gt;Some content here.&lt;/p&gt;  &lt;/div&gt;);\n\n5. 條件渲染：可以使用 JavaScript 中的條件語句，如 if 或三元運算符，來根據不同條件渲染不同的 JSX 內容。\n12345const isLoggedIn = true;const loginStatus = (  &lt;p&gt;&#123;isLoggedIn ? &quot;User is logged in&quot; : &quot;User is logged out&quot;&#125;&lt;/p&gt;);\n\n6. 列表渲染：JSX 可以與 JavaScript 中的 .map() 函數一起使用，以便根據數據集合生成列表。\n123456789const numbers = [1, 2, 3, 4, 5];const list = (  &lt;ul&gt;    &#123;numbers.map((number) =&gt; (      &lt;li key=&#123;number&#125;&gt;&#123;number&#125;&lt;/li&gt;    ))&#125;  &lt;/ul&gt;);\n\n\n\n\n\n\n\n\n\n\n總的來說，JSX 提供了一種直觀和方便的語法，使得 React 元件的定義和渲染更加容易，同時保留了 JavaScript 的強大功能。當 React 代碼被編譯時，JSX 最終會被轉換為普通的 JavaScript 對象，並由 React DOM 使用。\nJSX 注意事項在使用 JSX 時，開發者需要注意一些潛在的細節和規則，以確保程式碼的正確性和可讀性。以下是一些建議和需要注意的事項：\n1. 包裝元素：JSX 中的每個返回值必須包裝在一個外層元素中。這是因為 JSX 被視為一個表達式，而表達式僅能返回單一值。\n12345678910111213141516171819// 正確const element = (  &lt;div&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Content&lt;/p&gt;  &lt;/div&gt;);// 正確-[Fragment(片段)]const element = (  &lt;&gt;    &lt;h1&gt;Title&lt;/h1&gt;    &lt;p&gt;Content&lt;/p&gt;  &lt;/&gt;);// 錯誤 - 缺少外層包裝元素const invalidElement = &lt;h1&gt;Title&lt;/h1&gt;&lt;p&gt;Content&lt;/p&gt;;\n\n建議儘可能使用內建的 Fragment(片段) 元件。因為當層級多、複雜且分散時，如果有過多層 div 或其它多餘標記，可能有樣式套用或小幅度效能影響問題。&lt;&gt;&lt;/&gt;是&lt;Fragment&gt;&lt;/Fragment&gt;的簡寫法\n2. 使用 className：在 JSX 中，指定 HTML 元素的 class 屬性應該使用 className 而非 class。這是因為 class 是 JavaScript 中的保留字。\n12345// 正確const element = &lt;div className=&quot;my-class&quot;&gt;Content&lt;/div&gt;;// 錯誤 - 使用 classconst invalidElement = &lt;div class=&quot;my-class&quot;&gt;Content&lt;/div&gt;;\n\n3. 屬性名稱使用 camelCase：在 JSX 中，屬性名稱應該使用 camelCase 寫法，就像在 JavaScript 中一樣。這是為了與 HTML 的屬性區分開來。\n12345// 正確const element = &lt;input type=&quot;text&quot; maxLength=&#123;10&#125; /&gt;;// 錯誤 - 使用 kebab-caseconst invalidElement = &lt;input type=&quot;text&quot; max-length=&#123;10&#125; /&gt;;\n\n4. 自閉合標籤：對於沒有子元素的標籤，應該使用自閉合的方式，以確保一致性和可讀性。\n12345// 正確const selfClosingTag = &lt;img src=&quot;path/to/image.jpg&quot; alt=&quot;An Image&quot; /&gt;;// 錯誤 - 不使用自閉合const invalidTag = &lt;img src=&quot;path/to/image.jpg&quot; alt=&quot;An Image&quot;&gt;&lt;/img&gt;;\n\n5. 表達式中的注意事項：在 &#123;&#125; 中的表達式中，應該注意不要放置太複雜或長的邏輯，以保持可讀性。若邏輯複雜，建議在外部先定義再引用。\n1234567// 正確const greeting = &lt;p&gt;Hello, &#123;name&#125;!&lt;/p&gt;;// 錯誤 - 過於複雜的邏輯const invalidGreeting = (  &lt;p&gt;&#123;name &amp;&amp; name.length &gt; 0 ? `Hello, $&#123;name&#125;!` : &quot;Hello!&quot;&#125;&lt;/p&gt;);\n\n\n\n\n\n\n\n\n\n\n這些是在使用 JSX 時需要注意的一些建議和細節，遵守這些規則有助於保持代碼的一致性和可維護性。\nReact FragmentsReact Fragments 是一種允許在 JSX 中返回多個元素而無需添加多餘外層包裝元素的機制。當你希望返回多個元素卻不想在 DOM 中添加額外的父元素時，React Fragments 提供了一種優雅的解決方案。\n使用方式1. 使用 &lt;React.Fragment&gt;：12345678910import React from &quot;react&quot;;const ComponentWithFragments = () =&gt; (  &lt;React.Fragment&gt;    &lt;p&gt;Paragraph 1&lt;/p&gt;    &lt;p&gt;Paragraph 2&lt;/p&gt;  &lt;/React.Fragment&gt;);export default ComponentWithFragments;\n\n2. 簡化 &lt;&gt;&lt;&#x2F;&gt; 語法（僅在 React 16.2.0 以上版本支援）：12345678910import React from &quot;react&quot;;const ComponentWithFragments = () =&gt; (  &lt;&gt;    &lt;p&gt;Paragraph 1&lt;/p&gt;    &lt;p&gt;Paragraph 2&lt;/p&gt;  &lt;/&gt;);export default ComponentWithFragments;\n\n優勢\n減少不必要的 DOM 元素： 使用 Fragments 可以防止因為外層包裝元素而導致不必要的 DOM 層次。\n\n提高可讀性： Fragments 使得返回多個元素時更加清晰和簡潔，無需額外的 div 或其他元素。\n\n避免樣式和佈局影響： 不添加多餘的父元素，可以避免對樣式和佈局產生不必要的影響。\n\n\n注意事項\nFragments 不會在最終的渲染結果中產生任何實際的 DOM 元素。\n當返回多個元素時，React Fragments 是一個優雅而有效的解決方案，特別是在不需要額外包裝元素的情況下。\n\n\n\n\n\n\n\n\n\n\nReact Fragments 提供了一種清晰的方式來處理返回多個元素的情況，同時保持了代碼的可讀性和結構。\nNode.js 模組系統Node.js 最初使用的是 CommonJS 模組系統，其中使用 require 和 module.exports。\n隨著 Node.js 的發展，ECMAScript 模組系統（使用 import 和 export）已成為標準，Node.js 也加入了對其的支援。\nNode.js 會將 .cjs 檔案視為 CommonJS 模組，將 .mjs 檔案視為 ECMAScript 模組。對於 .js 檔案，Node.js 將其視為專案的預設模組系統（除非 package.json 中指定 **”type”: “module”**）。\n","slug":"240124React零碎知識點","date":"2024-01-24T11:28:08.000Z","categories_index":"React","tags_index":"資策會上課筆記","author_index":"Hsu's Blog"},{"id":"0634d188a86a5b5d91c4c97fbcbf73a7","title":"240127前期練習-建立開發環境","content":"前期練習 - 建立開發環境Github Repo\n\n\n\n\n\n\n\n\n注意: 是用 branch(分支)的同一 repo 的協作者進行方式，並非 fork(分叉)，分叉的管理流程會較複雜不同。\n\n建立一個共同 repo，每個組員區分分支(branch)\n建立自己私有的數個 repo，主要作測試，或前期在建立基本版面使用\n\n所以每位組員至少應有四個專案，next(react)x2 與 express(node)x2。\n可以使用一個 repo 中有兩個資料夾來儲放，但注意開發時，每個專案應用獨立單一個 Visual Studio Code 分別開啟，切記不可直接開啟兩個資料夾。\n\nbackend 與 frontend\nserver 與 client\nreact 與 node\nnext 與 express\n\n前期訓練:\n開設一個測試用的 repo，自行用兩個 email 帳號註冊兩組 github 帳號，用兩個瀏覽器互相管理測試，以下是建議每位組員都能達成的流程(以下以 A 帳號與 B 帳號來說明):\n\nA 開立新的單一個 repo，A 與 B 帳號均 clone(建立副本)在兩個不同的資料夾中\nA 帳號 push(推上)主分支(main)二個程式碼檔案(.js 或.css 均可)，B 帳號之後同步拉下\nB 帳號由主分支目前檔案，建立 branch(分支)，取名為 B\nA 帳號由主分支目前檔案，建立 branch(分支)，取名為 A\nA 帳號修改其中兩個檔案的內容，之後 push(推上)A 分支\nA 帳號進行 A 分支合併(merge)到主分支的工作\nB 帳號修改其中兩個檔案的內容，之後 push(推上)B 分支\nB 帳號進行 B 分支合併(merge)到主分支的工作，將會產生衝突，並試著練習解決衝突\n\n以上重覆練習，之後改由傳上一整個專案(例如上課用的 next-base 專案)進行練習。儘可能先熟悉你所使用的 git 管理工具，例如是 Visual Studio Code 套件，或是 github desktop、命令列指令都可以。\n一般組員至少要會到第 6 步，知道自己要作什麼。到第 5 步是每工作日都要一定作的工作。\n","slug":"240124前期練習-建立開發環境","date":"2024-01-24T11:24:33.000Z","categories_index":"github","tags_index":"資策會上課筆記","author_index":"Hsu's Blog"},{"id":"70dadd491ec3695ca3bd2adef4b59f9a","title":"如何發問程式碼問題","content":"如何發問程式碼問題使用 Gist (推薦!!!)Gist 是 Github 的一個免費服務，且任何人都可以使用這個服務，不論你是否擁有 Github 帳號。\n以開發者的角度來說，最基本的功能就是可以分享片段的原始碼。有別於 Github 的 Repository，Gist 可以只分享專案中的某一個小檔案中的程式碼，且擁有私人的選項，讓別人不會搜尋到你的 Gist。\n\n以上摘錄自https://ithelp.ithome.com.tw/articles/10206233\nhttps://www.zhihu.com/question/21343711\nhttps://gohom.win/2015/11/26/gist/\n\n使用 Github Repo 中 Issue 或檔案連結可以加上附圖、影片、附檔(有 html&#x2F;css&#x2F;js 記得先 zip 壓縮再附上)、可貼上程式碼，語法為 markdown。\n使用 Code 沙盒的線上工具\n\n\n\n\n\n\n\n\n註: 請勿使用線上沙盒開發專案，這種工具只適合很簡單的應用程式，它多半也沒有除錯、檢查或格式化排版功能。\n\n(react 專案推薦): https://codesandbox.io/\n(react 專案推薦): https://stackblitz.com/\nhttps://codepen.io/\nhttps://jsfiddle.net/\nhttps://jsbin.com/\n\n","slug":"240124如何發問程式碼問題","date":"2024-01-24T11:17:41.000Z","categories_index":"github","tags_index":"資策會上課筆記","author_index":"Hsu's Blog"},{"id":"1e00bbc5a1a969d8b4414c942e9fedc9","title":"ES6 介绍","content":"02 【let 和 const】1.let 指令1.1 基本用法ES6 新增了 let 指令，用來聲明變量。它的用法類似於var，但是所聲明的變量，只在let指令所在的代碼區塊內有效。\n1234567&#123;  let a = 10;  var b = 1;&#125;a; // ReferenceError: a is not defined.b; // 1\n\n上面代碼在代碼區塊之中，分別用let和var聲明了兩個變量。然後在代碼區塊之外執行這兩個變量，結果let聲明的變量報錯，var聲明的變量返回了正確的值。這表明，let聲明的變量只在它所在的代碼區塊有效。\nfor循環的計數器，就很合適使用let指令。\n123456for (let i = 0; i &lt; 10; i++) &#123;  // ...&#125;console.log(i);// ReferenceError: i is not defined\n\n上面代碼中，計數器i只在for循環體內有效，在循環體外引用就會報錯。\n下面的代碼如果使用var，最後輸出的是10。\n1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[6](); // 10\n\n上面代碼中，變量i是var指令聲明的，在全局範圍內都有效，所以全局只有一個變量i。每一次循環，變量i的值都會發生改變，而循環內被賦給陣列a的函式內部的console.log(i)，裡面的i指向的就是全局的i。也就是說，所有陣列a的成員裡面的i，指向的都是同一個i，導致執行時輸出的是最後一輪的i的值，也就是 10。\n\n\n\n\n\n\n\n\n\n如果使用let，聲明的變量僅在塊級作用域內有效，最後輸出的是 6。\n1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123;  a[i] = function () &#123;    console.log(i);  &#125;;&#125;a[6](); // 6\n\n使用了 let 來宣告迴圈中的變數 i，這意味著 i 是在每次迴圈迭代時都會建立一個新的 binding，並且在每次迭代中都會有不同的值。\n當迴圈結束後，a 陣列中的每個函式都記住了在其宣告的時候 i 的值，因此當你執行 a[6]() 時，它會輸出迴圈結束時 i 的值，即 6。\n\n\n\n\n\n\n\n\n\nQ: 如果每一輪循環的變量i都是重新聲明的，那它怎麼知道上一輪循環的值，從而計算出本輪循環的值？\nA: JavaScript 的閉包(closure)特性。閉包允許函式在其宣告的範圍外訪問變數，而且它們可以記住宣告時的上下文。在這種情況下，每個函式都記住了它們宣告時的迴圈範圍內的 i 的值，而不是在函式被調用時的值。\n\n\n\n\n\n\n\n\n\n補充資料:怎麼理解for迴圈中用let宣告的迭代變數每次都是新的變數\n\n另外，for循環還有一個特別之處，就是設定循環變量的那部分是一個父作用域，而循環體內部是一個單獨的子作用域。\n1234567for (let i = 0; i &lt; 3; i++) &#123;  let i = &quot;abc&quot;;  console.log(i);&#125;// abc// abc// abc\n\n上面代碼正確執行，輸出了 3 次abc。這表明函式內部的變量i與循環變量i不在同一個作用域，有各自單獨的作用域（同一個作用域不可使用 let 重複聲明同一個變量）。\n1.2 不存在變量提升var指令會發生“變量提升”現象(類似將代碼移至程式頂端之行為)，值為undefined。這種現象多多少少是有些奇怪的，按照一般的邏輯，變量應該在聲明語句之後才可以使用。\n\n\n\n\n\n\n\n\n\n**變數提升**在執行任何程式碼前，JavaScript 會把函式宣告放進記憶體裡面，這樣做的優點是：可以在程式碼宣告該函式之前使用它。\n為了糾正這種現象，let指令改變了語法行為，它所聲明的變量一定要在聲明後使用，否則報錯。\n1234567// var 的情況console.log(foo); // 輸出undefinedvar foo = 2;// let 的情況console.log(bar); // 報錯ReferenceErrorlet bar = 2;\n\n\n使用 var 声明的變數會發生變量提升，在腳本開始執行時，變數已經存在，但尚未賦值，因此訪問它會得到 undefined。\n使用 let 声明的變數不會發生變量提升，變數在聲明之前不存在，如果在聲明之前訪問它，會導致 ReferenceError 錯誤。\nvar 存在變量提升的特性，而 let 則引入了暫時性死區（TDZ）的概念，確保變量在聲明之前無法被訪問，使代碼更加可控和健壯。\n\n1.3 暫時性死區（Temporal Dead Zone，TDZ）\n\n\n\n\n\n\n\n\nlet、const，所聲明的變量或常數就自動 “綁定” 作用域，不再受到外部作用域的影響。\nES6 中的「暫時性死區」（Temporal Dead Zone，TDZ）指的是在使用 let 或 const 狀態變數時，變數在程式碼區塊內存在但在宣告之前無法被訪問的情況。\n在 ES6 之前，JavaScript 中只有函式作用域和全域作用域，變數宣告會被提升到其作用域的頂部。但是 ES6 引入了 let 和 const，它們的作用域僅限於宣告它們的程式碼區塊內。\nTDZ 的概念源自於這樣一種行為：在宣告 let 或 const 變數之前，任何對變數的引用都會導致 ReferenceError 錯誤。這是因為在程式碼執行過程中，JavaScript 引擎會在進入作用域時對 let 或 const 宣告的變數進行宣告（在編譯階段），但是初始化（賦值）卻留在了原始位置。在宣告到初始化的這一過程中，變數處於 TDZ。\n123456let a = 2;function func() &#123;  console.log(a); // 報錯  let a = 1; // 暫時性死區&#125;func();\n\n12345let a = 2;function func() &#123;  console.log(a); // 2&#125;func();\n\n只要作用域內出現了同名的 let 或 const，那麼就會去找這個量（向前找），如果找不到也不會跳去外部找，只會直接報錯！\n\n\n\n\n\n\n\n\n\n遵守 “先聲明後使用”，那基本不會遇到變量提升及暫時性死區問題。\n1.4 不允許重複聲明let不允許在相同作用域內，重複聲明同一個變量。\n1234567891011// 報錯function func() &#123;  let a = 10;  var a = 1;&#125;// 報錯，相同作用域中不可重複聲明變數function func() &#123;  let a = 10;  let a = 1;&#125;\n\n因此，不能在函式內部重新聲明參數。\n1234567891011function func(arg) &#123;  let arg;&#125;func(); // 報錯function func(arg) &#123;  &#123;    let arg;  &#125;&#125;func(); // 不報錯\n\n2.塊級作用域2.1 為什麼需要塊級作用域？ES5 只有全局作用域和函式作用域，沒有塊級作用域，這帶來很多不合理的場景。\n第一種場景，內層變量可能會覆蓋外層變量。\n12345678910var tmp = new Date();function f() &#123;  console.log(tmp);  if (false) &#123;    var tmp = &quot;hello world&quot;;  &#125;&#125;f(); // undefined\n\n上面代碼的原意是，if代碼區塊的外部使用外層的tmp變量，內部使用內層的tmp變量。但是，函式f執行後，輸出結果為undefined，原因在於變量提升，導致內層的tmp變量覆蓋了外層的tmp變量。\n第二種場景，用來計數的循環變量泄露為全局變量。\n1234567var s = &quot;hello&quot;;for (var i = 0; i &lt; s.length; i++) &#123;  console.log(s[i]);&#125;console.log(i); // 5\n\n上面代碼中，變量i只用來控制循環，但是循環結束後，它並沒有消失，泄露成了全局變量。\n2.2 ES6 的塊級作用域let實際上為 JavaScript 新增了塊級作用域。\n\n作用域鏈：內層作用域 ——&gt; 外層作用域 ——&gt; 全局作用域\n\n塊級作用域：除了物件 &#123;&#125;，函式 &#123;&#125;（函式作用域）之外的一切 &#123;&#125; 都屬於塊級作用域。\n\n\n12345let x = 1;&#123;  let x = 2;&#125;console.log(x); // logs 1\n\n1234567891011function foo() &#123;  &#123;    var a = &quot;var&quot;;    &#123;      let a = &quot;let&quot;;      console.log(a); // let    &#125;  &#125;  console.log(a); // var&#125;foo();\n\n上面的函式有兩個區塊分別定義了變數 a，一個是外層區塊使用 var 定義的 a，另一個是在內層區塊中，使用 let 定義的變數 a 只存在於該區塊範圍內，不會影響外層區塊中的 a。\n因此，第一個 console.log(a) 印出的是內層區塊中的 a，值為 **”let”**。而第二個 console.log(a) 印出的是外層區塊中的 a，值為 “var”\n\nES6 允許塊級作用域的任意嵌套。\n123456789101112&#123;  &#123;    &#123;      &#123;        &#123;          let insane = &quot;Hello World&quot;;        &#125;        console.log(insane); // 報錯      &#125;    &#125;  &#125;&#125;\n\n上面代碼使用了一個五層的塊級作用域，每一層都是一個單獨的作用域。第四層作用域無法讀取第五層作用域的內部變量。\n內層作用域可以定義外層作用域的同名變量。\n123456789101112&#123;  &#123;    &#123;      &#123;        let insane = &quot;Hello World&quot;;        &#123;          let insane = &quot;Hello World&quot;;        &#125;      &#125;    &#125;  &#125;&#125;\n\n塊級作用域的出現，實際上使得獲得廣泛應用的匿名立即執行函式表達式（匿名 IIFE）不再必要了。\n1234567891011// IIFE 寫法(function () &#123;  var tmp = ...;  ...&#125;());// 塊級作用域寫法&#123;  let tmp = ...;  ...&#125;\n\n2.3 塊級作用域與函式聲明函式能不能在塊級作用域之中聲明？這是一個相當令人混淆的問題。\nES5 規定，函式只能在頂層作用域和函式作用域之中聲明，不能在塊級作用域聲明。\n1234567891011// 情況一if (true) &#123;  function f() &#123;&#125;&#125;// 情況二try &#123;  function f() &#123;&#125;&#125; catch (e) &#123;  // ...&#125;\n\n上面兩種函式聲明，根據 ES5 的規定都是非法的。\n但是，瀏覽器沒有遵守這個規定，為了相容以前的舊代碼，還是支持在塊級作用域之中聲明函式，因此上面兩種情況實際都能執行，不會報錯。\nES6 引入了塊級作用域，明確允許在塊級作用域之中聲明函式。ES6 規定，塊級作用域之中，函式聲明語句的行為類似於let，在塊級作用域之外不可引用。\n1234567891011121314function f() &#123;  console.log(&quot;I am outside!&quot;);&#125;(function () &#123;  if (false) &#123;    // 重複聲明一次函式f    function f() &#123;      console.log(&quot;I am inside!&quot;);    &#125;  &#125;  f();&#125;)();\n\n上面代碼在 ES5 中執行，會得到“I am inside!”，因為在if內聲明的函式f會被提升到函式頭部，實際執行的代碼如下。\n12345678910111213// ES5 環境function f() &#123;  console.log(&quot;I am outside!&quot;);&#125;(function () &#123;  function f() &#123;    console.log(&quot;I am inside!&quot;);  &#125;  if (false) &#123;  &#125;  f();&#125;)();\n\nES6 就完全不一樣了，理論上會得到“I am outside!”。因為塊級作用域內聲明的函式類似於let，對作用域之外沒有影響。但是，如果你真的在 ES6 瀏覽器中執行一下上面的代碼，是會報錯的，這是為什麼呢？\n12345678910111213141516// 瀏覽器的 ES6 環境function f() &#123;  console.log(&quot;I am outside!&quot;);&#125;(function () &#123;  if (false) &#123;    // 重複聲明一次函式f    function f() &#123;      console.log(&quot;I am inside!&quot;);    &#125;  &#125;  f();&#125;)();// Uncaught TypeError: f is not a function\n\n上面的代碼在 ES6 瀏覽器中，都會報錯。\n原來，如果改變了塊級作用域內聲明的函式的處理規則，顯然會對老代碼産生很大影響。\n\n允許在塊級作用域內聲明函式。\n函式聲明類似於var，即會提升到全局作用域或函式作用域的頭部。\n同時，函式聲明還會提升到所在的塊級作用域的頭部。\n\n注意，上面三條規則只對 ES6 的瀏覽器實現有效，其他環境的實現不用遵守，還是將塊級作用域的函式聲明當作let處理。\n根據這三條規則，瀏覽器的 ES6 環境中，塊級作用域內聲明的函式，行為類似於var聲明的變量。上面的例子實際執行的代碼如下。\n123456789101112131415// 瀏覽器的 ES6 環境function f() &#123;  console.log(&quot;I am outside!&quot;);&#125;(function () &#123;  var f = undefined;  if (false) &#123;    function f() &#123;      console.log(&quot;I am inside!&quot;);    &#125;  &#125;  f();&#125;)();// Uncaught TypeError: f is not a function\n\n考慮到環境導致的行為差異太大，應該避免在塊級作用域內聲明函式。如果確實需要，也應該寫成函式表達式，而不是函式聲明語句。\n123456789101112131415// 塊級作用域內部的函式聲明語句，建議不要使用&#123;  let a = &quot;secret&quot;;  function f() &#123;    return a;  &#125;&#125;// 塊級作用域內部，優先使用函式表達式&#123;  let a = &quot;secret&quot;;  let f = function () &#123;    return a;  &#125;;&#125;\n\n另外，還有一個需要注意的地方。ES6 的塊級作用域必須有大括號，如果沒有大括號，JavaScript 引擎就認為不存在塊級作用域。\n1234567// 第一種寫法，報錯if (true) let x = 1;// 第二種寫法，不報錯if (true) &#123;  let x = 1;&#125;\n\n上面代碼中，第一種寫法沒有大括號，所以不存在塊級作用域，而let只能出現在當前作用域的頂層，所以報錯。第二種寫法有大括號，所以塊級作用域成立。\n函式聲明也是如此，嚴格模式下，函式只能聲明在當前作用域的頂層。\n123456789// 不報錯&quot;use strict&quot;;if (true) &#123;  function f() &#123;&#125;&#125;// 報錯(&quot;use strict&quot;);if (true) function f() &#123;&#125;\n\n3.const 指令3.1 基本用法const聲明一個只讀的常數。一旦聲明，常數的值就不能改變。\n12345const PI = 3.1415;PI; // 3.1415PI = 3;// TypeError: Assignment to constant variable.\n\n上面代碼表明改變常數的值會報錯。\nconst聲明的變量不得改變值，這意味著，const一旦聲明變量，就必須立即初始化，不能留到以後賦值。\n12const foo;// SyntaxError: Missing initializer in const declaration\n\n上面代碼表示，對於const來說，只聲明不賦值，就會報錯。\nconst的作用域與let指令相同：只在聲明所在的塊級作用域內有效。\n12345if (true) &#123;  const MAX = 5;&#125;MAX; // Uncaught ReferenceError: MAX is not defined\n\nconst指令聲明的常數也是不提升，同樣存在暫時性死區，只能在聲明的位置後面使用。\n1234if (true) &#123;  console.log(MAX); // ReferenceError  const MAX = 5;&#125;\n\n上面代碼在常數MAX聲明之前就執行，結果報錯。\nconst聲明的常數，也與let一樣不可重複聲明。\n123456var message = &quot;Hello!&quot;;let age = 25;// 以下兩行都會報錯const message = &quot;Goodbye!&quot;;const age = 30;\n\n3.2 本質\nconst實際上保證的，並不是變量的值不得改動，而是變量指向的那個內存地址所儲存的資料不得改動。\n對於簡單型別的資料（數值、字符串、布爾值），值就儲存在變量指向的那個內存地址，因此等同於常數。\n對於複合型別的資料（主要是物件和陣列），變量指向的內存地址，儲存的只是一個指向實際資料的指針，const只能保證這個指針是固定的（即總是指向另一個固定的地址），至於它指向的資料結構是不是可變的，就完全不能控制了。\n因此，將一個物件聲明為常數必須非常小心。\n\n12345678const foo = &#123;&#125;;// 為 foo 加入一個屬性，可以成功foo.prop = 123;foo.prop; // 123// 將 foo 指向另一個物件，就會報錯foo = &#123;&#125;; // TypeError: &quot;foo&quot; is read-only\n\n上面代碼中，常數foo儲存的是一個地址，這個地址指向一個物件。不可變的只是這個地址，即不能把foo指向另一個地址，但物件本身是可變的，所以依然可以為其加入新屬性。\n下面是另一個例子。\n1234const a = [];a.push(&quot;Hello&quot;); // 可執行a.length = 0; // 可執行a = [&quot;Dave&quot;]; // 報錯\n\n上面代碼中，常數a是一個陣列，這個陣列本身是可寫的，但是如果將另一個陣列賦值給a，就會報錯。\n3.3 window 物件的屬性和方法（全局作用域中）全局作用域中，var 聲明的變量，function 聲明的函式，會自動變成 window 物件的屬性或方法。\n1234var age = 18;function add() &#123;&#125;console.log(window.age); // 18console.log(window.add === add); // true\n\n1234let age = 18;const add = function () &#123;&#125;;console.log(window.age); // undefinedconsole.log(window.add === add); // false\n\n3.4 什麼時候用 let，什麼使用 const原則：如果不知道用什麼的時候，就用 const，這有助於提高代碼的可靠性和安全性，同時也使程式碼更易於理解和維護。\n原因：如果應該是常數，那麼剛好符合需求。如果應該是變量，那麼後來報錯時，再來改為變量也為時不晚。同時，一開始就設定為常數還會避免真的需要為常數時，該值在後來被意外修改的情況。\n4.let 和 const 總結\nlet 聲明的變量會産生塊作用域，var 不會産生塊作用域\nconst 聲明的常數也會産生塊作用域\n不同代碼區塊之間的變量無法互相存取\n注意: 物件屬性修改和陣列元素變化不會出發 const 錯誤 （陣列和物件存的是引用地址）\n應用場景：聲明物件型別使用 const，非物件型別聲明選擇 let\ncosnt 聲明必須賦初始值，標識符一般為大寫，值不允許修改。\n\n5.頂層物件的屬性頂層物件，在瀏覽器環境指的是window物件，在 Node 指的是global物件。ES5 之中，頂層物件的屬性與全局變量是等價的。\n12345window.a = 1;a; // 1a = 2;window.a; // 2\n\n上面代碼中，頂層物件的屬性賦值與全局變量的賦值，是同一件事。\n6.JavaScript 全局變量與頂層物件的挂鈎問題與 ES6 的改進JavaScript 中，全局變量與頂層物件的屬性掛鈎被認為是該語言設計上的一個重大缺陷。這樣的設計帶來了多個問題：\n\n編譯時錯誤檢測不完善： JavaScript 在編譯時無法即時報告變量未聲明的錯誤，只有在執行時才能得知。這是因為全局變量可能是頂層物件的屬性動態創建的。\n易於創建全局變量： 程式員容易通過錯誤的拼寫等方式意外創建全局變量。\n不利於模塊化編程： 頂層物件的屬性是全局可讀寫的，這對於模塊化編程是不利的。\n\n另外，window 物件有著實際的含義，代表瀏覽器的窗口物件。因此，將頂層物件視為有實體含義的物件是不合適的。\n為了改善這些問題，ES6 做出了以下改進：\n\n保持相容性： 使用 var 和 function 定義的全局變量仍然是頂層物件的屬性。\n脫鈎全局變量： 使用 let、const 和 class 定義的全局變量不再是頂層物件的屬性。這意味著從 ES6 開始，全局變量將逐步與頂層物件的屬性脫鈎。\n\n1234567var a = 1;// 如果在 Node 的 REPL 環境，可以寫成 global.a// 或者採用通用方法，寫成 this.awindow.a; // 1let b = 1;window.b; // undefined\n\n上面代碼中，全局變量a由var指令聲明，所以它是頂層物件的屬性；全局變量b由let指令聲明，所以它不是頂層物件的屬性，返回undefined。\n","slug":"ES602 【let和const】","date":"2024-01-24T02:06:25.000Z","categories_index":"ES6","tags_index":"桃園資展筆記,ES6","author_index":"Hsu's Blog"},{"id":"1e00bbc5a1a969d8b4414c942e9fedc9","title":"ES6 介绍","content":"01 【ES6 介紹】ECMAScript 6.0（以下簡稱 ES6）是 JavaScript 語言的下一代標準，已於 2015 年 6 月正式發布。它的目標是使 JavaScript 語言能夠編寫複雜的大型應用程序，成為企業級開發語言。\n1.ECMAScript 和 JavaScript 的關係一個常見的問題是，ECMAScript 和 JavaScript 到底是什麼關係？\n要講清楚這個問題，需要回顧歷史。1996 年 11 月，JavaScript 的創造者 Netscape 公司，決定將 JavaScript 提交給標準化組織 ECMA，希望這種語言能夠成為國際標準。次年，ECMA 發布 262 號標準文件（ECMA-262）的第一版，規定了瀏覽器腳本語言的標準，並將這種語言稱為 ECMAScript，這個版本就是 1.0 版。\n該標準從一開始就是針對 JavaScript 語言製定的，但是之所以不叫 JavaScript，有兩個原因。一是商標，Java 是 Sun 公司的商標，根據授權協議，只有 Netscape 公司可以合法地使用 JavaScript 這個名字，且 JavaScript 本身也已經被 Netscape 公司註冊為商標。二是想體現這門語言的製定者是 ECMA，不是 Netscape，這樣有利於保證這門語言的開放性和中立性。\n因此，ECMAScript 和 JavaScript 的關係是，前者是後者的規格，後者是前者的一種實現（另外的 ECMAScript 方言還有 JScript 和 ActionScript）。日常場合，這兩個詞是可以互換的。\n2.ES6 與 ECMAScript 2015 的關係ECMAScript 2015（簡稱 ES2015）這個詞，也是經常可以看到的。它與 ES6 是什麼關係呢？\n2011 年，ECMAScript 5.1 版發布後，就開始製定 6.0 版了。因此，ES6 這個詞的原意，就是指 JavaScript 語言的下一個版本。\n但是，因為這個版本引入的語法功能太多，而且製定過程當中，還有很多組織和個人不斷提交新功能。事情很快就變得清楚了，不可能在一個版本裡面包括所有將要引入的功能。常規的做法是先發布 6.0 版，過一段時間再發 6.1 版，然後是 6.2 版、6.3 版等等。\n但是，標準的製定者不想這樣做。他們想讓標準的升級成為常規流程：任何人在任何時候，都可以向標準委員會提交新語法的提案，然後標準委員會每個月開一次會，評估這些提案是否可以接受，需要哪些改進。如果經過多次會議以後，一個提案足夠成熟了，就可以正式進入標準了。這就是說，標準的版本升級成為了一個不斷滾動的流程，每個月都會有變動。\n標準委員會最終決定，標準在每年的 6 月份正式發布一次，作為當年的正式版本。接下來的時間，就在這個版本的基礎上做改動，直到下一年的 6 月份，草案就自然變成了新一年的版本。這樣一來，就不需要以前的版本號了，只要用年份標記就可以了。\nES6 的第一個版本，就這樣在 2015 年 6 月發布了，正式名稱就是《ECMAScript 2015 標準》（簡稱 ES2015）。2016 年 6 月，小幅修訂的《ECMAScript 2016 標準》（簡稱 ES2016）如期發布，這個版本可以看作是 ES6.1 版，因為兩者的差異非常小（只新增了陣列實例的includes方法和指數運算子），基本上是同一個標準。根據計畫，2017 年 6 月發布 ES2017 標準。\n因此，ES6 既是一個歷史名詞，也是一個泛指，含義是 5.1 版以後的 JavaScript 的下一代標準，涵蓋了 ES2015、ES2016、ES2017 等等，而 ES2015 則是正式名稱，特指該年發布的正式版本的語言標準。本書中提到 ES6 的地方，一般是指 ES2015 標準，但有時也是泛指“下一代 JavaScript 語言”。\n3. ES6 簡介\nES6 是 ECMAScript 6.0 的簡稱，是語言的第 6 代版本（2015 年）。\nECMAScript 是語言的標準，ECMA 代表歐洲計算機製造商協會。\nES6 包括語法和 API 的更新，是 JavaScript 的進化版本。\n目前，主流瀏覽器的最新版本基本都支持 ES6，但IE 等舊版本可能不支持，可以使用 Babel 轉碼來解決相容性問題。\n建議放心使用 ES6 的新特性來開發項目。\n\nES 與 JS 的關係：JavaScript(瀏覽器端) = ESMAScript(語法+API) + DOM + BOM\n","slug":"ES601 【ES6 介绍】","date":"2024-01-24T00:06:25.000Z","categories_index":"ES6","tags_index":"桃園資展筆記,ES6","author_index":"Hsu's Blog"},{"id":"c288451229d981ac1c523a14e9961496","title":"運算子的擴展","content":"08【運算子的擴展】1.指數運算子(Exponentiation Operator)ES2016 新增了一個指數運算子（**）。\n指數的基本運算\n123452 ** 3; // 83 ** 2; // 93 ** 2.5; // 15.58845726811989610 ** -1; // 0.1NaN ** 2; // NaN\n\n1.1 指數運算子（**）會回傳以第一個數字作為底數；第二個數字做為指數的運算結果。12342 ** 2; // Expected output: 42 ** 3; // Expected output: 83 ** 4; // Expected output: 8110 ** -2; // Expected output: 0.01\n\n1.2 right-associative這個運算子的一個特點是右結合 (right-associative)，而不是常見的左結合。多個指數運算子連用時，是從最右邊開始計算的。\n1234// a ** b ** c  相當於   a ** (b ** c)// 相當於 2 ** (3 ** 2)2 ** (3 ** 2);// 512\n\n上面代碼中，首先計算的是第二個指數運算子，而不是第一個。\n1.3 指數運算子可以與等號結合，形成一個新的賦值運算子（**=）。1234567let a = 1.5;a **= 2;// 等同於 a = a * a;let b = 4;b **= 3;// 等同於 b = b * b * b;\n\n1.4 與一元運算子一同使用反轉指數運算結果之正負：\n1-(2 ** 2); // -4\n\n計算底數為負數的指數運算：\n1(-2) ** 2; // 4\n\n2.可選串連運算子(Optional chaining operator)在許多程式語言中，當我們嘗試存取一個物件的屬性或方法時，如果該物件為 null 或 undefined，就會引發錯誤。為了避免這種情況，我們通常需要額外進行多層的存在性檢查來檢查物件是否存在，這樣會使程式碼變得冗長且難以閱讀。\n可選串連運算子的出現解決了這個問題。它允許我們在存取物件屬性或方法時，同時進行存在性檢查，如果物件為 null 或 undefined，則返回 undefined 而不是拋出錯誤。這樣我們就可以在不必添加額外檢查程式碼的情況下，安全地存取物件屬性或方法。\n\n\n\n\n\n\n\n\n\n可選串連運算子可讓程式碼在存取可能不存在的屬性時更加安全，減少了因為屬性不存在而引發的錯誤，使程式碼更具可靠性。\n2.1 不使用?.運算子的存在性檢查校驗方法以 message.body.user.firstName 為例，為了安全地取得 firstName 屬性，傳統做法需要進行多次層層判斷，如下所示：\n12345678910// 錯誤的寫法const firstName = message.body.user.firstName || &quot;default&quot;;// 正確的寫法const firstName =  (message &amp;&amp;    message.body &amp;&amp;    message.body.user &amp;&amp;    message.body.user.firstName) ||  &quot;default&quot;;\n\n上面例子中，firstName屬性在物件的第四層，所以需要判斷四次，每一層是否有值。為了簡化這種層層判斷的過程，JavaScript 引入了可選串連運算子 ?.。\n2.2 利用?.運算子的方式簡化三元運算子的寫法[補充]三元運算子?:也常用於判斷物件是否存在。\n12const fooInput = myForm.querySelector(&quot;input[name=foo]&quot;);const fooValue = fooInput ? fooInput.value : undefined;\n\n上面例子中，必須先判斷fooInput是否存在，才能讀取fooInput.value。\n利用?.運算子的方式簡化三元運算子的寫法\n這樣的層層判斷非常麻煩，因此 ES2020 引入了“可選串連運算子”（optional chaining operator）?.，簡化上面的寫法。\n12const firstName = message?.body?.user?.firstName || &quot;default&quot;;const fooValue = myForm.querySelector(&quot;input[name=foo]&quot;)?.value;\n\n上面代碼使用了?.運算子，直接在鏈式執行的時候判斷，左側的物件是否為null或undefined。如果是的，就不再往下運算，而是返回undefined。\n2.3 其他場景下的可選串連運算子應用可選串連運算子不僅僅用於屬性存取，還可以應用在方法的執行上，尤其是在判斷方法是否存在並立即執行的場景下。\n1iterator.return?.();\n\n上面代碼中，iterator.return如果有定義，就會執行該方法，否則iterator.return直接返回undefined，不再執行?.後面的部分。這對於可能存在或不存在的方法，尤其有用。\n2.4 使用可選串連運算子進行可能校驗失敗的方法對於那些可能沒有實現的方法，這個運算子尤其有用。\n1234if (myForm.checkValidity?.() === false) &#123;  // 表單校驗失敗  return;&#125;\n\n上面代碼中，老式瀏覽器的表單物件可能沒有checkValidity()這個方法，這時?.運算子就會返回undefined，判斷語句就變成了undefined === false，所以就會跳過下面的代碼。\n2.5 可選串連運算子?.有三種寫法。\nobj?.prop &#x2F;&#x2F; 物件屬性是否存在\nobj?.[expr] &#x2F;&#x2F; 同上\nfunc?.(...args) &#x2F;&#x2F; 函式或物件方法是否存在\n\n下面是obj?.[expr]用法的一個例子。\n1let hex = &quot;#C0FFEE&quot;.match(/#([A-Z]+)/i)?.[1];\n\n上面例子中，字符串的match()方法，如果沒有發現匹配會返回null，如果發現匹配會返回一個陣列，?.運算子起到了判斷作用。\n2.6 ?.運算子常見形式及等價形式?.運算子有幾種常見形式，以及等價的非簡寫形式，如下所示：\n1234567891011121314151617a?.b;// 等同於a == null ? undefined : a.b;a?.[x];// 等同於a == null ? undefined : a[x];a?.b();// 等同於a == null ? undefined : a.b();// 即使 `a?.b()` 中的 `a` 存在且 `b` 屬性存在，但如果 `b` 不是一個函式，那麼調用 `a?.b()` 就會引發錯誤。a?.();// 等同於a == null ? undefined : a();// 使用 `a?.()` 來調用函式，如果 `a` 存在但不是一個函式，也會報錯。\n\n注意事項：\n\na?.b()運算子：\n\n\n如果 a 不是 null 或 undefined，但是 a.b 存在且不是函式，那麼 a?.b() 會報錯。\n這意味著，即使 a 不是 null 或 undefined，但是 b 屬性不是一個可調用的函式，也會導致錯誤。\n\n\na?.()運算子：\n\n\n如果 a 不是 null 或 undefined，但也不是一個函式，那麼 a?.() 會報錯。\n這意味著，即使 a 存在，但是它並不是一個可以調用的函式，使用 a?.() 也會引發錯誤。\n\n使用?.運算子的注意點。（1）短路機製(Short-circuiting)\n本質上，?.運算子相當於一種短路機製，只要不滿足條件，就不再往下執行。\n123a?.[++x];// 等同於a == null ? undefined : a[++x];\n\n上面代碼中，如果a是undefined或null，那麼x不會進行遞增運算。也就是說，可選串連運算子一旦為真，右側的表達式就不再求值。\n（2）括號的影響\n如果屬性鏈有圓括號，可選串連運算子對圓括號外部沒有影響，只對圓括號內部有影響。\n1234(a?.b).c(  // 等價於  a == null ? undefined : a.b).c;\n\n上面代碼中，?.對圓括號外部沒有影響，不管a物件是否存在，圓括號後面的.c總是會執行。\n一般來說，使用?.運算子的場合，不應該使用圓括號。\n（3）報錯場合\n以下寫法是禁止的，會報錯。\n1234567891011121314// 構造函式new a?.()new a?.b()// 可選串連運算子的右側有模板字符串a?.`&#123;b&#125;`a?.b`&#123;c&#125;`// 可選串連運算子的左側是 supersuper?.()super?.foo// 鏈運算子用於賦值運算子左側a?.b = c\n\n3.空值合併運算子(Nullish coalescing operator)?? 運算子是 ES2020 中引入的 Nullish Coalescing Operator，用於設置預設值，僅在左側的值為null或undefined 時，才會返回右側的值。\n3.1 使用 ?? 運算子的原因前三行代碼透過||運算子指定預設值，但是這樣寫會與開發者的原意不同。\n\n\n\n\n\n\n\n\n\n開發者的原意是，只要屬性的值為null或undefined，預設值就會生效，但是屬性的值如果為空字符串或false或0，預設值也會生效。\n123456789// 通過`||`運算子指定預設值(錯誤寫法)const headerText = response.settings.headerText || &quot;Hello, world!&quot;;const animationDuration = response.settings.animationDuration || 300;const showSplashScreen = response.settings.showSplashScreen || true;// 使用空值合併運算子`??`const headerText = response.settings.headerText ?? &quot;Hello, world!&quot;;const animationDuration = response.settings.animationDuration ?? 300;const showSplashScreen = response.settings.showSplashScreen ?? true;\n\n為了避免這種情況，使用空值合併運算子??。它的行為類似||，但是只有運算子左側的值為null或undefined時，才會返回右側的值。\n上面代碼中，預設值只有在左側屬性值為null或undefined時，才會生效。\n3.2 ?? 運算子與 ?. 運算子的結合使用?? 運算子跟可選串連運算子?.配合使用，為null或undefined的值設定預設值。\n1const animationDuration = response.settings?.animationDuration ?? 300;\n\n上面代碼中，如果response.settings是null或undefined，或者response.settings.animationDuration是null或undefined，就會返回預設值 300。也就是說，這一行代碼包括了兩級屬性的判斷。\n3.3 ?? 運算子在函數參數中的應用?? 運算子也適用於判斷函數參數是否賦值，並設置默認值。\n1234function Component(props) &#123;  const enable = props.enabled ?? true;  // …&#125;\n\n上面代碼判斷props參數的enabled屬性是否賦值，基本等同於下面的寫法。\n1234function Component(props) &#123;  const &#123; enabled: enable = true &#125; = props;  // …&#125;\n\n3.4 優先級和使用括號??本質上是邏輯運算，它與其他兩個邏輯運算子&amp;&amp;和||有一個優先級問題，它們之間的優先級到底孰高孰低。優先級的不同，往往會導致邏輯運算的結果不同。\n如果同時使用多個邏輯運算子，應該使用括號來明確指定優先級，以避免混淆和報錯。\n12345// 報錯lhs &amp;&amp; middle ?? rhslhs ?? middle &amp;&amp; rhslhs || middle ?? rhslhs ?? middle || rhs\n\n上面四個表達式都會報錯，必須加入表明優先級的括號。\n1234567891011(lhs &amp;&amp; middle) ?? rhs;lhs &amp;&amp; (middle ?? rhs);(lhs ?? middle) &amp;&amp; rhs;lhs ?? (middle &amp;&amp; rhs);(lhs || middle) ?? rhs;lhs || (middle ?? rhs);(lhs ?? middle) || rhs;lhs ?? (middle || rhs);\n\n\n\n\n\n\n\n\n\n\n空合併運算子的運算子優先順序倒數第五，直接低於 || 並直接高於條件（三元）運算子。\n3.5 短路機制(Short-circuiting)與 OR 和 AND 邏輯運算子一樣，如果左側表達式既不是 null 也不是 undefined ，則不會評估右側表達式。\n1234567891011121314151617181920function a() &#123;  console.log(&quot;a was called&quot;);  return undefined;&#125;function b() &#123;  console.log(&quot;b was called&quot;);  return false;&#125;function c() &#123;  console.log(&quot;c was called&quot;);  return &quot;foo&quot;;&#125;console.log(a() ?? c());// 輸出 &quot;a was called&quot; 然後 &quot;c was called&quot; 接著 &quot;foo&quot;// 因為 a() 返回 undefined，所以兩個表達式都被評估console.log(b() ?? c());// 輸出 &quot;b was called&quot; 然後 &quot;false&quot;// 因為 b() 返回 false（而不是 null 或 undefined），右邊的表達式沒有被評估\n\n4.邏輯賦值運算子ES2021 引入了三個新的邏輯賦值運算子（logical assignment operators），將邏輯運算子與賦值運算子進行結合。\n1234567891011121314// 或賦值運算子x ||= y;// 等同於x || (x = y);// 與賦值運算子x &amp;&amp;= y;// 等同於x &amp;&amp; (x = y);// Null 賦值運算子x ??= y;// 等同於x ?? (x = y);\n\n這三個運算子||=、&amp;&amp;=、??=相當於先進行邏輯運算，然後根據運算結果，再視情況進行賦值運算。\n它們的一個用途是，為變量或屬性設定預設值。\n12345// 老的寫法user.id = user.id || 1;// 新的寫法user.id ||= 1;\n\n上面示例中，user.id屬性如果不存在，則設為1，新的寫法比老的寫法更緊湊一些。\n下面是另一個例子。\n1234function example(opts) &#123;  opts.foo = opts.foo ?? &quot;bar&quot;;  opts.baz ?? (opts.baz = &quot;qux&quot;);&#125;\n\n上面示例中，參數物件opts如果不存在屬性foo和屬性baz，則為這兩個屬性設定預設值。有了“Null 賦值運算子”以後，就可以統一寫成下面這樣。\n1234function example(opts) &#123;  opts.foo ??= &quot;bar&quot;;  opts.baz ??= &quot;qux&quot;;&#125;\n","slug":"ES608【運算子的擴展】","date":"2024-01-24T00:06:25.000Z","categories_index":"ES6","tags_index":"ES6","author_index":"Hsu's Blog"},{"id":"08a95690396abe22dee79253dd37972c","title":"async 函式","content":"11【async 函式】async 簡介處理 JavaScript 中的異步程序總是需要面臨各種不同應用情況的挑戰。在 ES6(ES2015)中加入的 Promise 和 Generator 提供了一些新的工具和語法，可以更方便地處理這些異步程序的流程控制。然而，這些新的工具或結構也帶來了一些新的問題，例如：\n\n語法複雜，需要進一步學習與大幅度修改原有的程式碼\n除錯不容易\n錯誤處理不容易\n對於情況控制(Conditionals)與迴圈&#x2F;迭代處理仍然不是很理想\n\n在 ECMAScript 2017(ES8) 後，async 函式加入了標準中，其目的是為了解決上述問題。它可以進一步簡化整個語法。\nasync&#x2F;await 的語法非常容易學習與使用。相較於 Promise 或 Generator，開發者可以在很短的時間內理解用法，並開始使用它們，甚至不需要對 Promise 或 Generator 有太深入的知識。\n然而，async 函式的基礎仍然是 Promise，它的相對轉換的語法則是組合了 Promise 與 Generator。儘管它提供了更方便使用的語法，能夠輕鬆處理異步程序的流程控制，但仍然需要對 Promise 有一定的理解，才能真正靈活地應用到各種情況中。換句話說，Promise 的知識仍然是必須的，沒有什麼誰可以取代誰的問題。\n1.基本用法\n\n\n\n\n\n\n\n\n當 async 函式被呼叫時，它會回傳一個 Promise，這與有沒有使用 await 無關\n\n\n\n\n\n\n\n\n\nasync函式返回一個 Promise 物件，可以使用then方法加入回調函式。\n\n\n\n\n\n\n\n\n\n在 async 函式內部，遇到 await 指令會暫停當前函式的執行，等待後面的 Promise 物件解析為止，然後繼續執行函式體內後面的語句。\n1.1 不同的 async 函式形式async 函式可以以不同的形式聲明，包括函式聲明、函式表達式、物件的方法、以及箭頭函式。\n123456789101112// 函式聲明async function foo() &#123;&#125;// 函式表達式const foo = async function () &#123;&#125;;// 物件的方法let obj = &#123; async foo() &#123;&#125; &#125;;obj.foo().then(...)// 箭頭函式const foo = async () =&gt; &#123;&#125;;\n\n1.2 async 函式與 Promise 差異1.2.1 PromisePromise 是一種非同步操作的解決方案，它提供了一個連續的、非阻塞的語法結構，用於處理異步操作的結果或錯誤。其基本語法如下：\n12345678fetch(&quot;http://example.com/items&quot;)  .then((response) =&gt; response.json())  .then((data) =&gt; &#123;    updateView(data);  &#125;)  .catch((error) =&gt; &#123;    console.log(&quot;Update failed&quot;, error);  &#125;);\n這種結構的涵意是 “我想要進行這個操作，然後在下一步對操作得到的資料再進行處理”。\n1.2.2 async&#x2F;awaitawait 的語法涵意會是 “我想要得到這個操作的結果(值)”，這會感覺像是在撰寫同步的語句。\n123const response = await fetch(&quot;http://example.com/items&quot;);const data = await response.json();updateView(data);\n\n\n由於 await 運算子是被設計來等待 Promise 的，建議寫在 async 函式 內使用，像下面這樣的程式碼:\n12345async function updateMyView() &#123;  const response = await fetch(&quot;http://example.com/items&quot;);  const data = await response.json();  updateView(data);&#125;\n\n\n\n\n\n\n\n\n\nES13（ECMAScript 2022）將 await 運算子的使用擴展到了非 async 函式中\n[示例]：獲取股票報價123456789async function getStockPriceByName(name) &#123;  const symbol = await getStockSymbol(name);  const stockPrice = await getStockPrice(symbol);  return stockPrice;&#125;getStockPriceByName(&quot;goog&quot;).then(function (result) &#123;  console.log(result);&#125;);\n\n上面代碼是一個獲取股票報價的函式，函式前面的async關鍵字，表明該函式內部有異步操作。執行該函式時，會立即返回一個Promise物件。\n[示例]：指定多少毫秒後輸出一個值。123456789101112function timeout(ms) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(resolve, ms);  &#125;);&#125;async function asyncPrint(value, ms) &#123;  await timeout(ms);  console.log(value);&#125;asyncPrint(&quot;hello world&quot;, 50);\n\n上面代碼指定 50 毫秒以後，輸出hello world。\n由於async函式返回的是 Promise 物件，可以作為await指令的參數。所以，上面的例子也可以寫成下面的形式。\n123456789101112async function timeout(ms) &#123;  await new Promise((resolve) =&gt; &#123;    setTimeout(resolve, ms);  &#125;);&#125;async function asyncPrint(value, ms) &#123;  await timeout(ms);  console.log(value);&#125;asyncPrint(&quot;hello world&quot;, 50);\n\n2.語法async函式的語法規則總體上比較簡單，難點是錯誤處理機製。\n2.1 返回 Promise 物件\n\n\n\n\n\n\n\n\nasync 函式被呼叫後，如果回傳一個值，就會被視為帶有該回傳值的實現(resolved)狀態的 Promise，反之如果拋出例外，就會被視為帶有被拋出值的拒絕(rejected)狀態的 Promise。\nasync函式內部return語句返回的值，會成為then方法回調函式的參數。\n123456async function f() &#123;  return &quot;hello world&quot;;&#125;f().then((v) =&gt; console.log(v));// &quot;hello world&quot;\n\n上面代碼中，函式f內部return指令返回的值，會被then方法回調函式接收到(透過Promise 物件)。\nasync函式內部拋出錯誤，會導致返回的 Promise 物件變為reject狀態。拋出的錯誤物件會被catch方法回調函式接收到。\n123456789async function f() &#123;  throw new Error(&quot;出錯了&quot;);&#125;f().then(  (v) =&gt; console.log(&quot;resolve&quot;, v),  (e) =&gt; console.log(&quot;reject&quot;, e));//reject Error: 出錯了\n\n2.2 Promise 物件的狀態變化async函式返回的 Promise 物件，必須等到內部所有await指令後面的 Promise 物件執行完，才會發生狀態改變，除非遇到return語句或者拋出錯誤。也就是說，只有async函式內部的異步操作執行完，then方法才會執行指定的回調函式。\n下面是一個例子。\n1234567async function getTitle(url) &#123;  let response = await fetch(url);  let html = await response.text();  return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1];&#125;getTitle(&quot;https://tc39.github.io/ecma262/&quot;).then(console.log);// &quot;ECMAScript 2017 Language Specification&quot;\n\n上面代碼中，函式getTitle內部有三個操作：抓取網頁、取出文本、匹配頁面標題。只有這三個操作全部完成，才會執行then方法裡面的console.log。\n\n\n\n\n\n\n\n\n\n[備註]： async/await 函式的目的在於簡化同步操作 promise 的表現，以及對多個 Promise 物件執行某些操作。就像 Promise 類似於具結構性的回呼函式，同樣地，async/await 好比將 generator 與 promise 組合起來。\n2.3 await 指令async 函式內部可以使用 await 表達式，它會暫停此 async 函式的執行，並且等待傳遞至表達式的 Promise 的解析，解析完之後會回傳解析值，並繼續此 async 函式的執行。\n\n\n\n\n\n\n\n\n\nawait 是一個運算子，使用這個關鍵字在表達式前作為修飾關鍵字詞，會讓表達式變為 “等待 Promise 解析的表達式”\n2.3.1 等待 Promise 解析的表達式正常情況下，await指令後面是一個 Promise 物件，返回該物件的結果。如果不是 Promise 物件，就直接返回對應的值。\n123456async function f() &#123;  // 等同於　return 123;  return await 123;&#125;f().then((v) =&gt; console.log(v)); // 123\n\n上面代碼中，await指令的參數是數值123，這時等同於return 123。\n2.3.2 實現休眠效果\n\n\n\n\n\n\n\n\n可以利用 await 指令來實現程式的暫停，例如在一段時間後再繼續執行。\nJavaScript 一直沒有休眠的語法，但是借助await指令就可以讓程序停頓指定的時間。下面給出了一個簡化的sleep實現。\n1234567891011121314function sleep(interval) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(resolve, interval);  &#125;);&#125;async function countOneToFive() &#123;  for (let i = 1; i &lt;= 5; i++) &#123;    console.log(i);    await sleep(1000);  &#125;&#125;countOneToFive();\n\n2.3.3 處理 Promise 的 reject 狀態如果 await 後面的 Promise 物件變為 reject 狀態，則可以通過 catch 方法處理錯誤。\n1234567async function f() &#123;  await Promise.reject(&quot;出錯了&quot;);&#125;f()  .then((v) =&gt; console.log(v))  .catch((e) =&gt; console.log(e)); // 出錯了\n\n注意，上面代碼中，await語句前面沒有return，但是reject方法的參數依然傳入了catch方法的回調函式。這裏如果在await前面加上return，效果是一樣的。\n2.3.4 中斷整個 async 函式的執行如果任何一個await語句後面的 Promise 物件變為reject狀態，整個async函式都會中斷執行。\n1234async function f() &#123;  await Promise.reject(&quot;出錯了&quot;);  await Promise.resolve(&quot;hello world&quot;); // 不會執行&#125;\n\n上面代碼中，第二個await語句是不會執行的，因為第一個await語句狀態變成了reject。\n2.3.5 避免中斷執行如果希望即使前一個異步操作失敗，也不要中斷後面的異步操作，可以將第一個await放在try...catch結構裡面，這樣不管這個異步操作是否成功，第二個await都會執行。\n12345678async function f() &#123;  try &#123;    await Promise.reject(&quot;出錯了&quot;);  &#125; catch (e) &#123;&#125;  return await Promise.resolve(&quot;hello world&quot;);&#125;f().then((v) =&gt; console.log(v)); // hello world\n\n2.3.6 處理可能出現的錯誤可以將 await 後面的 Promise 物件再跟一個 catch 方法，處理可能出現的錯誤。\n123456async function f() &#123;  await Promise.reject(&quot;出錯了&quot;).catch((e) =&gt; console.log(e));  return await Promise.resolve(&quot;hello world&quot;);&#125;f().then((v) =&gt; console.log(v)); // 出錯了, hello world\n\n\n\n\n\n\n\n\n\n\nawait 這個英文字詞也是有 “等待、等候” 意思的動詞，它與另一個常用的英文字詞 wait 意思相近。\nwait 後面通常會加上 for，經常使用在等候某人、等公車、等聖誕老公公…等等，它也可以不需要加上後面的受詞。\nawait 則會用於比 wait 較為正式的場合或書面文章，它有預期某事物會延時發生的意思，後面必定要加上受詞，經常用於例如等候法院判決、等候合約審查、等候某人作決定…等等情況。\n2.4 錯誤處理2.4.1 利用 catch 方法(類似 Promise 裡的 catch 方法)如果await後面的異步操作出錯，那麼等同於async函式返回的 Promise 物件被reject。\n12345678910async function f() &#123;  await new Promise(function (resolve, reject) &#123;    throw new Error(&quot;出錯了&quot;);  &#125;);&#125;f()  .then((v) =&gt; console.log(v))  .catch((e) =&gt; console.log(e));// Error：出錯了\n\n上面代碼中，async函式f執行後，await後面的 Promise 物件會拋出一個錯誤物件，導致catch方法的回調函式被執行，它的參數就是拋出的錯誤物件。\n2.4.2 利用 try…catch 方法在 JavaScript 中，使用 try...catch 機制可以捕獲異步操作中的錯誤，這在處理異步程式碼中尤其重要。\n以下是幾種利用 try...catch 的情境和範例：\n1. 單個異步操作的錯誤處理\n12345678910async function f() &#123;  try &#123;    await new Promise(function (resolve, reject) &#123;      throw new Error(&quot;出錯了&quot;);    &#125;);  &#125; catch (e) &#123;    console.error(e.message); // 處理錯誤  &#125;  return &quot;hello world&quot;;&#125;\n\n在 async 函式中使用 try...catch 來捕捉異步操作中的錯誤，並在 catch 區塊中進行錯誤處理。\n2. 多個異步操作的錯誤處理\n如果有多個await指令，可以統一放在try...catch結構中。\n1234567891011async function main() &#123;  try &#123;    const val1 = await firstStep();    const val2 = await secondStep(val1);    const val3 = await thirdStep(val1, val2);    console.log(&quot;Final: &quot;, val3);  &#125; catch (err) &#123;    console.error(err); // 處理錯誤  &#125;&#125;\n\n在這個示例中，main() 函式中的多個異步操作被放置在 try...catch 結構中，如果其中任何一個操作出錯，都會被 catch 區塊捕獲，並進行錯誤處理。\n3. 多次重複嘗試的錯誤處理\n下面的例子使用try...catch結構，實現多次重複嘗試。\n1234567891011121314151617const superagent = require(&quot;superagent&quot;);const NUM_RETRIES = 3;async function test() &#123;  let i;  for (i = 0; i &lt; NUM_RETRIES; ++i) &#123;    try &#123;      await superagent.get(&quot;http://google.com/this-throws-an-error&quot;);      break;    &#125; catch (err) &#123;      console.error(err); // 處理錯誤    &#125;  &#125;  console.log(i); // 3&#125;test();\n\n上面代碼中，如果await操作成功，就會使用break語句退出循環；如果失敗，會被catch語句捕捉，然後進入下一輪循環。\n2.5 用 IIFE 或是箭頭函式的語法來搭配 async 函式這可以因應不同的使用情況，以及讓語法更為簡化，在處理異步操作時，能夠清晰地表達程式的邏輯和流程，像下面的程式碼:\n1. 立即執行函式表達式（IIFE）與 async 函式結合\n12345678910111213// 定義了匿名的async立即執行函式，並等待異步操作完成。(async () =&gt; &#123;  // 透過 await 來等待 fetch 函式的回應  try &#123;    const response = await fetch(&quot;http://example.com/items&quot;);    // 將其解析為 JSON 格式    const data = await response.json();    updateView(data);  &#125; catch (error) &#123;    // 如果任何一步出錯，catch 區塊將捕獲到錯誤並加以處理。    console.log(&quot;Update failed&quot;, error);  &#125;&#125;)();\n\n2. 箭頭函式與 async 函式結合\n123456789101112131415// 定義了一個箭頭函式 fetchData (亦是 async 函式)const fetchData = async () =&gt; &#123;  // 使用 await 來等待 fetch 函式的回應  try &#123;    const response = await fetch(&quot;http://example.com/items&quot;);    // 將其解析為 JSON 格式    const data = await response.json();    updateView(data);  &#125; catch (error) &#123;    // 如果任何一步出錯，catch 區塊將捕獲到錯誤並加以處理。    console.log(&quot;Update failed&quot;, error);  &#125;&#125;;fetchData();\n\n3.使用注意點3.1 await 指令的錯誤處理在 await 指令後面的 Promise 物件可能被拒絕（rejected），因此最好將 await 指令放在 try...catch 代碼區塊中，以便捕獲可能的錯誤。\n1234567891011121314async function myFunction() &#123;  try &#123;    await somethingThatReturnsAPromise();  &#125; catch (err) &#123;    console.log(err);  &#125;&#125;// 另一種寫法async function myFunction() &#123;  await somethingThatReturnsAPromise().catch(function (err) &#123;    console.log(err);  &#125;);&#125;\n\n3.2 多個 await 指令的並行執行如果多個 await 指令後面的異步操作彼此獨立(不存在繼發關係)，最好讓它們同時觸發以減少執行時間。\n12let foo = await getFoo();let bar = await getBar();\n\n上面代碼中，getFoo和getBar是兩個獨立的異步操作（即互不依賴），被寫成繼發關係。這樣比較耗時，因為只有getFoo完成以後，才會執行getBar，完全可以讓它們同時觸發。\n12345678// 寫法一let [foo, bar] = await Promise.all([getFoo(), getBar()]);// 寫法二let fooPromise = getFoo();let barPromise = getBar();let foo = await fooPromise;let bar = await barPromise;\n\n上面兩種寫法，將getFoo和getBar改成同時觸發，這樣將會縮短程式的執行時間。\n3.3 async 函式中的非同步操作await 指令只能用在 async 函式內部，嘗試在普通函式內部使用會導致錯誤。\n12345678async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  // 報錯，因為await用在普通函式之中了  docs.forEach(function (doc) &#123;    await db.post(doc);  &#125;);&#125;\n\n但是，如果將forEach方法的參數改成async函式，也有問題。\n123456789function dbFuc(db) &#123;  //這裏不需要 async  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  // 可能得到錯誤結果  docs.forEach(async function (doc) &#123;    await db.post(doc);  &#125;);&#125;\n\n上面代碼可能不會正常工作，原因是這時三個db.post()操作將是並發執行，也就是同時執行，而不是繼發執行。\n\n\n\n\n\n\n\n\n\n在 async 函式內部使用 forEach 等迭代方法，也可能會產生意外的行為，應該使用 for 循環來處理。\n1234567async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  for (let doc of docs) &#123;    await db.post(doc);  &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n另一種方法是使用陣列的reduce()方法。\n12345678async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  await docs.reduce(async (_, doc) =&gt; &#123;    await _;    await db.post(doc);  &#125;, undefined);&#125;\n\n上面例子中，reduce()方法的第一個參數是async函式，導致該函式的第一個參數是前一步操作返回的 Promise 物件，所以必須使用await等待它操作結束。另外，reduce()方法返回的是docs陣列最後一個成員的async函式的執行結果，也是一個 Promise 物件，導致在它前面也必須加上await。\n上面的reduce()的參數函式裡面沒有return語句，原因是這個函式的主要目的是db.post()操作，不是返回值。而且async函式不管有沒有return語句，總是返回一個 Promise 物件，所以這裏的return是不必要的。\n如果確實希望多個請求並發執行，可以使用Promise.all方法。當三個請求都會resolved時，下面兩種寫法效果相同。\n1234567891011121314151617181920async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  let promises = docs.map((doc) =&gt; db.post(doc));  let results = await Promise.all(promises);  console.log(results);&#125;// 或者使用下面的寫法async function dbFuc(db) &#123;  let docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];  let promises = docs.map((doc) =&gt; db.post(doc));  let results = [];  for (let promise of promises) &#123;    results.push(await promise);  &#125;  console.log(results);&#125;\n\n3.4 保留執行堆棧async 函式可以保留執行堆棧，這意味著在 async 函式內部的異步操作完成之前，函式的上下文環境將被保留。這有助於更好地處理異步操作中的錯誤。\n123const a = () =&gt; &#123;  b().then(() =&gt; c());&#125;;\n\n上面代碼中，函式a內部執行了一個異步任務b()。當b()執行的時候，函式a()不會中斷，而是繼續執行。等到b()執行結束，可能a()早就執行結束了，b()所在的上下文環境已經消失了。如果b()或c()報錯，錯誤堆棧將不包括a()。\n現在將這個例子改成async函式。\n1234const a = async () =&gt; &#123;  await b();  c();&#125;;\n\n上面代碼中，b()執行的時候，a()是暫停執行，上下文環境都儲存著。一旦b()或c()報錯，錯誤堆棧將包括a()。\n4.es13 新增在 JavaScript 中，await 運算子用於暫停執行，直到 Promise 被解決（履行或拒絕）。以前，我們只能在 async 函式中使用此運算子 - 使用 async 關鍵字聲明的函式。我們無法在全域範圍內這樣做。\n123456789function setTimeoutAsync(timeout) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve();    &#125;, timeout);  &#125;);&#125;// SyntaxError: await is only valid in async functionsawait setTimeoutAsync(3000);\n\n在 JavaScript 中，ES13（ECMAScript 2022）將 await 運算子的使用擴展到了非 async 函式中。在過去，await 運算子只能在使用 async 關鍵字聲明的函式中使用，這意味著它只能在 Promise-based 的異步操作中使用。\n123456789function setTimeoutAsync(timeout) &#123;  return new Promise((resolve) =&gt; &#123;    setTimeout(() =&gt; &#123;      resolve();    &#125;, timeout);  &#125;);&#125;// Waits for timeout - no error thrownawait setTimeoutAsync(3000);\n\nES13 中能更靈活地使用 await 運算子，而不僅僅局限於 async 函式中。這對於某些場景下，特別是在代碼的邏輯結構上，將會更方便。\n","slug":"ES611【async 函式】","date":"2024-01-24T00:06:25.000Z","categories_index":"ES6","tags_index":"桃園資展筆記,ES6","author_index":"Hsu's Blog"},{"id":"2eee75b9eadbff5e92bde1a81c889d22","title":"跨域初識-跨來源資源共用（CORS）","content":"05 【跨域初識】在認識跨域前，先簡單認識同源策略延伸閱讀-簡單弄懂同源政策 (Same Origin Policy) 與跨網域 (CORS)\n1.同源策略\n\n\n\n\n\n\n\n\n同源政策是網站安全的基礎。 https://domain-a.com 只能存取自己網站裡的資源 (圖片、影片、程式碼等)，不允許網站 https://domain-b.com 來存取。想要存取跨來源資源必須在某些特定情況下才被允許。\n◎ Photo by Hannah Lin blog\n\n同源策略(Same-Origin Policy)最早由 Netscape 公司提出，是一種重要的安全機制，它限制一個來源載入的文件或腳本如何與另一個來源的資源互動。\n同源： 只要 scheme、domain、port 一樣就會被視為同源 (same-origin)，其他則是不同源\n跨域： 違背同源策略就是跨域\n\n◎ Photo by Hannah Lin blog\n[補充]在以下情況跨來源被允許，不受同源策略限制跨來源嵌入通常被允許 (embed)\n跨來源嵌入允許在網頁中嵌入來自其他源的資源，包括但不限於 JavaScript 文件、CSS 樣式表、圖片、視頻、字體等。這些嵌入的資源可以通過 &lt;script&gt;、&lt;link&gt;、&lt;iframe&gt;、&lt;img&gt;、&lt;video&gt;、或是 @font-face&lt;object&gt;、&lt;embed&gt; 等標籤來實現。\n\n\n\n\n\n\n\n\n\n儘管跨來源嵌入是被允許的，但是網站開發者應該注意安全問題，確保嵌入的資源來源可靠，避免引入安全漏洞或惡意代碼。\n跨來源寫入通常被允許 (writes)\n跨來源寫入允許在一個網站上的表單（&lt;form&gt;）中，向另一個不同源的網站提交數據。這包括在表單中使用 action 屬性指向不同源的網站、通過連結 (&lt;a&gt; 標籤) 或重定向 (redirect) 到其他網站。\n跨來源讀取通常被禁止 (reads)\ndomain-a.com 不能讀取 domain-b.com 的 cookie、XMLHttpRequest ，Fetch API 也都無法被讀取，會回報錯誤\n◎ Photo by Hannah Lin blog\n2.如何解決跨域2.1 JSONP\n\n\n\n\n\n\n\n\njsonp 只支持 get 請求不支持 post 請求\n1. JSONP 簡述JSONP(JSON with Padding)，是一個非官方的跨域解決方案，憑藉工程師的聰明才智開發出來，只支援 get 請求。\n2. JSONP 原理在網頁有一些標籤天生具有跨域能力，比如：&lt;script&gt;、&lt;link&gt;、&lt;iframe&gt;、&lt;img&gt;。JSONP 透過使用 script 標籤的跨域能力來發送請求的。\n3. JSONP 風險JSONP 的優點在於它的兼容性和簡單易用性，但也存在一些安全風險，比如可能遭受到 XSS（跨站腳本攻擊）等攻擊。因此，在使用 JSONP 時，需要注意安全性問題，確保來源的可靠性和數據的完整性。\n3. JSONP 的使用html 代碼\n1234567891011//1. 創建 script 標籤const script = document.createElement(&quot;script&quot;);//2. 設置標籤的 src 屬性script.src = &quot;http://127.0.0.1:8000/check-username?callback=abc&quot;;//3. 將script 加入到body 中document.body.appendChild(script);// 名為 abc 的回調函數function abc(data) &#123;  alert(data.name);&#125;\n\nnodejs 代碼\n12345678910app.get(&quot;/check-username&quot;, function (req, res) &#123;  var callback = req.query.callback;  const data = &#123;    name: &quot;孫悟空&quot;,  &#125;;  //將資料轉化為字串  let str = JSON.stringify(data);  //返回結果(一段可執行的JavaScript代碼)  response.end(`handle($&#123;str&#125;)`);&#125;);\n\n2.2 CORS跨來源資源共用（CORS）\n\nCORS 是什麼？CORS（Cross-Origin Resource Sharing），跨域資源分享。CORS 是官方的跨域解決方案，它的特點是不需要在用戶端做任何特殊的操作，完全在伺服器中進行處理，支持 get 和 post 請求。跨域資源分享標準新增了一組 HTTP 首部欄位，允許伺服器聲明哪些源站通過瀏覽器有許可權訪問哪些資源\n\nCORS 怎麼工作的？CORS 的工作方式是通過在 HTTP 響應標頭中添加特定的 CORS 標頭來告訴瀏覽器是否允許來自不同源的請求。當瀏覽器發送一個跨域請求時，伺服器在收到請求後，會檢查請求中的 Origin 標頭，然後決定是否允許該請求。如果伺服器允許跨域請求，則會在響應中添加一個 Access-Control-Allow-Origin 標頭，指定允許的來源。瀏覽器收到這個響應後，就會允許該請求，否則將會拒絕該請求。\n\nCORS 的使用\n\n\n主要是伺服器端的設置：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import express from &quot;express&quot;;import cors from &quot;cors&quot;; // 引入 cors 套件import multer from &quot;multer&quot;;// 預設的 express.json() 和 express.urlencoded() 中間件不能解析 multipart/form-data// 要解析這種格式的要求，需要使用像 multer 這樣的第三方模組const upload = multer();// 定義允許跨來源請求的來源白名單// 流覽器在發出預檢請求時不會包含 Origin header，所以在你的 CORS callback 中的 origin 參數可能是 undefined// 1.所以修正的方式可以在 whitelist 加上 undefinedconst whitelist = [  &quot;http://localhost:5500&quot;,  &quot;http://localhost:3000&quot;,  &quot;http://127.0.0.1:5500&quot;,  undefined,];// 設置 CORS 選項const corsOptions = &#123;  credentials: true, // 允許包含凭證的請求  origin(origin, callback) &#123;    // 檢查請求的來源是否在白名單中    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    // 2. 另一種修正方式 是維持原來的 whitelist，但在 callback 上多一個判斷，判斷有沒有 origin    // if (!origin || whitelist.includes(origin)) &#123;    // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■    if (whitelist.includes(origin)) &#123;      callback(null, true); // 允許請求    &#125; else &#123;      callback(new Error(&quot;不允許傳遞資料&quot;)); // 拒絕請求    &#125;  &#125;,&#125;;const app = express();// 使用 CORS 中間件，並傳遞定制的 CORS 選項app.use(cors(corsOptions));// 使用 express.json() 解析 JSON 請求主體app.use(express.json());// 使用 express.urlencoded() 解析 URL 編碼請求主體app.use(express.urlencoded(&#123; extended: true &#125;));app.get(&quot;/&quot;, (req, res) =&gt; &#123;  res.send(&quot;首頁&quot;);&#125;);app.post(&quot;/&quot;, upload.none(), (req, res) =&gt; &#123;  console.log(req.body);  res.json(&#123; message: &quot;welcome&quot; &#125;);&#125;);app.listen(3000, () =&gt; &#123;  console.log(&quot;running at http://localhost:3000&quot;);&#125;);\n\n用戶端傳遞資料範例\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;title&gt;Title&lt;/title&gt;    &lt;!-- Required meta tags --&gt;    &lt;meta charset=&quot;utf-8&quot; /&gt;    &lt;meta      name=&quot;viewport&quot;      content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;    /&gt;    &lt;!-- Bootstrap CSS v5.2.1 --&gt;    &lt;link      href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css&quot;      rel=&quot;stylesheet&quot;      integrity=&quot;sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN&quot;      crossorigin=&quot;anonymous&quot;    /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;container p-3&quot;&gt;      &lt;form name=&quot;form1&quot; action=&quot;http://localhost:3000&quot; method=&quot;post&quot;&gt;        &lt;div class=&quot;input-group input-group-lg mb-2&quot;&gt;          &lt;span class=&quot;input-group-text&quot;&gt;ID&lt;/span&gt;          &lt;input type=&quot;text&quot; name=&quot;userID&quot; class=&quot;form-control&quot; /&gt;        &lt;/div&gt;        &lt;div class=&quot;input-group input-group-lg mb-2&quot;&gt;          &lt;span class=&quot;input-group-text&quot;&gt;PWD&lt;/span&gt;          &lt;input type=&quot;text&quot; name=&quot;userPWD&quot; class=&quot;form-control&quot; /&gt;        &lt;/div&gt;        &lt;div class=&quot;d-flex&quot;&gt;          &lt;!-- &lt;div class=&quot;btn btn-primary btn-lg ms-auto btn-send&quot;&gt;Send&lt;/div&gt; --&gt;          &lt;button class=&quot;btn btn-primary btn-lg ms-auto btn-send&quot; type=&quot;submit&quot;&gt;            send          &lt;/button&gt;        &lt;/div&gt;      &lt;/form&gt;    &lt;/div&gt;    &lt;script&gt;      const btnSend = document.querySelector(&quot;.btn-send&quot;); // 選取具有 .btn-send 類別的按鈕元素      btnSend.addEventListener(&quot;click&quot;, (e) =&gt; &#123;        // 添加點擊事件監聽器        // 把送出表單的行為擋掉，因為現在是想用 fetch 的方式送出表單，而不是用表單元素送出        e.preventDefault(); // 防止默認行為，通常是防止表單的提交        let form = document.querySelector(&quot;form&quot;); // 選取表單元素        // 當不是使用 HTML 的 submit 按鈕送出表單時，就要使用 FormData 來建置符合 HTML 表單送出內容格式的資料，這樣後端程式才能接得到        let formData = new FormData(form); // 建立 FormData 物件，用於儲存表單數據        // ■■■撈取物件的方式■■■■■■■■■■■■■■■■■■■■■■■■        // 觀察資料用，實務上不用這段        for (let [key, value] of formData.entries()) &#123;          console.log(`$&#123;key&#125;: $&#123;value&#125;`); // 迭代 FormData 物件，輸出每個鍵值對的內容        &#125;        // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■        let url = &quot;http://localhost:3000/&quot;; // 設置發送 POST 請求的目標 URL        fetch(url, &#123;          // 使用 fetch API 發送 POST 請求          method: &quot;POST&quot;, // 指定請求方法為 POST          body: formData, // 將表單數據作為請求主體          credentials: &quot;include&quot;, // 包括跨站請求中的凭證        &#125;)          .then((response) =&gt; &#123;            return response.json(); // 將服務器的回應解析為 JSON 格式          &#125;)          .then((result) =&gt; &#123;            console.log(result); // 處理從服務器返回的 JSON 數據          &#125;)          .catch((error) =&gt; &#123;            console.log(error); // 處理錯誤          &#125;);      &#125;);    &lt;/script&gt;    &lt;script      src=&quot;https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js&quot;      integrity=&quot;sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r&quot;      crossorigin=&quot;anonymous&quot;    &gt;&lt;/script&gt;    &lt;script      src=&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js&quot;      integrity=&quot;sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+&quot;      crossorigin=&quot;anonymous&quot;    &gt;&lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;\n","slug":"AJAX05 【跨域初識-跨來源資源共用（CORS）】","date":"2024-01-15T13:52:05.000Z","categories_index":"AJAX","tags_index":"AJAX,jQuery,桃園資展筆記,node.js","author_index":"Hsu's Blog"},{"id":"92da9106fb683f4d6b08c8fcca39f76e","title":"AJAX、Axios、Fetch差異","content":"04【AJAX、Axios、Fetch差異】前言在前端開發中，與後端互動的重要途徑之一就是「請求」。三種常見的網路請求方式：Ajax、Fetch、以及 axios。這些名詞都用來發送網路請求，但它們有不同的特點和使用方式。\n1. Ajax(Asynchronous JavaScript And XML)AJAX (Asynchronous JavaScript and XML) 是一種在不重新加載整個網頁的情況下，通過後台發送 HTTP 請求和接收回應的技術。特點:實現局部刷新頁面，避免整個頁面的重新載入。\nXMLHttpRequest 是實作 Ajax 的一種方式，常被用來發送網路請求，目前較流行使用 json 的方式。\n利用 XMLHttpRequest 模組實作 Ajax。若使用 JSON 要使用 JSON.parse() 將收到的 JSON 字串解析為 JavaScript 物件\n1234567891011121314151617181920function ajax(url) &#123;  const xhr = new XMLHttpRequest();  xhr.open(&quot;get&quot;, url, false);  xhr.onreadystatechange = function () &#123;    if (xhr.readyState === 4) &#123;      if (xhr.status === 200) &#123;        // 1. 使用XMLHttpRequest 實作的方式■■■■■■■■■■■        console.info(&quot;響應結果&quot;, xhr.response);        // 2. 使用JSON 實作的方式■■■■■■■■■■■■■■■■■■■■■        // // 將收到的 JSON 字串解析為 JavaScript 物件        // // responseText 是 XMLHttpRequest 物件的屬性之一，它用於獲取從伺服器返回的響應資料，以純文字字符串的形式表示。        // const responseData = JSON.parse(xhr.responseText);        // console.info(&quot;響應結果&quot;, responseData);        // ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■      &#125;    &#125;  &#125;;  xhr.send(null);&#125;ajax(&quot;https://api.example.com/data&quot;);\n\n輸出結果：\n這裡利用 XMLHttpRequest 模組實作了一個最簡單的 get 網路請求。注意：我們使用這種方式實現網路請求時，如果請求內部又包含請求，以此循環，就會出現回調地獄，這也是一個詬病，後來才催生了更優雅的請求方式。\n2.AxiosAxios: Vue 專案中廣泛應用的網路請求庫Axios 是一個網路請求庫，隨著 Vue 框架的興起而在前端開發中廣泛應用。它並非一個思想或原生 API，而是一個封裝函式庫，專為處理網路請求而設計。以下是 Axios 的特點和使用情境：\n特點：\n\n基於 Promise 封裝：Axios 使用 Promise 對網路請求進行封裝，使得處理異步操作更加容易。\n跨環境支援：\n\n\n從瀏覽器中建立 XMLHttpRequests。\n從 Node.js 中建立 http 請求。\n\n\nPromise API 支援：使用 Promise 作為異步操作的標準，讓程式碼更具可讀性。\n攔截請求和回應：提供攔截器，可以在發送請求或接收回應時進行攔截處理。\n數據轉換：\n\n\n轉換請求數據：自動將請求數據轉換為特定格式，例如 JSON。\n轉換回應數據：自動將回應數據轉換為 JavaScript 對象。\n\n\n取消請求：提供取消請求的機制，避免不必要的請求發送。\n自動轉換 JSON 數據：在發送和接收過程中自動處理 JSON 格式的數據。\n客戶端支援防禦 XSRF：提供機制防禦跨站請求偽造（XSRF）攻擊。\n\n使用情境：\n\n在 Vue 專案中，絕大多數的網路請求是透過 Axios 發起的。\n適用於各種網路請求場景，包括 GET、POST 等。\n由於提供了豐富的功能和良好的 API 設計，使得在處理複雜的網路請求時更加方便。\n\n\n\n\n\n\n\n\n\n\n總的來說，Axios 不僅是 XMLHttpRequest（XHR）的二次封裝，也是 Ajax 思想的延伸。在實際應用中，Axios 為前端開發者提供了一個強大而便捷的工具，使得處理網路請求變得更加優雅和有效。\n12345678axios  .get(&quot;https://api.example.com/data&quot;)  .then(function (response) &#123;    console.log(response.data);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);\n\n3.Fetch定義: Fetch 是 ES6 引入的 API，基於 Promise 物件，取代了 XMLHttpRequest，提供更簡潔的使用方式。\n特點:\n\n支援 Promise，使得處理異步請求更加方便，不使用回呼函數。\n模組化設計，如 Response、Request 等物件分散開來，更友善。\n透過資料流物件處理數據，提高網站效能。\n\n缺點它不自動傳遞或接收 cookies，並且不能取消請求，這些功能需要額外的處理。\n12345678910fetch(&quot;https://api.example.com/data&quot;)  .then(function (response) &#123;    return response.json();  &#125;)  .then(function (data) &#123;    console.log(data);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);\n\n輸出結果：\n上段程式碼利用 Fetch 發送了一個最簡單的 get 請求，其中最重要的特點之一就是採用了.then 鏈式呼叫的方式處理結果，這樣不僅利於程式碼的可讀，而且也解決了回呼地獄的問題。\n總結\nAjax、Fetch、axios 三者之間的關係可以用一張圖來清楚的表示，如圖：\n\n\n\n\n\n功能&#x2F;特性\nAJAX\nAxios\nFetch\n\n\n\n特點\n一種技術統稱，主要利用 XHR 實現網路請求\n一個封裝庫，基於 XHR 封裝\n具體 API，基於 Promise，實現網路請求\n\n\nPromise\n否\n是\n是\n\n\n瀏覽器支援\n原生\n需要引入庫\n部分現代瀏覽器\n\n\nAPI 簡潔性\n較複雜\n簡潔且易於使用\n簡潔且易於使用\n\n\n攔截器\n不支援\n支援\n不支援\n\n\n請求取消\n不支援\n支援\n不支援\n\n\n跨域請求\n需要額外處理\n需要額外處理\n與瀏覽器的 CORS 機制整合\n\n\n","slug":"AJAX04【AJAX、Axios、Fetch差異】","date":"2024-01-03T02:22:05.000Z","categories_index":"AJAX","tags_index":"AJAX,桃園資展筆記,Axios,Fetch","author_index":"Hsu's Blog"},{"id":"9a2aa4a955d2779579e86c05e126bfd4","title":"AJAX 概述和基本使用","content":"01 【AJAX 概述和基本使用】1.AJAX 簡介AJAX 全稱為 Asynchronous JavaScript And XML，是一種用於在網頁上以非同步方式傳輸資料的技術。它允許在不重新載入整個網頁的情況下，使用 JavaScript 從伺服器獲取資料、更新網頁內容，並與伺服器進行互動。AJAX 不是新的程式設計語言，而是一種將現有的標準組合在一起使用的新方式\n\n\n\n\n\n\n\n\n\nAJAX 名稱中包含 「XML」，但實際上 AJAX 可以使用多種格式的資料進行傳輸，如 JSON、HTML、純文字等。XML 在過去常用於 AJAX，但現在 JSON 成為更常見的選擇，因為它更輕量且易於處理\n2.AJAX 的特點2.1 AJAX 的優點\n無需重新整理頁面而與伺服器端進行通信： AJAX 允許部分頁面內容的動態更新，不必重新載入整個頁面。\n\n允許在背景下發送請求、接收回應並處理資料： AJAX 是非同步的，允許瀏覽器在背景下發送 HTTP 請求，並在收到伺服器的回應後處理資料。使用者可以同時進行其他操作，不會被阻塞。\n\n\n2.2 AJAX 的缺點\n沒有瀏覽歷史，不能回退： 在某些情況下，使用 AJAX 可能導致瀏覽器不正確地記錄瀏覽歷史，使得無法使用瀏覽器的回退按鈕進行上一步操作。這個問題可以通過在 AJAX 操作時手動更新瀏覽器的歷史狀態來解決，例如使用 HTML5 History API。\n\n存在跨域問題（同源策略）： AJAX 受到瀏覽器的同源策略的限制，意味著網頁只能向與其自身相同來源的伺服器發送 AJAX 請求。跨域請求可能需要使用跨域資源共享（CORS）等技術來解決。\n\n對搜索引擎優化（SEO）不友好： 傳統的 AJAX 加載內容可能對搜索引擎的爬取和索引造成困難，因為搜索引擎通常無法執行 JavaScript 以獲取動態生成的內容。然而，現代的搜索引擎已經能夠執行 JavaScript 並索引動態生成的內容，因此這個問題已經在某種程度上得到改善。\n\n\n2.HTTP 相關問題2.1 MDN 文檔https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n2.2 HTTP 請求互動的基本過程\n\n前後應用從瀏覽器端向伺服器發送 HTTP 請求(請求報文)\n後臺伺服器接收到請求後, 調度伺服器應用處理請求, 向瀏覽器端返回 HTTP 回應(回應報文)\n瀏覽器端接收到回應, 解析顯示回應體&#x2F;調用監視回檔\n\n2.3 HTTP 報文HTTP（hypertext transport protocol）協定『超文字傳輸協定』，是一種用於瀏覽器和網頁伺服器之間進行通信的協議，它細緻地定義了通信的規則和格式。\n2.3.1 請求報文格式與參數\n\n行： 指定請求的方法（如 GET、POST）、資源位置（URI）和所使用的 HTTP 版本。\n\n頭： 包含額外的請求資訊，如主機地址（Host）、Cookie、內容類型（Content-Type）和用戶代理（User-Agent）等。\n\n空行： 表示頭部的結束，後面即將開始請求體。\n\n體： 包含請求所攜帶的資料，僅在 POST 請求中存在。\n\n\nPOST 請求\n123456行      POST  /submit_form HTTP/1.1頭      Host: www.example.com        Content-Type: application/x-www-form-urlencoded        Content-Length: 25空行體      username=admin&amp;password=123\n\nGET 請求\n123456789行      GET /index.html HTTP/1.1頭      Host: www.example.com        User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8        Accept-Language: en-US,en;q=0.5        Accept-Encoding: gzip, deflate        Connection: keep-alive空行體      GET請求通常沒有請求體，故此示例請求體為空\n\n\n\n\n\n\n\n\n\n\n注:post 請求才有請求體\nRequest Headers\n\n\n\nRequest Headers\n說明\n\n\n\n接受 (Accept)\n瀏覽器可以接受的資料格式（例如：_&#x2F;_）\n\n\n接受語言 (Accept-Language)\n用戶端希望接收的語言類型（例如：zh-TW, en-US）\n\n\n連線 (Connection)\n維護用戶端和服務端之間的連接狀態（例如：Keep-Alive）\n\n\n主機 (Host)\n連接的目標主機和埠號（例如：localhost:8080）\n\n\n用戶代理 (User-Agent)\n用戶端的應用程式名稱和版本號\n\n\n接受編碼 (Accept-Encoding)\n用戶端可以接受的壓縮資料類型（例如：gzip）\n\n\nCookie\n用戶端暫存的服務端資訊\n\n\n內容類型 (Content-Type)\n發送資料的格式，GET 請求通常沒有（例如：application&#x2F;json）\n\n\n2.3.2 回應報文1234567891011121314行      HTTP/1.1  200  OK頭      Content-Type: text/html; charset=utf-8        Content-Length: 1234        Content-encoding: gzip空行體      &lt;html&gt;            &lt;head&gt;            &lt;/head&gt;            &lt;body&gt;                &lt;h1&gt;Welcome to Sample Page&lt;/h1&gt;                &lt;p&gt;This is a sample HTML page.&lt;/p&gt;            &lt;/body&gt;        &lt;/html&gt;        (html 文本/json 文本/js/css/圖片...)\n\n\n\n\n\n\n\n\n\n\n\n\n負載(Payload)用來查看請求發送的查詢字串和 form data\nPreview 用來查看解析後的返回資料\nResponse 用來查看返回資料\n\nResponse Headers\n\n\n\nResponse Headers\n說明\n\n\n\nContent-Type\n伺服器發送的類型及採用的編碼方式（例如：text&#x2F;html; charset&#x3D;utf-8）\n\n\nContent-Encoding\n伺服器能夠發送的壓縮編碼類型（例如：gzip）\n\n\nContent-Length\n伺服器發送的壓縮資料的長度（例如：128）\n\n\nSet-Cookie\n伺服器發送到客戶端的暫存資料\n\n\nCache-Control\n快取相關\n\n\nLast-Modified\n快取相關\n\n\nEtag\n快取相關\n\n\n2.3.3 post 請求體參數格式\n\n\n\n\n\n\n\n\n　用 js 傳送表單，如果資料不是以 formData 格式傳出，才需考慮設定 Conntent-Type\n\nContent-Type: application&#x2F;x-www-form-urlencoded;charset&#x3D;utf-8這是最常見的 POST 請求體格式之一，用於將表單數據發送到伺服器。鍵&#x2F;值對使用等號 (=) 連接，並使用和號 (&amp;) 分隔。例如：例如: name=John+Doe&amp;age=30&amp;email=john.doe@example.com\n\nContent-Type: application&#x2F;json;charset&#x3D;utf-8用於發送 JSON 格式的數據。這通常用於 API 通訊，用戶端將 JSON 對象作為請求主體發送到伺服器。例如: &#123;&quot;name&quot;: &quot;%E5%B0%8F%E6%98%8E&quot;, &quot;age&quot;: 12&#125;\n\n(了解即可，暫時遇不到) Content-Type: multipart&#x2F;form-data這種格式用於上傳文件和二進制數據。它允許在同一個 POST 請求中發送文本和二進制數據。每個數據部分都有自己的 Content-Type，並且每個部分都是獨立的。\n\nContent-Type: text&#x2F;plain這種格式用於純文本數據，沒有特定的結構。這通常用於簡單的文本消息或自定義格式的請求體。例如:This is a plain text message.\n\n\n2.4 常見的回應狀態碼HTTP 協議中常見的狀態碼\n\n\n\n狀態碼\n說明\n\n\n\n1xx\n指示資訊，表示請求已接收，繼續處理\n\n\n2xx\n成功，表示請求已被成功接收\n\n\n3xx\n重定向，要完成請求必須進行更進一步的操作\n\n\n4xx\n用戶端錯誤，請求有語法錯誤或請求無法實現\n\n\n5xx\n伺服器錯誤，伺服器未能實現合法的請求\n\n\n\n\n\n\n\n\n\n\n\n補充:\nreadyState 所有可能的值如下：\n\n0（還沒開始）\n1（讀取中）\n2（已讀取）\n3（資訊交換中）\n\n狀態碼用於描述 HTTP 請求的結果，而 readyState 屬性則用於描述 XMLHttpRequest 物件的通信狀態。它們描述了不同層面的通信和處理過程。\n常見的 http 狀態碼\n\n\n\n狀態碼\n說明\n\n\n\n200\n用戶端請求成功\n\n\n206\n客戶端發送帶有 range 頭的 GET 請求，伺服器完成了它\n\n\n301\n重定向（永久）\n\n\n302\n重定向（臨時）\n\n\n304\n資源未被修改，有緩存\n\n\n403\n請求被拒絕\n\n\n404\n資源未找到\n\n\n500\n伺服器錯誤\n\n\n504\n閘道超時\n\n\n2.5 不同類型的請求及其作用\nGET: 從伺服器端讀取數據（查）\nPOST: 向伺服器端加入新數據 （增）\nPUT: 更新資源 （改）\nDELETE: 刪除伺服器端資料 （刪）\n\n3. AJAX 的基本使用3.1 理解\nLow-Level Interface (低階介面):\n\n\n\n\n\n\n\n\n\n例如:$.ajax()方法即是低階介面\n\n直接使用 AJAX 方法的原始和底層方式來進行 AJAX 請求和處理。\n相對於使用 jQuery 提供的高階方法（High-Level Interface）而言。提供更細粒度的控制和靈活性，可以根據特定需求自定義 AJAX 請求的行為和處理方式。\n直接使用 XMLHttpRequest（XHR）對象來執行請求，並提供一系列方法和屬性來設置請求參數、處理回應數據和監聽事件。\n可以更深入地了解和掌握 AJAX 的內部運作機制，同時也可以根據具體需求進行更細節的控制和定製。\n適用於對 AJAX 請求有特殊要求的情境，或者希望直接操作 XHR 對象的開發者。\n\n\nHigh-Level Interface (高階介面):\n\n\n\n\n\n\n\n\n\n使用單一例如:$.get()、$.getJSON()、$.getScript()方法即是高階介面\n\n使用 jQuery 提供的方法來進行 AJAX 請求和處理。\n提供了更簡潔、抽象的 API，使得處理 AJAX 請求變得更容易和直觀。\n隱藏了底層的細節，讓開發者可以專注於請求的邏輯而不用擔心底層實現。\n提供了便捷的方法來處理請求成功和失敗的情況，以及其他常見的 AJAX 功能。\n可以快速地發送請求並處理回應，減少了開發時間和代碼量。\n適用於大多數情況下，尤其是對於常見的 AJAX 功能和一般性需求。\n\n\n\n3.2 低階介面 AJAX 使用步驟12345678$.ajax(&#123;  method: &quot;POST OR GET&quot;,  url: &quot;網址&quot;,  data: &quot;字串、數字、物件或陣列&quot;,  dataType: &quot;xml、html、script、json、jsonp 或 text&quot;,&#125;)  .done(function () &#123;&#125;)  .fail(function () &#123;&#125;);\n\n$.ajax() 方法:\n\nmethod: 指定傳輸的方法，可以是 POST 或 GET。\n\nurl: 指定目標網址。\n\ndata: 要傳輸到目標網址的內容，可以是字串、數字、物件或陣列，有時也不需要傳輸過去。\n\ndataType: 指定回傳內容的型態，可以是 xml、html、script、json、jsonp 或 text 等。處理成功和失敗:\n\n使用 .done() 方法來處理傳輸成功時要做的事，小括號中會放一個處理函數。\n\n使用 .fail() 方法來處理傳輸失敗時要做的事，小括號中會放一個處理函數。\n\n\n3.3 Shorthand Methods 方法\nShorthand Methods 是 jQuery 中的簡潔方法，提供方便的快捷方式來執行常見任務和操作。\n方法通常以簡短、易於記憶的形式存在，可以大大簡化編寫程式碼的過程，同時保持可讀性和清晰度。\nShorthand Methods 包括事件處理、元素選擇、樣式操作、動畫效果等常見操作，命名根據目的和行為使其易於理解和使用，如 .click()、.addClass()、.text()、.fadeIn() 等。\n使用 Shorthand Methods 可使程式碼更簡潔、易於閱讀和維護，提高開發效率，減少重複代碼。但要注意方法是否已被廢棄。\nAJAX 提供了幾個 Shorthand Methods，根據傳輸方式及取用內容，可用較少的參數設置來達到與 $.ajax() 一樣的效果。\n\n3.3.1 $.get() 請求1$.get(url, data, function () &#123;&#125;, dataType);\n\n\ndata 及 dataType 則不一定要填\ndataType 是傳入執行函數的型態，如果不填的話，jQuery 會自動判別，但盡量還是將其填上\n\nGET 請求設置請求參數\n設置 url 參數\n12345678910111213$.get(  &quot;http://example.com/api/data&quot;,  function (data) &#123;    console.log(data);  &#125;,  &quot;html&quot;)  .done(function (response) &#123;    console.log(&quot;Success:&quot;, response);  &#125;)  .fail(function (error) &#123;    console.error(&quot;Error:&quot;, error);  &#125;);\n\n\n.done() 來接成功時的處理\n.fail() 來接失敗時的處理\n\n3.3.2 $.getJSON() 請求1$.getJSON(url, data, function () &#123;&#125;);\n\n\n專門用來處理回傳內容是 JSON 的特別方法是 $.getJSON()。\n\n如果成功回傳，$.getJSON() 會自動將回傳內容轉換為物件型態。\n\n如果回傳內容不是 JSON 格式，則會自動進入 .fail() 流程。\n\n\n練習範例:\n1234let url = &quot;https://sagedaben.com/iSpan/api/spot.php&quot;;$.getJSON(url, function (data) &#123;  console.log(data);&#125;);\n\n3.3.3 $.getScript() 請求1$.getJSON(url, function () &#123;&#125;);\n\n\n專門用來載入外部 javaScript 檔用的特化方法\n專入成功會自動附加到文件上，不需要特別寫成功時的函數去執行，但有需要的話仍會在成功時的時間點觸發\n\n1234let url = &quot;https://sagedaben.com/iSpan/api/file.php?file=setBtn.js&quot;;$.getScript(url, function (data) &#123;  console.log(data);&#125;);\n\n\n放一個 class 為 btn 的任何物件\n再載入上面的網址\n載入後，.btn 就有 click 事件，會跳 alert 小視窗\n\n3.3.4 post 請求1$.post(url, data, function () &#123;&#125;, dataType);\n\n\n\n\n\n\n\n\n\n\n專門用來 post 到指定網址用的方法\n12345678910111213141516171819var url = &quot;http://example.com/api/data&quot;;var data = &#123;  username: &quot;john_doe&quot;,  password: &quot;secretpassword&quot;,&#125;;var dataType = &quot;json&quot;;$.post(  url,  data,  function (response) &#123;    // 成功回調函式，在這裡處理成功回傳的資料    console.log(&quot;Success:&quot;, response);  &#125;,  dataType).fail(function (error) &#123;  // 失敗回調函式，在這裡處理請求失敗的情況  console.error(&quot;Error:&quot;, error);&#125;);\n\n3.2.3 .load()1$().load(url, data, fucntion()&#123;&#125;)\n\n\n\n\n\n\n\n\n\n\n不送出資料，不寫成功函數，當載入成功時一樣會自動把內容變成該物件的 HTML\n12let url = &quot;https://sagedaben.com/iSpan/api/file.php?file=b.html&quot;;$(&quot;.block&quot;).load(url);\n\n\njQuery 物件的方法，會載入指定網址內容變成該物件的 HTML\n\n1$(&quot;.block&quot;).load(&quot;https://sagedaben.com/iSpan/api/file.php?file=d.html .area3&quot;);\n\n\n專入網址後，可以再進一步的指定要載入的內容區塊\n\n3.3 API 總結使用 jQuery 的 AJAX 方法可以方便地發送各種類型的請求，並且提供了豐富的選項和方法來處理請求的不同情況，這使得 AJAX 開發變得更加靈活和便捷。\n4. [補充]原生 AJAX 的基本使用4.1 理解\n使用XMLHttpRequest (XHR)物件可以與伺服器互動, 也就是發送 ajax 請求\n前端可以獲取到資料，而無需讓整個的頁面重新整理。\n這使得 Web 頁面可以只更新頁面的局部，而不影響使用者的操作。\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequestXMLHttpRequest，AJAX 的所有操作都是通過該物件進行的\n4.2 使用步驟123456789101112131415161718192021const xhttp = new XMLHttpRequest();// 請求方式xhttp.open(method, url);//可以設置請求頭，一般不設置xhttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);//get請求不傳 body 參數，只有post請求使用xhttp.send(body);// 事件綁定 處理服務端返回的結果// on  when 當....時候// readystate 是 xhttp 物件中的屬性, 表示狀態 0 1 2 3 4//狀態 0 表示未初始化  1 open方法調用完畢 2 send方法已經調用完畢 3 服務端返回部分結果 4 服務端返回了所有結果// change  改變xhttp.onreadystatechange = function () &#123;  //判斷 (服務端返回了所有的結果)  if (xhttp.readyState == 4 &amp;&amp; xhttp.status == 200) &#123;    console.log(xhttp.status); //狀態碼    console.log(xhttp.statusText); //狀態字串    console.log(xhttp.getAllResponseHeaders()); //所有回應頭    console.log(xhttp.response); //回應體  &#125;&#125;;\n\n4.2.1 get 請求123456789101112131415161718192021222324//  創建對象const xhttp = new XMLHttpRequest();// 2. 初始化 設置請求方法和urlxhttp.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/server&quot;);// 3. 發送xhttp.send();// 4. 事件綁定 處理服務端返回的結果xhttp.onreadystatechange = function () &#123;  // readyState 是 xhttp 物件中的屬性, 表示狀態 0 1 2 3 4  //判斷 (服務端返回了所有的結果)  if (xhttp.readyState === 4) &#123;    //判斷回應狀態碼 200  404  403 401 500    if (xhttp.status &gt;= 200 &amp;&amp; xhttp.status &lt; 300) &#123;      // 處理結果 行 頭 空行 體      // 回應      console.log(&quot;狀態碼&quot;, xhttp.status); // 狀態碼      console.log(&quot;狀態字串&quot;, xhttp.statusText); // 狀態字串      console.log(&quot;所有回應頭&quot;, xhttp.getAllResponseHeaders()); // 所有回應頭      console.log(&quot;回應體&quot;, xhttp.response); // 回應體      //設置 result 的文本      result.innerHTML = xhttp.response;    &#125;  &#125;&#125;;\n\nGET 請求設置請求參數\n設置 url 參數\n1xhttp.open(&quot;GET&quot;, &quot;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&quot;);\n\n\n\n4.2.2 post 請求1234567891011121314151617181920//  創建對象const xhttp = new XMLHttpRequest();// 2. 初始化 設置類型（請求方式）與urlxhttp.open(&quot;POST&quot;, &quot;http://127.0.0.1:8000/server&quot;);//設置請求頭xhttp.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);// 自訂頭資訊xhttp.setRequesHeader(&quot;name&quot;, &quot;ykyk&quot;);// 3. 發送   設置請求參數（請求體）xhttp.send(&quot;a=100&amp;b=200&amp;c=300&quot;);// 4. 事件綁定xhttp.onreadystatechange = function () &#123;  // 判斷  if (xhttp.readyState === 4) &#123;    if (xhttp.status &gt;= 200 &amp;&amp; xhttp.status &lt; 300) &#123;      // 處理服務端返回的結果      result.innerHTML = xhttp.response;    &#125;  &#125;&#125;;\n\n後端設置\n設置回應頭允許自訂請求頭 post 改成 all\n1response.setHeader(&quot;Access-Control-Allow-Header&quot;, &quot;*&quot;);\n\n4.2.3 取消發送無用的參數有的時候有的參數是可以不填寫的，這時儘管是空串也會隨著請求發過去，我們可以將參數的值設置成undefined，這樣就不會隨請求發過去了\n4.3 請求超時與網路異常12345678910// 超時設置 （2秒） 超過2s請求就取消  status 狀態變成 cancelxhttp.timeout = 2000;// 超時回檔xhttp.ontimeout = function () &#123;  alert(&quot;網路超時，請稍後重試&quot;);&#125;;// 網路異常回檔xhttp.onerror = function () &#123;  alert(&quot;網路異常，請稍後重試&quot;);&#125;;\n\n4.4 取消請求1234//     手動取消請求//    network中的status中pending為等待中//    取消就變成cancelxhttp.abort();\n\n[補充]5 AJAX 請求狀態xhttp.readyState 可以用來查看請求當前的狀態https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState\n\n\n0: 表示 XMLHttpRequest 實例已經生成，但是 open()方法還沒有被調用\n1: 表示 send()方法還沒有被調用，仍然可以使用 setRequestHeader()，設定 HTTP 請求的頭資訊\n2: 表示 send()方法已經執行，並且頭資訊和狀態碼已經收到\n3: 表示正在接收伺服器傳來的 body 部分的資料\n4: 表示伺服器資料已經完全接收，或者本次接收已經失敗了\n\n[補充]6 API 總結\nXMLHttpRequest()：創建 xhttp 物件的構造函式\nstatus：回應狀態碼值，如 200、404\nstatusText：回應狀態文本，如 ’ok‘、‘not found’\nreadyState：標識請求狀態的唯讀屬性 0-1-2-3-4\nonreadystatechange：綁定 readyState 改變的監聽\nresponseType：指定回應資料類型，如果是 ‘json’，得到回應後自動解析回應\nresponse：回應體資料，類型取決於 responseType 的指定\ntimeout：指定請求超時時間，默認為 0 代表沒有限制\nontimeout：綁定超時的監聽\nonerror：綁定請求網路錯誤的監聽\nopen()：初始化一個請求，參數為：(method, url[, async])\nsend(data)：發送請求\nabort()：插斷要求 （發出到返回之間）\ngetResponseHeader(name)：獲取指定名稱的回應頭值\ngetAllResponseHeaders()：獲取所有回應頭組成的字串\nsetRequestHeader(name, value)：設置請求頭\n\n","slug":"AJAX01 【AJAX概述和基本使用】","date":"2024-01-02T01:52:05.000Z","categories_index":"AJAX","tags_index":"AJAX,jQuery,桃園資展筆記","author_index":"Hsu's Blog"},{"id":"2011ff6695f520987816df543df8d79b","title":"photoshop 快捷鍵","content":"圖像處理筆記解析度\n解析度的單位有：\ndpi（點每英寸）\nlpi（線每英寸）\nppi（每英寸像素）\n\n\n“像素” 存在於電腦顯示領域\n“點” 存在於列印或印刷領域\n一般螢幕使用解析度為 72dpi\n彩色印刷一般為 300 或 350 dpi\n\n點陣圖\n不可透明：\nJPG 為失真壓縮標準方法\n\n\n可透明：\nWebP\n同時提供失真與無失真壓縮的圖片檔案格式\n目的在於減少圖片的檔案大小、提高圖片檔案在網路上的傳送時間\n\n\nPNG\n支援無失真壓縮，支援索引、灰度、RGB 三種顏色方案以及 Alpha 通道\n\n\nGif\n以 8 位元色（即 256 種顏色）重現真彩色的圖像\n可透明或不透明，可作動態\n\n\n\n向量圖 SVG\n由向量形式存取物件的圖檔類型\n每一個物件（點、線或面）都是以公式及座標來存取\n無論尺寸大小如何調整，都能透過物件各自的公式、參數精準呈現圖像\n\n色彩模式點陣圖\n以黑白兩種顏色來管理色彩資訊\n\n灰階\n以黑白兩種顏色的明暗來管理色彩資訊，8 位元 256 階\n\n雙色調\n四色內建立灰階、雙色調（2 ～ 4 個色版）進行單色或雙色時使用\n\nRGB\n紅、綠、藍三種顏色來管理色彩資訊，進行螢幕輸出時使用\n\nCMKY\n以青、洋紅、黃、黑四種顏色來管理色彩模式，以 0~100% 的範圍來分配數值，進行油墨印刷輸出時使用\n\nLAB\n以人眼辨識結構來呈現顏色，L 明度：以 0~100 為範圍，A：綠色到紅色軸，B：藍色到青色軸\n\n多重色版\n依照各個色版使用 256 色階灰色的色彩模式\n常用於特殊印刷\n\n","slug":"PS02【基礎知識】","date":"2023-12-18T13:15:32.000Z","categories_index":"photoshop","tags_index":"桃園資展筆記,視覺工具,photoshop","author_index":"Hsu's Blog"},{"id":"2011ff6695f520987816df543df8d79b","title":"photoshop 快捷鍵","content":"01【Photoshop 快捷鍵列表】\n\n\n快捷鍵\n描述\n\n\n\nCtrl + N\n新建文件\n\n\nCtrl + O\n打開文件\n\n\nCtrl + S\n儲存文件\n\n\nCtrl + Shift + S\n另存為\n\n\nCtrl + Z\n撤銷上一步操作\n\n\nCtrl + Shift + Z\n反撤銷上一步操作\n\n\nCtrl + X\n剪下選定的區域或對象\n\n\nCtrl + C\n複製選定的區域或對象\n\n\nCtrl + V\n貼上剪貼板內容\n\n\nCtrl + D\n取消選定\n\n\nCtrl + A\n全選\n\n\nCtrl + T\n自由變換\n\n\nCtrl + Shift + C\n複製所有可見圖層的內容\n\n\nCtrl + Shift + V\n貼上所有可見圖層的內容\n\n\nCtrl + G\n將圖層組合成組\n\n\nCtrl + E\n合併圖層\n\n\nCtrl + J\n複製圖層\n\n\nCtrl + Alt + Z\n回復多次操作\n\n\nCtrl + Alt + Shift + Z\n前進多次操作\n\n\nCtrl + Plus (+)\n放大畫布\n\n\nCtrl + Minus (-)\n縮小畫布\n\n\nCtrl + 0\n適應螢幕大小\n\n\nCtrl + Shift + 0\n實際像素顯示\n\n\nCtrl + Alt + I\n顯示圖像大小\n\n\nCtrl + Alt + Shift + I\n顯示畫布大小\n\n\nCtrl + Alt + Shift + K\n開啟鍵盤快捷鍵設定面板\n\n\nCtrl + R\n顯示&#x2F;隱藏標尺\n\n\nCtrl + H\n顯示&#x2F;隱藏輔助線\n\n\nCtrl + ;\n顯示&#x2F;隱藏網格\n\n\nCtrl + ‘\n鎖定&#x2F;解鎖參考線\n\n\n","slug":"PS01【快捷鍵】","date":"2023-12-18T12:42:58.000Z","categories_index":"photoshop","tags_index":"桃園資展筆記,快捷鍵,視覺工具,photoshop","author_index":"Hsu's Blog"},{"id":"ca0706464cd3c57b83bded93e4a0c449","title":"Figma 快捷鍵","content":"01【快捷鍵】1.常用快捷鍵\n\n\n\n\n\n\n\nCtrl + Shift + ？\n顯示鍵盤快捷鍵\n\n\nCtrl + \\\n隱藏 &#x2F; 顯示側邊欄\n\n\nCtrl + &#x2F;\n搜索\n\n\nCtrl + [\n圖件往後移\n\n\nCtrl + ]\n圖件往前移\n\n\nCtrl + G\n合成群組\n\n\nCtrl + Shift + G\n取消群組\n\n\nI\n取色器\n\n\n2.Tools 工具快捷鍵\n\n\n\n\n\n\n\nV\n移動\n\n\nF\nFrame\n\n\nP\n鋼筆\n\n\nShift + P\n鉛筆\n\n\nT\n文字\n\n\nR\n矩形\n\n\nO\n圓形\n\n\nL\n直線\n\n\nShift + L\n箭頭\n\n\nC\n添加評論\n\n\nS\n切割\n\n\n3.View 圖像快捷鍵\n\n\n\n\n\n\n\nShift + R\n尺標\n\n\nShift + O\n顯示線框\n\n\nCtrl + Shift + L\n物件鎖定\n\n\nAlt + 1\n切換到左側圖層面板\n\n\nAlt + 2\n切換到左側組件面板\n\n\nAlt + 8\n切換到右側設計面板\n\n\nAlt + 9\n切換到右側原型面板\n\n\nAlt + 0\n切換到右側程式碼面板\n\n\n4.Zoom 畫布快捷鍵\n\n\n\n\n\n\n\nSpace + 滑鼠\n拖動畫布\n\n\nCtrl + +\n放大\n\n\nCtrl + -\n縮小\n\n\nCtrl + 0\n畫布放大到 100%\n\n\nShift + 1\n縮放至螢幕合適大小\n\n\nN\n切換畫布(只有橫列)\n\n\nShift + N\n切換畫布\n\n\n5.Text 文字快捷鍵\n\n\n\n\n\n\n\nCtrl + B\n粗體字\n\n\nCtrl + U\n底線\n\n\nCtrl + K\n建立 Link\n\n\nCtrl + Shift + X\n刪除線\n\n\nCtrl + Shift + 7\n條列式(1.)\n\n\nCtrl + Shift + 8\n條列式(點點)\n\n\nCtrl + Alt + L\n文字靠左\n\n\nCtrl + Alt + T\n文字置中\n\n\nCtrl + Alt + R\n文字靠右\n\n\nCtrl + Alt + J\n文字上下左右置中\n\n\nCtrl + Shift + &lt; OR &gt;\n文字放大縮小\n\n\nAlt + &lt; OR &gt;\n文字間距調整\n\n\nShift + Alt + &lt; OR &gt;\n文字字高調整\n\n\n","slug":"FIGMA01【快捷鍵】","date":"2023-12-18T12:41:58.000Z","categories_index":"Figma","tags_index":"桃園資展筆記,Figma,快捷鍵,視覺工具","author_index":"Hsu's Blog"},{"id":"1ef0d77c68d0434927d931f06451670a","title":"gitignore/忽略某些文件","content":"04 【忽略某些文件】在 Git 版本控制系統中，.gitignore文件用於指定哪些文件或文件夾應該被 Git 忽略，不納入版本控制。這在需要排除某些不需要跟踪的文件時特別有用，比如臨時文件、編譯生成的文件、日誌文件等。\n\n創建.gitignore文件：在本地 Git 倉庫中，可以使用 Git Bash 或命令行工具來創建.gitignore文件。在 Windows 系統中，可以使用 Git Bash 來執行 touch .gitignore命令來創建.gitignore文件。\n\n.gitignore規則格式：.gitignore文件使用簡單的模式匹配規則來指定要忽略的文件或文件夾。每行一條規則，可以是文件路徑、文件夾路徑或通配符。\n\n\n\n常見規則寫法\n\n123456789101112131415# 忽略整个文件夹/mtk/# 忽略所有.zip 文件\\*.zip# 忽略某个具体文件/mtk/do.java# 不忽略某个文件!do.java\n\n\n規則優先順序：.gitignore文件中的規則按照出現的順序進行匹配，越靠近文件頂部的規則優先級越高。如果某個文件或文件夾被規則匹配到忽略，則它將被忽略不納入版本控制。\n\n全局忽略：除了在每個倉庫中單獨定義.gitignore文件外，還可以在全局設置中定義全局忽略規則，這對於一些常見的忽略規則很有用。\n\n\n\n\n\n\n\n\n\n\n\n總之，.gitignore文件是管理 Git 倉庫中需要忽略的文件的重要工具，通過適當地配置.gitignore文件，可以使版本控制更加清晰和高效。\n","slug":"GIT04 【gitignore忽略某些文件】","date":"2023-12-05T10:42:08.000Z","categories_index":"git","tags_index":"桃園資展筆記,git,指令列表","author_index":"Hsu's Blog"},{"id":"34c374d5f6028d6959470611bd751584","title":"TailWind CSS 安裝使用","content":"01 【TailWind CSS 安裝使用】\n\n\n\n\n\n\n\n\n簡介：Tailwind CSS 是一個功能類優先的 CSS 框架，它整合了諸如 flex, pt-4, text-center 和 rotate-90 這樣的的類，它們能直接在腳本標記語言中組合起來，建構出任何設計。\n1. [方法一] 使用 CDN 快速體驗 Tailwind CSS\n\n\n\n\n\n\n\n\n使用 Play CDN 直接在瀏覽器中試用 Tailwind，無需任何建構步驟。Play CDN 僅用於開發目的，不是生産的最佳選擇。\n將 Play CDN 腳本標記加入到 HTML 文件的 ，然後開始使用 Tailwind 的實用工具類來設定內容的樣式。&lt;head&gt;\n1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;!-- Play CDN --&gt;    &lt;script src=&quot;https://cdn.tailwindcss.com&quot;&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;flex&quot;&gt;      &lt;div class=&quot;flex-none w-14 h-14 bg-pink-500&quot;&gt;1&lt;/div&gt;      &lt;div class=&quot;flex-initial w-64 bg-red-700&quot;&gt;2&lt;/div&gt;      &lt;div class=&quot;flex-initial w-32 bg-green-50&quot;&gt;3&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\n2. [方法二] 使用 npm 安裝 Tailwind CSS第一步：安裝 Tailwind CSS\n安裝 Tailwind CSS 並創建 tailwind.config.js 配置文件\n123456789# 建立一個名為 demo 的資料夾mkdir demo# 進入 demo 資料夾cd demo# 安裝 Tailwind CSS，-D 參數表示將其作為開發相依性安裝npm install -D tailwindcss# 初始化，此命令會生成 tailwind.config.js 配置檔npx tailwindcss init\n\n\n\n\n\n\n\n\n\n\n1）npm install -D tailwindcss 會生成文件及目錄\nnode_modules package-lock.json package.json\n2）npx tailwindcss init 生成如下配置文件\ntailwind.config.js\n第二步：編輯 tailwind.config.js 配置文件\n加入文件到配置文件中\n1234567891011121314151617module.exports = &#123;  // content 欄位指定需要掃描的檔案，以提取樣式  // 會掃描 ./src 目錄下的所有 HTML 和 JavaScript 檔案  content: [&quot;./src/**/*.&#123;html,js&#125;&quot;],  // theme 欄位用於定義主題，包括顏色、字型大小等  // 在這個例子中，extend 欄位是空的，表示沒有對主題進行額外的擴展。  theme: &#123;    // extend 欄位允許你在已有主題的基礎上進行擴展    extend: &#123;&#125;,  &#125;,  // plugins 欄位用於配置外掛程式  // 外掛程式陣列是空的，表示沒有額外的外掛程式被配置  plugins: [],&#125;;\n\n第三步：加入 Tailwind 樣式指令到 CSS 文件中\n12345678/* 引入 Tailwind CSS 的基本樣式 */@tailwind base;/* 引入 Tailwind CSS 的元件樣式 */@tailwind components;/* 引入 Tailwind CSS 的實用程式類別 */@tailwind utilities;\n\n**@tailwind base;**：這將引入 Tailwind CSS 的基本樣式，通常包括一些重置樣式和一般的 HTML 元素樣式。\n**@tailwind components;**：這將引入 Tailwind CSS 的元件樣式，包括預製的元件樣式，如按鈕、卡片等。\n**@tailwind utilities;**：這將引入 Tailwind CSS 的實用程式類別，這是 Tailwind 的強大之處，提供了大量的快速實用的樣式類別，用於調整元素的外觀和排版。\n\n\n\n\n\n\n\n\n\n若有警告的在 vscode 中安裝PostCSS Language Support插件\n第四步：npm init -y\n第五步：使用 Tailwind Cli 建構 CSS 樣式\n1npx tailwindcss -i ./src/input.css -o ./dist/output.css --watch\n\n該指令會將 src/style.css 中 Tailwind CSS 編譯到 demo/dist/mystyle.css 文件中，mystyle.css 就是編譯後樣式，項目中引入的就是它。\n現在打開 package.json 文件，加入以下執行腳本：\n123&quot;scripts&quot;: &#123;  &quot;build&quot;: &quot;tailwindcss -i ./src/style.css -o ./dist/output.css --watch&quot;&#125;\n\n這時候只要執行npm run build就可以自動監聽你的頁面改動並且實時編譯了。\n第六步：小試牛刀\n經過上面 4 個小步驟，Tailwind CSS 就已經安裝好，下面就來瞅瞅。\n1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;    &lt;link href=&quot;/dist/output.css&quot; rel=&quot;stylesheet&quot; /&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1 class=&quot;text-3xl font-bold underline&quot;&gt;Hello world!&lt;/h1&gt;  &lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n(題外補充) 自動重新整理 HTML 文件不屬於 Tailwind CSS 的範疇，如果在寫靜態頁面的時候，需要每次修改 html 頁面，瀏覽器就自動重新整理這個頁面，那麼只需要在 vscode 內搜索Live Preview並且安裝，之後在你需要預覽的頁面，右鍵，選擇Live Preview：Show Preview即可。\n","slug":"TWCSS01 【TailWind CSS 安裝使用】","date":"2023-12-05T10:42:08.000Z","categories_index":"TailWind CSS","tags_index":"CSS,TailWind CSS","author_index":"Hsu's Blog"},{"id":"8b32b5826583a4eb1fdc583e0a714960","title":"git 指令列表","content":"git 指令列表git指令速查表\n1.切換目錄\n\n\n指令\n描述\n\n\n\ncd 路徑(完整目錄)+目錄\n\n\n\ncd ~\n回家目錄，返回起始目錄\n\n\ncd ..\n回上一層\n\n\n2.取得目前目錄\n\n\n指令\n描述\n\n\n\ncd\nwindows 取得目前所在的位置的指令\n\n\npwd\nMacOS &#x2F; Linux 取得目前所在的位置的指令\n\n\n3.創建和複製\n\n\n指令\n描述\n\n\n\ngit init \n初始化一個新的 Git 倉庫\n\n\ngit clone &lt;URL&gt;\n複製一個遠端倉庫到本地\n\n\n4.基本操作\n\n\n指令\n描述\n\n\n\ngit add &lt;file&gt;\n將文件添加到暫存區\n\n\ngit commit -m &quot;message&quot;\n提交暫存區的變更到本地倉庫\n\n\ngit status\n檢查當前工作目錄中的文件狀態\n\n\ngit log\n查看提交歷史\n\n\n5.分支和合併\n\n\n指令\n描述\n\n\n\ngit branch\n列出本地分支\n\n\ngit branch &lt;branch&gt;\n創建新分支\n\n\ngit checkout &lt;branch&gt;\n切換到指定分支\n\n\ngit merge &lt;branch&gt;\n合併指定分支到當前分支\n\n\ngit branch -d &lt;branch&gt;\n刪除本地分支（安全刪除，確保分支已合併）\n\n\ngit branch -D &lt;branch&gt;\n強制刪除本地分支（不管是否合併）v\n\n\ngit tag &lt;tagname&gt;\n在當前提交上創建一個標籤\n\n\n6.遠端操作\n\n\n指令\n描述\n\n\n\ngit remote -v\n顯示遠端倉庫的 URL\n\n\ngit remote show &lt;remote&gt;\n顯示遠端倉庫的詳細信息\n\n\ngit remote add &lt;name&gt; &lt;URL&gt;\n添加一個新的遠端倉庫\n\n\ngit remote rm &lt;name&gt;\n移除指定的遠端倉庫\n\n\ngit fetch &lt;remote&gt;\n從遠端倉庫拉取最新變更，但不合併到當前分支\n\n\ngit pull\n從遠端倉庫拉取最新變更到本地倉庫\n\n\ngit push\n推送本地變更到遠端倉庫\n\n\n7.查詢和比較\n\n\n指令\n描述\n\n\n\ngit log --oneline --graph --all\n以簡短形式顯示提交歷史和分支結構\n\n\ngit diff\n顯示未暫存的變更\n\n\ngit diff --staged\n顯示已暫存的變更\n\n\ngit show &lt;tagname&gt;\n顯示標籤的詳細信息\n\n\n8.撤銷和還原\n\n\n指令\n描述\n\n\n\ngit reset &lt;file&gt;\n將文件從暫存區中移除，但保留在工作目錄中\n\n\ngit reset &lt;commit&gt;\n將 HEAD 指向指定的提交\n\n\ngit revert &lt;commit&gt;\n創建一個新提交，撤銷指定提交的變更\n\n\ngit checkout -- &lt;file&gt;\n還原文件到最後一次提交的狀態\n\n\n9.子模組\n\n\n指令\n描述\n\n\n\ngit submodule add &lt;URL&gt;\n添加子模組\n\n\ngit submodule init\n初始化子模組\n\n\ngit submodule update\n更新子模組\n\n\n10.日誌和比較\n\n\n指令\n描述\n\n\n\ngit log --grep=&quot;&lt;pattern&gt;&quot;\n根據提交消息中的模式搜索提交\n\n\ngit log --author=&quot;&lt;author&gt;&quot;\n根據作者名稱搜索提交\n\n\ngit log --oneline\n以單行形式顯示簡略的提交歷史\n\n\n11.高級操作\n\n\n指令\n描述\n\n\n\ngit cherry-pick &lt;commit&gt;\n將一個提交應用到當前分支\n\n\ngit rebase &lt;branch&gt;\n將當前分支的變更移動到指定分支之上\n\n\ngit bisect\n用二分法查找引入錯誤的提交\n\n\ngit fsck\n檢查儲存庫的完整性\n\n\n12.全域設定和別名\n\n\n指令\n描述\n\n\n\ngit config --global user.name &quot;&lt;name&gt;&quot;\n設置全局使用者名稱\n\n\ngit config --global user.email &quot;&lt;email&gt;&quot;\n設置全局使用者電子郵件地址\n\n\ngit config --global alias.&lt;alias&gt; &lt;command&gt;\n創建一個全局別名，以簡化長命令\n\n\n13.其他\n\n\n指令\n描述\n\n\n\ngit stash\n暫存當前的變更，將工作目錄恢復到乾淨狀態\n\n\ngit clean -n\n顯示將被刪除的未追蹤文件，使用 -f 執行實際刪除\n\n\ngit reflog\n顯示 HEAD 的歷史，用於找回被刪除的分支或提交\n\n\ngit blame &lt;file&gt;\n顯示文件的每一行是由誰最後修改的\n\n\ngit config --global alias.&lt;alias&gt; &lt;command&gt;\n創建一個全局別名，以簡化長命令\n\n\n","slug":"GIT00 【指令】","date":"2023-12-05T08:42:08.000Z","categories_index":"git","tags_index":"桃園資展筆記,git,指令列表","author_index":"Hsu's Blog"},{"id":"0d39cf4a28042b6e57e14b1a8dcd5529","title":"版本控制和 Git 的安裝介紹","content":"01 【版本控制和 Git 的安裝介紹】工程設計領域中，使用“版本控制”管理工程藍圖的設計過程。在 IT 開發中也可以使用版本控制思想管理代碼的版本叠代。\n1.目的協同修改：支持在伺服器對同一個文件多人協同地修改；資料備份：同時儲存目錄及文件的當前狀態與每次提交時的歷史狀態；版本管理：不儲存版本間的重複資料以節約存儲空間；\n\n\n\n\n\n\n\n\n\n為此，SVN 和 Git 分別採用增量式管理 和文件系統快照 的方式。\n權限控制：對團隊協作者進行權限控制（SVN 和 Git 共有）；審核團隊外開發者貢獻的代碼（Git 獨有）；歷史記錄：查看修改者、修改時間、修改內容、記錄資訊等項目；將本地文件恢複到某一指定的歷史狀態；分支管理：允許開發團隊同時優雅地推進多條生産線任務，提高效率。\n2. 工具版本控制工具是版本控制思想的實現。\n2.1 本地端版本控制\n\n手動控管，人工管理\n常見的版本控制就是按照日期分檔案夾，每過一天就把前一天的檔案複製一份，在新的天數的檔案夾中繼續製作與修改\n這樣的方式只能知道檔案的新增與移除，無法知道內容是否有修改\n\n2.2 集中化版本控制工具如：CVS、SVN、VSS、google 雲端、dropbox、等。\n\n後來演化把檔案放在雲端或共有硬碟上共同管理，像是 google 雲端、dropbox 等\n要使用的時候把最新的抓下來，做完後再傳上雲端或共用硬碟\n僅雲端庫有版本歷史記錄，本地庫僅有最新的版本；\n無法完全避免單點故障的問題。\n\n\n\n\n\n\n\n\n\n\n單點故障：一個主機連接多個處理節點，主節點負責分發任務，而子節點負責處理業務，當主節點發生故障時，會導致整個系統發故障。\n\n\n2.3 分散式版本控制工具\n雲端庫和本地庫都會為各個版本歷史記錄存檔；\n從根本上避免了單點故障。\n\n如：Git、Mercurial、Bazaar、Darcs 等。\n\n3.Git 簡介Git 是一種分散式版本控制系統，因此每個參與專案的人都有完整的版本庫，不需要依賴中央伺服器。\n3.1 Git：分散式版本控制的特色\n每個人都有完整的版本庫：在 Git 中，每個參與專案的人都有一個完整的版本庫，包含了專案的所有歷史記錄和文件。\n\n無需依賴中央伺服器：與集中式版本控制系統不同，Git 不需要中央伺服器來儲存版本庫，每個人的本機版本庫都是獨立的。\n\n工作時不需要連網：由於每個人都有完整的版本庫，因此在工作時不需要連網。每個人可以在本地進行提交、分支、合併等操作。\n\n協作方式：多人協作時，可以透過推送（push）和拉取（pull）操作來同步彼此的變更。例如，如果多個人都對檔案 A 進行了修改，他們可以將自己的修改推送到共享的遠端倉庫，並從遠端倉庫拉取其他人的修改。\n\n解決衝突：如果多個人對相同文件的同一部分進行了修改，Git 會產生衝突。衝突需要手動解決，通常透過合併工具或手動編輯文件來解決。\n\n分支管理：Git 鼓勵使用分支進行開發，每個人可以在本地建立、切換和合併分支，以便於並行開發和管理複雜的專案結構。\n\n\n下圖就是分散式版本控制工具管理方式：\n\n倉庫（版本庫）：相當於一個專門用來存放代碼的目錄。這個目錄裡面的所有文件都可以 Git 管理，每個文件的增刪改查都能被 Git 跟蹤到\n3.2 發展史\n3.3 優勢\n大部分操作在本地完成，不需要聯網；\n完整性保證；\n盡可能加入資料，而不是刪除或修改資料；\n分支操作非常快捷流暢；\n與 Linux 指令全面相容。\n\n4.Git 軟件的安裝從 https://git-scm.com/downloads 下載對應操作系統的二進位可執行文件。\n\n\n\n\n\n\n\n\n\n直接下一步的過程就不介紹了\n1.安裝到無空格的英文路徑下（這是軟件安裝過程中的規範，防止因程序的不健壯而引發未知錯誤）；\n\n2.選擇需要安裝的組件；\n\n3.選擇 Visual Studio Code 用於 Git 的預設文本編輯器；\n\n4.設定在執行git init指令後，由 Git 自行定義新存儲庫的初始分支名稱——master；\n\n5.設定 PATH 環境變量——保持預設；\n\n6.選用內建的 OpenSSH 作為 SSH 可執行文件；\n\n7.選擇 OpenSSL 庫作為 HTTPS 傳輸端；\n\n8.使用預設配置轉換文本文件中的行尾；\n\n9.使用預設配置，選用 MinTTY 作為 Git Bash 的終端；\n\n10.對於執行 git pull 指令後的行為保持預設；\n\n11.選用預設的授權助手；\n\n12.其他雜項設定；\n\n13.保持對實驗性選項的禁用後安裝 (Install)；\n\n","slug":"GIT01 【版本控制和Git的安装介绍】","date":"2023-12-05T08:35:08.000Z","categories_index":"git","tags_index":"桃園資展筆記,git,指令列表","author_index":"Hsu's Blog"},{"id":"26478f3dfc6b501436963f38a4c764d1","title":"資料庫概述","content":"01 【資料庫概述】資料庫是用來存儲和組織資訊的系統，它可以有效地管理大量的數據，並提供對這些數據的快速訪問和檢索。在計算機科學和資訊技術領域中，有許多不同類型的資料庫，每種資料庫都有其自身的特點和適用場景。\n1.為什麼要使用資料庫\n持久化 (Persistence)：\n\n把資料儲存到可掉電式存儲設備中以供之後使用。即使在系統故障或停電情況下，數據也不會丟失，通過持久化機制確保數據的安全性和完整性。\n企業級應用中的意義：將內存中的資料儲存到硬盤上加以固化，通常通過關聯式資料庫來實現。\n\n\n資料組織和管理：\n\n資料庫幫助組織和管理大量的數據，提供結構化的方法存儲和維護數據，使數據易於管理、查找和更新。\n資料庫支持事務處理，確保一組操作要麼全部完成，要麼全部不完成，有助於確保數據的一致性和完整性。\n資料庫提供各種管理工具和功能，幫助管理員有效地管理數據庫系統，包括性能優化、數據備份和恢復、故障排除等。\n\n\n數據共享和協作：\n\n資料庫是多個用戶共享和協作的理想工具，多個用戶可以同時訪問和修改資料庫中的數據，實現數據的共享和協作。\n\n\n數據安全性：\n\n資料庫提供各種安全機制保護數據的安全性，包括訪問控制、加密、數據備份和恢復等功能，防止數據被未授權用戶訪問和修改。\n\n\n\n\n2.資料庫與資料庫管理系統2.1 相關概念\n\n\n概念\n概述\n\n\n\nDB：資料庫（Database）\n即存儲資料的“倉庫”，其本質是一個文件系統。它儲存了一系列有組織的資料。\n\n\nDBMS：資料庫管理系統（Database Management System）\n是一種操縱和管理資料庫的大型軟件，用於建立、使用和維護資料庫，對資料庫進行統一管理和控制。用戶通過資料庫管理系統存取資料庫中表內的資料。\n\n\nSQL：結構化查詢語言（Structured Query Language）\n專門用來與資料庫通信的語言。\n\n\n2.2 資料庫與資料庫管理系統的關係資料庫管理系統(DBMS)可以管理多個資料庫，一般開發人員會針對每一個應用創建一個資料庫。為儲存應用中實體的資料，一般會在資料庫創建多個表，以儲存程序中實體用戶的資料。\n資料庫管理系統、資料庫和表的關係如圖所示：\n\n2.3 常見的資料庫管理系統排名(DBMS)\n對應的走勢圖：（https://db-engines.com/en/ranking_trend）\n\n2.4 常見的資料庫類型\n關聯式資料庫（Relational Database）：\n\n\n關聯式資料庫是以表格的形式組織資料的，這些表格之間通過主鍵和外鍵關係進行連接。\n最常見的關聯式資料庫管理系統（RDBMS）包括 MySQL、PostgreSQL、Oracle、Microsoft SQL Server 等。\n使用結構化查詢語言（SQL）來操作和管理資料。\n\n\n非關聯式資料庫（NoSQL Database）：\n\n\n非關聯式資料庫不使用傳統的表格結構，而是使用其他方式來組織和存儲資料，如文檔、鍵值對、列族、圖形等。\n非關聯式資料庫通常用於需要處理大量非結構化或半結構化數據的應用場景，如大數據、即時分析等。\n常見的非關聯式資料庫包括 MongoDB、Cassandra、Redis、Couchbase 等。\n\n\n圖形資料庫（Graph Database）：\n\n\n圖形資料庫專門用於存儲圖形結構的資料，其中的數據以節點（node）和邊（edge）的形式表示，用於表示實體之間的關係。\n圖形資料庫對於需要進行複雜的關係查詢和分析的應用場景非常有用，如社交網絡、推薦系統等。\nNeo4j 是一個常見的圖形資料庫。\n\n\n內存資料庫（In-Memory Database）：\n\n\n內存資料庫將數據完全存儲在計算機的內存中，這樣可以實現非常快的數據讀寫速度。\n內存資料庫通常用於需要快速響應和處理大量事務的應用場景，如金融交易、在線遊戲等。\nRedis 和 Memcached 是兩個常見的內存資料庫。\n\n\n分佈式資料庫（Distributed Database）：\n\n\n分佈式資料庫將數據分散存儲在多個物理或邏輯位置上，這樣可以提高數據的可用性、可靠性和擴展性。\n分佈式資料庫常用於需要處理大量數據和提供高性能的應用場景，如互聯網應用、大數據分析等。\nApache Hadoop、Apache Cassandra、Amazon DynamoDB 等都是常見的分佈式資料庫。\n\n2.5 常見的資料庫介紹MySQL：MySQL 是一個開源的關聯式資料庫管理系統（RDBMS），廣泛應用於各種網絡應用和中小型企業的資料管理中。它支援多種操作系統，具有高性能、穩定性和可靠性，並且提供了廣泛的功能和工具。\nPostgreSQL：PostgreSQL 是另一個開源的關聯式資料庫管理系統，被廣泛用於企業級應用和大型數據系統。它提供了許多高級功能，如事務處理、外鍵支援、觸發器和存儲過程等，同時具有良好的擴展性和安全性。\nOracle Database：Oracle Database 是一個強大的關聯式資料庫管理系統，用於企業級應用和大型組織的資料管理。它提供了廣泛的功能和工具，包括高級的數據處理、安全性、備份和恢復等功能。\nMongoDB：MongoDB 是一個開源的非關聯式資料庫管理系統，使用文檔導向的資料模型，特別適用於處理大量非結構化數據。它支援動態查詢、索引、負載平衡和數據複製等功能，並且具有良好的擴展性和性能。\nRedis：Redis 是一個開源的內存資料庫管理系統，用於高速數據緩存、會話存儲、消息代理等場景。它支援多種數據結構，如字符串、哈希、列表、集合和有序集合等，並且提供了持久化支援和集群功能。\nNeo4j：Neo4j 是一個知名的圖形資料庫管理系統，專門用於存儲和查詢圖形結構的資料。它提供了強大的圖形查詢語言和高性能的圖形算法，適用於複雜的關係分析和圖形數據可視化。\n3.MySQL 介紹3.1 概述\nMySQL 是一個開放源代碼的關聯式資料庫管理系統，由瑞典 MySQL AB（創始人 Michael Widenius）公司 1995 年開發，迅速成為開源資料庫的 No.1。\n2008 被Sun收購（10 億美金），2009 年 Sun 被Oracle收購。MariaDB應運而生。（MySQL 的創造者擔心 MySQL 有閉源的風險，因此創建了 MySQL 的分支項目 MariaDB）\nMySQL6.x 版本之後分為社群版和商業版。\nMySQL 是一種關聯資料庫管理系統，將資料儲存在不同的表中，而不是將所有資料放在一個大倉庫內，這樣就增加了速度並提高了靈活性。\nMySQL 是開源的，所以你不需要支付額外的費用。\nMySQL 是可以定製的，採用了GPL（GNU General Public License）協議，你可以修改源碼來開發自己的 MySQL 系統。\nMySQL 支持大型的資料庫。可以處理擁有上仟萬條記錄的大型資料庫。\nMySQL 支持大型資料庫，支持 5000 萬條記錄的資料倉庫，32 位系統表文件最大可支持4GB，64 位系統支持最大的表文件為8TB。\nMySQL 使用標準的SQL資料語言形式。\nMySQL 可以允許執行於多個系統上，並且支持多種語言。這些編程語言包括 C、C++、Python、Java、Perl、PHP 和 Ruby 等。\n\n3.2 關於 MySQL 8.0MySQL從5.7版本直接跳躍發布了8.0版本，可見這是一個令人興奮的裏程碑版本。MySQL 8 版本在功能上做了顯著的改進與增強，開發者對 MySQL 的源代碼進行了重構，最突出的一點是多 MySQL Optimizer 優化器進行了改進。\n不僅在速度上得到了改善，還為用戶帶來了更好的性能和更棒的體驗。\n3.3 Why choose MySQL?為什麼如此多的廠商要選用 MySQL？大概總結的原因主要有以下幾點：\n\n開放源代碼，使用成本低。\n性能卓越，服務穩定。\n軟件體積小，使用簡單，並且易於維護。\n歷史悠久，社群用戶非常活躍，遇到問題可以尋求幫助。\n許多網際網路公司在用，經過了時間的驗證。\n\n3.4 Oracle vs MySQL\nOracle\n更適合大型跨國企業的使用，因為他們對費用不敏感，但是對性能要求以及安全性有更高的要求。\n\n\nMySQL\n由於其體積小、速度快、總體擁有成本低，可處理上仟萬條記錄的大型資料庫，尤其是開放源碼這一特點，使得很多網際網路公司、中小型網站選擇了 MySQL 作為網站資料庫（Facebook，Twitter，YouTube，阿裏巴巴&#x2F;螞蟻金服，去哪兒，美團外賣，騰訊）。\n\n\n\n4.RDBMS 與 非 RDBMS4.1 關聯式資料庫(RDBMS)\n這種型別的資料庫是最古老 的資料庫型別，關聯式資料庫模型是把複雜的資料結構歸結為簡單的二元關係（即二維表格形式）。\n\n\n\n關聯式資料庫是一種以行（row）和列（column）的形式來組織和存儲資料的資料庫系統。在關聯式資料庫中，數據被組織成表（table）的形式，每個表包含一系列的行和列，行代表特定的資料記錄，而列則代表不同的資料屬性或字段。\n\n表與表之間的資料記錄之間可以存在關係，這種關係可以通過不同表之間的共同字段來建立。這種關係模型有助於描述現實世界中各種實體（entities）以及這些實體之間的關係（relationships）。\n\n關聯式資料庫建立在關係模型的基礎上，通過組織資料成表的形式，並且建立表之間的關係，實現了數據的結構化存儲和管理。這使得用戶可以通過簡單而直觀的方式來理解和操作資料。\n\nSQL（Structured Query Language）是關聯式資料庫的查詢語言，它提供了一套標準化的語法和命令，用於對關聯式資料庫中的資料進行查詢、更新、添加和刪除等操作。SQL 的使用使得用戶可以以簡單、有效的方式與關聯式資料庫進行交互，執行各種數據操作，並獲取需要的資訊。\n\n\n\n\n優勢\n複雜查詢 可以用 SQL 語句方便的在一個表以及多個表之間做非常複雜的資料查詢。\n事務支持 使得對於安全性能很高的資料存取要求得以實現。\n\n\n\n4.2 非關聯式資料庫(非 RDBMS)介紹\n非關聯式資料庫，可看成傳統關聯式資料庫的功能 閹割版本 ，基於鍵值對存儲資料，不需要經過 SQL 層的解析， 性能非常高 。同時，通過減少不常用的功能，進一步提高性能。\n有哪些非關聯式資料庫\n\n鍵值型資料庫\ntxt鍵值型資料庫通過 Key-Value 鍵值的方式來存儲資料，其中 Key 和 Value 可以是簡單的物件，也可以是複雜的物件。`Key 作為唯一的標識符，優點是查找速度快`，在這方面明顯優於關聯式資料庫，缺點是無法像關聯式資料庫一樣使用條件過濾（比如 WHERE），如果你不知道去哪裏找資料，就要遍曆所有的鍵，這就會消耗大量的計算。\n\n鍵值型資料庫典型的使用場景是作為`內存緩存`。`Redis`是最流行的鍵值型資料庫。\n\n文檔型資料庫\ntxt此類資料庫可存放並獲取文檔，可以是 XML、JSON 等格式。在資料庫中文檔作為處理資訊的基本單位，一個文檔就相當於一條記錄。文檔資料庫所存放的文檔，就相當於鍵值資料庫所存放的“值”。\n\nMongoDB 是最流行的文檔型資料庫。此外，還有 CouchDB 等。\n\n搜索引擎資料庫\n搜索引擎資料庫是應用在搜索引擎領域的資料存儲形式，由於搜索引擎會爬取大量的資料，並以特定的格式進行存儲，這樣在檢索的時候才能保證性能最優。核心原理是“倒排索引”。\n典型産品：Solr、Elasticsearch、Splunk 等。\n\n列式資料庫\n列式資料庫是相對於行式存儲的資料庫，Oracle、MySQL、SQL Server 等資料庫都是採用的行式存儲（Row-based），而列式資料庫是將資料按照列存儲到資料庫中，這樣做的好處是可以大量降低系統的 I&#x2F;O，適合於分布式文件系統，不足在於功能相對有限。典型産品：HBase 等。\n\n\n\n\n圖形資料庫\n\n圖形資料庫，利用了圖這種資料結構存儲了實體（物件）之間的關係。圖形資料庫最典型的例子就是社交網絡中人與人的關係，資料模型主要是以節點和邊（關係）來實現，特點在於能高效地解決複雜的關係問題。\n圖形資料庫顧名思義，就是一種存儲圖形關係的資料庫。它利用了圖這種資料結構存儲了實體（物件）之間的關係。關係型資料用於存儲明確關係的資料，但對於複雜關係的資料存儲卻有些力不從心。如社交網絡中人物之間的關係，如果用關聯式資料庫則非常複雜，用圖形資料庫將非常簡單。典型産品：Neo4J、InfoGrid 等。\n4.3 小結在數據庫管理系統（DBMS）的排名中，關聯式資料庫的比重仍然佔主導地位，這在一定程度上反映了 SQL 的重要性和廣泛應用。儘管 NoSQL 技術的發展和應用在某些場景下已經展示出了優勢，但是關聯式資料庫仍然是許多企業和組織的首選，特別是在傳統業務和企業級應用中。\n影響力前 5 的 DBMS 中有 4 個是關聯式資料庫，而排名前 20 的 DBMS 中也有 12 個是關聯式資料庫。所以說，掌握 SQL 是非常有必要的。\n5.關聯式資料庫設計規則\n關聯式資料庫的典型資料結構就是資料表，這些資料表的組成都是結構化的（Structured）。\n將資料放到表中，表再放到庫中。\n一個資料庫中可以有多個表，每個表都有一個名字，用來標識自己。表名具有唯一性。\n表具有一些特性，這些特性定義了資料在表中如何存儲，類似 Java 和 Python 中 “類”的設計。\n\n5.1 表、記錄、字段\nE-R（entity-relationship，實體-關係模型）模型中有三個主要概念是： 實體集 、屬性 、關係集。\n一個實體集（class）對應於資料庫中的一個表（table），一個實體（instance）則對應於資料庫表中的一行（row），也稱為一條記錄（record）。一個屬性（attribute）對應於資料庫表中的一列（column），也稱為一個字段（field）。\n\n​ \n[擴展閱讀]ORM（Object-Relational Mapping）ORM思想(Object Relational Mapping)體現解決關聯式資料庫和物件導向程式設計之間的不匹配。它通過將資料庫中的資料映射到程式中的物件，以及將物件的操作映射到資料庫的操作，實現了資料庫和應用程式之間的無縫整合。\n\n映射：ORM 將資料庫中的表、行和列映射到程式中的物件和屬性。\n減少重複性的代碼：ORM 能夠自動生成資料庫操作代碼，減少了重複性的代碼量。\n提高開發效率：ORM 提供了簡潔、直觀的 API，使開發人員能夠更快地開發出具有資料庫支援的應用程式。\n提高可維護性：ORM 將資料庫操作封裝在物件的方法中，使程式碼更加模組化和可維護。\n跨平台性：ORM 框架通常支援多種資料庫系統，使得應用程式更具彈性。\n提供事務支援：ORM 框架提供了事務管理的功能，保證資料庫操作的原子性和一致性。\n\n5.2 表的關聯關係\n表與表之間的資料記錄有關係(relationship)。現實世界中的各種實體以及實體之間的各種關係均用關係模型來表示。\n四種：\n一對一（One-to-One）關係\n一對多（One-to-Many）關係\n多對多（Many-to-Many）關係\n自我引用\n\n\n\n5.2.1 一對一關聯（one-to-one）\n在實際的開發中應用不多，因為一對一可以創建成一張表。\n\n兩個資料表之間的關係，其中一個記錄在一個表中只對應另一個表中的一個記錄。\n\n舉例：設計學生表：學號、姓名、手機號碼、班級、係別、身份證號碼、家庭住址、籍貫、緊急關係人、…\n\n拆為兩個表：兩個表的記錄是一一對應關係。\n基礎資訊表（常用資訊）：學號、姓名、手機號碼、班級、係別\n檔案資訊表（不常用資訊）：學號、身份證號碼、家庭住址、籍貫、緊急關係人、…\n\n\n兩種建表原則：\n\n外鍵唯一：主表的主鍵和從表的外鍵（唯一），形成主外鍵關係，外鍵唯一。\n\n外鍵是主鍵：主表的主鍵和從表的主鍵，形成主外鍵關係。\n（主表和從表的區分：從表一般需要創建一個外鍵來引用主表的主鍵）\n\n\n\n\n\n5.2.2 一對多關係（one-to-many）\n兩個資料表之間的關係，其中一個記錄在一個表中可以對應另一個表中的多個記錄。\n常見實例場景：客戶表和訂單表，分類表和商品表，部門表和員工表。\n舉例：\n部門表：編號、名稱、簡介\n員工表：編號、姓名、…、所屬部門\n\n\n一對多建表原則：在從表(多方)創建一個字段，字段作為外鍵指向主表(一方)的主鍵\n\n\n\n\n5.2.3 多對多（many-to-many）\n兩個資料表之間的關係，其中一個記錄在一個表中可以對應多個記錄，同時另一個表中的記錄也可以對應多個記錄。通常需要通過中間表（Join Table）來實現多對多關係。它將多對多關係劃分為兩個一對多關係。將這兩個表的主鍵都插入到第三個表中。\n\n\n\n\n舉例 1：學生-課程\n\n學生資訊表：一行代表一個學生的資訊（學號、姓名、手機號碼、班級、係別…）\n\n課程資訊表：一行代表一個課程的資訊（課程編號、授課老師、簡介…）\n\n選課資訊表：一個學生可以選多門課，一門課可以被多個學生選擇\n1234學號     課程編號1        10012        10011        1002\n\n\n舉例 2：産品-訂單\n“訂單”表和“産品”表有一種多對多的關係，這種關係是通過與“訂單明細”表建立兩個一對多關係來定義的。一個訂單可以有多個産品，每個産品可以出現在多個訂單中。\n\n産品表：“産品”表中的每條記錄表示一個産品。\n訂單表：“訂單”表中的每條記錄表示一個訂單。\n訂單明細表：每個産品可以與“訂單”表中的多條記錄對應，即出現在多個訂單中。一個訂單可以與“産品”表中的多條記錄對應，即包含多個産品。\n\n\n\n\n\n舉例 3：用戶-角色\n多對多關係建表原則：需要創建第三張表，中間表中至少兩個字段，這兩個字段分別作為外鍵指向各自一方的主鍵。\n\n\n5.2.4 自我引用(Self reference)\n","slug":"MYSQL01 【資料庫概述】","date":"2023-11-17T08:22:05.000Z","categories_index":"mySQL","tags_index":"桃園資展筆記,mySQL","author_index":"Hsu's Blog"},{"id":"956114e1932534f6adc2e3848138c40e","title":"JavaScript 進階 - 第4天","content":"深淺拷貝淺拷貝首先淺拷貝和深拷貝只針對參考類型\n淺拷貝：拷貝的是位址\n常見方法：\n\n拷貝物件：Object.assgin() &#x2F; 展開運運算元 {…obj} 拷貝物件\n拷貝陣列：Array.prototype.concat() 或者 […arr]\n\n\n\n\n\n\n\n\n\n\n如果是單一資料型別拷貝值，引用資料類型拷貝的是位址 (簡單理解： 如果是單層物件，沒問題，如果有多層就有問題)\n深拷貝首先淺拷貝和深拷貝只針對參考類型\n深拷貝：拷貝的是物件，不是位址\n常見方法：\n\n通過遞迴實現深拷貝\nlodash&#x2F;cloneDeep\n通過JSON.stringify()實現\n\n遞迴實現深拷貝函數遞迴：\n如果一個函數在內部可以調用其本身，那麼這個函數就是遞迴函數\n\n簡單理解:函數內部自己調用自己, 這個函數就是遞迴函數\n遞迴函數的作用和迴圈效果類似\n由於遞迴很容易發生“棧溢出”錯誤（stack overflow），所以必須要加退出條件 return\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;body&gt;  &lt;script&gt;    const obj = &#123;      uname: &#x27;pink&#x27;,      age: 18,      hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;],      family: &#123;        baby: &#x27;小pink&#x27;      &#125;    &#125;    const o = &#123;&#125;    // 拷貝函數function deepCopy(newObj, oldObj) &#123;  debugger  // 遍歷oldObj中的每一個屬性  for (let k in oldObj) &#123;    // 處理陣列的問題  一定先寫陣列 在寫 物件 不能顛倒    if (oldObj[k] instanceof Array) &#123;      // 如果該屬性的值是一個陣列，則在 newObj 中生成一個新的空陣列      newObj[k] = []      //  newObj[k] 接收 []  hobby      //  oldObj[k] =  [&#x27;乒乓球&#x27;, &#x27;足球&#x27;]      // 遞歸調用 deepCopy 函數，把 oldObj 中的陣列複製到新生成的陣列中。      deepCopy(newObj[k], oldObj[k])    &#125; else if (oldObj[k] instanceof Object) &#123;      // 如果該屬性的值是一個物件，則在 newObj 中生成一個新的空物件      newObj[k] = &#123;&#125;      // 遞歸調用 deepCopy 函數，把 oldObj 中的物件複製到新生成的物件中。      deepCopy(newObj[k], oldObj[k])    &#125;    else &#123;      // 如果該屬性的值不是物件或陣列，則直接把該值複製到 newObj 中。      newObj[k] = oldObj[k]    &#125;  &#125;&#125;    deepCopy(o, obj) // 函式呼叫  兩個參數 o 新物件  obj 舊物件    console.log(o)    o.age = 20    o.hobby[0] = &#x27;籃球&#x27;    o.family.baby = &#x27;老pink&#x27;    console.log(obj)    console.log([1, 23] instanceof Object)    // 複習    // const obj = &#123;    //   uname: &#x27;pink&#x27;,    //   age: 18,    //   hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;]    // &#125;    // function deepCopy(&#123; &#125;, oldObj) &#123;    //   // k 屬性名  oldObj[k] 屬性值    //   for (let k in oldObj) &#123;    //     // 處理陣列的問題   k 變數    //     newObj[k] = oldObj[k]    //     // o.uname = &#x27;pink&#x27;    //     // newObj.k  = &#x27;pink&#x27;    //   &#125;    // &#125;  &lt;/script&gt;&lt;/body&gt;\n\njs庫lodash裡面cloneDeep內部實現了深拷貝123456789101112131415161718&lt;body&gt;  &lt;!-- 先引用 --&gt;  &lt;script src=&quot;./lodash.min.js&quot;&gt;&lt;/script&gt;  &lt;script&gt;    const obj = &#123;      uname: &#x27;pink&#x27;,      age: 18,      hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;],      family: &#123;        baby: &#x27;小pink&#x27;      &#125;    &#125;    const o = _.cloneDeep(obj)    console.log(o)    o.family.baby = &#x27;老pink&#x27;    console.log(obj)  &lt;/script&gt;&lt;/body&gt;\n\nJSON序列化123456789101112131415161718&lt;body&gt;  &lt;script&gt;    const obj = &#123;      uname: &#x27;pink&#x27;,      age: 18,      hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;],      family: &#123;        baby: &#x27;小pink&#x27;      &#125;    &#125;    // 把物件轉換為 JSON 字串    // console.log(JSON.stringify(obj))    const o = JSON.parse(JSON.stringify(obj))    console.log(o)    o.family.baby = &#x27;123&#x27;    console.log(obj)  &lt;/script&gt;&lt;/body&gt;\n","slug":"2303-3 JS 進階4-1 深淺拷貝","date":"2023-04-01T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"956114e1932534f6adc2e3848138c40e","title":"JavaScript 進階 - 第4天","content":"處理this\n\n\n\n\n\n\n\n\n瞭解函數中 this 在不同場景下的預設值，知道動態指定函數 this 值的方法。\nthis 是 JavaScript 最具“魅惑”的知識點，不同的應用場合 this 的取值可能會有意想不到的結果，在此我們對以往學習過的關於【 this 預設的取值】情況進行歸納和總結。\n普通函數普通函數的調用方式決定了 this 的值，即【誰調用 this 的值指向誰】，如下代碼所示：\n12345678910111213141516171819202122232425262728&lt;script&gt;  // 普通函數  function sayHi() &#123;    console.log(this)    &#125;  // 函數運算式  const sayHello = function () &#123;    console.log(this)  &#125;  // 函數的調用方式決定了 this 的值  sayHi() // window  window.sayHi()  // 普通對象  const user = &#123;    name: &#x27;小明&#x27;,    walk: function () &#123;      console.log(this)    &#125;  &#125;  // 動態為 user 添加方法  user.sayHi = sayHi  uesr.sayHello = sayHello  // 函式呼叫方式，決定了 this 的值  user.sayHi()  user.sayHello()&lt;/script&gt;\n\n注： 普通函數沒有明確調用者時 this 值為 window，嚴格模式下沒有調用者時 this 的值為 undefined。\n箭頭函數箭頭函數中的 this 與普通函數完全不同，也不受調用方式的影響，事實上箭頭函數中並不存在 this ！箭頭函數中訪問的 this 不過是箭頭函數所在作用域的 this 變數。\n1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;      console.log(this) // 此處為 window  // 箭頭函數  const sayHi = function() &#123;    console.log(this) // 該箭頭函數中的 this 為函式宣告環境中 this 一致  &#125;  // 普通對象  const user = &#123;    name: &#x27;小明&#x27;,    // 該箭頭函數中的 this 為函式宣告環境中 this 一致    walk: () =&gt; &#123;      console.log(this)    &#125;,        sleep: function () &#123;      let str = &#x27;hello&#x27;      console.log(this)      let fn = () =&gt; &#123;        console.log(str)        console.log(this) // 該箭頭函數中的 this 與 sleep 中的 this 一致      &#125;      // 調用箭頭函數      fn();    &#125;  &#125;  // 動態添加方法  user.sayHi = sayHi    // 函式呼叫  user.sayHi()  user.sleep()  user.walk()&lt;/script&gt;\n\n在開發中【使用箭頭函數前需要考慮函數中 this 的值】，事件回呼函數使用箭頭函數時，this 為全域的 window，因此DOM事件回呼函數不推薦使用箭頭函數，如下代碼所示：\n123456789101112&lt;script&gt;  // DOM 節點  const btn = document.querySelector(&#x27;.btn&#x27;)  // 箭頭函數 此時 this 指向了 window  btn.addEventListener(&#x27;click&#x27;, () =&gt; &#123;    console.log(this)  &#125;)  // 普通函數 此時 this 指向了 DOM 對象  btn.addEventListener(&#x27;click&#x27;, function () &#123;    console.log(this)  &#125;)&lt;/script&gt;\n\n同樣由於箭頭函數 this 的原因，基於原型的物件導向也不推薦採用箭頭函數，如下代碼所示：\n1234567891011&lt;script&gt;  function Person() &#123;  &#125;  // 原型對像上添加了箭頭函數  Person.prototype.walk = () =&gt; &#123;    console.log(&#x27;人都要走路...&#x27;)    console.log(this); // window  &#125;  const p1 = new Person()  p1.walk()&lt;/script&gt;\n\n改變this指向以上歸納了普通函數和箭頭函數中關於 this 預設值的情形，不僅如此 JavaScript 中還允許指定函數中 this 的指向，有 3 個方法可以動態指定普通函數中 this 的指向：\ncall使用 call 方法調用函數，同時指定函數中 this 的值\n\n\n\n\n\n\n\n\n\n語法fun.call(thisArg, arg1, arg2, …)\n\nthisArg ：在 fun 函數 運行時指定 的 this 值\narg1 arg2 ：傳遞 的其他參數\n返回 值就是函數的返回值，因為它就是調用 函數\n\n使用方法如下代碼所示：\n1234567891011121314151617181920212223242526272829&lt;script&gt;  // 普通函數  function sayHi() &#123;    console.log(this);  &#125;  let user = &#123;    name: &#x27;小明&#x27;,    age: 18  &#125;  let student = &#123;    name: &#x27;小紅&#x27;,    age: 16  &#125;  // 調用函數並指定 this 的值  sayHi.call(user); // this 值為 user  sayHi.call(student); // this 值為 student  // 求和函數  function counter(x, y) &#123;    return x + y;  &#125;  // 調用 counter 函數，並傳入參數  let result = counter.call(null, 5, 10);  console.log(result);&lt;/script&gt;\n\n總結：\n\ncall 方法能夠在調用函數的同時指定 this 的值\n使用 call 方法調用函數時，第1個參數為 this 指定的值\ncall 方法的其餘參數會依次自動傳入函數做為函數的參數\n\napply使用 call 方法調用函數，同時指定函數中 this 的值\n\n\n\n\n\n\n\n\n\n語法fun.apply(thisArg, [argsArray])\n\nthisArg ：在 fun 函數運行時指定的 this 值\nargsArray ：傳遞的值，必須包含在 數組 裡面\n返回 值就是函數的返回值，因為它就是調用 函數\n因此 apply 主要跟數組有關係，比如使用 Math.max() 求數組的最大 值\n\n使用方法如下代碼所示：\n12345678910111213141516171819202122232425262728&lt;script&gt;  // 普通函數  function sayHi() &#123;    console.log(this)  &#125;  let user = &#123;    name: &#x27;小明&#x27;,    age: 18  &#125;  let student = &#123;    name: &#x27;小紅&#x27;,    age: 16  &#125;  // 調用函數並指定 this 的值  sayHi.apply(user) // this 值為 user  sayHi.apply(student) // this 值為 student  // 求和函數  function counter(x, y) &#123;    return x + y  &#125;  // 調用 counter 函數，並傳入參數  let result = counter.apply(null, [5, 10])  console.log(result)&lt;/script&gt;\n\n總結：\n\napply 方法能夠在調用函數的同時指定 this 的值\n使用 apply 方法調用函數時，第1個參數為 this 指定的值\napply 方法第2個參數為陣列，陣列的單元值依次自動傳入函數做為函數的參數\n\nbindbind 方法並不會調用函數，而是創建一個指定了 this 值的新函數\n\n\n\n\n\n\n\n\n\n語法fun.bind(thisArg, arg1, arg2, …)\n\nthisArg ：在 fun 函数运行时指定的 this 值\narg1 arg2 ：传递的其他参数\n返回由指定的 this 值和初始化参数改造的 原函数拷贝 （新函数\n因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind 比如改变定时器内部的this 指向\n\n使用方法如下代碼所示：\n1234567891011121314&lt;script&gt;  // 普通函數  function sayHi() &#123;    console.log(this)  &#125;  let user = &#123;    name: &#x27;小明&#x27;,    age: 18  &#125;  // 調用 bind 指定 this 的值  let sayHello = sayHi.bind(user);  // 調用使用 bind 創建的新函數  sayHello()&lt;/script&gt;\n\n注：bind 方法創建新的函數，與原函數的唯一的變化是改變了 this 的值。\ncall apply bind 總結\n相同點 :\n\n都可以改變函數內部的 this 指向\n\n\n區別點 :\n\ncall 和 apply 會調用函數 , 並且改變函數內部 this 指向\ncall 和 apply 傳遞的參數不一樣 , call 傳遞參數 aru1, aru2.. 形式 apply 必須數組形式 arg\nbind 不會調用函數 , 可以改變函數內部 this 指向\n\n\n主要應用場景 :\n\ncall 調用函數並且可以傳遞參數\napply 經常跟數組有關係 . 比如借助於數學對象實現數組最大值最小值\nbind 不調用函數 但是還想改變 this 指向 . 比如改變定時器內部的 this 指向\n\n\n\n","slug":"2303-3 JS 進階4-3 處理this","date":"2023-04-01T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"956114e1932534f6adc2e3848138c40e","title":"JavaScript 進階 - 第4天","content":"異常處理\n\n\n\n\n\n\n\n\n瞭解 JavaScript 中程式異常處理的方法，提升代碼運行的健壯性。\nthrow異常處理是指預估代碼執行過程中可能發生的錯誤，然後最大程度的避免錯誤的發生導致整個程式無法繼續運行\n總結：\n\nthrow 拋出異常資訊，程式也會終止執行\nthrow 後面跟的是錯誤提示資訊\nError 物件配合 throw 使用，能夠設置更詳細的錯誤資訊\n\n12345678910111213&lt;script&gt;  function counter(x, y) &#123;    if(!x || !y) &#123;      // throw &#x27;參數不能為空!&#x27;;      throw new Error(&#x27;參數不能為空!&#x27;)    &#125;    return x + y  &#125;  counter()&lt;/script&gt;\n\n總結：\n\nthrow 拋出異常資訊，程式也會終止執行\nthrow 後面跟的是錯誤提示資訊\nError 物件配合 throw 使用，能夠設置更詳細的錯誤資訊\n\ntry … catch1234567891011121314151617181920212223&lt;script&gt;   function foo() &#123;      try &#123;        // 查找 DOM 節點        const p = document.querySelector(&#x27;.p&#x27;)        p.style.color = &#x27;red&#x27;      &#125; catch (error) &#123;        // try 程式碼片段中執行有錯誤時，會執行 catch 程式碼片段        // 查看錯誤資訊        console.log(error.message)        // (補充)可以配合throw        throw new Error(&#x27;選擇錯誤&#x27;)        // 終止代碼繼續執行        return      &#125;      finally &#123;          alert(&#x27;執行&#x27;)      &#125;      console.log(&#x27;如果出現錯誤，我的語句不會執行&#x27;)    &#125;    foo()&lt;/script&gt;\n\n總結：\n\ntry...catch 用於捕獲錯誤資訊\n將預估可能發生錯誤的代碼寫在 try 程式碼片段中\n如果 try 程式碼片段中出現錯誤後，會執行 catch 程式碼片段，並截獲到錯誤資訊\nfinally不管是否有無錯誤都會執行\n\ndebugger相當於中斷點調試，在代碼中打debugger即可\n","slug":"2303-3 JS 進階4-2 異常處理","date":"2023-04-01T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"956114e1932534f6adc2e3848138c40e","title":"JavaScript 進階 - 第4天","content":"防抖節流節流 和防抖的區別是？\n\n防抖（debounce）\n\n\n所謂防抖，就是指觸發事件後在 n 秒內函數只能執行一次(最後一次)，如果在 n 秒內又觸發了事件，則會重新計算函數執行時間\n\n\n節流（throttle）\n\n\n所謂節流，就是指連續觸發事件但是在 n 秒中只執行一次函數(不會被打斷)\n\n節流和防抖 的使用場景是\n\n防抖 : 搜索框輸入，設定每次輸入完畢 n 秒後發送請求，如果期間還有輸入，則從新計算時間\n節流 : 鼠標移動mousemove，頁面尺寸發生變化resize，滾動條滾動scroll等開銷比較大的情況下\n\n","slug":"2303-3 JS 進階4-4 防抖節流","date":"2023-04-01T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"c43b2d50b25bb22e84622db700db53eb","title":"JavaScript 進階 - 第3天","content":"\n\n\n\n\n\n\n\n\n瞭解構造函數原型物件的語法特徵，掌握 JavaScript 中物件導向程式設計的實現方式，基於物件導向程式設計思想實現 DOM 操作的封裝。\n\n瞭解物件導向程式設計的一般特徵\n掌握基於構造函數原型物件的邏輯封裝\n掌握基於原型物件實現的繼承\n理解什麼原型鏈及其作用\n能夠處理常式異常提升程式執行的健壯性\n\n程式設計思想\n\n\n\n\n\n\n\n\n學習 JavaScript 中基於原型的物件導向編程式的語法實現，理解物件導向程式設計的特徵。\n面向過程(前端使用居多)面向過程就是分析出解決問題所需要的步驟，然後用函數把這些步驟一步一步實現，使用的時候再一個一個的依次\n調用就可以了。\n物件導向(面向對象)物件導向是把事務分解成為一個個物件，然後由物件之間分工與合作。\n在物件導向程式開發思想中，每一個物件都是功能中心，具有明確分工。\n物件導向程式設計具有靈活、代碼可複用、容易維護和開發的優點，更適合多人合作的大型軟體專案。\n物件導向的特性：\n\n封裝性\n\n繼承性\n\n多態性\n\n\n比較\n面向過程編程\n\n優點：性能比面向對象高 ，適合跟 硬件聯繫很緊密的東西 ，例如單片機就採用的面向過程 編程。\n缺點：沒有面向對象易維護、易復用、易擴展\n\n\n面向對象編程\n\n優點：易維護、易復用、易擴展，由於面向對像有封裝、繼承、多態性的特性，可以設計出低耦合的系統，使系統 更加靈活、更加易於維護\n缺點：性能比面向過程低\n\n\n\n構造函數對比以下通過物件導向的構造函數實現的封裝：\n12345678910111213141516171819202122&lt;script&gt;  function Person() &#123;    this.name = &#x27;佚名&#x27;    // 設置名字    this.setName = function (name) &#123;      this.name = name    &#125;    // 讀取名字    this.getName = () =&gt; &#123;      console.log(this.name)    &#125;  &#125;  // 實例對像，獲得了構造函數中封裝的所有邏輯  let p1 = new Person()  p1.setName(&#x27;小明&#x27;)  console.log(p1.name)  // 實例物件  let p2 = new Person()  console.log(p2.name)&lt;/script&gt;\n\n封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。\n同樣的將變數和函數組合到了一起並能通過 this 實現資料的共用，所不同的是借助構造函數創建出來的實例物件之間是彼此不影響的\n\n\n\n\n\n\n\n\n\n總結：\n\n構造函數體現了物件導向的封裝特性\n構造函數實例創建的物件彼此獨立、互不影響\n\n封裝是物件導向思想中比較重要的一部分，js物件導向可以通過構造函數實現的封裝。\n前面我們學過的構造函數方法很好用，但是 存在浪費記憶體的問題\n原型物件構造函數通過原型分配的函數是所有物件所 共用的。\n\nJavaScript 規定，每一個構造函數都有一個 prototype 屬性，指向另一個物件，所以我們也稱為原型物件\n這個物件可以掛載函數，物件產生實體不會多次創建原型上函數，節約記憶體\n我們可以把那些不變的方法，直接定義在 prototype 物件上，這樣所有物件的實例就可以共用這些方法。\n構造函數和原型物件中的this 都指向 產生實體的物件\n\n12345678&lt;script&gt;  function Person() &#123;      &#125;  // 每個函數都有 prototype 屬性  console.log(Person.prototype)&lt;/script&gt;\n\n\n瞭解了 JavaScript 中構造函數與原型物件的關係後，再來看原型物件具體的作用，如下代碼所示：\n1234567891011121314&lt;script&gt;  function Person() &#123;    // 此處未定義任何方法  &#125;  // 為構造函數的原型物件添加方法  Person.prototype.sayHi = function () &#123;    console.log(&#x27;Hi~&#x27;);  &#125;    // 產生實體  let p1 = new Person();  p1.sayHi(); // 輸出結果為 Hi~&lt;/script&gt;\n\n\n構造函數 Person 中未定義任何方法，這時實例物件調用了原型物件中的方法 sayHi，接下來改動一下代碼：\n12345678910111213141516&lt;script&gt;  function Person() &#123;    // 此處定義同名方法 sayHi    this.sayHi = function () &#123;      console.log(&#x27;嗨!&#x27;);    &#125;  &#125;  // 為構造函數的原型物件添加方法  Person.prototype.sayHi = function () &#123;    console.log(&#x27;Hi~&#x27;);  &#125;  let p1 = new Person();  p1.sayHi(); // 輸出結果為 嗨!&lt;/script&gt;\n\n構造函數 Person 中定義與原型物件中相同名稱的方法，這時實例物件調用則是構造函中的方法 sayHi。\n通過以上兩個簡單示例不難發現 JavaScript 中物件的工作機制：當訪問物件的屬性或方法時，先在當前實例物件是查找，然後再去原型物件查找，並且原型物件被所有實例共用。\n123456789101112131415161718192021&lt;script&gt;  function Person() &#123;    // 此處定義同名方法 sayHi    this.sayHi = function () &#123;      console.log(&#x27;嗨!&#x27; + this.name)    &#125;  &#125;  // 為構造函數的原型物件添加方法  Person.prototype.sayHi = function () &#123;    console.log(&#x27;Hi~&#x27; + this.name)  &#125;  // 在構造函數的原型物件上添加屬性  Person.prototype.name = &#x27;小明&#x27;  let p1 = new Person()  p1.sayHi(); // 輸出結果為 嗨!    let p2 = new Person()  p2.sayHi()&lt;/script&gt;\n\n總結：結合構造函數原型的特徵，實際開發重往往會將封裝的功能函數添加到原型物件中。\nconstructor 屬性在哪裡？ 每個原型物件裡面都有個constructor 屬性（constructor 構造函數）\n作用：該屬性指向該原型物件的構造函數， 簡單理解，就是指向我的爸爸，我是有爸爸的孩子\n使用場景：\n如果有多個物件的方法，我們可以給原型物件採取物件形式賦值.\n但是這樣就會覆蓋構造函數原型物件原來的內容，這樣修改後的原型物件 constructor 就不再指向當前構造函數了\n此時，我們可以在修改後的原型物件中，添加一個 constructor 指向原來的構造函數。\n物件原型物件都會有一個屬性 _proto_ 指向構造函數的 prototype 原型物件，之所以我們物件可以使用構造函數 prototype \n原型物件的屬性和方法，就是因為物件有 _proto_ 原型的存在。\n注意：\n\n__proto__ 是JS非標準屬性\n[[prototype]]和_proto_意義相同\n用來表明當前實例物件指向哪個原型物件prototype\n_proto_物件原型裡面也有一個 constructor屬性，指向創建該實例物件的構造函數\n\n小節\n\nprototype 是什麼？哪裡來的？\n\n\n原型（原型對象）\n構造函數都自動有原型\n\n\n\nconstructor 屬性在哪裡？作用乾啥的？\n\n\nprototype 原型和對象原型 _proto_ 裡面都有\n都指向創建實例對象 原型的 構造函數\n\n\n\n_proto_屬性 在哪裡 ？指向誰\n\n\n在實例對象裡面\n指向原型 prototype\n\n\n\n原型繼承繼承是物件導向程式設計的另一個特徵，通過繼承進一步提升代碼封裝的程度，JavaScript 中大多是借助原型物件實現繼承的特性。\n龍生龍、鳳生鳳、老鼠的兒子會打洞描述的正是繼承的含義。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;body&gt;  &lt;script&gt;    // 繼續抽取   公共的部分放到原型上    // const Person1 = &#123;    //   eyes: 2,    //   head: 1    // &#125;    // const Person2 = &#123;    //   eyes: 2,    //   head: 1    // &#125;    // 構造函數  new 出來的物件 結構一樣，但是物件不一樣    function Person() &#123;      this.eyes = 2      this.head = 1    &#125;    // console.log(new Person)    // 女人  構造函數   繼承  想要 繼承 Person    function Woman() &#123;    &#125;    // Woman 通過原型來繼承 Person    // 父構造函數（父類）   子構造函數（子類）    // 子類的原型 =  new 父類      Woman.prototype = new Person()   // &#123;eyes: 2, head: 1&#125;     // 指回原來的構造函數    Woman.prototype.constructor = Woman    // 給女人添加一個方法  生孩子    Woman.prototype.baby = function () &#123;      console.log(&#x27;寶貝&#x27;)    &#125;    const red = new Woman()    console.log(red)    // console.log(Woman.prototype)    // 男人 構造函數  繼承  想要 繼承 Person    function Man() &#123;    &#125;    // 通過 原型繼承 Person    Man.prototype = new Person()    Man.prototype.constructor = Man    const pink = new Man()    console.log(pink)  &lt;/script&gt;&lt;/body&gt;\n\n原型鏈基於原型物件的繼承使得不同構造函數的原型物件關聯在一起，並且這種關聯的關係是一種鏈狀的結構，我們將原型對象的鏈狀結構關係稱為原型鏈\n\n12345678910111213141516171819&lt;body&gt;  &lt;script&gt;    // function Objetc() &#123;&#125;    console.log(Object.prototype)    console.log(Object.prototype.__proto__)    function Person() &#123;    &#125;    const ldh = new Person()    // console.log(ldh.__proto__ === Person.prototype)    // console.log(Person.prototype.__proto__ === Object.prototype)    console.log(ldh instanceof Person)    console.log(ldh instanceof Object)    console.log(ldh instanceof Array)    console.log([1, 2, 3] instanceof Array)    console.log(Array instanceof Object)  &lt;/script&gt;&lt;/body&gt;\n\n① 當訪問一個物件的屬性（包括方法）時，首先查找這個物件自身有沒有該屬性。② 如果沒有就查找它的原型（也就是 __proto__指向的 prototype 原型物件）③ 如果還沒有就查找原型物件的原型（Object的原型物件）④ 依此類推一直找到 Object 為止（null）⑤ __proto__物件原型的意義就在於為物件成員查找機制提供一個方向，或者說一條路線⑥ 可以使用 instanceof 運算子用於檢測構造函數的 prototype 屬性是否出現在某個實例物件的原型鏈上\n","slug":"2303-3 JS 進階3","date":"2023-03-31T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"b57064d0869ba36d27730b8b11beee0b","title":"JavaScript 進階 - 第2天","content":"\n\n\n\n\n\n\n\n\n瞭解物件導向程式設計的基礎概念及構造函數的作用，體會 JavaScript 一切皆物件的語言特徵，掌握常見的物件屬性和方法的使用。\n\n瞭解物件導向程式設計中的一般概念\n能夠基於構造函數創建物件\n理解 JavaScript 中一切皆物件的語言特徵\n理解引用物件類型值存儲的的特徵\n掌握包裝類型物件常見方法的使用\n\n深入對象\n\n\n\n\n\n\n\n\n瞭解物件導向的基礎概念，能夠利用構造函數創建物件。\n構造函數構造函數是專門用於創建物件的函數，如果一個函數使用 new 關鍵字調用，那麼這個函數就是構造函數。\n12345678&lt;script&gt;  // 定義函數  function foo() &#123;    console.log(&#x27;通過 new 也能調用函數...&#x27;);  &#125;  // 調用函數  new foo;&lt;/script&gt;\n\n\n總結：\n\n使用 new 關鍵字調用函數的行為被稱為產生實體\n產生實體構造函數時沒有參數時可以省略 ()\n構造函數的返回值即為新創建的物件\n構造函數內部的 return 返回的值無效！\n\n注：實踐中為了從視覺上區分構造函數和普通函數，習慣將構造函數的首字母大寫。\n實例化執行過程說明：\n\n創建新對象\n構造函數 this 指向新對象\n執行構造函數 代碼，修改 this ，添加新的屬性\n返回新對象\n\n實例成員通過構造函數創建的物件稱為實例物件，實例物件中的屬性和方法稱為實例成員。\n123456789101112131415161718&lt;script&gt;  // 構造函數  function Person() &#123;    // 構造函數內部的 this 就是實例物件    // 實例物件中動態添加屬性    this.name = &#x27;小明&#x27;    // 實例物件動態添加方法    this.sayHi = function () &#123;      console.log(&#x27;大家好~&#x27;)    &#125;  &#125;  // 產生實體，p1 是實例物件  // p1 實際就是 構造函數內部的 this  const p1 = new Person()  console.log(p1)  console.log(p1.name) // 訪問實例屬性  p1.sayHi() // 調用實例方法&lt;/script&gt;\n\n總結：\n\n構造函數內部 this 實際上就是實例物件，為其動態添加的屬性和方法即為實例成員\n為構造函數傳入參數，動態創建結構相同但值不同的物件\n\n注：構造函數創建的實例物件彼此獨立互不影響。\n靜態成員在 JavaScript 中底層函數本質上也是物件類型，因此允許直接為函數動態添加屬性或方法，構造函數的屬性和方法被稱為靜態成員。\n123456789101112131415&lt;script&gt;  // 構造函數  function Person(name, age) &#123;    // 省略實例成員  &#125;  // 靜態屬性  Person.eyes = 2  Person.arms = 2  // 靜態方法  Person.walk = function () &#123;    console.log(&#x27;^_^人都會走路...&#x27;)    // this 指向 Person    console.log(this.eyes)  &#125;&lt;/script&gt;\n\n總結：\n\n靜態成員指的是添加到構造函數本身的屬性和方法\n一般公共特徵的屬性或方法靜態成員設置為靜態成員\n靜態成員方法中的 this 指向構造函數本身\n\n內置構造函數\n\n\n\n\n\n\n\n\n掌握各參考類型和包裝類型物件屬性和方法的使用。\n在 JavaScript 中最主要的資料類型有 6 種，分別是字串、數值、布林、undefined、null 和 物件，常見的物件類型資料包括陣列和普通物件。其中字串、數值、布林、undefined、null 也被稱為簡單類型或基礎類型，物件也被稱為參考類型。\n在 JavaScript 內置了一些構造函數，絕大部的資料處理都是基於這些構造函數實現的，JavaScript 基礎階段學習的 Date 就是內置的構造函數。\n1234567&lt;script&gt;  // 產生實體  let date = new Date();    // date 即為實例物件  console.log(date);&lt;/script&gt;\n\n甚至字串、數值、布林、陣列、普通物件也都有專門的構造函數，用於創建對應類型的資料。\nObjectObject 是內置的構造函數，用於創建普通物件。\n12345678910111213141516171819202122&lt;script&gt;  // 通過構造函數創建普通物件  const user = new Object(&#123;name: &#x27;小明&#x27;, age: 15&#125;)  // 這種方式聲明的變數稱為【字面量】  let student = &#123;name: &#x27;杜子騰&#x27;, age: 21&#125;    // 物件語法簡寫  let name = &#x27;小紅&#x27;;  let people = &#123;    // 相當於 name: name    name,    // 相當於 walk: function () &#123;&#125;    walk () &#123;      console.log(&#x27;人都要走路...&#x27;);    &#125;  &#125;  console.log(student.constructor);  console.log(user.constructor);  console.log(student instanceof Object);&lt;/script&gt;\n\n。\n總結：\n\n推薦使用字面量方式聲明物件，而不是 Object 構造函數\nObject.assign 靜態方法創建新的物件\nObject.keys 靜態方法獲取物件中所有屬性\nObject.values 表態方法獲取物件中所有屬性值\n\nArrayArray 是內置的構造函數，用於創建陣列。\n12345678&lt;script&gt;  // 構造函數創建陣列  let arr = new Array(5, 7, 8);  // 字面量方式創建陣列  let list = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]&lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\narr.reduce(function(上一次值, 当前元素值){}, 起始值)\n陣列賦值後，無論修改哪個變數另一個物件的資料值也會相當發生改變。\n\n\n\n方法\n作用\n說明\n\n\n\nforEach\n遍歷數組\n不返回數組，用於查找遍歷數組元素\n\n\nfilter\n過濾數組\n返回新數組，返回的是篩選滿足條件的數組元素\n\n\nmap\n迭代數組\n返回新數組，返回的是處理之後的數組元素，想要使用返回的新數組\n\n\nreduve\n累計器\n返回累計處理的結果，經常用於求和等\n\n\n\n總結：\n\n推薦使用字面量方式聲明陣列，而不是 Array 構造函數\n\n實例方法 forEach 用於遍歷陣列，替代 for 迴圈 (重點)\n\n實例方法 filter 過濾陣列單元值，生成新陣列(重點)\n\n實例方法 map 反覆運算原陣列，生成新陣列(重點)\n\n實例方法 join 陣列元素拼接為字串，返回字串(重點)\n\n實例方法  find  查找元素， 返回符合測試條件的第一個陣列元素值，如果沒有符合條件的則返回 undefined(重點)\n\n實例方法every 檢測陣列所有元素是否都符合指定條件，如果所有元素都通過檢測返回 true，否則返回 false(重點)\n\n實例方法some 檢測陣列中的元素是否滿足指定條件   如果陣列中有元素滿足條件返回 true，否則返回 false\n\n實例方法 concat  合併兩個陣列，返回生成新陣列\n\n實例方法 sort 對原陣列單元值排序\n\n實例方法 splice 刪除或替換原陣列單元\n\n實例方法 reverse 反轉陣列\n\n實例方法 findIndex  查找元素的索引值\n\n\n\n包裝類型在 JavaScript 中的字串、數值、布林具有物件的使用特徵，如具有屬性和方法，如下代碼舉例：\n1234567891011&lt;script&gt;  // 字串類型  const str = &#x27;hello world!&#x27;  // 統計字元的長度（字元數量）  console.log(str.length)    // 數數值型別  const price = 12.345  // 保留兩位小數  price.toFixed(2) // 12.34&lt;/script&gt;\n\n之所以具有物件特徵的原因是字串、數值、布林類型資料是 JavaScript 底層使用 Object 構造函數“包裝”來的，被稱為包裝類型。\n1234567891011121314151617181920212223&lt;script&gt;    //1. split 把字符串 轉換為 數組  和 join() 相反    const str = &#x27;pink,red&#x27;    const arr = str.split(&#x27;,&#x27;)    console.log(arr)    const str1 = &#x27;2022-4-8&#x27;    const arr1 = str1.split(&#x27;-&#x27;)    console.log(arr1)        // 2. 字符串的截取   substring(開始的索引號[， 結束的索引號])    // 2.1 如果省略 結束的索引號，默認取到最後    // 2.2 結束的索引號不包含想要截取的部分    const str = &#x27;今天又要做核酸了&#x27;    console.log(str.substring(5, 7))        // 3. startsWith 判斷是不是以某個字符開頭    const str = &#x27;pink老師上課中&#x27;    console.log(str.startsWith(&#x27;pink&#x27;))        // 4. includes 判斷某個字符是不是包含在一個字符串裡面    const str = &#x27;我是pink老師&#x27;    console.log(str.includes(&#x27;pink&#x27;)) // true  &lt;/script&gt;\n\nStringString 是內置的構造函數，用於創建字串。\n1234567891011&lt;script&gt;  // 使用構造函數創建字串  let str = new String(&#x27;hello world!&#x27;);  // 字面量創建字串  let str2 = &#x27;你好，世界！&#x27;;  // 檢測是否屬於同一個構造函數  console.log(str.constructor === str2.constructor); // true  console.log(str instanceof String); // false&lt;/script&gt;\n\n總結：\n\n實例屬性 length 用來獲取字串的度長(重點)\n實例方法 split(&#39;分隔符號&#39;) 用來將字串拆分成陣列(重點)\n實例方法 substring（需要截取的第一個字元的索引[,結束的索引號]） 用於字串截取(重點)\n實例方法 startsWith(檢測字串[, 檢測位置索引號]) 檢測是否以某字元開頭(重點)\n實例方法 includes(搜索的字串[, 檢測位置索引號]) 判斷一個字串是否包含在另一個字串中，根據情況返回 true 或 false(重點)\n實例方法 toUpperCase 用於將字母轉換成大寫\n實例方法 toLowerCase 用於將就轉換成小寫\n實例方法 indexOf  檢測是否包含某字元\n實例方法 endsWith 檢測是否以某字元結尾\n實例方法 replace 用於替換字串，支援正則匹配\n實例方法 match 用於查找字串，支援正則匹配\n\n注：String 也可以當做普通函數使用，這時它的作用是強制轉換成字串資料型別。\nNumberNumber 是內置的構造函數，用於創建數值。\n123456789&lt;script&gt;  // 使用構造函數創建數值  let x = new Number(&#x27;10&#x27;)  let y = new Number(5)  // 字面量創建數值  let z = 20&lt;/script&gt;\n\n總結：\n\n推薦使用字面量方式聲明數值，而不是 Number 構造函數\n實例方法 toFixed 用於設置保留小數位的長度\n\n","slug":"2303-3 JS 進階2","date":"2023-03-30T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"35ba1b013b453118df98cec61f2a93fb","title":"JavaScript 進階 - 第1天","content":"\n\n\n\n\n\n\n\n\n學習作用域、變數提升、閉包等語言特徵，加深對 JavaScript 的理解，掌握變數賦值、函式宣告的簡潔語法，降低代碼的冗餘度。\n\n理解作用域對程式執行的影響\n能夠分析程式執行的作用域範圍\n理解閉包本質，利用閉包創建隔離作用域\n瞭解什麼變數提升及函數提升\n掌握箭頭函數、解析剩餘參數等簡潔語法\n\n作用域\n\n\n\n\n\n\n\n\n瞭解作用域對程式執行的影響及作用域鏈的查找機制，使用閉包函數創建隔離作用域避免全域變數污染。\n作用域（scope）規定了變數能夠被訪問的“範圍”，離開了這個“範圍”變數便不能被訪問，作用域分為全域作用域和局部作用域。\n局部作用域局部作用域分為函數作用域和塊作用域。\n函數作用域在函數內部聲明的變數只能在函數內部被訪問，外部無法直接訪問。\n123456789101112&lt;script&gt;  // 聲明 counter 函數  function counter(x, y) &#123;    // 函數內部聲明的變數    const s = x + y    console.log(s) // 18  &#125;  // 設用 counter 函數  counter(10, 8)  // 訪問變數 s  console.log(s)// 報錯&lt;/script&gt;\n\n總結：\n\n函數內部聲明的變數，在函數外部無法被訪問\n函數的參數也是函數內部的區域變數\n不同函數內部聲明的變數無法互相訪問\n函數執行完畢後，函數內部的變數實際被清空了\n\n塊作用域在 JavaScript 中使用 &#123;&#125; 包裹的代碼稱為代碼塊，代碼塊內部聲明的變數外部將【有可能】無法被訪問。\n12345678910111213141516171819202122232425262728&lt;script&gt;  &#123;    // age 只能在該代碼塊中被訪問    let age = 18;    console.log(age); // 正常  &#125;    // 超出了 age 的作用域  console.log(age) // 報錯    let flag = true;  if(flag) &#123;    // str 只能在該代碼塊中被訪問    let str = &#x27;hello world!&#x27;    console.log(str); // 正常  &#125;    // 超出了 age 的作用域  console.log(str); // 報錯    for(let t = 1; t &lt;= 6; t++) &#123;    // t 只能在該代碼塊中被訪問    console.log(t); // 正常  &#125;    // 超出了 t 的作用域  console.log(t); // 報錯&lt;/script&gt;\n\nJavaScript 中除了變數外還有常量，常量與變數本質的區別是【常量必須要有值且不允許被重新賦值】，常量值為物件時其屬性和方法允許重新賦值。\n1234567891011121314151617181920&lt;script&gt;  // 必須要有值  const version = &#x27;1.0.0&#x27;;  // 不能重新賦值  // version = &#x27;1.0.1&#x27;;  // 常量值為對象類型  const user = &#123;    name: &#x27;小明&#x27;,    age: 18  &#125;  // 不能重新賦值  user = &#123;&#125;;  // 屬性和方法允許被修改  user.name = &#x27;小小明&#x27;;  user.gender = &#x27;男&#x27;;&lt;/script&gt;\n\n總結：\n\nlet 聲明的變數會產生塊作用域，var 不會產生塊作用域\nconst 聲明的常量也會產生塊作用域\n不同代碼塊之間的變數無法互相訪問\n推薦使用 let 或 const\n\n注：開發中 let 和 const 經常不加區分的使用，如果擔心某個值會不小被修改時，則只能使用 const 聲明成常量。\n全域作用域&lt;script&gt; 標籤和 .js 檔的【最外層】就是所謂的全域作用域，在此聲明的變數在函數內部也可以被訪問。\n123456789&lt;script&gt;  // 此處是全域    function sayHi() &#123;    // 此處為局部  &#125;  // 此處為全域&lt;/script&gt;\n\n全域作用域中聲明的變數，任何其它作用域都可以被訪問，如下代碼所示：\n1234567891011121314151617181920&lt;script&gt;    // 全域變數 name    const name = &#x27;小明&#x27;      // 函數作用域中訪問全域    function sayHi() &#123;      // 此處為局部      console.log(&#x27;你好&#x27; + name)    &#125;    // 全域變數 flag 和 x    const flag = true    let x = 10      // 塊作用域中訪問全域    if(flag) &#123;      let y = 5      console.log(x + y) // x 是全域的    &#125;&lt;/script&gt;\n\n總結：\n\n為 window 物件動態添加的屬性預設也是全域的，不推薦！\n函數中未使用任何關鍵字聲明的變數為全域變數，不推薦！！！\n盡可能少的聲明全域變數，防止全域變數被污染\n\nJavaScript 中的作用域是程式被執行時的底層機制，瞭解這一機制有助於規範代碼書寫習慣，避免因作用域導致的語法錯誤。\n作用域鏈在解釋什麼是作用域鏈前先來看一段代碼：\n12345678910111213&lt;script&gt;  // 全域作用域  let a = 1  let b = 2  // 局部作用域  function f() &#123;    let c    // 局部作用域    function g() &#123;      let d = &#x27;yo&#x27;    &#125;  &#125;&lt;/script&gt;\n\n函數內部允許創建新的函數，f 函數內部創建的新函數 g，會產生新的函數作用域，由此可知作用域產生了嵌套的關係。\n如下圖所示，父子關係的作用域關聯在一起形成了鏈狀的結構，作用域鏈的名字也由此而來。\n作用域鏈本質上是底層的變數查找機制，在函數被執行時，會優先查找當前函數作用域中查找變數，如果當前作用域查找不到則會依次逐級查找父級作用域直到全域作用域，如下代碼所示：\n12345678910111213141516171819202122232425262728&lt;script&gt;  // 全域作用域  let a = 1  let b = 2  // 局部作用域  function f() &#123;    let c    // let a = 10;    console.log(a) // 1 或 10    console.log(d) // 報錯        // 局部作用域    function g() &#123;      let d = &#x27;yo&#x27;      // let b = 20;      console.log(b) // 2 或 20    &#125;        // 調用 g 函數    g()  &#125;  console.log(c) // 報錯  console.log(d) // 報錯    f();&lt;/script&gt;\n\n總結：\n\n嵌套關係的作用域串聯起來形成了作用域鏈\n相同作用域鏈中按著從小到大的規則查找變數\n子作用域能夠訪問父作用域，父級作用域無法訪問子級作用域\n\nJS垃圾回收機制垃圾回收機制(Garbage Collection) 簡稱 GCJS中內存的分配和回收都是自動完成的，內存在不使用的時候會被垃圾回收器自動回收。 **如果不了解JS的內存管理機制，我們同樣非常容易成內存洩漏（內存無法被回收）的情況不再用到的內存，沒有及時釋放，就叫做**內存洩漏\n\n內存的生命週期JS環境中分配的內存, 一般有如下生命週期：\n\n內存分配：當我們聲明變量、函數、對象的時候，系統會自動為他們分配內存\n內存使用：即讀寫內存，也就是使用變量、函數等\n內存回收：使用完畢，由垃圾回收自動回收不再使用的內存\n\n\n\n\n\n\n\n\n\n\n說明：\n\n全局變量一般不會回收(關閉頁面回收)；\n一般情況下局部變量的值, 不用了, 會被自動回收掉\n\n\n算法說明堆棧空間分配區別：\n\n棧（操作系統）: 由操作系統自動分配釋放函數的參數值、局部變量等，基本數據類型放到棧裡面。\n堆（操作系統）: 一般由程序員分配釋放，若程序員不釋放，由垃圾回收機制回收。複雜數據類型放到堆裡面。\n\n\n常見的瀏覽器垃圾回收算法: 引用計數法 和 標記清除法\n引用計數IE採用的引用計數算法, 定義“內存不再使用”，就是看一個對像是否有指向它的引用，沒有引用了就回收對象\n\n跟踪記錄被引用的次數\n如果被引用了一次，那麼就記錄次數1,多次引用會累加 ++\n如果減少一個引用就減1 –\n如果引用次數是0 ，則釋放內存\n\n標記清除法現代的瀏覽器已經不再使用引用計數算法了。現代瀏覽器通用的大多是基於標記清除算法的某些改進算法，總體思想都是一致的。核心：\n\n標記清除算法將“不再使用的對象”定義為“無法達到的對象”。\n就是從根部（在JS中就是全局對象）出發定時掃描內存中的對象。凡是能從根部到達的對象，都是還需要使用的。\n那些無法由根部出發觸及到的對像被標記為不再使用，稍後進行回收。\n\n閉包閉包是一種比較特殊和函數，使用閉包能夠訪問函數作用域中的變數。從代碼形式上看閉包是一個做為返回值的函數，如下代碼所示：\n\n\n\n\n\n\n\n\n\n閉包 : 內層函數 + 外層函數變數\n12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;body&gt;  &lt;script&gt;    // 1. 閉包 : 內層函數 + 外層函數變數    // function outer() &#123;        //外層函數變數    //   const a = 1        //內層函數    //   function f() &#123;    //     console.log(a)    //   &#125;    //   f()    // &#125;    // outer()    // 2. 閉包的應用： 統計函數的調用次數    // let count = 1    // function fn() &#123;    //   count++    //   console.log(`函數被調用$&#123;count&#125;次`)    // &#125;    //  因为 count 是全局變量，容易被修改    // 3. 閉包的升級寫法 實現資料的私有。 統計函數的調用次數    function outer() &#123;      let count = 1      function fn() &#123;        count++        console.log(`函數被調用$&#123;count&#125;次`)      &#125;      return fn    &#125;    //全局~    const re = outer()    // const re = function fn() &#123;    //   count++    //   console.log(`函數被調用$&#123;count&#125;次`)    // &#125;    re()    re()    // const fn = function() &#123; &#125;  函數運算式    // 4. 閉包存在的問題： 可能會造成記憶體洩漏  &lt;/script&gt;&lt;/body&gt;\n\n總結：\n1.怎麼理解閉包？\n\n閉包 &#x3D; 內層函數 + 外層函數的變數\n\n2.閉包的作用？\n\n封閉資料，實現資料私有，外部也可以訪問函數內部的變數\n閉包很有用，因為它允許將函數與其所操作的某些資料（環境）關聯起來\n\n3.閉包可能引起的問題？\n\n記憶體洩漏\n\n變數提升變數提升是 JavaScript 中比較“奇怪”的現象，它允許在變數聲明之前即被訪問，\n1234567&lt;script&gt;  // 訪問變數 str  console.log(str + &#x27;world!&#x27;);  // 聲明變數 str  var str = &#x27;hello &#x27;;&lt;/script&gt;\n\n總結：\n\n變數在未聲明即被訪問時會報語法錯誤\n變數在聲明之前即被訪問，變數的值為 undefined\nlet 聲明的變數不存在變數提升，推薦使用 let\n變數提升出現在相同作用域當中\n實際開發中推薦先聲明再訪問變數\n\n注：關於變數提升的原理分析會涉及較為複雜的詞法分析等知識，而開發中使用 let 可以輕鬆規避變數的提升，因此在此不做過多的探討，有興趣可查閱資料。\n函數\n\n\n\n\n\n\n\n\n知道函數參數預設值、動態參數、剩餘參數的使用細節，提升函數應用的靈活度，知道箭頭函數的語法及與普通函數的差異。\n函數提升函數提升與變數提升比較類似，是指函數在聲明之前即可被調用。\n1234567891011121314&lt;script&gt;  // 調用函數  foo()  // 聲明函數  function foo() &#123;    console.log(&#x27;聲明之前即被調用...&#x27;)  &#125;  // 不存在提升現象  bar()  // 錯誤  var bar = function () &#123;    console.log(&#x27;函數運算式不存在提升現象...&#x27;)  &#125;&lt;/script&gt;\n\n總結：\n\n函數提升能夠使函數的聲明調用更靈活\n函數運算式不存在提升的現象\n函數提升出現在相同作用域當中\n\n函數參數函數參數的使用細節，能夠提升函數應用的靈活度。\n預設值12345678910&lt;script&gt;  // 設置參數預設值  function sayHi(name=&quot;小明&quot;, age=18) &#123;    document.write(`&lt;p&gt;大家好，我叫$&#123;name&#125;，我今年$&#123;age&#125;歲了。&lt;/p&gt;`);  &#125;  // 調用函數  sayHi();  sayHi(&#x27;小紅&#x27;);  sayHi(&#x27;小剛&#x27;, 21);&lt;/script&gt;\n\n總結：\n\n聲明函數時為形參賦值即為參數的預設值\n如果參數未自訂預設值時，參數的預設值為 undefined\n調用函數時沒有傳入對應實參時，參數的預設值被當做實參傳入\n\n動態參數arguments 是函數內部內置的偽陣列變數，它包含了調用函數時傳入的所有實參。\n1234567891011121314&lt;script&gt;  // 求生函數，計算所有參數的和  function sum() &#123;    // console.log(arguments)    let s = 0    for(let i = 0; i &lt; arguments.length; i++) &#123;      s += arguments[i]    &#125;    console.log(s)  &#125;  // 調用求和函數  sum(5, 10)// 兩個參數  sum(1, 2, 4) // 兩個參數&lt;/script&gt;\n\n總結：\n\narguments 是一個偽陣列\narguments 的作用是動態獲取函數的實參\n\n剩餘參數 (與 展開運算符 相似)12345678&lt;script&gt;  function config(baseURL, ...other) &#123;    console.log(baseURL) // 得到 &#x27;http://baidu.com&#x27;    console.log(other)  // other  得到 [&#x27;get&#x27;, &#x27;json&#x27;]  &#125;  // 調用函數  config(&#x27;http://baidu.com&#x27;, &#x27;get&#x27;, &#x27;json&#x27;);&lt;/script&gt;\n\n總結：\n\n... 是語法符號，置於最末函數形參之前，用於獲取多餘的實參\n借助 ... 獲取的剩餘實參，是個真陣列\n\n展開運算符 or 剩餘參數剩餘參數：函數參數使用，得到真數組展開運算符：數組中使用，數組展開\n箭頭函數箭頭函數是一種聲明函數的簡潔語法，它與普通函數並無本質的區別，差異性更多體現在語法格式上，更適用於那些本來需要匿名函數的地方。\n12345678910111213141516171819202122232425262728293031323334353637&lt;body&gt;  &lt;script&gt;    // const fn = function () &#123;    //   console.log(123)    // &#125;    // 1. 箭頭函數 基本語法    // const fn = () =&gt; &#123;    //   console.log(123)    // &#125;    // fn()    // const fn = (x) =&gt; &#123;    //   console.log(x)    // &#125;    // fn(1)    // 2. 只有一個形參的時候，可以省略小括弧    // const fn = x =&gt; &#123;    //   console.log(x)    // &#125;    // fn(1)    // // 3. 只有一行代碼的時候，我們可以省略大括弧    // const fn = x =&gt; console.log(x)    // fn(1)    // 4. 只有一行代碼的時候，可以省略return    // const fn = x =&gt; x + x    // console.log(fn(1))    // 5. 箭頭函數可以直接返回一個物件    // const fn = (uname) =&gt; (&#123; uname: uname &#125;)    // console.log(fn(&#x27;劉德華&#x27;))  &lt;/script&gt;&lt;/body&gt;\n\n總結：\n\n箭頭函數屬於運算式函數，因此不存在函數提升\n箭頭函數只有一個參數時可以省略圓括號 ()\n箭頭函數函數體只有一行代碼時可以省略花括弧 &#123;&#125;，並自動做為返回值被返回\n\n箭頭函數參數箭頭函數中沒有動態參數 arguments，只能使用剩餘參數 ... 動態獲取實參\n12345678910111213&lt;body&gt;  &lt;script&gt;    // 1. 利用箭頭函數來求和    const getSum = (...arr) =&gt; &#123;      let sum = 0      for (let i = 0; i &lt; arr.length; i++) &#123;        sum += arr[i]      &#125;      return sum    &#125;    const result = getSum(2, 3, 4)    console.log(result) // 9  &lt;/script&gt;\n\n箭頭函數 this箭頭函數不會創建自己的this,它只會從自己的作用域鏈的上一層沿用this。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;script&gt;   // 以前this的指向：  誰調用的這個函數，this 就指向誰   // console.log(this)  // window   // // 普通函數   // function fn() &#123;   //   console.log(this)  // window   // &#125;   // window.fn()   // // 物件方法裡面的this   // const obj = &#123;   //   name: &#x27;andy&#x27;,   //   sayHi: function () &#123;   //     console.log(this)  // obj   //   &#125;   // &#125;   // obj.sayHi()   // 2. 箭頭函數的this  是上一層作用域的this 指向   // const fn = () =&gt; &#123;   //   console.log(this)  // window   // &#125;   // fn()   // 物件方法箭頭函數 this   // const obj = &#123;   //   uname: &#x27;pink老師&#x27;,   //   sayHi: () =&gt; &#123;   //     console.log(this)  // this 指向誰？ window   //   &#125;   // &#125;   // obj.sayHi()   const obj = &#123;     uname: &#x27;老師&#x27;,     sayHi: function () &#123;       console.log(this)  // obj       let i = 10       const count = () =&gt; &#123;         console.log(this)  // obj        &#125;       count()     &#125;   &#125;   obj.sayHi() &lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n箭頭函數不會創建自己的this,它只會從自己的作用域鏈的上一層沿用thisDOM事件回調函數不推薦使用箭頭函數嗎，特別是需要用到this的時候事件回調函數使用箭頭函數時，this 為全局的 window\n解構賦值\n\n\n\n\n\n\n\n\n知道解構的語法及分類，使用解構簡潔語法快速為變數賦值。\n解構賦值是一種快速為變數賦值的簡潔語法，本質上仍然是為變數賦值，分為陣列解構、物件解構兩大類型。\n1console [變量1,變量2,變量3] = [單元值1, 單元值2, 單元值3]\n\n陣列解構陣列解構是將陣列的單元值快速批量賦值給一系列變數的簡潔語法，如下代碼所示：\n12345678910&lt;script&gt;  // 普通的陣列  let arr = [1, 2, 3]  // 批量聲明變數 a b c   // 同時將陣列單元值 1 2 3 依次賦值給變數 a b c  let [a, b, c] = arr  console.log(a); // 1  console.log(b); // 2  console.log(c); // 3&lt;/script&gt;\n\n1234567891011121314151617&lt;script&gt;  // const arr = [100, 60, 80]  // 數組解構 賦值  // // const [max, min, avg] = arr  const [max, min, avg] = [100, 60, 80]  // // const max = arr[0]  // // const min = arr[1]  // // const avg = arr[2]  console.log(max) // 100  console.log(avg) // 80  // 交換2個變量的值  let a = 1  let b = 2;  [b, a] = [a, b]  console.log(a, b)  &lt;/script&gt;\n1234567891011121314151617&lt;script&gt;    // 1. 立即执行函数要加    // (function () &#123; &#125;)();    // (function () &#123; &#125;)();    // 2. 使用数组的时候    // const arr = [1, 2, 3]    const str = &#x27;pink&#x27;;    [1, 2, 3].map(function (item) &#123;      console.log(item)    &#125;)    let a = 1    let b = 2      ;[b, a] = [a, b]    console.log(a, b)  &lt;/script&gt;\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script&gt;    // const pc = [&#x27;海爾&#x27;, &#x27;聯想&#x27;, &#x27;小米&#x27;, &#x27;方正&#x27;];    // [hr, lx, mi, fz] = pc    // console.log(hr, lx, mi, fz);    // function getValue() &#123;    //   return [100, 60]    // &#125;    // [max, min] = getValue()    // console.log(max, min);    // const pc = [&#x27;海爾&#x27;, &#x27;聯想&#x27;, &#x27;小米&#x27;, &#x27;方正&#x27;]    // const [hr, lx, mi, fz] = [&#x27;海爾&#x27;, &#x27;聯想&#x27;, &#x27;小米&#x27;, &#x27;方正&#x27;]    // console.log(hr)    // console.log(lx)    // console.log(mi)    // console.log(fz)    // // 請將最大值和最小值函數返回值解構 max 和min 兩個變量    // function getValue() &#123;    //   return [100, 60]    // &#125;    // const [max, min] = getValue()    // console.log(max)    // console.log(min)        // 1. 變量多， 單元值少 ， undefined    // const [a, b, c, d] = [1, 2, 3]    // console.log(a) // 1    // console.log(b) // 2    // console.log(c) // 3    // console.log(d) // undefined    // 2. 變量少， 單元值多    // const [a, b] = [1, 2, 3]    // console.log(a) // 1    // console.log(b) // 2    // 3.  剩餘參數 變量少， 單元值多    // const [a, b, ...c] = [1, 2, 3, 4]    // console.log(a) // 1    // console.log(b) // 2    // console.log(c) // [3, 4]  真數組    // 4.  防止 undefined 傳遞    // const [a = 0, b = 0] = [1, 2]    // const [a = 0, b = 0] = []    // console.log(a) // 1    // console.log(b) // 2    // 5.  按需導入賦值    // const [a, b, , d] = [1, 2, 3, 4]    // console.log(a) // 1    // console.log(b) // 2    // console.log(d) // 4    // const arr = [1, 2, [3, 4]]    // console.log(arr[0])  // 1    // console.log(arr[1])  // 2    // console.log(arr[2])  // [3,4]    // console.log(arr[2][0])  // 3    // 多維數組解構    // const arr = [1, 2, [3, 4]]    // const [a, b, c] = [1, 2, [3, 4]]    // console.log(a) // 1    // console.log(b) // 2    // console.log(c) // [3,4]    // const [a, b, [c, d]] = [1, 2, [3, 4]]    // console.log(a) // 1    // console.log(b) // 2    // console.log(c) // 3    // console.log(d) // 4  &lt;/script&gt;\n總結：\n\n設定運算子 = 左側的 [] 用於批量聲明變數，右側陣列的單元值將被賦值給左側的變數\n變數的順序對應陣列單元值的位置依次進行賦值操作\n變數的數量大於單元值數量時，多餘的變數將被賦值為  undefined\n變數的數量小於單元值數量時，可以通過 ... 獲取剩餘單元值，但只能置於最末位\n允許初始化變數的預設值，且只有單元值為 undefined 時預設值才會生效\n\n注：支持多維解構賦值，比較複雜後續有應用需求時再進一步分析\n對象解構 (重要)\n\n\n\n\n\n\n\n\n複習: 數組中括號[]，對象大括號{}\n物件解構是將物件屬性和方法快速批量賦值給一系列變數的簡潔語法，如下代碼所示：\n123456789101112131415161718&lt;script&gt;  // 普通對象  const user = &#123;    name: &#x27;小明&#x27;,    age: 18  &#125;;  // 批量聲明變數 name age  // 同時將陣列單元值 小明  18 依次賦值給變數 name  age  //解構的語法  const &#123;name, age&#125; = user  // const &#123;name, age&#125; = &#123;name: &#x27;小明&#x27;,age: 18&#125; 亦可  // 等價於 const name =  obj.name    // 要求屬性名和變量名必須一直才可以  console.log(name) // 小明  console.log(age) // 18&lt;/script&gt;\n\n總結：\n\n設定運算子 = 左側的 &#123;&#125; 用於批量聲明變數，右側物件的屬性值將被賦值給左側的變數\n物件屬性的值將被賦值給與屬性名相同的變數\n物件中找不到與變數名一致的屬性時變數值為 undefined\n允許初始化變數的預設值，屬性不存在或單元值為 undefined 時預設值才會生效\n\n123456789101112131415161718&lt;script&gt;    // 1. 對象解構的變量名 可以重新改名  舊變量名: 新變量名    // const &#123; uname: username, age &#125; = &#123; uname: &#x27;老師&#x27;, age: 18 &#125;    // // console.log(username)    // // console.log(age)    // 2. 解構數組對象    const pig = [      &#123;        uname: &#x27;佩奇&#x27;,        age: 6      &#125;    ]    const [&#123; uname, age &#125;] = pig    console.log(uname)    console.log(age)  &lt;/script&gt;\n\n\n\n\n\n\n\n\n\n\n注：支持多維解構賦值\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt;  &lt;script&gt;    // 1. 這是後臺傳遞過來的資料    const msg = &#123;      &quot;code&quot;: 200,      &quot;msg&quot;: &quot;獲取新聞列表成功&quot;,      &quot;data&quot;: [        &#123;          &quot;id&quot;: 1,          &quot;title&quot;: &quot;5G商用自己，三大運用商收入下降&quot;,          &quot;count&quot;: 58        &#125;,        &#123;          &quot;id&quot;: 2,          &quot;title&quot;: &quot;國際媒體頭條速覽&quot;,          &quot;count&quot;: 56        &#125;,        &#123;          &quot;id&quot;: 3,          &quot;title&quot;: &quot;烏克蘭和俄羅斯持續衝突&quot;,          &quot;count&quot;: 1669        &#125;,      ]    &#125;    // 需求1： 請將以上msg物件  採用物件解構的方式 只選出  data 方面後面使用渲染頁面    // const &#123; data &#125; = msg    // console.log(data)    // 需求2： 上面msg是後臺傳遞過來的資料，我們需要把data選出當做參數傳遞給 函數    // const &#123; data &#125; = msg    // msg 雖然很多屬性，但是我們利用解構只要 data值    function render(&#123; data &#125;) &#123;      // const &#123; data &#125; = arr      // 我們只要 data 資料      // 內部處理      console.log(data)    &#125;    render(msg)    //給新的變量名賦值(冒號表示 “ 什麼值：賦值給誰 ”)    // 需求3， 為了防止msg裡面的data名字混淆，要求渲染函數裡面的資料名改為 myData    function render(&#123; data: myData &#125;) &#123;      // 要求將 獲取過來的 data資料 更名為 myData      // 內部處理      console.log(myData)    &#125;    render(msg)  &lt;/script&gt;\n\n綜合案例forEach遍歷陣列forEach() 方法用於調用陣列的每個元素，並將元素傳遞給回呼函數\n1234語法:被遍歷的數組.forEach(function (當前數組元素, 當前元素索引號) &#123;  //函數體&#125;)\n\n\n\n\n\n\n\n\n\n\n注意：  \n1.forEach 主要是遍歷陣列\n2.參數當前陣列元素是必須要寫的， 索引號可選。\n1234567891011&lt;body&gt;  &lt;script&gt;    // forEach 就是遍歷  加強版的for迴圈  適合於遍歷陣列物件    const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;]    const result = arr.forEach(function (item, index) &#123;      console.log(item)  // 陣列元素 red  green pink      console.log(index) // 索引號    &#125;)    // console.log(result)  &lt;/script&gt;&lt;/body&gt;\n\nfilter篩選陣列filter() 方法創建一個新的陣列，新陣列中的元素是通過檢查指定陣列中符合條件的所有元素\n1234語法:被遍歷的數組.filter(function (参數, index) &#123;  return 篩選條件&#125;)\n\n主要使用場景： 篩選陣列符合條件的元素，並返回篩選之後元素的新陣列\n1234567891011121314&lt;body&gt;  &lt;script&gt;    const arr = [10, 20, 30]    // const newArr = arr.filter(function (item, index) &#123;    //   // console.log(item)    //   // console.log(index)    //   return item &gt;= 20    // &#125;)    // 返回的符合條件的新陣列    const newArr = arr.filter(item =&gt; item &gt;= 20)    console.log(newArr)  &lt;/script&gt;&lt;/body&gt;\n\n\n\n\n","slug":"2303-3 JS 進階1","date":"2023-03-29T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"1359ad702c466c1bb96b6c62885f8401","title":"JavaScript Web APIs - 第6天","content":"\n\n\n\n\n\n\n\n\n目標：能夠利用規則運算式完成小兔鮮註冊頁面的表單驗證，具備常見的表單驗證能力\n\n規則運算式\n綜合案例\n階段案例\n\n規則運算式規則運算式（Regular Expression）是一種字串匹配的模式（規則）\n使用場景：\n\n例如驗證表單：手機號表單要求用戶只能輸入11位元的數字 (匹配)\n過濾掉頁面內容中的一些敏感詞(替換)，或從字串中獲取我們想要的特定部分(提取)等\n\n正則基本使用\n\n\n\n\n\n\n\n\n作用:表單驗證(匹配)、過濾敏感字(替換)、字符串提取想要的部分(提取)\n\n定義規則\n1const reg =  /運算式/\n\n\n其中/   /是規則運算式字面量\n規則運算式也是物件 \n\n\n使用正則-判斷是否有符合規則的字符串\n\ntest()方法   用來查看規則運算式與指定的字串是否匹配\n如果規則運算式與指定的字串匹配 ，返回true，否則false\n\n\n\n\n\n\n\n\n\n\n\n\nreg.test(被檢測的字符串)\n123456789101112&lt;body&gt;  &lt;script&gt;    // 規則運算式的基本使用    const str = &#x27;web前端開發&#x27;    // 1. 定義規則    const reg = /web/    // 2. 使用正則  test()    console.log(reg.test(str))  // true  如果符合規則匹配上則返回true    console.log(reg.test(&#x27;java開發&#x27;))  // false  如果不符合規則匹配上則返回 false  &lt;/script&gt;&lt;/body&gt;\n\n\n使用正則-檢索（查找）符合規則的字符串\nexec() 方法 在一個指定字符串中執行一個搜索匹配\n如果匹配成功，exec() 方法返回一個數組，否則返回null\n\n\n\n\n\n\n\n\n\n\n\n\nreg.exec(被檢測的字符串)\n12345678910&lt;body&gt;  &lt;script&gt;    const str = &#x27;學習前端&#x27;    // 正則表達式使用：    // 1. 定義規則    const reg = /前端/    // 2. exec()    console.log(reg.exec(str))  // 返回數組  &lt;/script&gt;&lt;/body&gt;\n\n\n正則表達式檢測查找 test方法和exec方法有什麼區別？\ntest方法 用於判斷是否有符合規則的字符串，返回的是  布爾值 找到返回true，否則false\nexec方法 用於檢索（查找）符合規則的字符串，找到返回數組，否則為 null\n\n\n\n元字元\n普通字元:\n\n\n大多數的字元僅能夠描述它們本身，這些字元稱作普通字元，例如所有的字母和數位。\n普通字元只能夠匹配字串中與它們相同的字元。    \n比如，規定用戶只能輸入英文26個英文字母，普通字元的話  &#x2F;[abcdefghijklmnopqrstuvwxyz]&#x2F;\n\n\n元字元(特殊字元)\n\n\n是一些具有特殊含義的字元，可以極大提高了靈活性和強大的匹配功能。\n比如，規定用戶只能輸入英文26個英文字母，換成元字元寫法： &#x2F;[a-z]&#x2F;\n\n邊界符規則運算式中的邊界符（位置符）用來提示字元所處的位置，主要有兩個字元\n\n\n\n邊界符\n說明\n\n\n\n^\n表示匹配行首的文本(以誰開始)\n\n\n$\n表示匹配行尾的文本(以誰結束)\n\n\n\n\n\n\n\n\n\n\n\n如果 ^ 和 $ 在一起，表示必須是精確匹配\n1234567891011121314151617181920212223242526272829303132&lt;body&gt;  &lt;script&gt;    // 前面正則  test()    console.log(/web/.test(&#x27;web&#x27;))  // true    console.log(/web/.test(&#x27;前端web&#x27;))  // true    console.log(/web/.test(&#x27;前端web學習&#x27;))  // true    // 元字元之邊界符    // 1. 匹配開頭的位置 ^    const reg = /^web/    console.log(reg.test(&#x27;web前端&#x27;))  // true    console.log(reg.test(&#x27;前端web&#x27;))  // false    console.log(reg.test(&#x27;前端web學習&#x27;))  // false    console.log(reg.test(&#x27;we&#x27;))  // false    // 2. 匹配結束的位置 $    const reg1 = /web$/    console.log(reg1.test(&#x27;web前端&#x27;))  //  false    console.log(reg1.test(&#x27;前端web&#x27;))  // true    console.log(reg1.test(&#x27;前端web學習&#x27;))  // false    console.log(reg1.test(&#x27;we&#x27;))  // false      // 3. 精確匹配 ^ $    const reg2 = /^web$/    console.log(reg2.test(&#x27;web前端&#x27;))  //  false    console.log(reg2.test(&#x27;前端web&#x27;))  // false    console.log(reg2.test(&#x27;前端web學習&#x27;))  // false    console.log(reg2.test(&#x27;we&#x27;))  // false     console.log(reg2.test(&#x27;web&#x27;))  // true    console.log(reg2.test(&#x27;webweb&#x27;))  // flase   &lt;/script&gt;&lt;/body&gt;\n\n量詞量詞用來設定某個模式重複次數\n\n\n\n量詞\n說明\n\n\n\n*\n重複0次或更多次\n\n\n+\n重複1次或更多次\n\n\n?\n重複0次或1次\n\n\n&#123;n&#125;\n重複n次\n\n\n&#123;n,&#125;\n重複n次或更多次\n\n\n&#123;n,m&#125;\n重複n次到m次\n\n\n\n\n\n\n\n\n\n\n\n注意： 逗號左右兩側千萬不要出現空格\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;body&gt;  &lt;script&gt;    // 元字元之量詞    // 1. * 重複次數 &gt;= 0 次    const reg1 = /^w*$/    console.log(reg1.test(&#x27;&#x27;))  // true    console.log(reg1.test(&#x27;w&#x27;))  // true    console.log(reg1.test(&#x27;ww&#x27;))  // true    console.log(&#x27;-----------------------&#x27;)    // 2. + 重複次數 &gt;= 1 次    const reg2 = /^w+$/    console.log(reg2.test(&#x27;&#x27;))  // false    console.log(reg2.test(&#x27;w&#x27;))  // true    console.log(reg2.test(&#x27;ww&#x27;))  // true    console.log(&#x27;-----------------------&#x27;)    // 3. ? 重複次數  0 || 1     const reg3 = /^w?$/    console.log(reg3.test(&#x27;&#x27;))  // true    console.log(reg3.test(&#x27;w&#x27;))  // true    console.log(reg3.test(&#x27;ww&#x27;))  // false    console.log(&#x27;-----------------------&#x27;)    // 4. &#123;n&#125; 重複 n 次    const reg4 = /^w&#123;3&#125;$/    console.log(reg4.test(&#x27;&#x27;))  // false    console.log(reg4.test(&#x27;w&#x27;))  // flase    console.log(reg4.test(&#x27;ww&#x27;))  // false    console.log(reg4.test(&#x27;www&#x27;))  // true    console.log(reg4.test(&#x27;wwww&#x27;))  // false    console.log(&#x27;-----------------------&#x27;)    // 5. &#123;n,&#125; 重複次數 &gt;= n     const reg5 = /^w&#123;2,&#125;$/    console.log(reg5.test(&#x27;&#x27;))  // false    console.log(reg5.test(&#x27;w&#x27;))  // false    console.log(reg5.test(&#x27;ww&#x27;))  // true    console.log(reg5.test(&#x27;www&#x27;))  // true    console.log(&#x27;-----------------------&#x27;)    // 6. &#123;n,m&#125;   n =&lt; 重複次數 &lt;= m    const reg6 = /^w&#123;2,4&#125;$/    console.log(reg6.test(&#x27;w&#x27;))  // false    console.log(reg6.test(&#x27;ww&#x27;))  // true    console.log(reg6.test(&#x27;www&#x27;))  // true    console.log(reg6.test(&#x27;wwww&#x27;))  // true    console.log(reg6.test(&#x27;wwwww&#x27;))  // false    // 7. 注意事項： 逗號兩側千萬不要加空格否則會匹配失敗  &lt;/script&gt;\n\n範圍表示字元的範圍，定義的規則限定在某個範圍，比如只能是英文字母，或者數位等等，用表示範圍\n\n\n\n範圍\n說明\n\n\n\n[abc]\n匹配方括號中的任意一個字符，也就是說可以匹配 a、b 或 c 這三個字母中的任意一個。 多選1\n\n\n[a-z]\n匹配所有小寫字母中的任意一個字符，從 a 到 z。單個\n\n\n[^a-z]\n取反符，匹配不在小寫字母 a 到 z 中的任何一個字符，換句話說，就是匹配除了小寫字母 a 到 z 以外的所有字符。\n\n\n123456789101112131415161718192021222324252627282930313233343536373839&lt;body&gt;  &lt;script&gt;    // 元字元之範圍  []      // 1. [abc] 匹配包含的單個字元， 多選1    const reg1 = /^[abc]$/    console.log(reg1.test(&#x27;a&#x27;))  // true    console.log(reg1.test(&#x27;b&#x27;))  // true    console.log(reg1.test(&#x27;c&#x27;))  // true    console.log(reg1.test(&#x27;d&#x27;))  // false    console.log(reg1.test(&#x27;ab&#x27;))  // false    // 2. [a-z] 連字號 單個    const reg2 = /^[a-z]$/    console.log(reg2.test(&#x27;a&#x27;))  // true    console.log(reg2.test(&#x27;p&#x27;))  // true    console.log(reg2.test(&#x27;0&#x27;))  // false    console.log(reg2.test(&#x27;A&#x27;))  // false    // 想要包含小寫字母，大寫字母 ，數位    const reg3 = /^[a-zA-Z0-9]$/    console.log(reg3.test(&#x27;B&#x27;))  // true    console.log(reg3.test(&#x27;b&#x27;))  // true    console.log(reg3.test(9))  // true    console.log(reg3.test(&#x27;,&#x27;))  // flase    // 用戶名可以輸入英文字母，數位，可以加底線，要求 6~16位    const reg4 = /^[a-zA-Z0-9_]&#123;6,16&#125;$/    console.log(reg4.test(&#x27;abcd1&#x27;))  // false     console.log(reg4.test(&#x27;abcd12&#x27;))  // true    console.log(reg4.test(&#x27;ABcd12&#x27;))  // true    console.log(reg4.test(&#x27;ABcd12_&#x27;))  // true    // 3. [^a-z] 取反符    const reg5 = /^[^a-z]$/    console.log(reg5.test(&#x27;a&#x27;))  // false     console.log(reg5.test(&#x27;A&#x27;))  // true    console.log(reg5.test(8))  // true  &lt;/script&gt;&lt;/body&gt;\n\n\n\n\n\n\n\n\n\n\n身分證字號：^[A-Z][1-2][0-9]&#123;8&#125;$\n字元類字符類 . (點)代表什麼意思？\n\n\n\n\n\n\n\n\n\nA.匹配除換行符之外的任何單個字符\n某些常見模式的簡寫方式，區分字母和數位\n\n\n\n字符類\n說明\n\n\n\n\\d\n代表一個數字字符，等價於 [0-9]。\n\n\n\\D\n代表一個非數字字符，等價於 [^0-9]。\n\n\n\\w\n代表一個單字字符（即字母、數字或底線），等價於 [a-zA-Z0-9_]。\n\n\n\\W\n代表一個非單字字符，等價於 [^a-zA-Z0-9_]。\n\n\n\\s\n代表一個空白字符（包括空格、製表符、換行符等），等價於 [\\t\\n\\f\\r\\p{Z}]。\n\n\n\\S\n代表一個非空白字符，等價於 [^\\t\\n\\f\\r\\p{Z}]。\n\n\n1日期格式：/^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;$/\n替換和修飾符replace 替換方法，可以完成字元的替換\n1字符串.replace(/正則表達式/, &#x27;替換的文本&#x27;)\n\n123456789&lt;body&gt;  &lt;script&gt;    // 替換和修飾符    const str = &#x27;學習前端，成為前端大神&#x27;    // 1. 替換  replace  需求：把前端替換為 web    // 1.1 replace 返回值是替換完畢的字串    // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替換一個  &lt;/script&gt;&lt;/body&gt;\n\n修飾符約束正則執行的某些細節行為，如是否區分大小寫、是否支持多行匹配等\n\ni 是單詞 ignore 的縮寫，正則匹配時字母不區分大小寫\ng 是單詞 global 的縮寫，匹配所有滿足規則運算式的結果\n\n12345678910111213&lt;body&gt;  &lt;script&gt;    // 替換和修飾符    const str = &#x27;歡迎大家學習前端，相信大家一定能學好前端，都成為前端大神&#x27;    // 1. 替換  replace  需求：把前端替換為 web    // 1.1 replace 返回值是替換完畢的字串    // const strEnd = str.replace(/前端/, &#x27;web&#x27;) 只能替換一個    // 2. 修飾符 g 全部替換    const strEnd = str.replace(/前端/g, &#x27;web&#x27;)    console.log(strEnd)   &lt;/script&gt;&lt;/body&gt;\n\n正則外掛程式 \nchange 事件給input註冊 change 事件，值被修改並且失去焦點後觸發\n判斷是否有類12345678//添加類名元素.classList.contains()//刪除類名元素.classList.contains()//切換類名元素.classList.contains()//判斷是否包含某個類名，如果有則返回true，沒有則返回false元素.classList.contains() \n\n\n\n","slug":"2303-2 JS Web APIs 06","date":"2023-03-28T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"ba21313bf340a72e13573e85234fd6fe","title":"JavaScript Web APIs - 第5天","content":"\n\n\n\n\n\n\n\n\n目標： 能夠利用JS操作流覽器,具備利用本機存放區實現學生就業表的能力\n\nBOM操作\n綜合案例\n\njs組成JavaScript的組成\n\nECMAScript:\n\n規定了js基礎語法核心知識。\n比如：變數、分支語句、迴圈語句、物件等等\n\n\nWeb APIs :\n\nDOM   文檔物件模型， 定義了一套操作HTML文檔的API\nBOM   流覽器物件模型，定義了一套操作流覽器視窗的API\n\n\n\n \nwindow對象BOM (Browser Object Model ) 是流覽器物件模型\n\nwindow物件是一個全域物件，也可以說是JavaScript中的頂級物件\n像document、alert()、console.log()這些都是window的屬性，基本BOM的屬性和方法都是window的\n所有通過var定義在全域作用域中的變數、函數都會變成window物件的屬性和方法\nwindow物件下的屬性和方法調用的時候可以省略window\n\n \n計時器-延遲函數JavaScript 內置的一個用來讓代碼延遲執行的函數，叫 setTimeout\n語法：\n1setTimeout(回呼函數, 延遲時間)\n\nsetTimeout 僅僅只執行一次，所以可以理解為就是把一段代碼延遲執行, 平時省略window\n間歇函數 setInterval : 每隔一段時間就執行一次， , 平時省略window\n清除延時函數：\n1clearTimeout(timerId)\n\n\n\n\n\n\n\n\n\n\n注意點\n\n延時函數需要等待,所以後面的代碼先執行\n返回值是一個正整數，表示計時器的編號\n\n12345678910111213141516171819&lt;body&gt;  &lt;script&gt;    // 計時器之延遲函數    // 1. 開啟延遲函數    let timerId = setTimeout(function () &#123;      console.log(&#x27;我只執行一次&#x27;)    &#125;, 3000)    // 1.1 延遲函數返回的還是一個正整數數位，表示延遲函數的編號    console.log(timerId)    // 1.2 延遲函數需要等待時間，所以下面的代碼優先執行    // 2. 關閉延遲函數    clearTimeout(timerId)  &lt;/script&gt;&lt;/body&gt;\n\nlocation對象location (位址) 它拆分並保存了 URL 位址的各個組成部分， 它是一個物件\n\n\n\n屬性&#x2F;方法\n說明\n\n\n\nhref\n屬性，獲取完整的 URL 位址，賦值時用於地址的跳轉\n\n\nsearch\n屬性，獲取位址中攜帶的參數，符號 ？後面部分\n\n\nhash\n屬性，獲取位址中的啥希值，符號 # 後面部分\n\n\nreload()\n方法，用來刷新當前頁面，傳入參數 true 時表示強制刷新\n\n\n12345678910111213141516171819202122232425262728&lt;body&gt;  &lt;form&gt;    &lt;input type=&quot;text&quot; name=&quot;search&quot;&gt; &lt;button&gt;搜索&lt;/button&gt;  &lt;/form&gt;  &lt;a href=&quot;#/music&quot;&gt;音樂&lt;/a&gt;  &lt;a href=&quot;#/download&quot;&gt;下載&lt;/a&gt;  &lt;button class=&quot;reload&quot;&gt;刷新頁面&lt;/button&gt;  &lt;script&gt;    // location 對象      // 1. href屬性 （重點） 得到完整地址，賦值則是跳轉到新地址    console.log(location.href)    // location.href = &#x27;http://www.itcast.cn&#x27;    // 2. search屬性  得到 ? 後面的地址     console.log(location.search)  // ?search=筆記本    // 3. hash屬性  得到 # 後面的地址    console.log(location.hash)    // 4. reload 方法  刷新頁面    const btn = document.querySelector(&#x27;.reload&#x27;)    btn.addEventListener(&#x27;click&#x27;, function () &#123;      // location.reload() // 頁面刷新      location.reload(true) // 強制頁面刷新 ctrl+f5    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\nnavigator對象navigator是物件，該物件下記錄了流覽器自身的相關資訊\n常用屬性和方法：\n\n通過 userAgent 檢測流覽器的版本及平臺\n\n12345678910// 檢測 userAgent（流覽器資訊）(function () &#123;  const userAgent = navigator.userAgent  // 驗證是否為Android或iPhone  const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/)  const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/)  // 如果是Android或iPhone，則跳轉至移動網站  if (android || iphone) &#123;    location.href = &#x27;http://google.com&#x27;  &#125;&#125;)();\n\nhistroy對象history (歷史)是物件，主要管理歷史記錄， 該物件與流覽器位址欄的操作相對應，如前進、後退等\n使用場景\nhistory物件一般在實際開發中比較少用\n常見方法：\n\n\n\nhistory對象方法\n作用\n\n\n\nback()\n後退功能\n\n\nforward()\n前進功能\n\n\ngo(參數)\n前進後退功能，如果參數是1前進1個頁面，-1則後退1個頁面\n\n\n123456789101112131415161718192021&lt;body&gt;  &lt;button class=&quot;back&quot;&gt;←後退&lt;/button&gt;  &lt;button class=&quot;forward&quot;&gt;前進→&lt;/button&gt;  &lt;script&gt;    // histroy對象    // 1.前進    const forward = document.querySelector(&#x27;.forward&#x27;)    forward.addEventListener(&#x27;click&#x27;, function () &#123;      // history.forward()       history.go(1)    &#125;)    // 2.後退    const back = document.querySelector(&#x27;.back&#x27;)    back.addEventListener(&#x27;click&#x27;, function () &#123;      // history.back()      history.go(-1)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n本機存放區（今日重點）本機存放區：將資料存儲在本地流覽器中\n常見的使用場景：\nhttps://todomvc.com/examples/vanilla-es6/    頁面刷新資料不丟失\n好處：\n1、頁面刷新或者關閉不丟失資料，實現資料持久化\n2、容量較大，sessionStorage和 localStorage 約 5M 左右\nlocalStorage（重點）作用: 資料可以長期保留在本地流覽器中，刷新頁面和關閉頁面，資料也不會丟失，除非手動刪除。\n特性：以鍵值對的形式存儲，並且存儲的是字串， 省略了window\n\n\n\n\n\n\n\n\n\n語法:儲存數據 localStorage.setItem(&#39;key&#39;, value)讀取數據 localStorage.getItem(&#39;key&#39;)刪除數據 localStorage.removeItem(&#39;key&#39;)\n12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;本機存放區-localstorage&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 本機存放區 - localstorage 存儲的是字串     // 1. 存儲    localStorage.setItem(&#x27;age&#x27;, 18)    // 2. 獲取    console.log(typeof localStorage.getItem(&#x27;age&#x27;))    // 3. 刪除    localStorage.removeItem(&#x27;age&#x27;)    // 4. 改(重新存)    localStorage.setItem(&#x27;age&#x27;, 19999)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nsessionStorage（瞭解）特性：\n\n用法跟localStorage基本相同\n區別是：當頁面流覽器被關閉時，存儲在 sessionStorage 的資料會被清除\n\n存儲：sessionStorage.setItem(key,value)\n獲取：sessionStorage.getItem(key)\n刪除：sessionStorage.removeItem(key)\nlocalStorage 存儲複雜資料類型問題：本地只能存儲字串,無法存儲複雜資料類型.\n解決：需要將複雜資料類型轉換成 JSON字串,在存儲到本地\n語法：JSON.stringify(複雜資料類型)\nJSON字串：\n\n首先是1個字串\n屬性名使用雙引號引起來，不能單引號\n屬性值如果是字串型也必須雙引號\n\n123456789101112131415161718&lt;body&gt;  &lt;script&gt;    // 本機存放區複雜資料類型    const goods = &#123;      name: &#x27;小米&#x27;,      price: 1999    &#125;    // 存储 複雜數據類型  -無法直接使用，不能直接使用對象    // localStorage.setItem(&#x27;goods&#x27;, goods)    // 取    // console.log(localStorage.getItem(&#x27;goods&#x27;))    // 1. 把物件轉換為JSON字串  JSON.stringify    localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods))    // console.log(typeof localStorage.getItem(&#x27;goods&#x27;))  &lt;/script&gt;&lt;/body&gt;\n\n\n問題：因為本機存放區裡面取出來的是字串，不是物件，無法直接使用\n**解決： **把取出來的字串轉換為物件\n語法：JSON.parse(JSON字串)\n123456789101112131415161718192021&lt;body&gt;  &lt;script&gt;    // 本機存放區複雜資料類型    const goods = &#123;      name: &#x27;小米&#x27;,      price: 1999    &#125;    // 存储 複雜數據類型    -無法直接使用，不能直接使用對象    // localStorage.setItem(&#x27;goods&#x27;, goods)    // 取    // console.log(localStorage.getItem(&#x27;goods&#x27;))    // 1. 把物件轉換為JSON字串  JSON.stringify    localStorage.setItem(&#x27;goods&#x27;, JSON.stringify(goods))    // console.log(typeof localStorage.getItem(&#x27;goods&#x27;))    // 2. 把JSON字串轉換為物件  JSON.parse    console.log(JSON.parse(localStorage.getItem(&#x27;goods&#x27;)))  &lt;/script&gt;&lt;/body&gt;\n\n綜合案例陣列map 方法使用場景：\nmap 可以遍歷陣列處理資料，並且返回新的陣列\n語法：\n123456789101112&lt;body&gt;  &lt;script&gt;  const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;]  // 1. 陣列 map方法 處理資料並且 返回一個陣列   const newArr = arr.map(function (ele, index) &#123;    // console.log(ele)  // 陣列元素    // console.log(index) // 索引號    return ele + &#x27;顏色&#x27;  //讓數組中每個元素添加&#x27;顏色&#x27;  &#125;)  console.log(newArr)  //[&#x27;red顏色&#x27;, &#x27;blue顏色&#x27;, &#x27;pink顏色&#x27;] &lt;/script&gt;&lt;/body&gt;\n\n\n\n\n\n\n\n\n\n\nmap 也稱為映射。映射是個術語，指兩個元素的集之間元素相互“對應”的關係。\nmap重點在於有返回值，forEach沒有返回值（undefined）\n陣列join方法作用：join() 方法用於把陣列中的所有元素轉換一個字串\n語法：\n1234567891011121314151617181920&lt;body&gt;  &lt;script&gt;    const arr = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;]    // 1. 陣列 map方法 處理資料並且 返回一個陣列    const newArr = arr.map(function (ele, index) &#123;      // console.log(ele)  // 陣列元素      // console.log(index) // 索引號      return ele + &#x27;顏色&#x27;    &#125;)    console.log(newArr)    // 2. 陣列join方法  把陣列轉換為字串    // 小括弧為空則逗號分割    console.log(newArr.join())  // red顏色,blue顏色,pink顏色    // 小括弧是空字串，則元素之間沒有分隔符號    console.log(newArr.join(&#x27;&#x27;))  //red顏色blue顏色pink顏色    console.log(newArr.join(&#x27;|&#x27;))  //red顏色|blue顏色|pink顏色  &lt;/script&gt;&lt;/body&gt;\n\n\n\n\n\n\n\n\n\n\n","slug":"2303-2 JS Web APIs 05","date":"2023-03-27T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"00643405d99d1bca34738d1b7609799a","title":"JavaScript Web APIs - 第4天","content":"\n\n\n\n\n\n\n\n\n進一步學習 DOM 相關知識，實現可交互的網頁特效\n\n能夠插入、刪除和替換元素節點\n能夠依據元素節點關係查找節點\n\n日期對象掌握 Date 日期物件的使用，動態獲取當前電腦的時間。\nECMAScript 中內置了獲取系統時間的物件 Date，使用 Date 時與之前學習的內置物件 console 和 Math 不同，它需要借助 new 關鍵字才能使用。\n產生實體12345678// 1. 產生實體// const date = new Date(); // 系統預設時間const date = new Date(&#x27;2020-05-01&#x27;) // 指定時間// date 變數即所謂的時間物件console.log(typeof date)\n\n方法 123456 // 1. 產生實體const date = new Date();// 2. 調用時間物件方法// 通過方法分別獲取年、月、日，時、分、秒const year = date.getFullYear(); // 四位年份const month = date.getMonth(); // 0 ~ 11\n\n\n\n方法\n作用\n說明\n\n\n\ngetFullYear()\n獲取年份\n獲取四位年份\n\n\ngetMonth()\n獲取月份\n取值為 0 ~ 11\n\n\ngetDate()\n獲取月份中的每一天\n不同月份取值也不相同\n\n\ngetDay()\n獲取星期\n取值為 0 ~ 6\n\n\ngetHours()\n獲取小時\n取值為 0 ~ 23\n\n\ngetMinutes()\n獲取分鐘\n取值為 0 ~ 59\n\n\ngetSeconds()\n獲取秒\n取值為 0 ~ 59\n\n\n時間戳記時間戳記是指1970年01月01日00時00分00秒起至現在的總秒數或毫秒數，它是一種特殊的計量時間的方式。\n注：ECMAScript 中時間戳記是以毫秒計的。\n12345678910// - 產生實體const date = new Date()// 法1. getTime()法，獲取時間戳記  console.log(date.getTime())// 法2. 簡寫 +new Date()，獲取時間戳記// 可以返回當前時間戳或者指定的時間戳  console.log(+new Date())// 法3. Date.now()，獲取時間戳記的方法//但是只能得到當前的時間戳， 而前面兩種可以返回指定時間的時間戳  console.log(Date.now())\n\n獲取時間戳記的方法，分別為 getTime 和  +new Date()和 Date.now\n\n通過時間戳得到是毫秒，需要轉換為秒在計算\n轉換公式：\nd &#x3D; parseInt(總秒數&#x2F; 60&#x2F;60 &#x2F;24); &#x2F;&#x2F; 計算天數\nh &#x3D; parseInt(總秒數&#x2F; 60&#x2F;60 %24) &#x2F;&#x2F; 計算小時\nm &#x3D; parseInt(總秒數 &#x2F;60 %60 ); &#x2F;&#x2F; 計算分數\ns &#x3D; parseInt(總秒數%60); &#x2F;&#x2F; 計算當前秒數\n\n\n\nDOM節點操作\n\n\n\n\n\n\n\n\n掌握元素節點創建、複製、插入、刪除等操作的方法，能夠依據元素節點的結構關係查找節點\n\n節點類型\n元素節點\n所有的標籤 比如 body、 div\nhtml 是根節點\n\n\n屬性節點\n所有的屬性 比如 href\n\n\n文本節點\n所有的文本\n\n\n其他\n\n\n\n回顧之前 DOM 的操作都是針對元素節點的屬性或文本的，除此之外也有專門針對元素節點本身的操作，如插入、複製、刪除、替換等。\n查找節點DOM 樹中的任意節點都不是孤立存在的，它們要麼是父子關係，要麼是兄弟關係，不僅如此，我們可以依據節點之間的關係查找節點。\n父子關係12345678910111213141516171819202122&lt;body&gt;  &lt;button class=&quot;btn1&quot;&gt;所有的子節點&lt;/button&gt;  &lt;!-- 獲取 ul 的子節點 --&gt;  &lt;ul&gt;    &lt;li&gt;HTML&lt;/li&gt;    &lt;li&gt;CSS&lt;/li&gt;    &lt;li&gt;JavaScript 基礎&lt;/li&gt;    &lt;li&gt;Web APIs&lt;/li&gt;  &lt;/ul&gt;  &lt;script&gt;    const btn1 = document.querySelector(&#x27;.btn1&#x27;)    btn1.addEventListener(&#x27;click&#x27;, function () &#123;      // 父節點      const ul = document.querySelector(&#x27;ul&#x27;)      // 所有的子節點      console.log(ul.childNodes)      // 只包含元素子節點      console.log(ul.children)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n結論：\n\nchildNodes 獲取全部的子節點，回車換行會被認為是空白文本節點\nchildren 只獲取元素類型節點\n\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;  &lt;table&gt;    &lt;tr&gt;      &lt;td width=&quot;60&quot;&gt;序號&lt;/td&gt;      &lt;td&gt;課程名&lt;/td&gt;      &lt;td&gt;難度&lt;/td&gt;      &lt;td width=&quot;80&quot;&gt;操作&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;1&lt;/td&gt;      &lt;td&gt;&lt;span&gt;HTML&lt;/span&gt;&lt;/td&gt;      &lt;td&gt;初級&lt;/td&gt;      &lt;td&gt;&lt;button&gt;變色&lt;/button&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;2&lt;/td&gt;      &lt;td&gt;&lt;span&gt;CSS&lt;/span&gt;&lt;/td&gt;      &lt;td&gt;初級&lt;/td&gt;      &lt;td&gt;&lt;button&gt;變色&lt;/button&gt;&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;3&lt;/td&gt;      &lt;td&gt;&lt;span&gt;Web APIs&lt;/span&gt;&lt;/td&gt;      &lt;td&gt;中級&lt;/td&gt;      &lt;td&gt;&lt;button&gt;變色&lt;/button&gt;&lt;/td&gt;    &lt;/tr&gt;  &lt;/table&gt;  &lt;script&gt;    // 獲取所有 button 節點，並添加事件監聽    const buttons = document.querySelectorAll(&#x27;table button&#x27;)    for(let i = 0; i &lt; buttons.length; i++) &#123;      buttons[i].addEventListener(&#x27;click&#x27;, function () &#123;        // console.log(this.parentNode); // 父節點 td        // this.parentNode.style.color = &#x27;red&#x27;        // console.log(this.parentNode.parentNode); // 爺爺節點 tr        this.parentNode.parentNode.style.color = &#x27;red&#x27;      &#125;)    &#125;  &lt;/script&gt;&lt;/body&gt;\n\n結論：parentNode 獲取父節點，以相對位置查找節點，實際應用中非常靈活。\n兄弟關係12345678910111213141516171819202122&lt;body&gt;  &lt;ul&gt;    &lt;li&gt;HTML&lt;/li&gt;    &lt;li&gt;CSS&lt;/li&gt;    &lt;li&gt;JavaScript 基礎&lt;/li&gt;    &lt;li&gt;Web APIs&lt;/li&gt;  &lt;/ul&gt;  &lt;script&gt;    // 獲取所有 li 節點    const lis = document.querySelectorAll(&#x27;ul li&#x27;)    // 對所有的 li 節點添加事件監聽    for(let i = 0; i &lt; lis.length; i++) &#123;      lis[i].addEventListener(&#x27;click&#x27;, function () &#123;        // 前一個節點        console.log(this.previousSibling)        // 下一下節點        console.log(this.nextSibling)      &#125;)    &#125;  &lt;/script&gt;&lt;/body&gt;\n\n結論：\n\npreviousSibling 獲取前一個節點，以相對位置查找節點，實際應用中非常靈活。\nnextSibling 獲取後一個節點，以相對位置查找節點，實際應用中非常靈活。\n\n增加節點在已有的 DOM 節點中插入新的 DOM 節點時，需要關注兩個關鍵因素：首先要得到新的 DOM 節點，其次在哪個位置插入這個節點。\n\n創建節點 document.createElement(&#39;標籤名&#39;)\n追加節點\n父元素.appendChild(要插入的元素)    &#x2F;&#x2F;插入到父元素的最後一個子元素\n父元素.insertBefore(要插入的元素,在哪個元素之前)  &#x2F;&#x2F;插入到父元素中某個子元素的前面\n\n\n\n如下代碼演示：\n123456789101112131415161718192021222324252627&lt;body&gt;  &lt;h3&gt;插入節點&lt;/h3&gt;  &lt;p&gt;在現有 dom 結構基礎上插入新的元素節點&lt;/p&gt;  &lt;hr&gt;  &lt;!-- 普通盒子 --&gt;  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;  &lt;!-- 點擊按鈕向 box 盒子插入節點 --&gt;  &lt;button class=&quot;btn&quot;&gt;插入節點&lt;/button&gt;  &lt;script&gt;    // 點擊按鈕，在網頁中插入節點    const btn = document.querySelector(&#x27;.btn&#x27;)    btn.addEventListener(&#x27;click&#x27;, function () &#123;      // 1. 獲得一個 DOM 元素節點      const p = document.createElement(&#x27;p&#x27;)      p.innerText = &#x27;創建的新的p標籤&#x27;      p.className = &#x27;info&#x27;            // 複製原有的 DOM 節點      const p2 = document.querySelector(&#x27;p&#x27;).cloneNode(true)      p2.style.color = &#x27;red&#x27;      // 2. 插入盒子 box 盒子      document.querySelector(&#x27;.box&#x27;).appendChild(p)      document.querySelector(&#x27;.box&#x27;).appendChild(p2)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n結論：\n\ncreateElement 動態創建任意 DOM 節點\n\ncloneNode 複製現有的 DOM 節點，傳入參數 true 會複製所有子節點\n\nappendChild 在末尾（結束標籤前）插入節點\n\n\n再來看另一種情形的代碼演示：\n123456789101112131415161718192021222324252627282930313233&lt;body&gt;  &lt;h3&gt;插入節點&lt;/h3&gt;  &lt;p&gt;在現有 dom 結構基礎上插入新的元素節點&lt;/p&gt;  &lt;hr&gt;  &lt;button class=&quot;btn1&quot;&gt;在任意節點前插入&lt;/button&gt;  &lt;ul&gt;    &lt;li&gt;HTML&lt;/li&gt;    &lt;li&gt;CSS&lt;/li&gt;    &lt;li&gt;JavaScript&lt;/li&gt;  &lt;/ul&gt;  &lt;script&gt;    // 點擊按鈕，在已有 DOM 中插入新節點    const btn1 = document.querySelector(&#x27;.btn1&#x27;)    btn1.addEventListener(&#x27;click&#x27;, function () &#123;      // 第 2 個 li 元素      const relative = document.querySelector(&#x27;li:nth-child(2)&#x27;)      // 1. 動態創建新的節點      const li1 = document.createElement(&#x27;li&#x27;)      li1.style.color = &#x27;red&#x27;      li1.innerText = &#x27;Web APIs&#x27;      // 複製現有的節點      const li2 = document.querySelector(&#x27;li:first-child&#x27;).cloneNode(true)      li2.style.color = &#x27;blue&#x27;      // 2. 在 relative 節點前插入      document.querySelector(&#x27;ul&#x27;).insertBefore(li1, relative)      document.querySelector(&#x27;ul&#x27;).insertBefore(li2, relative)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n結論：\n\ncreateElement 動態創建任意 DOM 節點\n\ncloneNode 複製現有的 DOM 節點，傳入參數 true 會複製所有子節點\n\ninsertBefore 在父節點中任意子節點之前插入新節點\n\n\n\n\n\n\n\n\n\n\n\n\ncloneNode會克隆出一個跟原標籤一樣的元素，括號內傳入布爾值\n若為true，則代表克隆時會包含後代節點一起克隆\n若為false，則代表克隆時不包含後代節點\n默認為false\n\n\n\n刪除節點刪除現有的 DOM 節點，也需要關注兩個因素：首先由父節點刪除子節點，其次是要刪除哪個子節點。\n12345678910111213141516171819202122&lt;body&gt;  &lt;!-- 點擊按鈕刪除節點 --&gt;  &lt;button&gt;刪除節點&lt;/button&gt;  &lt;ul&gt;    &lt;li&gt;HTML&lt;/li&gt;    &lt;li&gt;CSS&lt;/li&gt;    &lt;li&gt;Web APIs&lt;/li&gt;  &lt;/ul&gt;  &lt;script&gt;    const btn = document.querySelector(&#x27;button&#x27;)    btn.addEventListener(&#x27;click&#x27;, function () &#123;      // 獲取 ul 父節點      let ul = document.querySelector(&#x27;ul&#x27;)      // 待刪除的子節點      let lis = document.querySelectorAll(&#x27;li&#x27;)      // 刪除節點      ul.removeChild(lis[0])    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n結論：removeChild 刪除節點時一定是由父子關係。\n\n\n\n\n\n\n\n\n\n\n注：\n如不存在父子關係則刪除不成功\n刪除節點和隱藏節點（display:none） 有區別的： 隱藏節點還是存在的，但是刪除，則從html中刪除節點\n\n\n\nM端事件目標：了解M端常見的事件\n\n\n\n\n\n\n\n\n\n移動端也有自己獨特的地方。比如觸屏事件 touch（也稱觸摸事件），Android 和 IOS 都有。\n\n觸屏事件 touch（也稱觸摸事件），Android 和 IOS 都有。\ntouch 對象代表一個觸摸點。觸摸點可能是一根手指，也可能是一根觸摸筆。觸屏事件可響應用戶手指（或觸控筆）對屏幕或者觸控板操作。常見的觸屏事件如下：\n\n\n觸屏touch事件\n說明\n\n\n\ntouchstart\n手指觸碰到一個DOM元素時觸發\n\n\ntouchmove\n手指在一個DOM元素上滑動時觸發\n\n\ntouchend\n手指在一個DOM元素上移開時觸發\n\n\n\n\nJS插件就是別人寫好的一些代碼,我們只需要復制對應的代碼,就可以直接實現對應的效果\n","slug":"2303-2 JS Web APIs 04","date":"2023-03-26T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"4c656a1bef12133b7e372d516df2e64e","title":"JavaScript Web APIs - 第3天","content":"\n\n\n\n\n\n\n\n\n進一步學習 事件進階，實現更多交互的網頁特效，結合事件流的特徵優化事件執行的效率\n\n掌握阻止事件冒泡的方法\n理解事件委託的實現原理\n\n事件流事件流是對事件執行過程的描述，瞭解事件的執行過程有助於加深對事件的理解，提升開發實踐中對事件運用的靈活度。\n\n如上圖所示，任意事件被觸發時總會經歷兩個階段：【捕獲階段】和【冒泡階段】。\n簡言之，捕獲階段是【從父到子】的傳導過程，冒泡階段是【從子向父】的傳導過程。\n捕獲和冒泡\n\n\n\n\n\n\n\n\n事件捕獲語法DOM.addEventListener(&#39;事件類型&#39;, 事件處理函數, 是否使用捕獲機制)\n\n事件捕獲概念：\n\n從DOM的根項目開始去執行對應的事件 (從外到裡)\n\n\n說明：\n\naddEventListener第三個參數傳入 true 代表是捕獲階段觸發（很少使用）\n若傳入false代表冒泡階段觸發，默認就是false\n若是用 L0 事件監聽，則只有冒泡階段，沒有捕獲\n\n\n事件冒泡概念:\n\n當一個元素的事件被觸發時，同樣的事件將會在該元素的所有父項目中依次被觸發。這一過程被稱為事件冒泡\n\n\n簡單理解：當一個元素觸發事件後，會依次向上調用所有父級元素的 同名事件\n\n事件冒泡是默認存在的\n\nL2事件監聽第三個參數是 false，或者默認都是冒泡\n\n\n事件流是如何影響事件執行的：\n12345678910111213141516171819202122232425262728293031323334353637383940&lt;body&gt;  &lt;h3&gt;事件流&lt;/h3&gt;  &lt;p&gt;事件流是事件在執行時的底層機制，主要體現在父子盒子之間事件的執行上。&lt;/p&gt;  &lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;      &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    // 獲取嵌套的3個節點    const outer = document.querySelector(&#x27;.outer&#x27;);    const inner = document.querySelector(&#x27;.inner&#x27;);    const child = document.querySelector(&#x27;.child&#x27;);        // html 元素添加事件    document.documentElement.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;html...&#x27;)    &#125;)        // body 元素添加事件    document.body.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;body...&#x27;)    &#125;)    // 外層的盒子添加事件    outer.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;outer...&#x27;)    &#125;)        // 中間的盒子添加事件    outer.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;inner...&#x27;)    &#125;)        // 內層的盒子添加事件    outer.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;child...&#x27;)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n執行上述代碼後發現，當按一下事件觸發時，其父項目的按一下事件也【相繼觸發】，這是為什麼呢？\n結合事件流的特徵，我們知道當某個元素的事件被觸發時，事件總是會先經過其祖先才能到達當前元素，然後再由當前元素向祖先傳遞，事件在流動的過程中遇到相同的事件便會被觸發。\n再來關注一個細節就是事件相繼觸發的【執行順序】，事件的執行順序是可控制的，即可以在捕獲階段被執行，也可以在冒泡階段被執行。\n如果事件是在冒泡階段執行的，我們稱為冒泡模式，它會先執行子盒子事件再去執行父盒子事件，預設是冒泡模式。\n如果事件是在捕獲階段執行的，我們稱為捕獲模式，它會先執行父盒子事件再去執行子盒子事件。\n12345678910111213141516171819202122&lt;body&gt;  &lt;h3&gt;事件流&lt;/h3&gt;  &lt;p&gt;事件流是事件在執行時的底層機制，主要體現在父子盒子之間事件的執行上。&lt;/p&gt;  &lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    // 獲取嵌套的3個節點    const outer = document.querySelector(&#x27;.outer&#x27;)    const inner = document.querySelector(&#x27;.inner&#x27;)    // 外層的盒子    outer.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;outer...&#x27;)    &#125;, true) // true 表示在捕獲階段執行事件        // 中間的盒子    outer.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;inner...&#x27;)    &#125;, true)  &lt;/script&gt;&lt;/body&gt;\n\n結論：\n\naddEventListener 第3個參數決定了事件是在捕獲階段觸發還是在冒泡階段觸發\naddEventListener 第3個參數為  true 表示捕獲階段觸發，false 表示冒泡階段觸發，預設值為 false\n事件流只會在父子元素具有相同事件類型時才會產生影響\n絕大部分場景都採用預設的冒泡模式（其中一個原因是早期 IE 不支援捕獲）\n\n阻止冒泡\n\n\n\n\n\n\n\n\n語法:事件對象.stopPropagation()阻止冒泡是指阻斷事件的流動，保證事件只在當前元素被執行，而不再去影響到其對應的父項目。\n123456789101112131415161718192021222324252627282930313233343536&lt;body&gt;  &lt;h3&gt;阻止冒泡&lt;/h3&gt;  &lt;p&gt;阻止冒泡是指阻斷事件的流動，保證事件只在當前元素被執行，而不再去影響到其對應的父項目。&lt;/p&gt;  &lt;div class=&quot;outer&quot;&gt;    &lt;div class=&quot;inner&quot;&gt;      &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    // 獲取嵌套的3個節點    const outer = document.querySelector(&#x27;.outer&#x27;)    const inner = document.querySelector(&#x27;.inner&#x27;)    const child = document.querySelector(&#x27;.child&#x27;)    // 外層的盒子    outer.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;outer...&#x27;)    &#125;)    // 中間的盒子    inner.addEventListener(&#x27;click&#x27;, function (ev) &#123;      console.log(&#x27;inner...&#x27;)      // 阻止事件冒泡      ev.stopPropagation()    &#125;)    // 內層的盒子    child.addEventListener(&#x27;click&#x27;, function (ev) &#123;      console.log(&#x27;child...&#x27;)      // 借助事件物件，阻止事件向上冒泡      ev.stopPropagation()    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n結論：事件物件中的 ev.stopPropagation 方法，專門用來阻止事件冒泡。\n\n\n\n\n\n\n\n\n\n滑鼠經過事件：\nmouseover 和 mouseout 會有冒泡效果\nmouseenter  和 mouseleave   沒有冒泡效果 (推薦)\n解綁事件1. on事件方式直接使用null覆蓋偶就可以實現事件的解綁\n1234567891011&lt;button&gt;點擊&lt;/button&gt;  &lt;script&gt;    const btn = document.querySelector(&#x27;button&#x27;)    //綁定事件    btn.onclick = function () &#123;      alert(&#x27;點擊了&#x27;)      // L0 事件移除解綁      btn.onclick = null    &#125;      &lt;/script&gt;\naddEventListener方式，必須使用：removeEventListener(事件類型, 事件處理函數, [獲取捕獲或者冒泡階段])\n1234567891011&lt;button&gt;點擊&lt;/button&gt;  &lt;script&gt;    const btn = document.querySelector(&#x27;button&#x27;)    function fn() &#123;      alert(&#x27;點擊了&#x27;)    &#125;    //綁定事件    btn.addEventListener(&#x27;click&#x27;, fn)    // L2 事件移除解綁    btn.removeEventListener(&#x27;click&#x27;, fn)  &lt;/script&gt;\n\n\n\n\n\n\n\n\n\n注意：匿名函數無法被解綁\n兩種註冊事件的區別\n傳統on註冊（L0）\n同一個對象,後面註冊的事件會覆蓋前面註冊(同一個事件)\n直接使用null覆蓋偶就可以實現事件的解綁\n都是冒泡階段執行的\n\n\n事件監聽註冊（L2）\n語法: addEventListener(事件類型, 事件處理函數, 是否使用捕獲)\n後面註冊的事件不會覆蓋前面註冊的事件(同一個事件)\n可以通過第三個參數去確定是在冒泡或者捕獲階段執行\n必須使用removeEventListener(事件類型, 事件處理函數, 獲取捕獲或者冒泡階段)\n匿名函數無法被解綁\n\n\n\n鼠標經過事件的區別\n鼠標經過事件：\nmouseover 和 mouseout 會有冒泡效果\nmouseenter 和 mouseleave 沒有冒泡效果 (推薦)\n\n\n\n事件委託\n\n\n\n\n\n\n\n\n事件委託是利用事件流的特徵解決一些現實開發需求的知識技巧，主要的作用是提升程式效率。\n\n事件委託是利用事件流的特徵解決一些開發需求的知識技巧\n優點：減少註冊次數，可以提高程式性能\n原理：事件委託其實是利用事件冒泡的特點。\n給父元素註冊事件，當我們觸發子元素的時候，會冒泡到父元素身上，從而觸發父元素的事件\n\n\n實現：事件對象.target.tagName ===&#39;標籤名&#39; 可以獲得真正觸發事件的元素ev.target.tagName &#x3D;&#x3D;&#x3D; ‘BUTTON’大量的事件監聽是比較耗費性能的，如下代碼所示\n\n\n\n1234567891011&lt;script&gt;  // 假設頁面中有 10000 個 button 元素  const buttons = document.querySelectorAll(&#x27;table button&#x27;);  for(let i = 0; i &lt;= buttons.length; i++) &#123;    // 為 10000 個 button 元素添加了事件    buttons.addEventListener(&#x27;click&#x27;, function () &#123;      // 省略具體執行邏輯...    &#125;)  &#125;&lt;/script&gt;\n\n利用事件流的特徵，可以對上述的代碼進行優化，事件的的冒泡模式總是會將事件流向其父元素的，如果父元素監聽了相同的事件類型，那麼父元素的事件就會被觸發並執行，正是利用這一特徵對上述代碼進行優化，如下代碼所示：\n12345678910&lt;script&gt;  // 假設頁面中有 10000 個 button 元素  let buttons = document.querySelectorAll(&#x27;table button&#x27;);    // 假設上述的 10000 個 buttom 元素共同的父項目是 table  let parents = document.querySelector(&#x27;table&#x27;);  parents.addEventListener(&#x27;click&#x27;, function () &#123;    console.log(&#x27;點擊任意子元素都會觸發事件...&#x27;);  &#125;)&lt;/script&gt;\n\n我們的最終目的是保證只有點擊 button 子元素才去執行事件的回呼函數，如何判斷用戶點擊是哪一個子元素呢？\n事件物件中的屬性 target 或 srcElement屬性工作表示真正觸發事件的元素，它是一個元素類型的節點。\n1234567891011121314&lt;script&gt;  // 假設頁面中有 10000 個 button 元素  const buttons = document.querySelectorAll(&#x27;table button&#x27;)    // 假設上述的 10000 個 buttom 元素共同的父項目是 table  const parents = document.querySelector(&#x27;table&#x27;)  parents.addEventListener(&#x27;click&#x27;, function (ev) &#123;    // console.log(ev.target);    // 只有 button 元素才會真正去執行邏輯    if(ev.target.tagName === &#x27;BUTTON&#x27;) &#123;      // 執行的邏輯    &#125;  &#125;)&lt;/script&gt;\n\n優化過的代碼只對父項目添加事件監聽，相比對 10000 個元素添加事件監聽執行效率要高許多！！！\n其他事件頁面載入事件載入外部資源（如圖片、外聯CSS和JavaScript等）載入完畢時觸發的事件\n有些時候需要等頁面資源全部處理完了做一些事情\nload 事件監聽頁面所有資源載入完畢：\n\n\n\n\n\n\n\n\n\n\n監聽整個頁面資源給 window 加\n\n123window.addEventListener(&#x27;load&#x27;, function() &#123;    // 執行的操作~~~~~&#125;)\n\nDOMContentLoaded\n\n\n\n\n\n\n\n\n\n\n給 document 加\n無需等待樣式表、圖像等完全加載\n\n123document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123;  // 執行的操作~~~~~&#125;)\n\n\n元素滾動事件很多網頁需要檢測用戶把頁面滾動到某個區域後做一些處理， 比如固定導航欄，比如返回頂部\n\n\n\n\n\n\n\n\n\n捲軸在滾動的時候持續觸發的事件\nscroll 事件\n123window.addEventListener(&#x27;scroll&#x27;, function() &#123;    // 執行的操作~~~~~&#125;)\n監聽某個元素的內部滾動直接給某個元素加即可\n頁面滾動事件-獲取位置\nscrollLeft和scrollTop （屬性）\n獲取被卷去的大小\n獲取元素內容往左、往上滾出去看不到的距離\n這兩個值是可讀寫的\n\n\n\ndiv滾動\n123456const div = document.querySelector(&#x27;div&#x27;)div.addEventListener(&#x27;scroll&#x27;, function () &#123;  // console.log(111)  // scrollTop 被卷去的頭部  console.log(div.scrollTop)&#125;)\n頁面滾動\n123456789101112131415const div = document.querySelector(&#x27;div&#x27;)// 頁面滾動事件window.addEventListener(&#x27;scroll&#x27;, function () &#123;  // console.log(&#x27;我滾了&#x27;)  // 我想知道頁面到底滾動了多少圖元， 被卷去了多少  scrollTop  // 獲取html元素寫法    // document.documentElement    // console.log(document.documentElement.scrollTop)  const n = document.documentElement.scrollTop  if (n &gt;= 100) &#123;    div.style.display = &#x27;block&#x27;  &#125; else &#123;    div.style.display = &#x27;none&#x27;  &#125;&#125;)\n細節注意\n1234567document.documentElement.scrollTop = 800window.addEventListener(&#x27;scroll&#x27;, function () &#123;  // 必須寫到裡面  const n = document.documentElement.scrollTop  // 得到是什麼資料   數字型 不帶單位  // console.log(n)&#125;)\n\n頁面滾動事件-滾動到指定的坐標\n\n\n\n\n\n\n\n\nscrollTo() 方法可把內容滾動到指定的坐標\n\n語法：元素.scrollTo(x, y)\n\n頁面尺寸事件會在視窗尺寸改變的時候觸發事件：\n123window.addEventListener(&#x27;resize&#x27;, function() &#123;    // 執行的操作~~~~~&#125;)\n\n元素尺寸與位置\n獲取寬高\n\n獲取元素的自身寬高、包含元素自身設置的寬高、padding、border\noffsetWidth和offsetHeight  \n獲取出來的是數值,方便計算\n注意: 獲取的是可視寬高, 如果盒子是隱藏的,獲取的結果是0\n\n\n獲取位置：\n\n獲取元素距離自己定位父級元素的左、上距離\noffsetLeft和offsetTop \n注意是只讀屬性\n\n\nelement.getBoundingClientRect()\n方法返回元素的大小及其相對於視口的位\n\n\n\n\n\n\noffsetWidth和offsetHeight是得到元素什麼的寬高？\n\n\n內容 + padding + border\n\n\noffsetTop和offsetLeft 得到位置以誰為準？\n\n\n帶有定位的父級\n如果都沒有則以 文檔左上角 為準\n\n\n\n\n屬性\n作用\n說明\n\n\n\nscrollLeft和scrollTop\n被捲去的頭部和左側\n配合頁面滾動來用，可讀寫\n\n\nclientWidth 和 clientHeight\n獲得元素寬度和高度\n不包含border,margin，滾動條 用於js獲取元素大小，只讀屬性\n\n\noffsetWidth和offsetHeight\n獲得元素寬度和高度\n包含border、padding，滾動條等，只讀\n\n\noffsetLeft和offsetTop\n獲取元素距離自己定位父級元素的左、上距離\n獲取元素位置的時候使用，只讀屬性\n\n\n","slug":"2303-2 JS Web APIs 03 事件流","date":"2023-03-25T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"b74e92afe19531c6070a34e8d8d93dcd","title":"JavaScript Web APIs - 第2天","content":"\n\n\n\n\n\n\n\n\n學會通過為DOM註冊事件來實現可交互的網頁特效。\n\n能夠判斷函數運行的環境並確字 this 所指代的物件\n理解事件的作用，知道應用事件的 3 個步驟\n\n\n\n\n\n\n\n\n\n\n學習會為 DOM 註冊事件，實現簡單可交互的網頁特交。\n事件事件是程式設計語言中的術語，它是用來描述程式的行為或狀態的，一旦行為或狀態發生改變，便立即調用一個函數。\n例如：使用者使用【滑鼠點擊】網頁中的一個按鈕、使用者使用【滑鼠拖拽】網頁中的一張圖片\n事件監聽\n\n\n\n\n\n\n\n\n語法: 元素對象.addEventListener(‘事件類型’, 要執行的函數)\n結合 DOM 使用事件時，需要為 DOM 物件添加事件監聽，等待事件發生（觸發）時，便立即調用一個函數。\naddEventListener 是 DOM 物件專門用來添加事件監聽的方法，它的兩個參數分別為【事件類型】和【事件回檔】。\n123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;事件監聽&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h3&gt;事件監聽&lt;/h3&gt;  &lt;p id=&quot;text&quot;&gt;為 DOM 元素添加事件監聽，等待事件發生，便立即執行一個函數。&lt;/p&gt;  &lt;button id=&quot;btn&quot;&gt;點擊改變文字顏色&lt;/button&gt;  &lt;script&gt;    // 1. 獲取 button 對應的 DOM 對象    const btn = document.querySelector(&#x27;#btn&#x27;)    // 2. 添加事件監聽    btn.addEventListener(&#x27;click&#x27;, function () &#123;      console.log(&#x27;等待事件被觸發...&#x27;)      // 改變 p 標籤的文字顏色      let text = document.getElementById(&#x27;text&#x27;)      text.style.color = &#x27;red&#x27;    &#125;)    // 3. 只要使用者點擊了按鈕，事件便觸發了！！！  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n完成事件監聽分成3個步驟：\n\n獲取 DOM 元素\n通過 addEventListener 方法為 DOM 節點添加事件監聽\n等待事件觸發，如使用者點擊了某個按鈕時便會觸發 click 事件類型\n事件觸發後，相對應的回呼函數會被執行\n\n大白話描述：所謂的事件無非就是找個機會（事件觸發）調用一個函數（回呼函數）。\n事件類型click 譯成中文是【點擊】的意思，它的含義是監聽（等著）使用者滑鼠的按一下操作，除了【按一下】還有【按兩下】dblclick\n1234567891011&lt;script&gt;  // 按兩下事件類型  btn.addEventListener(&#x27;dblclick&#x27;, function () &#123;    console.log(&#x27;等待事件被觸發...&#x27;);    // 改變 p 標籤的文字顏色    const text = document.querySelector(&#x27;.text&#x27;)    text.style.color = &#x27;red&#x27;  &#125;)  // 只要使用者按兩下擊了按鈕，事件便觸發了！！！&lt;/script&gt;\n\n結論：【事件類型】決定了事件被觸發的方式，如 click 代表滑鼠按一下，dblclick 代表滑鼠按兩下。\n\n\n\n名稱\n說明\n舉例\n\n\n\n鼠標事件\n鼠標觸發\nclick 鼠標點擊、mouseenter鼠標經過、mouseleave 鼠標離開\n\n\n焦點事件\n表單獲得光標\nfocus 獲得焦點、blur 失去焦點\n\n\n鍵盤事件\n鍵盤觸發\nKeydown 鍵盤按下觸發、Keyup 鍵盤抬起觸發\n\n\n文本事件\n表單輸入觸發\ninput 用戶輸入事件\n\n\n事件處理常式addEventListener 的第2個參數是函數，這個函數會在事件被觸發時立即被調用，在這個函數中可以編寫任意邏輯的代碼，如改變 DOM 文本顏色、文本內容等。\n123456789101112&lt;script&gt;  // 按兩下事件類型  btn.addEventListener(&#x27;dblclick&#x27;, function () &#123;    console.log(&#x27;等待事件被觸發...&#x27;)        const text = document.querySelector(&#x27;.text&#x27;)    // 改變 p 標籤的文字顏色    text.style.color = &#x27;red&#x27;    // 改變 p 標籤的文本內容    text.style.fontSize = &#x27;20px&#x27;  &#125;)&lt;/script&gt;\n\n結論：【事件處理常式】決定了事件觸發後應該執行的邏輯。\n事件類型將眾多的事件類型分類可分為：滑鼠事件、鍵盤事件、表單事件、焦點事件等，我們逐一展開學習。\n滑鼠事件滑鼠事件是指跟滑鼠操作相關的事件，如按一下、按兩下、移動等。\n\n&#96;mouseenter 監聽滑鼠是否移入 DOM 元素\n\n123456789101112131415161718&lt;body&gt;  &lt;h3&gt;滑鼠事件&lt;/h3&gt;  &lt;p&gt;監聽與滑鼠相關的操作&lt;/p&gt;  &lt;hr&gt;  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 需要事件監聽的 DOM 元素    const box = document.querySelector(&#x27;.box&#x27;);    // 監聽滑鼠是移入當前 DOM 元素    box.addEventListener(&#x27;mouseenter&#x27;, function () &#123;      // 修改文本內容      this.innerText = &#x27;滑鼠移入了...&#x27;;      // 修改游標的風格      this.style.cursor = &#x27;move&#x27;;    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n\n&#96;mouseleave 監聽滑鼠是否移出 DOM 元素\n\n12345678910111213141516&lt;body&gt;  &lt;h3&gt;滑鼠事件&lt;/h3&gt;  &lt;p&gt;監聽與滑鼠相關的操作&lt;/p&gt;  &lt;hr&gt;  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 需要事件監聽的 DOM 元素    const box = document.querySelector(&#x27;.box&#x27;);    // 監聽滑鼠是移出當前 DOM 元素    box.addEventListener(&#x27;mouseleave&#x27;, function () &#123;      // 修改文本內容      this.innerText = &#x27;滑鼠移出了...&#x27;;    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n\n焦點事件\n\n\n\n\n\n\n\n\nfocus  獲得焦點blur 失去焦點\n12345678910&lt;input type=&quot;text&quot;&gt;  &lt;script&gt;    const input = document.querySelector(&#x27;input&#x27;)    input.addEventListener(&#x27;focus&#x27;, function () &#123;      console.log(&#x27;有焦點觸發&#x27;)    &#125;)    input.addEventListener(&#x27;blur&#x27;, function () &#123;      console.log(&#x27;失去焦點觸發&#x27;)    &#125;)  &lt;/script&gt;\n鍵盤事件\n\n\n\n\n\n\n\n\nkeydown   鍵盤按下觸發keyup   鍵盤抬起觸發\n1234567891011&lt;input type=&quot;text&quot;&gt;  &lt;script&gt;    const input = document.querySelector(&#x27;input&#x27;)    // 鍵盤事件    input.addEventListener(&#x27;keydown&#x27;, function () &#123;       console.log(&#x27;鍵盤按下了&#x27;)     &#125;)    input.addEventListener(&#x27;keyup&#x27;, function () &#123;      console.log(&#x27;鍵盤談起了&#x27;)     &#125;)  &lt;/script&gt;\n文字方塊輸入事件\n\n\n\n\n\n\n\n\ninput\n12345678&lt;input type=&quot;text&quot;&gt;  &lt;script&gt;    const input = document.querySelector(&#x27;input&#x27;)    // 用戶輸入文本事件  input    input.addEventListener(&#x27;input&#x27;, function () &#123;      console.log(input.value)    &#125;)  &lt;/script&gt;\n\n事件(對象)物件任意事件類型被觸發時與事件相關的資訊會被以物件的形式記錄下來，我們稱這個物件為事件物件。\n\n事件對像是什麼\n也是個對象，這個對象裡有事件觸發時的相關信息\n例如：鼠標點擊事件中，事件對象就存了鼠標點在哪個位置等信息\n使用場景\n可以判斷用戶按下哪個鍵，比如按下回車鍵可以發布新聞\n可以判斷鼠標點擊了哪個元素，從而做相應的操作\n\n\n\n\n\n\n\n\n語法元素.addEventListener(&#39;click&#39;, function (e)&#123;&#125;)\n123456789101112131415161718&lt;body&gt;  &lt;h3&gt;事件物件&lt;/h3&gt;  &lt;p&gt;任意事件類型被觸發時與事件相關的資訊會被以物件的形式記錄下來，我們稱這個物件為事件物件。&lt;/p&gt;  &lt;hr&gt;  &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;  &lt;script&gt;    // 獲取 .box 元素    const box = document.querySelector(&#x27;.box&#x27;)    // 添加事件監聽    box.addEventListener(&#x27;click&#x27;, function (e) &#123;      console.log(&#x27;任意事件類型被觸發後，相關資訊會以物件形式被記錄下來...&#x27;);      // 事件回呼函數的第1個參數即所謂的事件物件      console.log(e)    &#125;)  &lt;/script&gt;&lt;/body&gt;\n\n\n\n\n\n\n\n\n\n\n事件回呼函數的【第1個參數】即所謂的事件物件通常習慣性的將這個對數命名為 event、ev 、ev 。\n接下來簡單看一下事件物件中包含了哪些有用的資訊：\n\nev.type 當前事件的類型\nev.clientX/Y 游標相對流覽器窗口的位置\nev.offsetX/Y 游標相於當前 DOM 元素的位置\n\n\n補充 key 用户按下的鍵盤鍵的值\n\n注：在事件回呼函數內部通過 window.event 同樣可以獲取事件物件。\n123456789&lt;input type=&quot;text&quot;&gt;  &lt;script&gt;    const input = document.querySelector(&#x27;input&#x27;)    input.addEventListener(&#x27;keyup&#x27;, function (e) &#123;      if (e.key === &#x27;Enter&#x27;) &#123;        console.log(&#x27;我按下了Enter&#x27;)      &#125;    &#125;)  &lt;/script&gt;\n環境(對象)物件\n\n\n\n\n\n\n\n\n能夠分析判斷函數運行在不同環境中 this 所指代的物件。\n環境物件指的是函數內部特殊的變數 this ，它代表著當前函數運行時所處的環境。\n1234567891011121314151617181920212223242526&lt;script&gt;  // 聲明函數  function sayHi() &#123;    // this 是一個變數    console.log(this);  &#125;  // 聲明一個物件  let user = &#123;    name: &#x27;張三&#x27;,    sayHi: sayHi // 此處把 sayHi 函數，賦值給 sayHi 屬性  &#125;    let person = &#123;    name: &#x27;李四&#x27;,    sayHi: sayHi  &#125;  // 直接調用  sayHi() // window  window.sayHi() // window  // 做為物件方法調用  user.sayHi()// user  person.sayHi()// person&lt;/script&gt;\n\n結論：\n\nthis 本質上是一個變數，資料類型為物件\n函數的調用方式不同 this 變數的值也不同\n【誰調用 this 就是誰】是判斷 this 值的粗略規則\n函數直接調用時實際上 window.sayHi() 所以 this 的值為 window\n\n回呼函數如果將函數 A 做為參數傳遞給函數 B 時，我們稱函數 A 為回呼函數。\n1234567891011121314151617&lt;script&gt;  // 聲明 foo 函數  function foo(arg) &#123;    console.log(arg);  &#125;  // 普通的值做為參數  foo(10);  foo(&#x27;hello world!&#x27;);  foo([&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]);  function bar() &#123;    console.log(&#x27;函數也能當參數...&#x27;);  &#125;  // 函數也可以做為參數！！！！  foo(bar);&lt;/script&gt;\n\n函數 bar 做參數傳給了 foo 函數，bar 就是所謂的回呼函數了！！！\n回顧一下間歇函數 setInterval \n1234567&lt;script&gt;  function fn() &#123;    console.log(&#x27;我是回呼函數...&#x27;);  &#125;  // 調用計時器  setInterval(fn, 1000);&lt;/script&gt;\n\nfn 函數做為參數傳給了 setInterval ，這便是回呼函數的實際應用了，結合剛剛學習的函數運算式上述代碼還有另一種更常見寫法。\n123456&lt;script&gt;  // 調用計時器，匿名函數做為參數  setInterval(function () &#123;    console.log(&#x27;我是回呼函數...&#x27;);  &#125;, 1000);&lt;/script&gt;\n\n結論：\n\n回呼函數本質還是函數，只不過把它當成參數使用\n使用匿名函數做為回呼函數比較常見\n把函數当做另外一个函数的参數傳遞，这个函數就叫回调函數\n\n輪播圖練習123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot; /&gt;  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;  &lt;title&gt;輪播圖點擊切換&lt;/title&gt;  &lt;style&gt;    * &#123;      box-sizing: border-box;    &#125;    .slider &#123;      width: 560px;      height: 400px;      overflow: hidden;    &#125;    .slider-wrapper &#123;      width: 100%;      height: 320px;    &#125;    .slider-wrapper img &#123;      width: 100%;      height: 100%;      display: block;    &#125;    .slider-footer &#123;      height: 80px;      background-color: rgb(100, 67, 68);      padding: 12px 12px 0 12px;      position: relative;    &#125;    .slider-footer .toggle &#123;      position: absolute;      right: 0;      top: 12px;      display: flex;    &#125;    .slider-footer .toggle button &#123;      margin-right: 12px;      width: 28px;      height: 28px;      appearance: none;      border: none;      background: rgba(255, 255, 255, 0.1);      color: #fff;      border-radius: 4px;      cursor: pointer;    &#125;    .slider-footer .toggle button:hover &#123;      background: rgba(255, 255, 255, 0.2);    &#125;    .slider-footer p &#123;      margin: 0;      color: #fff;      font-size: 18px;      margin-bottom: 10px;    &#125;    .slider-indicator &#123;      margin: 0;      padding: 0;      list-style: none;      display: flex;      align-items: center;    &#125;    .slider-indicator li &#123;      width: 8px;      height: 8px;      margin: 4px;      border-radius: 50%;      background: #fff;      opacity: 0.4;      cursor: pointer;    &#125;    .slider-indicator li.active &#123;      width: 12px;      height: 12px;      opacity: 1;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;slider&quot;&gt;    &lt;div class=&quot;slider-wrapper&quot;&gt;      &lt;img src=&quot;./images/slider01.jpg&quot; alt=&quot;&quot; /&gt;    &lt;/div&gt;    &lt;div class=&quot;slider-footer&quot;&gt;      &lt;p&gt;對人類來說會不會太超前了？ &lt;/p&gt;      &lt;ul class=&quot;slider-indicator&quot;&gt;        &lt;li class=&quot;active&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;      &lt;/ul&gt;      &lt;div class=&quot;toggle&quot;&gt;        &lt;button class=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt;        &lt;button class=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    // 1. 初始數據    const data = [      &#123; url: &#x27;./images/slider01.jpg&#x27;, title: &#x27;對人類來說會不會太超前了？ &#x27;, color: &#x27;rgb(100, 67, 68)&#x27; &#125;,      &#123; url: &#x27;./images/slider02.jpg&#x27;, title: &#x27;開啟劍與雪的黑暗傳說！ &#x27;, color: &#x27;rgb(43, 35, 26)&#x27; &#125;,      &#123; url: &#x27;./images/slider03.jpg&#x27;, title: &#x27;真正的jo廚出現了！ &#x27;, color: &#x27;rgb(36, 31, 33)&#x27; &#125;,      &#123; url: &#x27;./images/slider04.jpg&#x27;, title: &#x27;李玉剛：讓世界通過B站看到東方大國文化&#x27;, color: &#x27;rgb(139, 98, 66)&#x27; &#125;,      &#123; url: &#x27;./images/slider05.jpg&#x27;, title: &#x27;快來分享你的寒假日常吧~&#x27;, color: &#x27;rgb(67, 90, 92)&#x27; &#125;,      &#123; url: &#x27;./images/slider06.jpg&#x27;, title: &#x27;嗶哩嗶哩小年YEAH&#x27;, color: &#x27;rgb(166, 131, 143)&#x27; &#125;,      &#123; url: &#x27;./images/slider07.jpg&#x27;, title: &#x27;一站式解決你的電腦配置問題！ ！ ！ &#x27;, color: &#x27;rgb(53, 29, 25)&#x27; &#125;,      &#123; url: &#x27;./images/slider08.jpg&#x27;, title: &#x27;誰不想和小貓咪貼貼呢！ &#x27;, color: &#x27;rgb(99, 72, 114)&#x27; &#125;,    ]    // 獲取元素    const img = document.querySelector(&#x27;.slider-wrapper img&#x27;)    const p = document.querySelector(&#x27;.slider-footer p&#x27;)    const footer = document.querySelector(&#x27;.slider-footer&#x27;)    // 1. 右按鈕業務    // 1.1 獲取右側按鈕     const next = document.querySelector(&#x27;.next&#x27;)    let i = 0  // 信號量 控製播放圖片張數    // 1.2 註冊點擊事件    next.addEventListener(&#x27;click&#x27;, function () &#123;      // console.log(11)      i++      // 1.6判斷條件  如果大於8 就復原為 0      // if (i &gt;= 8) &#123;      //   i = 0      // &#125;      i = i &gt;= data.length ? 0 : i      // 1.3 得到對應的對象      // console.log(data[i])      // 調用函數      toggle()    &#125;)    // 2. 左側按鈕業務    // 2.1 獲取左側按鈕     const prev = document.querySelector(&#x27;.prev&#x27;)    // 1.2 註冊點擊事件    prev.addEventListener(&#x27;click&#x27;, function () &#123;      i--      // 判斷條件  如果小於0  則爬到最後一張圖片索引號是 7      // if (i &lt; 0) &#123;      //   i = 7      // &#125;      i = i &lt; 0 ? data.length - 1 : i      // 1.3 得到對應的對象      // console.log(data[i])      // 調用函數      toggle()    &#125;)    // 聲明一個渲染的函數作為複用    function toggle() &#123;      // 1.4 渲染對應的數據      img.src = data[i].url      p.innerHTML = data[i].title      footer.style.backgroundColor = data[i].color      // 1.5 更換小圓點    先移除原來的類名， 當前li再添加 這個 類名      document.querySelector(&#x27;.slider-indicator .active&#x27;).classList.remove(&#x27;active&#x27;)      document.querySelector(`.slider-indicator li:nth-child($&#123;i + 1&#125;)`).classList.add(&#x27;active&#x27;)    &#125;// 3. 自動播放模塊    let timerId = setInterval(function () &#123;      // 利用js自動調用點擊事件  click()  一定加小括號調用函數      next.click()    &#125;, 1000)    // 4. 鼠標經過大盒子，停止定時器    const slider = document.querySelector(&#x27;.slider&#x27;)    // 註冊事件    slider.addEventListener(&#x27;mouseenter&#x27;, function () &#123;      // 停止定時器      clearInterval(timerId)    &#125;)    // 5. 鼠標離開大盒子，開啟定時器    // 註冊事件    slider.addEventListener(&#x27;mouseleave&#x27;, function () &#123;      // 停止定時器      if (timerId) clearInterval(timerId)      // 開啟定時器      timerId = setInterval(function () &#123;        // 利用js自動調用點擊事件  click()  一定加小括号调用函数        next.click()      &#125;, 1000)    &#125;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n","slug":"2303-2 JS Web APIs 02 事件","date":"2023-03-24T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"0a48fb7912b57657825a8de1e5528e6f","title":"JavaScript Web APIs - 第1天","content":"複習：splice() 方法用於添加或刪除陣列中的元素。\n注意：這種方法會改變原始陣列。\n\n刪除陣列：\n\nsplice(起始位置， 刪除的個數)\n比如：1\n123let arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]arr.splice(1,1) // 刪除green元素console.log(arr) // [&#x27;red, &#x27;blue&#x27;]\n\n\n添加元素\n\nsplice(起始位置，刪除個數，添加陣列元素)\n12345let arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]//arr.splice(1, 0, &#x27;pink&#x27;) // 在索引號是1的位置添加 pink//console.log(arr) // [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]arr.splice(1, 0, &#x27;pink&#x27;, &#x27;hotpink&#x27;) // 在索引號是1的位置添加 pink  hotpinkconsole.log(arr) // [&#x27;red&#x27;, &#x27;pink&#x27;, &#x27;hotpink&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]\n\n聲明變數優先使用哪個？\n\n\n\n\n\n\n\n\nconst有了變數先給const，如果發現它後面是要被修改的，再改為let\n為什麼const聲明的物件可以修改裡面的屬性？\n\n\n\n\n\n\n\n\nconst 聲明的值不能更改，而且const聲明變量的時候需要裡面進行初始化， 但是對於引用數據類型，const聲明的變量，裡面存的不是”值”是”地址”。因為物件是參考類型，裡面存儲的是位址，只要位址不變，就不會報錯建議陣列和物件使用 const 來聲明\n什麼時候使用let聲明變數？\n\n\n\n\n\n\n\n\n如果基本資料型別的值或者參考類型的位址發生變化的時候，需要用let比如 一個變數進行加減運算，比如 for迴圈中的 i++\nWeb APIs - 第1天筆記\n\n\n\n\n\n\n\n\n瞭解 DOM 的結構並掌握其基本的操作，體驗 DOM 的在開發中的作用\n\n知道 ECMAScript 與 JavaScript 的關係\n瞭解 DOM 的相關概念及DOM 的本質是一個物件\n掌握查找節點的基本方法\n掌握節點屬性和文本的操作\n能夠使用間歇函數創建定時任務\n\n介紹\n\n\n\n\n\n\n\n\n知道 ECMAScript 與 JavaScript 的關係，Web APIs 是流覽器擴展的功能。\n嚴格意義上講，我們在 JavaScript 階段學習的知識絕大部分屬於 ECMAScript 的知識體系，ECMAScript 簡稱 ES 它提供了一套語言標準規範，如變數、資料類型、運算式、語句、函數等語法規則都是由 ECMAScript 規定的。流覽器將 ECMAScript 大部分的規範加以實現，並且在此基礎上又擴展一些實用的功能，這些被擴展出來的內容我們稱為 Web APIs。\nECMAScript 運行在流覽器中然後再結合 Web APIs 才是真正的 JavaScript，Web APIs 的核心是 DOM 和 BOM。\n擴展閱讀：ECMAScript 規範在不斷的更新中，存在多個不同的版本，早期的版本號採用數位順序編號如 ECMAScript3、ECMAScript5，後來由於更新速度較快便採用年份做為版本號，如 ECMAScript2017、ECMAScript2018 這種格式，ECMAScript6 是 2015 年發佈的，常叫做 EMCAScript2015。\n關於 JavaScript 歷史的擴展閱讀。\n\n\n\n\n\n\n\n\n\n知道 DOM 相關的概念，建立對 DOM 的初步認識，學習 DOM 的基本操作，體會 DOM 的作用\n\n\n\n\n\n\n\n\n\nDOM（Document Object Model）是將整個 HTML 文檔的每一個標籤元素視為一個物件，這個物件下包含了許多的屬性和方法，通過操作這些屬性或者調用這些方法實現對 HTML 的動態更新，為實現網頁特效以及用戶交互提供技術支撐。\n簡言之 DOM 是用來動態修改 HTML 的，其目的是開發網頁特效及用戶交互。\n例如 當用戶分分別點擊【開始】或【結束】按鈕後，通過調試視窗可以觀察到 html 標籤的內容在不斷的發生改變，這便是通過 DOM 實現的。\n概念DOM 樹12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;標題&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  文本  &lt;a href=&quot;&quot;&gt;連結名&lt;/a&gt;  &lt;div id=&quot;&quot; class=&quot;&quot;&gt;文本&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n將 HTML 文檔以樹狀結構直觀的表現出來，我們稱之為文檔樹或 DOM 樹，文檔樹直觀的體現了標籤與標籤之間的關係。\nDOM 節點節點是文檔樹的組成部分，每一個節點都是一個 DOM 物件，主要分為元素節點、屬性節點、文本節點等。\n\n【元素節點】其實就是 HTML 標籤，如上圖中 head、div、body 等都屬於元素節點。\n【屬性節點】是指 HTML 標籤中的屬性，如上圖中 a 標籤的 href 屬性、div 標籤的 class 屬性。\n【文本節點】是指 HTML 標籤的文字內容，如 title 標籤中的文字。\n【根節點】特指 html 標籤。\n其它…\n\ndocument\n\n\n\n\n\n\n\n\n網頁所有内容都在document里面document 是 JavaScript 內置的專門用於 DOM 的物件，該物件包含了若干的屬性和方法，document 是學習 DOM 的核心。\n12345678910111213&lt;script&gt;  // document 是內置的對象  // console.log(typeof document);  // 1. 通過 document 獲取根節點  console.log(document.documentElement); // 對應 html 標籤  // 2. 通過 document 節取 body 節點  console.log(document.body); // 對應 body 標籤  // 3. 通過 document.write 方法向網頁輸出內容  document.write(&#x27;Hello World!&#x27;);&lt;/script&gt;\n\n上述列舉了 document 物件的部分屬性和方法，我們先對 document 有一個整體的認識。\n獲取DOM對象\n\n\n\n\n\n\n\n\ndocument.querySelector(‘css選擇器’) &#x2F;&#x2F;css選擇器須加引號瀏覽器根據html標籤生成的 JS對象（DOM對象）DOM的核心就是把內容當對象來處理\n\nquerySelector   滿足條件的第一個元素\nquerySelectorAll  滿足條件的元素集合 返回偽陣列\n瞭解其他方式\ngetElementById\ngetElementsByTagName\n\n\n\n12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;DOM - 查找節點&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;h3&gt;查找元素類型節點&lt;/h3&gt;  &lt;p&gt;從整個 DOM 樹中查找 DOM 節點是學習 DOM 的第一個步驟。&lt;/p&gt;  &lt;ul&gt;      &lt;li&gt;元素&lt;/li&gt;      &lt;li&gt;元素&lt;/li&gt;      &lt;li&gt;元素&lt;/li&gt;      &lt;li&gt;元素&lt;/li&gt;  &lt;/ul&gt;  &lt;script&gt;    const p = document.querySelector(&#x27;p&#x27;)  // 獲取第一個p元素    const lis = document.querySelectorAll(&#x27;li&#x27;)  // 獲取第一個p元素  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n總結：\n\ndocument.getElementById 專門獲取元素類型節點，根據標籤的 id  屬性查找\n任意 DOM 物件都包含 nodeType 屬性，用來檢檢測節點類型\n\n操作元素內容通過修改 DOM 的文本內容，動態改變網頁的內容。\n\ninnerText 將文本內容添加&#x2F;更新到任意標籤位置，文本中包含的標籤不會被解析。\n\n123456&lt;script&gt;  // innerText 將文本內容添加/更新到任意標籤位置  const intro = document.querySelector(&#x27;.intro&#x27;)  // intro.innerText = &#x27;嗨~ 我叫李雷！&#x27;  // intro.innerText = &#x27;&lt;h4&gt;嗨~ 我叫李雷！&lt;/h4&gt;&#x27;&lt;/script&gt;\n\n\ninnerHTML 將文本內容添加&#x2F;更新到任意標籤位置，文本中包含的標籤會被解析。\n\n123456&lt;script&gt;  // innerHTML 將文本內容添加/更新到任意標籤位置  const intro = document.querySelector(&#x27;.intro&#x27;)  intro.innerHTML = &#x27;嗨~ 我叫韓梅梅！&#x27;  intro.innerHTML = &#x27;&lt;h4&gt;嗨~ 我叫韓梅梅！&lt;/h4&gt;&#x27;&lt;/script&gt;\n\n總結：如果文本內容中包含 html 標籤時推薦使用 innerHTML，否則建議使用 innerText 屬性。\n\n\n\n\n\n\n\n\n\n元素.innerText 屬性 只識別文本，不能解析標籤元素.innerHTML 屬性 能識別文本，能夠解析標籤\n操作元素屬性有3種方式可以實現對屬性的修改：\n常用屬性修改\n直接能過屬性名修改，最簡潔的語法\n\n12345678&lt;script&gt;  // 1. 獲取 img 對應的 DOM 元素  const pic = document.querySelector(&#x27;.pic&#x27;)  // 2. 修改屬性  pic.src = &#x27;./images/lion.webp&#x27;  pic.width = 400;  pic.alt = &#x27;圖片不見了...&#x27;&lt;/script&gt;\n\n控制樣式屬性\n應用【修改樣式】，通過修改行內樣式 style 屬性，實現對樣式的動態修改。\n\n通過元素節點獲得的 style 屬性本身的資料類型也是物件，如 box.style.color、box.style.width 分別用來獲取元素節點 CSS 樣式的 color 和 width 的值。\n1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;練習 - 修改樣式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;隨便一些文本內容&lt;/div&gt;  &lt;script&gt;    // 獲取 DOM 節點    const box = document.querySelector(&#x27;.intro&#x27;)    box.style.color = &#x27;red&#x27;    box.style.width = &#x27;300px&#x27;    // css 屬性的 - 連接子與 JavaScript 的 減運算子    // 衝突，所以要改成駝峰法    box.style.backgroundColor = &#x27;pink&#x27;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n任何標籤都有 style 屬性，通過 style 屬性可以動態更改網頁標籤的樣式，如要遇到 css 屬性中包含字元 - 時，要將 - 去掉並將其後面的字母改成大寫，如 background-color 要寫成 box.style.backgroundColor\n\n操作類名(className) 操作CSS\n\n\n\n\n\n\n\n\n\n\n如果修改的樣式比較多，直接通過style屬性修改比較繁瑣，我們可以通過借助於css類名的形式。直接使用 className 賦值會覆盖以前的類名\n12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;title&gt;練習 - 修改樣式&lt;/title&gt;    &lt;style&gt;        .pink &#123;            background: pink;            color: hotpink;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;box&quot;&gt;隨便一些文本內容&lt;/div&gt;  &lt;script&gt;    // 獲取 DOM 節點    const box = document.querySelector(&#x27;.intro&#x27;)    box.className = &#x27;pink&#x27;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n注意：\n1.由於class是關鍵字, 所以使用className去代替\n2.className是使用新值換舊值, 如果需要添加一個類,需要保留之前的類名\n\n通過 classList 操作類控制CSS\n\n\n\n\n\n\n\n\n\n\n為了解決className 容易覆蓋以前的類名，我們可以通過classList方式追加和刪除類名\n123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;    &lt;style&gt;        div &#123;            width: 200px;            height: 200px;            background-color: pink;        &#125;        .active &#123;            width: 300px;            height: 300px;            background-color: hotpink;            margin-left: 100px;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class=&quot;one&quot;&gt;&lt;/div&gt;    &lt;script&gt;        // 1.獲取元素        // let box = document.querySelector(&#x27;css選擇器&#x27;)        let box = document.querySelector(&#x27;div&#x27;)        // add是個方法 添加  追加        // box.classList.add(&#x27;active&#x27;)        // remove() 移除 類        // box.classList.remove(&#x27;one&#x27;)        // 切換類        box.classList.toggle(&#x27;one&#x27;)    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n動作表單元素屬性表單很多情況，也需要修改屬性，比如點擊眼睛，可以看到密碼，本質是把表單類型轉換為文字方塊\n正常的有屬性有取值的跟其他的標籤屬性沒有任何區別\n獲取:DOM對象.屬性名\n設置:DOM對象.屬性名&#x3D; 新值\n1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input type=&quot;text&quot; value=&quot;請輸入&quot;&gt;    &lt;button disabled&gt;按鈕&lt;/button&gt;    &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; class=&quot;agree&quot;&gt;    &lt;script&gt;        // 1. 獲取元素        let input = document.querySelector(&#x27;input&#x27;)        // 2. 取值或者設置值  得到input裡面的值可以用 value        // console.log(input.value)        input.value = &#x27;小米手機&#x27;        input.type = &#x27;password&#x27;        // 2. 啟用按鈕        let btn = document.querySelector(&#x27;button&#x27;)        // disabled 不可用   =  false  這樣可以讓按鈕啟用        btn.disabled = false        // 3. 勾選核取方塊        let checkbox = document.querySelector(&#x27;.agree&#x27;)        checkbox.checked = false    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n自訂屬性標準屬性: 標籤天生自帶的屬性 比如class id title等, 可以直接使用點語法操作比如： disabled、checked、selected\n自訂屬性：\n在html5中推出來了專門的data-自訂屬性  \n在標籤上一律以data-開頭\n在DOM物件上一律以dataset物件方式獲取\n1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;   &lt;div data-id=&quot;1&quot;&gt; 自訂屬性 &lt;/div&gt;    &lt;script&gt;        // 1. 獲取元素        let div = document.querySelector(&#x27;div&#x27;)        // 2. 獲取自訂屬性值         console.log(div.dataset.id)          &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n間歇函數\n\n\n\n\n\n\n\n\n知道間歇函數的作用，利用間歇函數創建定時任務。\nsetInterval 是 JavaScript 中內置的函數，它的作用是間隔固定的時間自動重複執行另一個函數，也叫計時器函數。\n定時器函數可以開啟和關閉定時器\n\n開啟定時器1setInterval(函數, 間隔時間)\n\n\n作用：每隔一段時間調用這個函數\n間隔時間單位是毫秒\n\n12345678910&lt;script&gt;  // 1. 定義一個普通函數  function repeat() &#123;    console.log(&#x27;不知疲倦的執行下去....&#x27;)  &#125;  // 2. 使用 setInterval 調用 repeat 函數  // 間隔 1000 毫秒，重複調用 repeat  setInterval(repeat, 1000)&lt;/script&gt;\n\n關閉定時器12let 變量名 = setInterval(函數, 間隔時間)clearInterval(變量名)\n\n\n\n\n\n\n\n\n\n\n注意：\n函數名字不需要加括號\n定時器返回的是一個id數字\n\n\n\n123456789&lt;script&gt;  // setInterval(函數名, 間隔時間)  函數名不要加小括號  let n = setInterval(fn, 1000)  // setInterval(&#x27;fn()&#x27;, 1000)  console.log(n)  // 關閉定時器  clearInterval(n)&lt;/script&gt;\n\n用戶註冊倒計時(範例)1234567891011121314151617181920212223242526&lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;        用戶註冊協議        歡迎註冊成為京東用戶！在您註冊過程中，您需要完成我們的註冊流程並通過點擊同意的形式在線簽署以下協議，請您務必仔細閱讀、充分理解協議中的條款內容後再點擊同意（尤其是以粗體或下劃線標識的條款，因為這些條款可能會明確您應履行的義務或對您的權利有所限制）。        【請您注意】如果您不同意以下協議全部或任何條款約定，請您停止註冊。您停止註冊後將僅可以瀏覽我們的商品信息但無法享受我們的產品或服務。如您按照註冊流程提示填寫信息，閱讀並點擊同意上述協議且完成全部註冊流程後，即表示您已充分閱讀、理解並接受協議的全部內容，並表明您同意我們可以依據協議內容來處理您的個人信息，並同意我們將您的訂單信息共享給為完成此訂單所必須的第三方合作方（詳情查看    &lt;/textarea&gt;    &lt;br&gt;    &lt;button class=&quot;btn&quot; disabled&gt;我已經閱讀用戶協議(5)&lt;/button&gt;    &lt;script&gt;        // 1. 獲取元素        const btn = document.querySelector(&#x27;.btn&#x27;)        // console.log(btn.innerHTML)  butto按鈕特殊用innerHTML        // 2. 倒計時        let i = 5        // 2.1 開啟定時器        let n = setInterval(function () &#123;            i--            btn.innerHTML = `我已經閱讀用戶協議($&#123;i&#125;)`            if (i === 0) &#123;                clearInterval(n)  // 關閉定時器                // 定時器停了，我就可以開按鈕                btn.disabled = false                btn.innerHTML = &#x27;同意&#x27;            &#125;        &#125;, 1000)    &lt;/script&gt;\n輪波圖計時器範例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;style&gt;  * &#123;    box-sizing: border-box;  &#125;  .slider &#123;    width: 560px;    height: 400px;    overflow: hidden;  &#125;  .slider-wrapper &#123;    width: 100%;    height: 320px;  &#125;  .slider-wrapper img &#123;    width: 100%;    height: 100%;    display: block;  &#125;  .slider-footer &#123;    height: 80px;    background-color: rgb(100, 67, 68);    padding: 12px 12px 0 12px;    position: relative;  &#125;  .slider-footer .toggle &#123;    position: absolute;    right: 0;    top: 12px;    display: flex;  &#125;  .slider-footer .toggle button &#123;    margin-right: 12px;    width: 28px;    height: 28px;    appearance: none;    border: none;    background: rgba(255, 255, 255, 0.1);    color: #fff;    border-radius: 4px;    cursor: pointer;  &#125;  .slider-footer .toggle button:hover &#123;    background: rgba(255, 255, 255, 0.2);  &#125;  .slider-footer p &#123;    margin: 0;    color: #fff;    font-size: 18px;    margin-bottom: 10px;  &#125;  .slider-indicator &#123;    margin: 0;    padding: 0;    list-style: none;    display: flex;    align-items: center;  &#125;  .slider-indicator li &#123;    width: 8px;    height: 8px;    margin: 4px;    border-radius: 50%;    background: #fff;    opacity: 0.4;    cursor: pointer;  &#125;  .slider-indicator li.active &#123;    width: 12px;    height: 12px;    opacity: 1;  &#125;&lt;/style&gt;\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div class=&quot;slider&quot;&gt;    &lt;div class=&quot;slider-wrapper&quot;&gt;      &lt;img src=&quot;./images/slider01.jpg&quot; alt=&quot;&quot; /&gt;    &lt;/div&gt;    &lt;div class=&quot;slider-footer&quot;&gt;      &lt;p&gt;對人類來說會不會太超前了？ &lt;/p&gt;      &lt;ul class=&quot;slider-indicator&quot;&gt;        &lt;li class=&quot;active&quot;&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;        &lt;li&gt;&lt;/li&gt;      &lt;/ul&gt;      &lt;div class=&quot;toggle&quot;&gt;        &lt;button class=&quot;prev&quot;&gt;&amp;lt;&lt;/button&gt;        &lt;button class=&quot;next&quot;&gt;&amp;gt;&lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;script&gt;    // 1. 初始數據    const sliderData = [      &#123; url: &#x27;./images/slider01.jpg&#x27;, title: &#x27;對人類來說會不會太超前了？ &#x27;, color: &#x27;rgb(100, 67, 68)&#x27; &#125;,      &#123; url: &#x27;./images/slider02.jpg&#x27;, title: &#x27;開啟劍與雪的黑暗傳說！ &#x27;, color: &#x27;rgb(43, 35, 26)&#x27; &#125;,      &#123; url: &#x27;./images/slider03.jpg&#x27;, title: &#x27;真正的jo廚出現了！ &#x27;, color: &#x27;rgb(36, 31, 33)&#x27; &#125;,      &#123; url: &#x27;./images/slider04.jpg&#x27;, title: &#x27;李玉剛：讓世界通過B站看到東方大國文化&#x27;, color: &#x27;rgb(139, 98, 66)&#x27; &#125;,      &#123; url: &#x27;./images/slider05.jpg&#x27;, title: &#x27;快來分享你的寒假日常吧~&#x27;, color: &#x27;rgb(67, 90, 92)&#x27; &#125;,      &#123; url: &#x27;./images/slider06.jpg&#x27;, title: &#x27;嗶哩嗶哩小年YEAH&#x27;, color: &#x27;rgb(166, 131, 143)&#x27; &#125;,      &#123; url: &#x27;./images/slider07.jpg&#x27;, title: &#x27;一站式解決你的電腦配置問題！ ！ ！ &#x27;, color: &#x27;rgb(53, 29, 25)&#x27; &#125;,      &#123; url: &#x27;./images/slider08.jpg&#x27;, title: &#x27;誰不想和小貓咪貼貼呢！ &#x27;, color: &#x27;rgb(99, 72, 114)&#x27; &#125;,    ]    // 1. 獲取元素     const img = document.querySelector(&#x27;.slider-wrapper img&#x27;)    const p = document.querySelector(&#x27;.slider-footer p&#x27;)    let i = 0  // 信號量 控製圖片的張數    // 2. 開啟定時器    // console.log(sliderData[i])  拿到對應的對象啦    setInterval(function () &#123;      i++      // 無縫銜接位置  一共八張圖片，到了最後一張就是 8， 數組的長度就是 8      if (i &gt;= sliderData.length) &#123;        i = 0      &#125;      // console.log(i)      // console.log(sliderData[i])      // 更換圖片路徑        img.src = sliderData[i].url      // 把字寫到 p裡面      p.innerHTML = sliderData[i].title      // 小圓點      // 先刪除以前的active      document.querySelector(&#x27;.slider-indicator .active&#x27;).classList.remove(&#x27;active&#x27;)      // 只讓當前li添加active      document.querySelector(`.slider-indicator li:nth-child($&#123;i + 1&#125;)`).classList.add(&#x27;active&#x27;)    &#125;, 1000)  &lt;/script&gt;\n\n分析：\n\n①：準備一個數組對象，裡麵包含詳細信息（素材包含）\n②：獲取元素\n③：設置定時器函數\n設置一個變量++\n找到變量對應的對象\n更改圖片、文字信息\n激活小圓點：移除上一個高亮的類名，當前變量對應的小圓點添加類\n\n\n④：處理圖片自動復原從頭播放（放到變量++後面，緊挨）\n如果圖片播放到最後一張， 就是大於等於數組的長度\n則把變量重置為0\n\n\n\n","slug":"2303-2 JS Web APIs 01 DOM","date":"2023-03-23T01:22:08.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"866ec5a135e50f1f3d3c59488d09d968","title":"JavaScript 基礎 - 第5天","content":"\n\n\n\n\n\n\n\n\n知道物件資料類型的特徵，能夠利用陣列物件渲染頁面\n\n理解什麼是物件，掌握定義物件的語法\n掌握數學物件的使用\n\n對象\n\n\n\n\n\n\n\n\n物件為無序的資料的集合，是 JavaScript 資料類型的一種，之前已經學習了數數值型別、字串類型、布林類型、undefined。物件資料類型可以被理解成是一種資料集合。它由屬性和方法兩部分構成。\n語法聲明一個物件類型的變數與之前聲明一個數值或字串類型的變數沒有本質上的區別。\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 聲明字串類型變數    let str = &#x27;hello world!&#x27;        // 聲明數數值型別變數    let num = 199    // 聲明物件類型變數，使用一對花括弧    // user 便是一個物件了，目前它是一個空物件    let user = &#123;&#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n物件使用-增刪改查&#x2F;&#x2F;聲明let 對象名 &#x3D; {  uname: ‘ben’,  age: 18,  gender: ‘男’}&#x2F;&#x2F; console.log(ben)\n&#x2F;&#x2F; 改 把性別的女改為男對象名.屬性 &#x3D; ‘男’console.log(對象名)\n  &#x2F;&#x2F; 增 對象名.屬性 &#x3D; ‘足球’console.log(對象名)\n  &#x2F;&#x2F; 刪 (瞭解) delete 對象名.屬性console.log(對象名)\n屬性和訪問資料描述性的資訊稱為屬性，如人的姓名、身高、年齡、性別等，一般是名詞性的。\n\n屬性都是成 對出現的，包括屬性名和值，它們之間使用英文 : 分隔\n多個屬性之間使用英文 , 分隔\n屬性就是依附在物件上的變數\n屬性名可以使用 &quot;&quot; 或 &#39;&#39;，一般情況下省略，除非名稱遇到特殊符號如空格、中橫線等\n\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 通過物件描述一個人的資料資訊    // person 是一個物件，它包含了一個屬性 name    // 屬性都是成對出現的，屬性名 和 值，它們之間使用英文 : 分隔    let person = &#123;      name: &#x27;小明&#x27;, // 描述人的姓名      age: 18, // 描述人的年齡      stature: 185, // 描述人的身高      gender: &#x27;男&#x27;, // 描述人的性別    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n聲明物件，並添加了若干屬性後，可以使用 . 或 [] 獲得物件中屬性對應的值，我稱之為屬性訪問。\n123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 通過物件描述一個人的資料資訊    // person 是一個物件，它包含了一個屬性 name    // 屬性都是成對出現的，屬性名 和 值，它們之間使用英文 : 分隔    let person = &#123;      name: &#x27;小明&#x27;, // 描述人的姓名      age: 18, // 描述人的年齡      stature: 185, // 描述人的身高      gender: &#x27;男&#x27;, // 描述人的性別    &#125;;        // 訪問人的名字    console.log(person.name) // 結果為 小明    // 訪問人性別    console.log(person.gender) // 結果為 男    // 訪問人的身高    console.log(person[&#x27;stature&#x27;]) // 結果為 185   // 或者    console.log(person.stature) // 結果同為 185  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n擴展：也可以動態為物件添加屬性，動態添加與直接定義是一樣的，只是語法上更靈活。\n12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件語法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 聲明一個空的物件（沒有任何屬性）  let user = &#123;&#125;    // 動態追加屬性    user.name = &#x27;小明&#x27;    user[&#x27;age&#x27;] = 18        // 動態添加與直接定義是一樣的，只是語法上更靈活  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n方法和調用資料行為性的資訊稱為方法，如跑步、唱歌等，一般是動詞性的，其本質是函數。\n\n方法是由方法名和函數兩部分構成，它們之間使用 : 分隔\n多個屬性之間使用英文 , 分隔\n方法是依附在物件中的函數\n方法名可以使用 &quot;&quot; 或 &#39;&#39;，一般情況下省略，除非名稱遇到特殊符號如空格、中橫線等\n\n123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 方法是依附在物件上的函數    let person = &#123;      name: &#x27;小紅&#x27;,      age: 18,      // 方法是由方法名和函數兩部分構成，它們之間使用 : 分隔      singing: function () &#123;        console.log(&#x27;兩隻老虎，兩隻老虎，跑的快，跑的快...&#x27;)      &#125;,      run: function () &#123;        console.log(&#x27;我跑的非常快...&#x27;)      &#125;    &#125;  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n聲明物件，並添加了若干方法後，可以使用 . 或 [] 調用物件中函數，我稱之為方法調用。\n123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 方法是依附在物件上的函數    let person = &#123;      name: &#x27;小紅&#x27;,      age: 18,      // 方法是由方法名和函數兩部分構成，它們之間使用 : 分隔      singing: function () &#123;        console.log(&#x27;兩隻老虎，兩隻老虎，跑的快，跑的快...&#x27;)      &#125;,      run: function () &#123;        console.log(&#x27;我跑的非常快...&#x27;)      &#125;    &#125;        // 調用物件中 singing 方法    person.singing()    // 調用物件中的 run 方法    person.run()  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n擴展：也可以動態為物件添加方法，動態添加與直接定義是一樣的，只是語法上更靈活。\n1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 物件方法&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 聲明一個空的物件（沒有任何屬性，也沒有任何方法）  let user = &#123;&#125;    // 動態追加屬性    user.name = &#x27;小明&#x27;    user.[&#x27;age&#x27;] = 18        // 動態添加方法    user.move = function () &#123;      console.log(&#x27;移動一點距離...&#x27;)    &#125;      &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注：無論是屬性或是方法，同一個物件中出現名稱一樣的，後面的會覆蓋前面的。\nnullnull 也是 JavaScript 中資料類型的一種，通常只用它來表示不存在的物件。使用 typeof 檢測類型它的類型時，結果為 object。\n遍歷對象\n\n\n\n\n\n\n\n\n目標：能夠遍歷輸出物件裡面的元素for 遍歷物件的問題：Ø 物件沒有像陣列一樣的length屬性,所以無法確定長度Ø 物件裡面是無序的鍵值對, 沒有規律. 不像陣列裡面有規律的下標\n1234567let obj = &#123;    uname: &#x27;pink&#x27;&#125;for(let k in obj) &#123;    // k 屬性名  字串  帶引號    obj.&#x27;uname&#x27;     k ===  &#x27;uname&#x27;    // obj[k]  屬性值    obj[&#x27;uname&#x27;]   obj[k]&#125;\n\n\n\n\n\n\n\n\n\n\nfor in 不提倡遍歷陣列 因為 k 是 字串for in語法中的 k 是一個變數, 在迴圈的過程中依次代表物件的屬性名由於 k 是變數, 所以必須使用 [ ] 語法解析一定記住： k 是獲得物件的屬性名， 物件名[k] 是獲得 屬性值\n內置對象回想一下我們曾經使用過的 console.log，console其實就是 JavaScript 中內置的物件，該物件中存在一個方法叫 log，然後調用 log 這個方法，即 console.log()。\n除了 console 物件外，JavaScritp 還有其它的內置的物件\nMathMath 是 JavaScript 中內置的物件，稱為數學物件，這個物件下即包含了屬性，也包含了許多的方法。\n屬性\nMath.PI，獲取圓周率\n\n12// 圓周率console.log(Math.PI);\n\n方法\nMath.random，生成 0 到 1 間的亂數\n\n12// 0 ~ 1 之間的亂數, 包含 0 不包含 1Math.random()\n\n\nMath.ceil，數字向上取整\n\n12// 捨棄小數部分，整數部分加1Math.ceil(3.4)\n\n\nMath.floor，數字向下取整\n\n12// 捨棄小數部分，整數部分不變Math.floor(4.68)\n\n\nMath.round，四捨五入取整\n\n123// 取整，四捨五入原則Math.round(5.46539)Math.round(4.849)\n\n\nMath.max，在一組數中找出最大的\n\n12// 找出最大值Math.max(10, 21, 7, 24, 13)\n\n\nMath.min，在一組數中找出最小的\n\n12// 找出最小值Math.min(24, 18, 6, 19, 21)\n\n\nMath.pow，冪方法\n\n123// 求某個數的多少次方Math.pow(4, 2) // 求 4 的 2 次方Math.pow(2, 3) // 求 2 的 3 次方\n\n\nMath.sqrt，平方根\n\n12// 求某數的平方根Math.sqrt(16)\n\n數學物件提供了比較多的方法，這裡不要求強記，通過演示數學物件的使用，加深對物件的理解。拓展- 基底資料型別和引用資料類型\n\n\n\n術語\n解釋\n舉例\n\n\n\n關鍵字\n在JavaScript中有特殊意義的詞彙\nlet、var、function、if、else、switch、case、break\n\n\n保留字\n在目前的JavaScript中沒意義，但未來可能會具有特殊意義的詞彙\nint、short、long、char\n\n\n標識（識別字）\n變數名、函數名的另一種叫法\n無\n\n\n運算式\n能產生值的代碼，一般配合運算子出現\n10 + 3、age &gt;&#x3D; 18\n\n\n語句\n一段可執行的代碼\nIf () for()\n\n\n目標：瞭解基底資料型別和引用資料類型的存儲方式簡單類型又叫做基底資料型別或者數值型別，複雜類型又叫做參考類型。\n\n\n\n\n\n\n\n\n\n數值型別：單一資料型別&#x2F;基底資料型別，在存儲時變數中存儲的是值本身，因此叫做數值型別string ，number，boolean，undefined，null\n\n\n\n\n\n\n\n\n\n參考類型：複雜資料類型，在存儲時變數中存儲的僅僅是位址（引用），因此叫做引用資料類型通過 new 關鍵字創建的物件（系統物件、自訂物件），如 Object、Array、Date等\n","slug":"2303-1 JS 基礎5 對象","date":"2023-03-21T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"eddf66a4e61c3de8ab537ceecfc30415","title":"JavaScript 基礎 - 第4天","content":"\n\n\n\n\n\n\n\n\n理解封裝的意義，能夠通過函式的聲明實現邏輯的封裝，知道物件資料類型的特徵，結合數學物件實現簡單計算功能。\n\n理解函式的封裝的特徵\n掌握函式宣告的語法\n理解什麼是函式的返回值\n知道並能使用常見的內置函式\n\n函式\n\n\n\n\n\n\n\n\n-理解函式的封裝特性，掌握函式的語法規則-function，是被設計為執行特定任務的代碼塊\n聲明和調用函式可以把具有相同或相似邏輯的代碼“包裹”起來，通過函式呼叫執行這些被“包裹”的代碼邏輯，這麼做的優勢是有利於精簡代碼方便複用。\n聲明（定義）\n\n\n\n\n\n\n\n\n聲明（定義）一個完整函式包括關鍵字(function)、函式名、形式參數、函式體、返回值5個部分\n1234function 函式名(形式參數)&#123;  函式體  (返回值)&#125;\n\n調用聲明（定義）的函式必須調用才會真正被執行，使用 () 調用函式。\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 聲明和調用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 聲明（定義）了最簡單的函式，既沒有形式參數，也沒有返回值    function sayHi() &#123;      console.log(&#x27;嗨~&#x27;)    &#125;    // 函式呼叫，這些函式體內的代碼邏輯會被執行    // 函式名()            sayHi()    // 可以重複被調用，多少次都可以    sayHi()  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n注：函式名的命名規則與變數是一致的，並且儘量保證函式名的語義。\n小案例： 小星星\n123456789101112131415161718192021&lt;script&gt;        // 函式宣告        function sayHi() &#123;            // document.write(&#x27;hai~&#x27;)            document.write(`*&lt;br&gt;`)            document.write(`**&lt;br&gt;`)            document.write(`***&lt;br&gt;`)            document.write(`****&lt;br&gt;`)            document.write(`*****&lt;br&gt;`)            document.write(`******&lt;br&gt;`)            document.write(`*******&lt;br&gt;`)            document.write(`********&lt;br&gt;`)            document.write(`*********&lt;br&gt;`)        &#125;        // 函式呼叫        sayHi()        sayHi()        sayHi()        sayHi()        sayHi()    &lt;/script&gt;\n\n參數通過向函式傳遞參數，可以讓函式更加靈活多變，參數可以理解成是一個變數。\n聲明（定義）一個功能為打招呼的函式\n\n傳入數據清單\n聲明這個函式需要傳入幾個資料\n多個資料用逗號隔開\n\n1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 函式參數&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 聲明（定義）一個功能為打招呼的函式    // function sayHi() &#123;    //   console.log(&#x27;嗨~&#x27;)    // &#125;    // 調用函式    // sayHi()      // 這個函式似乎沒有什麼價值，除非能夠向不同的人打招呼    // 這就需要借助參數來實現了    function sayHi(name) &#123;      // 參數 name 可以被理解成是一個變數      console.log(name)      console.log(&#x27;嗨~&#x27; + name)    &#125;    // 調用 sayHi 函式，括弧中多了 &#x27;小明&#x27;    // 這時相當於為參數 name 賦值了    sayHi(&#x27;小明&#x27;)// 結果為 小明    // 再次調用 sayHi 函式，括弧中多了 &#x27;小紅&#x27;    // 這時相當於為參數 name 賦值了    sayHi(&#x27;小紅&#x27;) // 結果為 小紅  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n總結：\n\n聲明（定義）函式時的形參沒有數量限制，當有多個形參時使用 , 分隔\n調用函式傳遞的實參要與形參的順序一致\n\n形參和實參形參：聲明函式時寫在函式名右邊小括弧裡的叫形參（形式上的參數）\n實參：調用函式時寫在函式名右邊小括弧裡的叫實參（實際上的參數）\n形參可以理解為是在這個函式內聲明的變數（比如 num1 &#x3D; 10）實參可以理解為是給這個變數賦值\n開發中儘量保持形參和實參個數一致\n1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 函式參數&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 聲明（定義）一個計算任意兩數位和的函式    // 形參 x 和 y 分別表示任意兩個數字，它們是兩個變數    function count(x, y) &#123;      console.log(x + y);    &#125;    // 調用函式，傳入兩個具體的數字做為實參    // 此時 10 賦值給了形參 x    // 此時 5  賦值給了形參 y    count(10, 5); // 結果為 15  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n返回值函式的本質是封裝（包裹），函式體內的邏輯執行完畢後，函式外部如何獲得函式內部的執行結果呢？要想獲得函式內部邏輯的執行結果，需要通過 return 這個關鍵字，將內部執行結果傳遞到函式外部，這個被傳遞到外部的結果就是返回值。\n1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 函式返回值&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    // 定義求和函式    function count(a, b) &#123;      let s = a + b      // s 即為 a + b 的結果      // 通過 return 將 s 傳遞到外部      return s    &#125;    // 調用函式，如果一個函式有返回值    // 那麼可將這個返回值賦值給外部的任意變數    let total = count(5, 12)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n總結：\n\n在函式體中使用return 關鍵字能將內部的執行結果交給函式外部使用\n\n函式內部只能出現1 次 return，並且 return 下一行代碼不會再被執行，所以return 後面的資料不要換行寫\n\nreturn會立即結束當前函式\n\n函式可以沒有return，這種情況預設返回值為 undefined\n\n#ˇ數組返回多個變量\n\n\n作用域通常來說，一段程式碼中所用到的名字並不總是有效和可用的，而限定這個名字的可用性的代碼範圍就是這個名字的作用域。\n作用域的使用提高了程式邏輯的局部性，增強了程式的可靠性，減少了名字衝突。\n全域作用域作用於所有代碼執行的環境(整個 script 標籤內部)或者一個獨立的 js 檔\n處於全域作用域內的變數，稱為全域變數\n局部作用域作用於函式內的代碼環境，就是局部作用域。 因為跟函式有關係，所以也稱為函式作用域。\n處於局部作用域內的變數稱為區域變數\n\n\n\n\n\n\n\n\n\n如果函式內部，變數沒有聲明，直接賦值，也當全域變數看，但是強烈不推薦\n但是有一種情況，函式內部的形參可以看做是區域變數。\n變數的訪問原則\n\n\n\n\n\n\n\n\n只要是代碼，就至少有一個作用域寫在函式內部的局部作用域如果函式中還有函式，那麼在這個作用域中就又可以誕生一個作用域訪問原則：在能夠訪問到的情況下 先局部， 局部沒有在找全域\n匿名函式函式可以分為具名函式和匿名函式\n具名函式function fn(){}\n匿名函式：沒有名字的函式,無法直接使用。function {}\n函式運算式123456// 聲明let fn = function() &#123;    console.log(&#x27;函式運算式&#x27;)&#125;// 調用fn()\n\n立即執行函式立即執行函式可 防止變數污染\n12(function(形參)&#123; xxx  &#125;)(實參);(function(形參)&#123;xxxx&#125;(實參));\n\n\n\n\n\n\n\n\n\n\n無需調用，立即執行，其實本質已經調用了\n多個立即執行函式之間用分號隔開\n   在能夠訪問到的情況下 先局部 局部沒有在找全域\n","slug":"2303-1 JS 基礎4 函式","date":"2023-03-20T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"d6326a002590bf2cbb1500ce76554880","title":"JavaScript 基礎 - 第3天","content":"if 多分支語句和 switch的區別：\n\n共同點\n\n都能實現多分支選擇， 多選1 \n大部分情況下可以互換\n\n\n區別：\n\nswitch…case語句通常處理case為比較確定值的情況，而if…else…語句更加靈活，通常用於範圍判斷(大於，等於某個範圍)。\nswitch 語句進行判斷後直接執行到程式的語句，效率更高，而if…else語句有幾種判斷條件，就得判斷多少次\nswitch 一定要注意 必須是 &#x3D;&#x3D;&#x3D;  全等，一定注意 資料類型，同時注意break否則會有穿透效果\n結論：\n當分支比較少時，if…else語句執行效率高。\n當分支比較多時，switch語句執行效率高，而且結構更清晰。\n\n\n\n\n\nfor 語句\n\n\n\n\n\n\n\n\n掌握 for 迴圈語句，讓程式具備重複執行能力\nfor 是 JavaScript 提供的另一種迴圈控制的話句，它和 while 只是語法上存在差異。\nfor語句的基本使用\n實現迴圈的 3 要素(起始值; 終止條件; 變化量)\n\n1234567891011121314&lt;script&gt;  // 1. 語法格式  // for(起始值; 終止條件; 變化量) &#123;  //   // 要重複執行的代碼  // &#125;  // 2. 示例：在網頁中輸入標題標籤  // 起始值為 1  // 變化量 i++  // 終止條件 i &lt;= 6  for(let i = 1; i &lt;= 6; i++) &#123;    document.write(`&lt;h$&#123;i&#125;&gt;迴圈控制，即重複執行&lt;h$&#123;i&#125;&gt;`)  &#125;&lt;/script&gt;\n\n\n變化量和閉環，for 迴圈和 while 一樣，如果不合理設置增量和終止條件，便會產生閉環。\n\n跳出和終止迴圈\n\n\n12345678910111213141516&lt;script&gt;    // 1. continue     for (let i = 1; i &lt;= 5; i++) &#123;        if (i === 3) &#123;            continue  // 結束本次迴圈，繼續下一次迴圈        &#125;        console.log(i)    &#125;    // 2. break    for (let i = 1; i &lt;= 5; i++) &#123;        if (i === 3) &#123;            break  // 退出結束整個迴圈        &#125;        console.log(i)    &#125;&lt;/script&gt;\n\n結論：\n\nJavaScript 提供了多種語句來實現迴圈控制，但無論使用哪種語句都離不開迴圈的3個特徵，即起始值、變化量、終止條件，做為初學者應著重體會這3個特徵，不必過多糾結三種語句的區別。\n起始值、變化量、終止條件，由開發者根據邏輯需要進行設計，規避閉環的發生。\n當如果明確了迴圈的次數的時候推薦使用for迴圈,當不明確迴圈的次數的時候推薦使用while迴圈\n\n\n\n\n\n\n\n\n\n\n注意：for 的語法結構更簡潔，故 for 迴圈的使用頻次會更多。\n迴圈嵌套利用迴圈的知識來對比一個簡單的天文知識，我們知道地球在自轉的同時也在圍繞太陽公轉，如果把自轉和公轉都看成是迴圈的話，就相當於是迴圈中又嵌套了另一個迴圈。\n12345for(外部聲明紀錄循環次數的變量;循環條件;變化值)&#123;  for(內部聲明紀錄循環次數的變量;循環條件;變化值)&#123;    循環體  &#125;&#125;\n\n實際上 JavaScript 中任何一種迴圈語句都支持迴圈的嵌套，如下代碼所示：\n12345678// 1. 外面的迴圈 記錄第n天 for (let i = 1; i &lt; 4; i++) &#123;    document.write(`第$&#123;i&#125;天 &lt;br&gt;`)    // 2. 裡層的迴圈記錄 幾個單詞    for (let j = 1; j &lt; 6; j++) &#123;        document.write(`記住第$&#123;j&#125;個單詞&lt;br&gt;`)    &#125;&#125;\n\n記住，外層迴圈迴圈一次，裡層迴圈迴圈全部\n倒三角12345678 // 外層列印幾行for (let i = 1; i &lt;= 5; i++) &#123;    // 裡層列印幾個星星    for (let j = 1; j &lt;= i; j++) &#123;        document.write(&#x27;★&#x27;)    &#125;    document.write(&#x27;&lt;br&gt;&#x27;)&#125;\n★★★★★★★★★★★★★★★\n九九乘法表樣式css\n123456789101112span &#123;    display: inline-block;    width: 100px;    padding: 5px 10px;    border: 1px solid pink;    margin: 2px;    border-radius: 5px;    box-shadow: 2px 2px 2px rgba(255, 192, 203, .4);    background-color: rgba(255, 192, 203, .1);    text-align: center;    color: hotpink;&#125;\n\njavascript \n1234567891011 // 外層列印幾行for (let i = 1; i &lt;= 9; i++) &#123;    // 裡層列印幾個星星    for (let j = 1; j &lt;= i; j++) &#123;        // 只需要吧 ★ 換成  1 x 1 = 1           document.write(`    &lt;div&gt; $&#123;j&#125; x $&#123;i&#125; = $&#123;j * i&#125; &lt;/div&gt;     `)    &#125;    document.write(&#x27;&lt;br&gt;&#x27;)&#125;\n","slug":"2303-1 JS 基礎3 for語句","date":"2023-03-19T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"d6326a002590bf2cbb1500ce76554880","title":"JavaScript 基礎 - 第3天","content":"陣列\n\n\n\n\n\n\n\n\n知道什麼是陣列及其應用的場景，掌握陣列聲明及訪問的語法。\n陣列是什麼？陣列：(Array)是一種可以按順序保存資料的資料類型\n使用場景：如果有多個資料可以用陣列保存起來，然後放到一個變數中，管理非常方便\n陣列的基本使用定義陣列和陣列單元12345678&lt;script&gt;  // 1. 語法，使用 [] 來定義一個空陣列  // 定義一個空陣列，然後賦值給變數 classes  // let classes = [];  // 2. 定義非空陣列  let classes = [&#x27;小明&#x27;, &#x27;小剛&#x27;, &#x27;小紅&#x27;, &#x27;小麗&#x27;, &#x27;小米&#x27;]&lt;/script&gt;\n\n通過 [] 定義陣列，資料中可以存放真正的資料，如小明、小剛、小紅等這些都是陣列中的資料，我們這些資料稱為陣列單元，陣列單元之間使用英文逗號分隔。\n訪問陣列和陣列索引使用陣列存放資料並不是最終目的，關鍵是能夠隨時的訪問到陣列中的資料（單元）。其實 JavaScript 為陣列中的每一個資料單元都編了號，通過資料單元在陣列中的編號便可以輕鬆訪問到陣列中的資料單元了。\n我們將資料單元在陣列中的編號稱為索引值，也有人稱其為下標。\n索引值實際是按著資料單元在陣列中的位置依次排列的，注意是從 0 開始的\n1234567891011121314&lt;script&gt;  let classes = [&#x27;小明&#x27;, &#x27;小剛&#x27;, &#x27;小紅&#x27;, &#x27;小麗&#x27;, &#x27;小米&#x27;]    // 1. 訪問陣列，語法格式為：變數名[索引值]  document.write(classes[0]) // 結果為：小明  document.write(classes[1]) // 結果為：小剛  document.write(classes[4]) // 結果為：小米    // 2. 通過索引值還可以為陣列單重新賦值  document.write(classes[3]) // 結果為：小麗  // 重新為索引值為 3 的單元賦值  classes[3] = &#x27;小小麗&#x27;  document.wirte(classes[3]); // 結果為： 小小麗&lt;/script&gt;\n\n資料單元數值型別陣列做為資料的集合，它的單元值可以是任意資料類型\n12345678910&lt;script&gt;  // 6. 陣列單數值型別可以是任意資料類型  // a) 陣列單元值的類型為字元類型  let list = [&#x27;HTML&#x27;, &#x27;CSS&#x27;, &#x27;JavaScript&#x27;]  // b) 陣列單元值的類型為數值類型  let scores = [78, 84, 70, 62, 75]  // c) 混合多種類型  let mixin = [true, 1, false, &#x27;hello&#x27;]&lt;/script&gt;\n\n陣列長度屬性重申一次，陣列在 JavaScript 中並不是新的資料類型，它屬於物件類型。\n123456&lt;script&gt;  // 定義一個陣列  let arr = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]  // 陣列對應著一個 length 屬性，它的含義是獲取陣列的長度  console.log(arr.length) // 3&lt;/script&gt;\n\n運算元組陣列做為物件資料類型，不但有 length 屬性可以使用，還提供了許多方法：\n\npush 動態向陣列的尾部添加一個單元\nunshit 動態向陣列頭部添加一個單元\npop 刪除最後一個單元\nshift 刪除第一個單元\nsplice 動態刪除任意單元\n\n使用以上4個方法時，都是直接在原陣列上進行操作，即成功調任何一個方法，原陣列都跟著發生相應的改變。並且在添加或刪除單元時 length 並不會發生錯亂。\n12345678910111213141516171819202122232425&lt;script&gt;  // 定義一個陣列  let arr = [&#x27;html&#x27;, &#x27;css&#x27;, &#x27;javascript&#x27;]  // 1. push 動態向陣列的尾部添加一個單元  arr.push(&#x27;Nodejs&#x27;)  console.log(arr)  arr.push(&#x27;Vue&#x27;)  // 2. unshit 動態向陣列頭部添加一個單元  arr.unshift(&#x27;VS Code&#x27;)  console.log(arr)  // 3. splice 動態刪除任意單元  arr.splice(2, 1) // 從索引值為2的位置開始刪除1個單元  console.log(arr)  // 4. pop 刪除最後一個單元  arr.pop()  console.log(arr)  // 5. shift 刪除第一個單元  arr.shift()  console.log(arr)&lt;/script&gt;\n\n\n","slug":"2303-1 JS 基礎3-1 陣列","date":"2023-03-19T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"119b4406e4e9c28d94cef591716ce0ed","title":"JavaScript 基礎 - 第2天","content":"\n\n\n\n\n\n\n\n\n理解什麼是流程控制，知道條件控制的種類並掌握其對應的語法規則，具備利用迴圈編寫簡易ATM取款機程式能力\n\n運算子\n語句\n綜合案例\n\n運算子算術運算子數字是用來計算的，比如：乘法 * 、除法 &#x2F; 、加法 + 、減法 - 等等，所以經常和算術運算子一起。\n算術運算子：也叫數學運算子，主要包括加、減、乘、除、取餘（求模）等\n\n\n\n運算子\n作用\n\n\n\n+\n求和\n\n\n-\n求差\n\n\n*\n求積\n\n\n&#x2F;\n求商\n\n\n%\n取模（取餘數），開發中經常用於作為某個數位是否被整除\n\n\n\n\n\n\n\n\n\n\n\n注意：在計算失敗時，顯示的結果是 NaN （not a number）\n12345678910111213141516// 算術運算子console.log(1 + 2 * 3 / 2) //  4 let num = 10console.log(num + 10)  // 20console.log(num + num)  // 20// 1. 取模(取餘數)  使用場景：  用來判斷某個數是否能夠被整除console.log(4 % 2) //  0  console.log(6 % 3) //  0console.log(5 % 3) //  2console.log(3 % 5) //  3// 2. 注意事項 : 如果我們計算失敗，則返回的結果是 NaN (not a number)console.log(&#x27;老徐&#x27; - 2)console.log(&#x27;老徐&#x27; * 2)console.log(&#x27;老徐&#x27; + 2)   // pink老師2\n\n設定運算子設定運算子：對變數進行賦值的運算子\n &#x3D;     將等號右邊的值賦予給左邊, 要求左邊必須是一個容器\n\n\n\n運算子\n作用\n\n\n\n+&#x3D;\n加法賦值\n\n\n-+\n減法賦值\n\n\n*&#x3D;\n乘法賦值\n\n\n&#x2F;&#x3D;\n除法賦值\n\n\n%&#x3D;\n取餘賦值\n\n\n12345678&lt;script&gt;let num = 1// num = num + 1// 採取設定運算子// num += 1num += 3console.log(num)&lt;/script&gt;\n\n自增&#x2F;自減運算子\n\n\n符號\n作用\n說明\n\n\n\n++\n自增\n變數自身的值加1，例如: x++\n\n\n–\n自減\n變數自身的值減1，例如: x–\n\n\n\n++在前和++在後在單獨使用時二者並沒有差別，而且一般開發中我們都是獨立使用\n++在後（尾碼式）我們會使用更多\n\n\n\n\n\n\n\n\n\n\n注意：\n\n只有變數能夠使用自增和自減運算子\n++、– 可以在變數前面也可以在變數後面，比如: x++  或者  ++x\n\n12345678910111213141516171819202122&lt;script&gt;    // let num = 10    // num = num + 1    // num += 1    // // 1. 前置自增    // let i = 1    // ++i    // console.log(i)    // let i = 1    // console.log(++i + 1)    // 2. 後置自增    // let i = 1    // i++    // console.log(i)    // let i = 1    // console.log(i++ + 1)    // 瞭解     let i = 1    console.log(i++ + ++i + i)  &lt;/script&gt;\n\n比較運算子使用場景：比較兩個資料大小、是否相等，根據比較結果返回一個布林值（true &#x2F; false）\n\n\n\n運算子\n作用\n\n\n\n&gt;\n左邊是否大於右邊\n\n\n&lt;\n左邊是否小於右邊\n\n\n&gt;&#x3D;\n左邊是否大於或等於右邊\n\n\n&lt;&#x3D;\n左邊是否小於或等於右邊\n\n\n&#x3D;&#x3D;&#x3D;\n左右兩邊是否類型和值都相等（重點）\n\n\n&#x3D;&#x3D;\n左右兩邊值是否相等\n\n\n!&#x3D;\n左右值不相等\n\n\n!&#x3D;&#x3D;\n左右兩邊是否不全等\n\n\n12345678910111213141516171819&lt;script&gt;  console.log(3 &gt; 5)  console.log(3 &gt;= 3)  console.log(2 == 2)  // 比較運算子有隱式轉換 把&#x27;2&#x27; 轉換為 2  雙等號 只判斷值  console.log(2 == &#x27;2&#x27;)  // true  // console.log(undefined === null)  // === 全等 判斷 值 和 資料類型都一樣才行  // 以後判斷是否相等 請用 ===    console.log(2 === &#x27;2&#x27;)  console.log(NaN === NaN) // NaN 不等於任何人，包括他自己  console.log(2 !== &#x27;2&#x27;)  // true    console.log(2 != &#x27;2&#x27;) // false   console.log(&#x27;-------------------------&#x27;)  console.log(&#x27;a&#x27; &lt; &#x27;b&#x27;) // true  console.log(&#x27;aa&#x27; &lt; &#x27;ab&#x27;) // true  console.log(&#x27;aa&#x27; &lt; &#x27;aac&#x27;) // true  console.log(&#x27;-------------------------&#x27;)&lt;/script&gt;\n\n邏輯運算子使用場景：可以把多個布林值放到一起運算，最終返回一個布林值\n\n\n\n符號\n名稱\n日常讀法\n特點\n口訣\n\n\n\n&amp;&amp;\n邏輯與\n並且\n符號兩邊有一個假的結果為假\n一假則假\n\n\n||\n邏輯或\n或者\n符號兩邊有一個真的結果為真\n一真則真\n\n\n!\n邏輯非\n取反\ntrue變false  false變true\n真變假，假變真\n\n\n\n\n\nA\nB\nA &amp;&amp; B\nA || B\n!A\n\n\n\nfalse\nfalse\nfalse\nfalse\ntrue\n\n\nfalse\ntrue\nfalse\ntrue\ntrue\n\n\ntrue\nfalse\nfalse\ntrue\nfalse\n\n\ntrue\ntrue\ntrue\ntrue\nfalse\n\n\n12345678910111213141516171819202122&lt;script&gt;    // 邏輯與 一假則假    console.log(true &amp;&amp; true)    console.log(false &amp;&amp; true)    console.log(3 &lt; 5 &amp;&amp; 3 &gt; 2)    console.log(3 &lt; 5 &amp;&amp; 3 &lt; 2)    console.log(&#x27;-----------------&#x27;)    // 邏輯或 一真則真    console.log(true || true)    console.log(false || true)    console.log(false || false)    console.log(&#x27;-----------------&#x27;)    // 邏輯非  取反    console.log(!true)    console.log(!false)    console.log(&#x27;-----------------&#x27;)    let num = 6    console.log(num &gt; 5 &amp;&amp; num &lt; 10)    console.log(&#x27;-----------------&#x27;)  &lt;/script&gt;\n\n運算子優先順序\n\n\n\n\n\n\n\n\n邏輯運算子優先順序： ！&gt; &amp;&amp; &gt;  ||  \n語句運算式和語句\n\n\n\n\n\n\n\n\n運算式:可以被求值的代碼計算出一個結果。\n123+4num++\n\n\n\n\n\n\n\n\n\n語句一段可以執行的代碼，是一種行為，例如分支語句和循環語句。\n123for(let i = 0; i &lt; 10; i++)&#123;  console.log(&#x27;我愛程式&#x27;)&#125;\n\n\n分支語句分支語句可以根據條件判定真假，來選擇性的執行想要的代碼\n分支語句包含：\n\nif分支語句（重點）\n三元運算子\nswitch語句\n\nif 分支語句語法：\n123if(條件運算式) &#123;  // 滿足條件要執行的語句&#125;\n\n小括弧內的條件結果是布林值，為 true 時，進入大括弧裡執行代碼；為false，則不執行大括弧裡面代碼\n小括弧內的結果若不是布林類型時，會發生類型轉換為布林值，類似Boolean()\n如果大括弧只有一個語句，大括弧可以省略，但是，俺們不提倡這麼做~\n123456789101112131415161718192021222324252627282930313233&lt;script&gt;    // 單分支語句    // if (false) &#123;    //   console.log(&#x27;執行語句&#x27;)    // &#125;    // if (3 &gt; 5) &#123;    //   console.log(&#x27;執行語句&#x27;)    // &#125;    // if (2 === &#x27;2&#x27;) &#123;    //   console.log(&#x27;執行語句&#x27;)    // &#125;    //  1. 除了0 所有的數字都為真    //   if (0) &#123;    //     console.log(&#x27;執行語句&#x27;)    //   &#125;    // 2.除了 &#x27;&#x27; 所有的字串都為真 true    // if (&#x27;老徐&#x27;) &#123;    //   console.log(&#x27;執行語句&#x27;)    // &#125;    // if (&#x27;&#x27;) &#123;    //   console.log(&#x27;執行語句&#x27;)    // &#125;    // // if (&#x27;&#x27;) console.log(&#x27;執行語句&#x27;)    // 1. 用戶輸入    let score = +prompt(&#x27;請輸入准考證號碼&#x27;)    // 2. 進行判斷輸出    if (score &gt;= 700) &#123;      alert(&#x27;恭喜上榜&#x27;)    &#125;    console.log(&#x27;-----------------&#x27;)  &lt;/script&gt;\n\nif雙分支語句如果有兩個條件的時候，可以使用 if else 雙分支語句\n12345if (條件運算式)&#123;  // 滿足條件要執行的語句&#125; else &#123;  // 不滿足條件要執行的語句&#125;\n\n例如：\n1234567891011&lt;script&gt;   // 1. 用戶輸入   let uname = prompt(&#x27;請輸入用戶名:&#x27;)   let pwd = prompt(&#x27;請輸入密碼:&#x27;)   // 2. 判斷輸出   if (uname === &#x27;pink&#x27; &amp;&amp; pwd === &#x27;123456&#x27;) &#123;     alert(&#x27;恭喜登錄成功&#x27;)   &#125; else &#123;     alert(&#x27;用戶名或者密碼錯誤&#x27;)   &#125; &lt;/script&gt;\n\nif 多分支語句使用場景： 適合於有多個條件的時候\n1234567891011121314&lt;script&gt;   // 1. 用戶輸入   let score = +prompt(&#x27;請輸入成績：&#x27;)   // 2. 判斷輸出   if (score &gt;= 90) &#123;     alert(&#x27;成績優秀，boy，你是我的驕傲&#x27;)   &#125; else if (score &gt;= 70) &#123;     alert(&#x27;成績良好，boy，你要加油哦~~&#x27;)   &#125; else if (score &gt;= 60) &#123;     alert(&#x27;成績及格，boy，你很危險~&#x27;)   &#125; else &#123;     alert(&#x27;成績不及格，boy，我不想和你說話~&#x27;)   &#125; &lt;/script&gt;\n\n三元運算子（三元運算式）使用場景： 一些簡單的雙分支，可以使用  三元運算子（三元運算式），寫起來比 if  else雙分支 更簡單\n符號：? 與 : 配合使用\n語法：\n1條件 ? 運算式1 ： 運算式2\n\n例如：\n12345678910111213141516171819202122// 三元運算子（三元運算式）// 1. 語法格式// 條件 ? 運算式1 : 運算式2 // 2. 執行過程 // 2.1 如果條件為真，則執行運算式1// 2.2 如果條件為假，則執行運算式2// 3. 驗證// 5 &gt; 3 ? &#x27;真的&#x27; : &#x27;假的&#x27;console.log(5 &lt; 3 ? &#x27;真的&#x27; : &#x27;假的&#x27;)// let age = 18 // age = age + 1//  age++// 1. 用戶輸入 let num = prompt(&#x27;請您輸入一個數字:&#x27;)// 2. 判斷輸出- 小於10才補0// num = num &lt; 10 ? 0 + num : numnum = num &gt;= 10 ? num : 0 + numalert(num)\n\nswitch語句（瞭解）使用場景： 適合於有多個條件的時候，也屬於分支語句，大部分情況下和 if多分支語句 功能相同\n注意：\n\nswitch case語句一般用於等值判斷, if適合於區間判斷\nswitchcase一般需要配合break關鍵字使用 沒有break會造成case穿透\nif 多分支語句開發要比switch更重要，使用也更多\n\n例如：\n123456789101112131415161718192021222324252627282930// switch分支語句// 1. 語法// switch (運算式) &#123;//   case 值1://     代碼1//     break//   case 值2://     代碼2//     break//   ...//   default://     代碼n// &#125;&lt;script&gt;  switch (2) &#123;    case 1:    console.log(&#x27;您選擇的是1&#x27;)    break  // 退出switch    case 2:    console.log(&#x27;您選擇的是2&#x27;)    break  // 退出switch    case 3:    console.log(&#x27;您選擇的是3&#x27;)    break  // 退出switch    default:    console.log(&#x27;沒有符合條件的&#x27;)  &#125;&lt;/script&gt;\n\n中斷點調試作用：學習時可以幫助更好的理解代碼運行，工作時可以更快找到bug\n流覽器打開調試介面\n\n按F12打開開發者工具\n點到原始程式碼一欄 （ sources ）\n選擇代碼檔\n\n中斷點：在某句代碼上加的標記就叫中斷點，當程式執行到這句有標記的代碼時會暫停下來\n迴圈語句使用場景：重複執行 指定的一段代碼，比如我們想要輸出10次 ‘我學的很棒’\n學習路徑：\n1.while迴圈\n2.for 迴圈（重點）\nwhile迴圈while :  在…. 期間， 所以 while迴圈 就是在滿足條件期間，重複執行某些代碼。\n語法：\n123while (條件運算式) &#123;   // 循環體    &#125;\n\n例如：\n12345678// while迴圈: 重複執行代碼// 1. 需求: 利用迴圈重複列印3次 &#x27;月薪過萬不是夢，畢業時候見英雄&#x27;let i = 1while (i &lt;= 3) &#123;  document.write(&#x27;年薪過百不是夢，畢業時候見英雄~&lt;br&gt;&#x27;)  i++   // 這裡千萬不要忘了變數自增否則造成閉環&#125;\n\n迴圈三要素：\n1.初始值 （經常用變數）\n2.終止條件\n3.變數的變化量\n例如：\n1234567891011121314151617181920&lt;script&gt;  // // 1. 變數的起始值  // let i = 1  // // 2. 終止條件  // while (i &lt;= 3) &#123;  //   document.write(&#x27;我要迴圈三次 &lt;br&gt;&#x27;)  //   // 3. 變數的變化量  //   i++  // &#125;  // 1. 變數的起始值  let end = +prompt(&#x27;請輸入次數:&#x27;)let i = 1// 2. 終止條件while (i &lt;= end) &#123;  document.write(&#x27;我要迴圈三次 &lt;br&gt;&#x27;)  // 3. 變數的變化量  i++&#125;&lt;/script&gt;\n\n中止迴圈break   中止整個迴圈，一般用於結果已經得到, 後續的迴圈不需要的時候可以使用（提高效率）  \ncontinue  中止本次迴圈，一般用於排除或者跳過某一個選項的時候\n12345678910111213141516171819202122&lt;script&gt;    // let i = 1    // while (i &lt;= 5) &#123;    //   console.log(i)    //   if (i === 3) &#123;    //     break  // 退出迴圈    //   &#125;    //   i++    // &#125;    let i = 1    while (i &lt;= 5) &#123;      if (i === 3) &#123;        i++        continue      &#125;      console.log(i)      i++    &#125;  &lt;/script&gt;\n\n無限迴圈1.while(true) 來構造“無限”迴圈，需要使用break退出迴圈。（常用）\n2.for(;;) 也可以來構造“無限”迴圈，同樣需要使用break退出迴圈。\n1234567891011121314151617181920// 無限迴圈  // 需求： 頁面會一直彈窗詢問你愛我嗎？// (1). 如果用戶輸入的是 &#x27;愛&#x27;，則退出彈窗// (2). 否則一直彈窗詢問// 1. while(true) 無限迴圈// while (true) &#123;//   let love = prompt(&#x27;你愛我嗎?&#x27;)//   if (love === &#x27;愛&#x27;) &#123;//     break//   &#125;// &#125;// 2. for(;;) 無限迴圈for (; ;) &#123;  let love = prompt(&#x27;你愛我嗎?&#x27;)  if (love === &#x27;愛&#x27;) &#123;    break  &#125;&#125;\n\n綜合案例-ATM存取款機分析：\n①：提示輸入框寫到迴圈裡面（無限迴圈）\n②：用戶輸入4則退出迴圈 break\n③：提前準備一個金額預先存儲一個數額 money\n④：根據輸入不同的值，做不同的操作\ntxt (1)  取錢則是減法操作， 存錢則是加法操作，查看餘額則是直接顯示金額\n\n (2) 可以使用 if else if 多分支 來執行不同的操作完整代碼：\n1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;  // 1. 開始迴圈 輸入框寫到 迴圈裡面  // 3. 準備一個總的金額  let money = 100while (true) &#123;  let re = +prompt(`請您選擇操作：1.存錢2.取錢3.查看餘額4.退出`)  // 2. 如果用戶輸入的 4 則退出迴圈， break  寫到if 裡面，沒有寫到switch裡面， 因為4需要break退出迴圈  if (re === 4) &#123;    break  &#125;  // 4. 根據輸入做操作  switch (re) &#123;    case 1:      // 存錢      let cun = +prompt(&#x27;請輸入存款金額&#x27;)      money = money + cun      break      case 2:      // 存錢      let qu = +prompt(&#x27;請輸入取款金額&#x27;)      money = money - qu      break      case 3:      // 存錢      alert(`您的銀行卡餘額是$&#123;money&#125;`)      break  &#125;&#125;&lt;/script&gt;\n\n\n\n\n\n\n\n\n\n","slug":"2303-1 JS 基礎2 運算子&語句","date":"2023-03-18T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"1517f5e85f0012c69f183e7960bb5313","title":"JavaScript 基礎- 第1天","content":"\n\n\n\n\n\n\n\n\n瞭解變數、資料類型、運算子等基礎概念，能夠實現資料類型的轉換，結合四則運算體會如何程式設計。\n\n體會現實世界中的事物與電腦的關係\n理解什麼是資料並知道資料的分類\n理解變數存儲資料的“容器”\n掌握常見運算子的使用，瞭解優先順序關係\n知道 JavaScript 資料類型隱式轉換的特徵\n\n介紹\n\n\n\n\n\n\n\n\n掌握 JavaScript 的引入方式，初步認識 JavaScript 的作用\n引入方式JavaScript 程式不能獨立運行，它需要被嵌入 HTML 中，然後流覽器才能執行 JavaScript 代碼。通過 script 標籤將 JavaScript 代碼引入到 HTML 中，有兩種方式：\n內部方式通過 script 標籤包裹 JavaScript 代碼\n12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 引入方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 內聯形式：通過 script 標籤包裹 JavaScript 代碼 --&gt;  &lt;script&gt;    alert(&#x27;嗨，前端技術！&#x27;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n外部形式一般將 JavaScript 代碼寫在獨立的以 .js 結尾的檔中，然後通過 script 標籤的 src 屬性引入\n12// demo.jsdocument.write(&#x27;嗨，前端技術！&#x27;)\n\n1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 引入方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 外部形式：通過 script 的 src 屬性引入獨立的 .js 文件 --&gt;  &lt;script src=&quot;demo.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n如果 script 標籤使用 src 屬性引入了某 .js 檔，那麼 標籤的代碼會被忽略！！！如下代碼所示：\n1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 引入方式&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 外部形式：通過 script 的 src 屬性引入獨立的 .js 文件 --&gt;  &lt;script src=&quot;demo.js&quot;&gt;    // 此處的代碼會被忽略掉！！！！    alert(666);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注釋和結束符通過注釋可以遮罩代碼被執行或者添加備註資訊，JavaScript 支援兩種形式注釋語法：\n單行注釋使用 // 注釋單行代碼\n12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 注釋&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;    // 這種是單行注釋的語法    // 一次只能注釋一行    // 可以重複注釋    document.write(&#x27;嗨，前端技術！&#x27;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n多行注釋使用 /* */ 注釋多行代碼\n12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 注釋&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;    /* 這種的是多行注釋的語法 */    /*      更常見的多行注釋是這種寫法      在些可以任意換行      多少行都可以      */    document.write(&#x27;嗨，來學習前端！&#x27;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注：編輯器中單行注釋的快速鍵為 ctrl + /\n結束符在 JavaScript 中 ; 代表一段代碼的結束，多數情況下可以省略 ; 使用回車（enter）替代。\n12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 結束符&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     alert(1);    alert(2);    alert(1)    alert(2)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n實際開發中有許多人主張書寫 JavaScript 代碼時省略結束符 ;\n輸入和輸出輸出和輸入也可理解為人和電腦的交互，使用者通過鍵盤、滑鼠等向電腦輸入資訊，電腦處理後再展示結果給用戶，這便是一次輸入和輸出的過程。\n舉例說明：如按鍵盤上的方向鍵，向上&#x2F;下鍵可以滾動頁面，按向上&#x2F;下鍵這個動作叫作輸入，頁面發生了滾動了這便叫輸出。\n輸出JavaScript 可以接收用戶的輸入，然後再將輸入的結果輸出：\nalert()、document.wirte()\n以數字為例，向 alert() 或 document.write()輸入任意數位，他都會以彈窗形式展示（輸出）給用戶。\n輸入向 prompt() 輸入任意內容會以彈窗形式出現在流覽器中，一般提示使用者輸入一些內容。\n123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 輸入輸出&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     // 1. 輸入的任意數位，都會以彈窗形式展示    document.write(&#x27;要輸出的內容&#x27;)    alert(&#x27;要輸出的內容&#x27;);    // 2. 以彈窗形式提示用戶輸入姓名，注意這裡的文字使用英文的引號    prompt(&#x27;請輸入您的姓名:&#x27;)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n變數\n\n\n\n\n\n\n\n\n理解變數是電腦存儲資料的“容器”，掌握變數的聲明方式\n變數是電腦中用來存儲資料的“容器”，它可以讓電腦變得有記憶，通俗的理解變數就是使用【某個符號】來代表【某個具體的數值】（資料）\n123456789101112131415&lt;script&gt;  // x 符號代表了 5 這個數值  x = 5  // y 符號代表了 6 這個數值  y = 6      //舉例： 在 JavaScript 中使用變數可以將某個資料（數值）記錄下來！  // 將使用者輸入的內容保存在 num 這個變數（容器）中  num = prompt(&#x27;請輸入一數位!&#x27;)  // 通過 num 變數（容器）將使用者輸入的內容輸出出來  alert(num)  document.write(num)&lt;/script&gt;\n\n聲明聲明(定義)變數有兩部分構成：聲明關鍵字、變數名（標識）\n1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 聲明和賦值&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     // let 變數名    // 聲明(定義)變數有兩部分構成：聲明關鍵字、變數名（標識）    // let 即關鍵字，所謂關鍵字是系統提供的專門用來聲明（定義）變數的詞語    // age 即變數的名稱，也叫識別字    let age  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n關鍵字是 JavaScript 中內置的一些英文詞彙（單詞或縮寫），它們代表某些特定的含義，如 let 的含義是聲明變數的，看到 let  後就可想到這行代碼的意思是在聲明變數，如 let age; \nlet 和 var 都是 JavaScript 中的聲明變數的關鍵字，推薦使用 let 聲明變數！！！\n賦值聲明（定義）變數相當於創造了一個空的“容器”，通過賦值向這個容器中添加資料。\n123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 聲明和賦值&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     // 聲明(定義)變數有兩部分構成：聲明關鍵字、變數名（標識）    // let 即關鍵字，所謂關鍵字是系統提供的專門用來聲明（定義）變數的詞語    // age 即變數的名稱，也叫識別字    let age    // 賦值，將 18 這個資料存入了 age 這個“容器”中    age = 18    // 這樣 age 的值就成了 18    document.write(age)        // 也可以聲明和賦值同時進行    let str = &#x27;hello world!&#x27;    alert(str);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n關鍵字JavaScript 使用專門的關鍵字 let 和 var 來聲明（定義）變數，在使用時需要注意一些細節：\n以下是使用 let 時的注意事項：\n\n允許聲明和賦值同時進行\n不允許重複聲明\n允許同時聲明多個變數並賦值\nJavaScript 中內置的一些關鍵字不能被當做變數名\n\n以下是使用 var 時的注意事項：\n\n允許聲明和賦值同時進行\n允許重複聲明\n允許同時聲明多個變數並賦值\n\n大部分情況使用 let 和 var 區別不大，但是 let 相較 var 更嚴謹，因此推薦使用 let，後期會更進一步介紹二者間的區別。\n變數名命名規則關於變數的名稱（識別字）有一系列的規則需要遵守：\n\n只能是字母、數位、底線、$，且不能能數字開頭\n字母區分大小寫，如 Age 和 age 是不同的變數\nJavaScript 內部已佔用於單詞（關鍵字或保留字）不允許使用\n儘量保證變數具有一定的語義，見字知義\n\n注：所謂關鍵字是指 JavaScript 內部使用的詞語，如 let 和var，保留字是指 JavaScript 內部目前沒有使用的詞語，但是將來可能會使用詞語。\n123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 變數名命名規則&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     let age = 18 // 正確    let age1 = 18 // 正確    let _age = 18 // 正確    // let 1age = 18; // 錯誤，不可以數位開頭    let $age = 18 // 正確    let Age = 24 // 正確，它與小寫的 age 是不同的變數    // let let = 18; // 錯誤，let 是關鍵字    let int = 123 // 不推薦，int 是保留字  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n常量概念：使用 const 聲明的變數稱為“常量”。\n使用場景：當某個變數永遠不會改變的時候，就可以使用 const 來聲明，而不是let。\n命名規範：和變數一致\n1const PI = 3.14\n\n\n\n\n\n\n\n\n\n\n注意： 常量不允許重新賦值,聲明的時候必須賦值（初始化）\n","slug":"2303-1 JS 基礎1 宣告","date":"2023-03-17T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"1517f5e85f0012c69f183e7960bb5313","title":"JavaScript 基礎- 第1天","content":"資料型別\n\n\n\n\n\n\n\n\n電腦世界中的萬事成物都是資料。\n電腦程式可以處理大量的資料，為了方便資料的管理，將資料分成了不同的型別：\n注：通過 typeof 關鍵字檢測資料型別\n1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 資料型別&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     // 檢測 1 是什麼型別資料，結果為 number    document.write(typeof 1)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n數值型別即我們數學中學習到的數位，可以是整數、小數、正數、負數\n12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 資料型別&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     let score = 100 // 正整數    let price = 12.345 // 小數    let temperature = -40 // 負數    document.write(typeof score) // 結果為 number    document.write(typeof price) // 結果為 number    document.write(typeof temperature) // 結果為 number  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nJavaScript 中的數數值型別與數學中的數字是一樣的，分為正數、負數、小數等。\n字串型別通過單引號（ &#39;&#39;） 、雙引號（ &quot;&quot;）或反引號包裹的資料都叫字串，單引號和雙引號沒有本質上的區別，推薦使用單引號。\n注意事項：\n\n無論單引號或是雙引號必須成對使用\n單引號&#x2F;雙引號可以互相嵌套，但是不以自已嵌套自已\n必要時可以使用轉義符 \\，輸出單引號或雙引號\n\n*範本字串-使用場景-拼接字串和變數、在沒有它之前，要拼接變數比較麻煩-語法    Ø &#96;&#96; (反引號)    Ø 在英文輸入模式下按鍵盤的tab鍵上方那個鍵（1左邊那個鍵）    Ø 內容拼接變數時，用 ${ } 包住變數\n1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 資料型別&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     let user_name = &#x27;小徐&#x27; // 使用單引號    let gender = &quot;男&quot; // 使用雙引號    let str = &#x27;123&#x27; // 看上去是數字，但是用引號包裹了就成了字串了    let str1 = &#x27;&#x27; // 這種情況叫空字串        documeent.write(typeof user_name) // 結果為 string    documeent.write(typeof gender) // 結果為 string    documeent.write(typeof str) // 結果為 string  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n布林型別表示肯定或否定時在電腦中對應的是布林型別資料，它有兩個固定的值 true 和 false，表示肯定的資料用 true，表示否定的資料用 false。\n1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 資料型別&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     //  我帥不帥？回答 是 或 否    let isCool = true // 是的，帥死了！    isCool = false // 不，是個醜人！    document.write(typeof isCool) // 結果為 boolean  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\nundefined未定義是比較特殊的型別，只有一個值 undefined，只聲明變數，不賦值的情況下，變數的預設值為 undefined，一般很少【直接】為某個變數賦值為 undefined。\n123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 資料型別&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;script&gt;     // 只聲明了變數，並末賦值    let tmp;    document.write(typeof tmp) // 結果為 undefined  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注：JavaScript 中變數的值決定了變數的資料型別。\n型別轉換\n\n\n\n\n\n\n\n\n理解弱型別語言的特徵，掌握顯式型別轉換的方法\n在 JavaScript 中資料被分成了不同的型別，如數值、字串、布林值、undefined，在實際程式設計的過程中，不同資料型別之間存在著轉換的關係。\n隱式轉換某些運算子被執行時，系統內部自動將資料型別進行轉換，這種轉換稱為隱式轉換。\n12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 隱式轉換&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;     let num = 13 // 數值    let num2 = &#x27;2&#x27; // 字串    // 結果為 132    // 原因是將數值 num 轉換成了字串，相當於 &#x27;13&#x27;    // 然後 + 將兩個字串拼接到了一起    console.log(num + num2)    // 結果為 11    // 原因是將字串 num2 轉換成了數值，相當於 2    // 然後數值 13 減去 數值 2    console.log(num - num2)    let a = prompt(&#x27;請輸入一個數字&#x27;)    let b = prompt(&#x27;請再輸入一個數字&#x27;)    alert(a + b);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n注：資料型別的隱式轉換是 JavaScript 的特徵，後續學習中還會遇到，目前先需要理解什麼是隱式轉換。\n補充介紹範本字串的拼接的使用\n顯式轉換編寫程式時過度依靠系統內部的隱式轉換是不嚴禁的，因為隱式轉換規律並不清晰，大多是靠經驗總結的規律。為了避免因隱式轉換帶來的問題，通常根邏輯需要對資料進行顯示轉換。\nNumber通過 Number 顯示轉換成數值型別，當轉換失敗時結果為 NaN（Not a Number）即不是一個數字。\n1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;title&gt;JavaScript 基礎 - 隱式轉換&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    let t = &#x27;12&#x27;    let f = 8    // 顯式將字串 12 轉換成數值 12    t = Number(t)    // 檢測轉換後的型別    // console.log(typeof t);    console.log(t + f) // 結果為 20    // 並不是所有的值都可以被轉成數值型別    let str = &#x27;hello&#x27;    // 將 hello 轉成數值是不現實的，當無法轉換成    // 數值時，得到的結果為 NaN （Not a Number）    console.log(Number(str))  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n","slug":"2303-1 JS 基礎1-1 型別","date":"2023-03-17T16:00:00.000Z","categories_index":"javaScript","tags_index":"javaScript","author_index":"Hsu's Blog"},{"id":"e6004c997fa8a9529d5026785922b3ae","title":"CSS 08-高級技巧","content":"CSS高級技巧目標\n\n理解\n元素顯示隱藏最常見的寫法\n精靈圖產生的目的\n去除圖片底側空白縫隙的方法\n\n\n應用\n寫出最常見的滑鼠樣式\n使用精靈圖技術\n用滑動門做巡覽列案例\n\n\n\n1. 元素的顯示與隱藏\n\n\n\n\n\n\n\n\n目的：讓一個元素在頁面中消失或者顯示出來\n場景：類似網站廣告，當我們點擊關閉就不見了，但是我們重新刷新頁面，會重新出現！\n1.1 display 顯示（重點）\ndisplay 設置或檢索物件是否及如何顯示。\n12345//隱藏物件display: none //除了轉換為塊級元素之外，同時還有顯示元素的意思。display：block \n\n特點： 隱藏之後，不再保留位置。\n\n\n實際開發場景：\n\n\n\n\n\n\n\n\n\n配合後面js做特效，比如下拉式功能表，原先沒有，滑鼠經過，顯示下拉式功能表， 應用極為廣泛\n1.2 visibility 可見性 (瞭解)\n設置或檢索是否顯示物件。\n123visibility：visible ; 　//對象可視visibility：hidden; 　  //物件隱藏\n\n特點： 隱藏之後，繼續保留原有位置。（停職留薪）\n\n\n1.3 overflow 溢出(重點)\n檢索或設置當物件的內容超過其指定高度及寬度時如何管理內容。\n\n\n\n\n屬性值\n描述\n\n\n\nvisible\n不剪切內容也不添加捲軸\n\n\nhidden\n不顯示超過物件尺寸的內容，超出的部分隱藏掉\n\n\nscroll\n不管超出內容否，總是顯示捲軸\n\n\nauto\n超出自動顯示捲軸，不超出不顯示捲軸\n\n\n實際開發場景：\n\n\n\n\n\n\n\n\n\n\n清除浮動\n隱藏超出內容，隱藏掉,  不允許內容超過父盒子。\n\n1.4 顯示與隱藏總結\n\n\n屬性\n區別\n用途\n\n\n\ndisplay\n隱藏物件，不保留位置\n配合後面js做特效，比如下拉式功能表，原先沒有，滑鼠經過，顯示下拉式功能表， 應用極為廣泛\n\n\nvisibility\n隱藏物件，保留位置\n使用較少\n\n\noverflow\n只是隱藏超出大小的部分\n1. 可以清除浮動 2. 保證盒子裡面的內容不會超出該盒子範圍\n\n\n2. CSS使用者介面樣式\n所謂的介面樣式， 就是更改一些使用者操作樣式，以便提高更好的用戶體驗。\n更改使用者的滑鼠樣式 (捲軸因為相容性非常差，我們不研究) \n表單輪廓等。\n防止表單欄位拖拽\n\n\n\n2.1 滑鼠樣式cursor 設置或檢索在物件上移動的滑鼠指標採用何種系統預定義的游標形狀。\n\n\n\n屬性值\n描述\n\n\n\ndefault\n小白  默認\n\n\npointer\n小手\n\n\nmove\n移動\n\n\ntext\n文本\n\n\nnot-allowed\n禁止\n\n\n滑鼠放我身上查看效果哦：\n1234567&lt;ul&gt;  &lt;li style=&quot;cursor:default&quot;&gt;我是小白&lt;/li&gt;  &lt;li style=&quot;cursor:pointer&quot;&gt;我是小手&lt;/li&gt;  &lt;li style=&quot;cursor:move&quot;&gt;我是移動&lt;/li&gt;  &lt;li style=&quot;cursor:text&quot;&gt;我是文本&lt;/li&gt;  &lt;li style=&quot;cursor:not-allowed&quot;&gt;我是文本&lt;/li&gt;&lt;/ul&gt;\n\n2.2 輪廓線 outline 是繪製于元素周圍的一條線，位於邊框邊緣的週邊，可起到突出元素的作用。 \n1outline : outline-color ||outline-style || outline-width \n\n 但是我們都不關心可以設置多少，我們平時都是去掉的。  \n最直接的寫法是 ：  outline: 0;   或者  outline: none;\n1&lt;input  type=&quot;text&quot;  style=&quot;outline: 0;&quot;/&gt;\n\n2.3 防止拖拽文本域resize實際開發中，我們文本域右下角是不可以拖拽： \n1&lt;textarea  style=&quot;resize: none;&quot;&gt;&lt;/textarea&gt;\n\n2.4 使用者介面樣式總結\n\n\n屬性\n用途\n用途\n\n\n\n滑鼠樣式\n更改滑鼠樣式cursor\n樣式很多，重點記住 pointer\n\n\n輪廓線\n表單默認outline\noutline 輪廓線，我們一般直接去掉，border是邊框，我們會經常用\n\n\n防止拖拽\n主要針對文本域resize\n防止使用者隨意拖拽文本域，造成頁面配置混亂，我們resize:none\n\n\n3. vertical-align 垂直對齊\n有寬度的塊級元素居中對齊，是margin: 0 auto;\n讓文字居中對齊，是 text-align: center;\n\n但是我們從來沒有講過有垂直居中的屬性。\nvertical-align 垂直對齊，它只針對於行內元素或者行內塊元素，\n1vertical-align : baseline |top |middle |bottom \n\n設置或檢索物件內容的垂直對其方式。\n\n注意：\nvertical-align 不影響塊級元素中的內容對齊，它只針對於行內元素或者行內塊元素，\n特別是行內塊元素， 通常用來控制圖片&#x2F;表單與文字的對齊。\n\n\n3.1 圖片、表單和文字對齊我們可以通過vertical-align 控制圖片和文字的垂直關係。預設的圖片會和文字基線對齊。\n3.2 去除圖片底側空白縫隙\n原因：\n圖片或者表單等行內塊元素，他的底線會和父級盒子的基線對齊。\n就是圖片底側會有一個空白縫隙。\n\n解決的方法就是：  \n\n給img vertical-align:middle | top| bottom等等。  讓圖片不要和基線對齊。\n給img 添加 display：block; 轉換為塊級元素就不會存在問題了。\n\n\n\n4. 溢出的文字省略號顯示4.1 white-space\nwhite-space設置或檢索物件內文本顯示方式。通常我們使用于強制一行顯示內容\n\n123white-space:normal ；預設處理方式white-space:nowrap ；強制在同一行內顯示所有文本，直到文本結束或者遭遇br標籤物件才換行。\n\n4.2 text-overflow 文字溢出\n設置或檢索是否使用一個省略標記（…）標示物件內文本的溢出\n\n123text-overflow : clip ；不顯示省略標記（...），而是簡單的裁切 text-overflow：ellipsis ； 當物件內文本溢出時顯示省略標記（...）\n\n\n\n\n\n\n\n\n\n\n注意：一定要首先強制一行內顯示，再次和overflow屬性  搭配使用\n4.3 總結三步曲123456/*1. 先強制一行內顯示文本*/    white-space: nowrap;/*2. 超出的部分隱藏*/    overflow: hidden;/*3. 文字用省略號替代超出的部分*/    text-overflow: ellipsis;\n\n5. CSS精靈技術（sprite) 重點5.1 為什麼需要精靈技術當用戶訪問一個網站時，需要向伺服器發送請求，網頁上的每張圖像都要經過一次請求才能展現給用戶。\n然而，一個網頁中往往會應用很多小的背景圖像作為修飾，當網頁中的圖像過多時，伺服器就會頻繁地接受和發送請求，這將大大降低頁面的載入速度。\n為什麼需要精靈技術：\n\n\n\n\n\n\n\n\n\n 為了有效地減少伺服器接受和發送請求的次數，提高頁面的載入速度。\n出現了CSS精靈技術（也稱CSS Sprites、CSS雪碧）。\n5.2 精靈技術講解CSS 精靈其實是將網頁中的一些背景圖像整合到一張大圖中（精靈圖），然而，各個網頁元素通常只需要精靈圖中不同位置的某個小圖，要想精確定位到精靈圖中的某個小圖。\n這樣，當使用者訪問該頁面時，只需向服務發送一次請求，網頁中的背景圖像即可全部展示出來。\n我們需要使用CSS的\n\nbackground-image\nbackground-repeat\nbackground-position屬性進行背景定位\n其中最關鍵的是使用background-position 屬性精確地定位。\n\n5.3 精靈技術使用的核心總結首先我們知道，css精靈技術主要針對於背景圖片，插入的圖片img 是不需要這個技術的。\n\n精確測量，每個小背景圖片的大小和 位置。\n給盒子指定小背景圖片時， 背景定位基本都是 負值。\n\n5.4 製作精靈圖(瞭解)CSS 精靈其實是將網頁中的一些背景圖像整合到一張大圖中（精靈圖），那我們要做的，就是把小圖拼合成一張大圖。\n大部分情況下，精靈圖都是網頁美工做。\n123精靈圖上放的都是小的裝飾性質的背景圖片。 **插入圖片不能往上放**。可以橫向擺放也可以縱向擺放，但是每個圖片之間留有適當的空隙在我們精靈圖的最低端，留一片空隙，方便我們以後添加其他精靈圖。\n\n結論：小公司，背景圖片很少的情況，沒有必要使用精靈技術，維護成本太高。 如果是背景圖片比較多，可以建議使用精靈技術。\n6. 滑動門滑動門出現的背景製作網頁時，為了美觀，常常需要為網頁元素設置特殊形狀的背景，比如巡覽列，使字數不一樣多的按鈕，有凸起和凹下去的感覺，，咋辦？\n為了使各種特殊形狀的背景能夠自我調整元素中文本內容的多少，出現了CSS滑動門技術。它從新的角度構建頁面，使各種特殊形狀的背景能夠自由拉伸滑動，以適應元素內部的文本內容，可用性更強。 最常見於各種巡覽列的滑動門。\n核心技術核心技術就是利用CSS精靈（主要是背景位置）和 盒子padding撐開寬度, 以便能適應不同字數的巡覽列。\n一般的經典佈局都是這樣的：\n12345&lt;li&gt;  &lt;a href=&quot;#&quot;&gt;    &lt;span&gt;巡覽列內容&lt;/span&gt;  &lt;/a&gt;&lt;/li&gt;\n\ncss樣式\n12345678910111213141516171819202122232425262728293031* &#123;      padding:0;      margin:0;    &#125;    body&#123;      background: url(images/wx.jpg) repeat-x;    &#125;    .father &#123;      padding-top:20px;    &#125;    li &#123;      padding-left: 16px;      height: 33px;      float: left;      line-height: 33px;      margin:0  10px;      background: url(./images/to.png) no-repeat left ;    &#125;    a &#123;      padding-right: 16px;      height: 33px;      display: inline-block;      color:#fff;      background: url(./images/to.png) no-repeat right ;      text-decoration: none;    &#125;    li:hover,    li:hover a &#123;      background-image:url(./images/ao.png);    &#125;\n\n\n總結： \n\na 設置 背景左側，padding撐開合適寬度。    \nspan 設置背景右側， padding撐開合適寬度 剩下由文字繼續撐開寬度。\n之所以a包含span就是因為 整個導航都是可以點擊的。\n\n7. 拓展@7.1 margin負值之美負邊距+定位：水準垂直居中\n一個絕對定位的盒子， 利用  父級盒子的 50%，  然後 往左(上) 走 自己寬度的一半 ，可以實現盒子水準垂直居中。\n7.2 CSS三角形之美1234567891011121314151617div &#123; width: 0;    height: 0;   line-height:0；   font-size: 0; border-top: 10px solid red; border-right: 10px solid green; border-bottom: 10px solid blue; border-left: 10px solid #000; &#125;\n\n\n用css 邊框可以模擬三角效果\n寬度高度為0\n4個邊框都要寫， 只保留需要的邊框顏色，其餘的不能省略，都改為 transparent 透明就好了\n為了照顧相容性 低版本的流覽器，加上 font-size: 0;  line-height: 0;\n\n","slug":"2301-2 CSS 08 高級技巧","date":"2023-03-17T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"a80bc05c620a4e285b16be71646cc7c5","title":"CSS 07-定位(position)","content":"定位(position)目標\n理解\n為什麼要用定位\n定位的4種分類\n4種定位的各自特點\n為什麼常用子絕父相佈局\n\n\n\n1. CSS 佈局的三種機制\n\n\n\n\n\n\n\n\n網頁佈局的核心 —— 就是用 CSS 來擺放盒子位置。\nCSS 提供了 3 種機制來設置盒子的擺放位置，分別是普通流、浮動和定位，其中：\n\n普通流（標準流）\n\n浮動\n\n讓盒子從普通流中浮起來 —— 讓多個盒子(div)水準排列成一行。\n\n\n定位\n\n將盒子定在某一個位置  自由的漂浮在其他盒子的上面  —— CSS 離不開定位，特別是後面的 js 特效。\n\n\n\n2. 為什麼使用定位\n\n\n\n\n\n\n\n\n將盒子定在某一個位置，自由的漂浮在其他盒子(包括標準流和浮動)的上面 \n所以，我們腦海應該有三種佈局機制的上下順序\n定位的盒子在最上層  （天空） 浮動的盒子在中間層  (海面)   標準流在最底層 (海底) \n3. 定位詳解定位也是用來佈局的，它有兩部分組成：\n\n\n\n\n\n\n\n\n\n定位 = 定位模式 + 邊偏移\n3.1 邊偏移簡單說， 我們定位的盒子，是通過邊偏移來移動位置的。\n在 CSS 中，通過 top、bottom、left 和 right 屬性定義元素的邊偏移：（方位名詞）\n\n\n\n邊偏移屬性\n示例\n描述\n\n\n\ntop\ntop: 10px\n頂端偏移量，定義元素相對于其父元素上邊線的距離。\n\n\nbottom\nbottom: 10px\n底部偏移量，定義元素相對于其父元素下邊線的距離。\n\n\nleft\nleft: 10px\n左側偏移量，定義元素相對于其父元素左邊線的距離。\n\n\nright\nright: 10px\n右側偏移量，定義元素相對于其父元素右邊線的距離\n\n\n定位的盒子有了邊偏移才有價值。 一般情況下，凡是有定位地方必定有邊偏移。\n3.2  定位模式 (position)在 CSS 中，通過 position 屬性定義元素的定位模式，語法如下：\n1選擇器 &#123; position: 屬性值; &#125;\n定位模式是有不同分類的，在不同情況下，我們用到不同的定位模式。\n\n\n\n值\n語義\n\n\n\nstatic\n靜態定位\n\n\nrelative\n相對定位\n\n\nabsolute\n絕對定位\n\n\nfixed\n固定定位\n\n\n3.2.1 靜態定位(static) - 瞭解\n靜態定位是元素的預設定位方式，無定位的意思。它相當於 border 裡面的none， 不要定位的時候用。\n靜態定位 按照標準流特性擺放位置，它沒有邊偏移。\n靜態定位在佈局時我們幾乎不用的\n\n3.2.1 相對定位(relative) - 重要\n相對定位是元素相對于它  原來在標準流中的位置 來說的。（自戀型）\n\n相對定位的特點：（務必記住）\n\n相對于 自己原來在標準流中位置來移動的\n原來在標準流的區域繼續佔有，後面的盒子仍然以標準流的方式對待它。\n\n3.2.3 絕對定位(absolute) - 重要絕對定位是元素以帶有定位的父級元素來移動位置 （拼爹型）\n\n完全脫標 —— 完全不占位置；  \n\n父元素沒有定位，則以流覽器為准定位（Document 文檔）。\n\n父元素要有定位\n\n將元素依據最近的已經定位（絕對、固定或相對定位）的父元素（祖先）進行定位。\n\n\n\n絕對定位的特點：（務必記住）\n\n絕對是以帶有定位的父級元素來移動位置 （拼爹型） 如果父級都沒有定位，則以流覽器文檔為准移動位置\n不保留原來的位置，完全是脫標的。\n\n因為絕對定位的盒子是拼爹的，所以要和父級搭配一起來使用。\n定位口訣 —— 子絕父相剛才咱們說過，絕對定位，要和帶有定位的父級搭配使用，那麼父級要用什麼定位呢？\n子絕父相 —— 子級是絕對定位，父級要用相對定位。\n\n\n\n\n\n\n\n\n\n子絕父相是使用絕對定位的口訣，要牢牢記住！\n疑問：為什麼在佈局時，子級元素使用絕對定位時，父級元素就要用相對定位呢？\n分析：\n\n方向箭頭疊加在其他圖片上方，應該使用絕對定位，因為絕對定位完全脫標，完全不占位置。\n父級盒子應該使用相對定位，因為相對定位不脫標，後續盒子仍然以標準流的方式對待它。\n如果父級盒子也使用絕對定位，會完全脫標，那麼下方的廣告盒子會上移，這顯然不是我們想要的。\n\n\n\n結論：父級要佔有位置，子級要任意擺放，這就是子絕父相的由來。\n3.2.4 固定定位(fixed) - 重要固定定位是絕對定位的一種特殊形式： （認死理型）   如果說絕對定位是一個矩形 那麼 固定定位就類似於正方形\n\n完全脫標 —— 完全不占位置；\n只認流覽器的可視窗口 —— 流覽器可視視窗 + 邊偏移屬性 來設置元素的位置；\n跟父元素沒有任何關係；單獨使用的\n不隨捲軸滾動。\n\n\n\n提示：IE 6 等低版本流覽器不支援固定定位。\n4. 定位(position)的擴展4.1 絕對定位的盒子居中\n\n\n\n\n\n\n\n\n注意：絕對定位&#x2F;固定定位的盒子不能通過設置 margin: auto 設置水準居中。\n在使用絕對定位時要想實現水準居中，可以按照以下的方法：\n\nleft: 50%;：讓盒子的左側移動到父級元素的水準中心位置；\nmargin-left: -100px;：讓盒子向左移動自身寬度的一半。\n\n4.2 堆疊順序（z-index）在使用定位佈局時，可能會出現盒子重疊的情況。\n加了定位的盒子，默認後來者居上， 後面的盒子會壓住前面的盒子。\n應用 z-index 層疊等級屬性可以調整盒子的堆疊順序。\nz-index 的特性如下：\n\n屬性值：正整數、負整數或 0，預設值是 0，數值越大，盒子越靠上；\n如果屬性值相同，則按照書寫順序，後來居上；\n數位後面不能加單位。\n\n注意：z-index 只能應用於相對定位、絕對定位和固定定位的元素，其他標準流、浮動和靜態定位無效。\n4.3 定位改變display屬性 前面我們講過， display 是 顯示模式， 可以改變顯示模式有以下方式:\n\n可以用inline-block  轉換為行內塊\n可以用浮動 float 默認轉換為行內塊（類似，並不完全一樣，因為浮動是脫標的）\n絕對定位和固定定位也和浮動類似， 默認轉換的特性 轉換為行內塊。\n\n所以說， 一個行內的盒子，如果加了浮動、固定定位和絕對定位，不用轉換，就可以給這個盒子直接設置寬度和高度等。\n同時注意：\n浮動元素、絕對定位(固定定位）元素的都不會觸發外邊距合併的問題。 （我們以前是用padding border overflow解決的）\n也就是說，我們給盒子改為了浮動或者定位，就不會有垂直外邊距合併的問題了。\n5. 定位小結\n\n\n定位模式\n是否脫標佔有位置\n移動位置基準\n模式轉換（行內塊）\n使用情況\n\n\n\n靜態static\n不脫標，正常模式\n正常模式\n不能\n幾乎不用\n\n\n相對定位relative\n不脫標，佔有位置\n相對自身位置移動\n不能\n基本單獨使用\n\n\n絕對定位absolute\n完全脫標，不佔有位置\n相對于定位父級移動位置\n能\n要和定位父級元素搭配使用\n\n\n固定定位fixed\n完全脫標，不佔有位置\n相對於流覽器移動位置\n能\n單獨使用，不需要父級\n\n\n注意：\n\n邊偏移需要和定位模式聯合使用，單獨使用無效；\ntop 和 bottom 不要同時使用；\nleft 和 right 不要同時使用。\n\n6. 網頁佈局總結一個完整的網頁，有標準流 、 浮動 、 定位 一起完成佈局的。每個都有自己的專門用法。\n1). 標準流可以讓盒子上下排列 或者 左右排列的\n2). 浮動可以讓多個塊級元素一行顯示  或者 左右對齊盒子   浮動的盒子就是按照順序左右排列 \n3). 定位定位最大的特點是有層疊的概念，就是可以讓多個盒子 前後 疊壓來顯示。 但是每個盒子需要測量數值。\n","slug":"2301-2 CSS 07 定位(position)","date":"2023-03-16T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"9ff528d9337f78a8c4f9529b9dd287e6","title":"CSS 06-浮動(float)","content":"1. 浮動(float)目標\n記憶\nCSS 的佈局的三種機制\n\n\n理解\n普通流在佈局中的特點\n為什麼用浮動\n為什麼要清除浮動\n\n\n應用\n利用浮動完成巡覽列案例\n清除浮動\n\n\n\n1.1 CSS 佈局的三種機制\n\n\n\n\n\n\n\n\n網頁佈局的核心——就是用 CSS 來擺放盒子。\nCSS 提供了 3 種機制來設置盒子的擺放位置，分別是普通流（標準流）、浮動和定位，其中： \n\n普通流（標準流）\n塊級元素會獨佔一行，從上向下順序排列；\n常用元素：div、hr、p、h1~h6、ul、ol、dl、form、table\n\n\n行內元素會按照順序，從左到右順序排列，碰到父元素邊緣則自動換行；\n常用元素：span、a、i、em等\n\n\n\n\n浮動\n讓盒子從普通流中浮起來,主要作用讓多個塊級盒子一行顯示。\n\n\n定位\n將盒子定在流覽器的某一個位置——CSS 離不開定位，特別是後面的 js 特效。\n\n\n\n1.2 為什麼需要浮動？思考題：\n 首先要思考以下2個佈局中最常見的問題？\n\n如何讓多個盒子(div)水準排列成一行？\n\n如何實現盒子的左右對齊？\n\n\n雖然學過行內塊（inline-block） 但是他卻有自己的缺陷：\n\n它可以實現多個元素一行顯示，但是中間會有空白縫隙，不能滿足以上第一個問題。\n它不能實現以上第二個問題，盒子左右對齊\n\n總結\n\n\n\n\n\n\n\n\n\n因為一些網頁佈局要求，標準流不能滿足我們的需要了，因此我們需要浮動來完成網頁佈局。\n1.3  什麼是浮動(float)概念：元素的浮動是指設置了浮動屬性的元素會\n\n脫離標準普通流的控制\n移動到指定位置。\n\n作用\n讓多個盒子(div)水準排列成一行，使得浮動成為佈局的重要手段。\n可以實現盒子的左右對齊等等..\n浮動最早是用來控制圖片，實現文字環繞圖片的效果。\n\n語法在 CSS 中，通過 float  屬性定義浮動，語法如下：\n1選擇器 &#123; float: 屬性值; &#125;\n\n\n\n\n屬性值\n描述\n\n\n\nnone\n元素不浮動（預設值）\n\n\nleft\n元素向左浮動\n\n\nright\n元素向右浮動\n\n\n記法 float   —  浮 漏 特\n1). 浮動口訣之 浮浮動——浮浮浮~~~漂浮在普通流的上面。  脫離標準流。 俗稱 “脫標”   \n1234567891011.box1 &#123;    width: 200px;    height: 200px;    background-color: rgba(255, 0, 0, 0.5);    float: left;&#125;.box2 &#123;    width: 150px;    height: 300px;    background-color: skyblue;&#125;\n\n小結：\n\nfloat 屬性會讓盒子漂浮在標準流的上面，所以第二個標準流的盒子跑到浮動盒子的底下了。\n\n2).  浮動口訣之 漏浮動——漏漏漏~  浮動的盒子，把自己原來的位置漏給下面標準流的盒子，就是不佔有原來位置，是脫離標準流的，我們俗稱 “脫標”。\n123456789101112.box1 &#123;    width: 200px;    height: 200px;    background-color: rgba(255, 0, 0, 0.5);    /* 讓第 1 個盒子漂浮起來，不占位置 */    float: left;&#125;.box2 &#123;    width: 150px;    height: 300px;    background-color: skyblue;&#125;\n\n 所以，box2下面的其實就是跑到box1盒子下面了， 被box1給壓住了，遮擋起來了\n3). 浮動口訣之 特浮動——特性  float屬性會改變元素display屬性。\n任何元素都可以浮動。浮動元素會生成一個塊級框，而不論它本身是何種元素。 生成的塊級框和我們前面的行內塊極其相似。\n案例——div 水準排列\n1234567891011121314div &#123;    width: 200px;    height: 200px;    background-color: pink;    /* 轉換為行內塊元素，可以水準顯示，不過 div 之間有間隙，不方便處理 */    /* display: inline-block; */    /* 設置浮動屬性，可以讓 div 水準排列，並且沒有間隙 */    float: left;&#125;.two &#123;    background-color: hotpink;&#125;\n\n注意： 浮動的元素互相貼靠一起的，但是如果父級寬度裝不下這些浮動的盒子， 多出的盒子會另起一行對齊\n1.4 浮動(float)小結\n\n\n\n\n\n\n\n\n我們使用浮動的核心目的——讓多個塊級盒子在同一行顯示。 因為這是我們最常見的一種佈局方式\nfloat —— 浮漏特\n\n\n\n特點\n說明\n\n\n\n浮\n加了浮動的盒子是浮起來的，漂浮在其他標準流盒子的上面。\n\n\n漏\n加了浮動的盒子是不占位置的，它原來的位置漏給了標準流的盒子。\n\n\n特\n特別注意：浮動元素會改變display屬性， 類似轉換為了行內塊，但是元素之間沒有空白縫隙\n\n\n1.5 浮動(float)的應用（重要）浮動和標準流的父盒子搭配我們知道，浮動是脫標的，會影響下面的標準流元素，此時，我們需要給浮動的元素添加一個標準流的父親，這樣，最大化的減小了對其他標準流的影響。\n\n\n\n\n\n\n\n\n\n一個完整的網頁，是 標準流 +  浮動 +  我們後面要講的定位 一起完成的。\n注意，實際重要的巡覽列中，我們不會直接用連結a 而是用 li  包含連結(li+a)的做法。\n\nli+a 語義更清晰，一看這就是有條理的清單型內容。\n如果直接用a，搜尋引擎容易辨別為有堆砌關鍵字嫌疑（故意堆砌關鍵字容易被搜尋引擎有降權的風險），從而影響網站排名\n\n1.6  浮動(float)的擴展1). 浮動元素與父盒子的關係\n子盒子的浮動參照父盒子對齊\n不會與父盒子的邊框重疊，也不會超過父盒子的內邊距\n\n2). 浮動元素與兄弟盒子的關係在一個父級盒子中，如果前一個兄弟盒子是：\n\n浮動的，那麼當前盒子會與前一個盒子的頂部對齊；\n普通流的，那麼當前盒子會顯示在前一個兄弟盒子的下方。\n\n\n\n\n\n\n\n\n\n\n\n浮動只會影響當前的或者是後面的標準流盒子，不會影響前面的標準流。\n建議\n如果一個盒子裡面有多個子盒子，如果其中一個盒子浮動了，其他兄弟也應該浮動。防止引起問題\n2. 清除浮動2.1 為什麼要清除浮動因為父級盒子很多情況下，不方便給高度，但是子盒子浮動就不佔有位置，最後父級盒子高度為0，就影響了下面的標準流盒子。\n\n總結：\n由於浮動元素不再佔用原文檔流的位置，所以它會對後面的元素排版產生影響\n準確地說，並不是清除浮動，而是清除浮動後造成的影響\n\n\n\n2.2 清除浮動本質 清除浮動主要為了解決父級元素因為子級浮動引起內部高度為0 的問題。 清除浮動之後， 父級就會根據浮動的子盒子自動檢測高度。 父級有了高度，就不會影響下面的標準流了\n2.3 清除浮動的方法在CSS中，clear屬性用於清除浮動，在這裡，我們先記住清除浮動的方法，具體的原理，等我們學完css會再回頭分析。\n\n語法：\n\n1選擇器&#123;clear:屬性值;&#125;   clear 清除  \n\n\n\n\n屬性值\n描述\n\n\n\nleft\n不允許左側有浮動元素（清除左側浮動的影響）\n\n\nright\n不允許右側有浮動元素（清除右側浮動的影響）\n\n\nboth\n同時清除左右兩側浮動的影響\n\n\n但是我們實際工作中， 幾乎只用 clear: both;\n1).額外標籤法(隔牆法)12是W3C推薦的做法是通過在浮動元素末尾添加一個空的標籤例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或則其他標籤br等亦可。\n\n\n優點： 通俗易懂，書寫方便\n缺點： 添加許多無意義的標籤，結構化較差。\n\n2).父級添加overflow屬性方法1可以給父級添加： overflow為 hidden| auto| scroll  都可以實現。\n\n優點：  代碼簡潔\n缺點：  內容增多時候容易造成不會自動換行導致內容被隱藏掉，無法顯示需要溢出的元素。\n3).使用after偽元素清除浮動:after 方式為空元素額外標籤法的升級版，好處是不用單獨加標籤了 \n使用方法：\n123456789.clearfix:after &#123;     content: &quot;&quot;;    display: block;    height: 0;    clear: both;    visibility: hidden;   &#125;   .clearfix &#123;*zoom: 1;&#125;   /* IE6、7 專有 */\n\n\n優點： 符合閉合浮動思想  結構語義化正確\n缺點： 由於IE6-7不支持:after，使用 zoom:1觸發 hasLayout。\n\n4).使用雙偽元素清除浮動使用方法：\n12345678910.clearfix:before,.clearfix:after &#123;   content:&quot;&quot;;  display:table; &#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123;  *zoom:1;&#125;\n\n\n優點：  代碼更簡潔\n\n缺點：  由於IE6-7不支持:after，使用 zoom:1觸發 hasLayout。\n\n\n2.4 清除浮動總結什麼時候用清除浮動？\n\n父級沒高度\n子盒子浮動了\n影響下面佈局了，我們就應該清除浮動了。\n\n\n\n\n清除浮動的方式\n優點\n缺點\n\n\n\n額外標籤法（隔牆法）\n通俗易懂，書寫方便\n添加許多無意義的標籤，結構化較差。\n\n\n父級overflow:hidden;\n書寫簡單\n溢出隱藏\n\n\n父級after偽元素\n結構語義化正確\n由於IE6-7不支持:after，相容性問題\n\n\n父級雙偽元素\n結構語義化正確\n由於IE6-7不支持:after，相容性問題\n\n\n","slug":"2301-2 CSS 06 浮動(float)","date":"2023-03-15T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"8c021a3b84d7a0602ad12ca159c8b3ca","title":"CSS 05-盒子模型+拓展規範","content":"盒子模型（CSS重點）\n\n\n\n\n\n\n\n\ncss學習三大重點： css 盒子模型   、  浮動  、  定位  \n目標： \n\n理解：\n盒子模型有那四部分組成\n內邊距的作用以及對盒子的影響\npadding設置不同數值個數分別代表的意思\n塊級盒子居中對齊需要的2個條件\n外邊距合併的解決方法\n\n\n應用：\n利用邊框複合寫法給元素添加邊框\n計算盒子的實際大小\n利用盒子模型佈局模組案例\n\n\n\n1.看透網頁佈局的本質網頁佈局中，如何把裡面的文字，圖片，按照美工給的效果圖排列的整齊有序呢？\n\n看透網頁佈局的本質：\n首先利用CSS設置盒子大小，然後擺放盒子的位置。\n最後把網頁元素比如文字圖片等等，放入盒子裡面。\n以上兩步 就是網頁佈局的本質\n\n\n\n盒子是網頁佈局的關鍵點，所以需要弄明白盒子有什麼特點。\n2. 盒子模型（Box Model）\n所謂盒子模型：\n\n就是把HTML頁面中的佈局元素看作是一個矩形的盒子，也就是一個盛裝內容的容器。\n\n總結：\n\n盒子模型有元素的內容、邊框（border）、內邊距（padding）、和外邊距（margin）組成。\n盒子裡面的文字和圖片等元素是內容區域\n盒子的厚度 成為 盒子的邊框 \n盒子內容與邊框的距離是內邊距（類似儲存格的 cellpadding）\n盒子與盒子之間的距離是外邊距（類似儲存格的 cellspacing）\n\n\n\n3. 盒子邊框（border）\n語法：\n\n1border : border-width || border-style || border-color \n\n\n\n\n屬性\n作用\n\n\n\nborder-width\n定義邊框粗細，單位是px\n\n\nborder-style\n邊框的樣式\n\n\nborder-color\n邊框顏色\n\n\n\n邊框的樣式：\nnone：沒有邊框即忽略所有邊框的寬度（預設值）\nsolid：邊框為單實線(最為常用的)\ndashed：邊框為虛線  \ndotted：邊框為點線\n\n\n\n3.1 邊框綜合設置1border : border-width || border-style || border-color \n\n例如：\n1border: 1px solid red;  沒有順序  \n\n\n3.2 盒子邊框寫法總結表很多情況下，我們不需要指定4個邊框，我們是可以單獨給4個邊框分別指定的。\n\n\n\n上邊框\n下邊框\n左邊框\n右邊框\n\n\n\nborder-top-style:樣式;\nborder-bottom-style:樣式;\nborder-left-style:樣式;\nborder-right-style:樣式;\n\n\nborder-top-width:寬度;\nborder- bottom-width:寬度;\nborder-left-width:寬度;\nborder-right-width:寬度;\n\n\nborder-top-color:顏色;\nborder- bottom-color:顏色;\nborder-left-color:顏色;\nborder-right-color:顏色;\n\n\nborder-top:寬度 樣式 顏色;\nborder-bottom:寬度 樣式 顏色;\nborder-left:寬度 樣式 顏色;\nborder-right:寬度 樣式 顏色;\n\n\n3.3 表格的細線邊框\n通過表格的cellspacing=&quot;0&quot;,將儲存格與儲存格之間的距離設置為0，\n\n但是兩個儲存格之間的邊框會出現重疊，從而使邊框變粗\n\n通過css屬性：\n1table&#123; border-collapse:collapse; &#125;  \n\n\ncollapse 單詞是合併的意思\nborder-collapse:collapse; 表示相鄰邊框合併在一起。\n\n\n\n1234567891011121314&lt;style&gt;  table &#123;    width: 500px;    height: 300px;    border: 1px solid red;  &#125;  td &#123;    border: 1px solid red;    text-align: center;  &#125;  table, td &#123;    border-collapse: collapse;  /*合併相鄰邊框*/  &#125;&lt;/style&gt;\n\n4. 內邊距（padding）4.1 內邊距： padding屬性用於設置內邊距。 是指 邊框與內容之間的距離\n4.2 設置\n\n\n屬性\n作用\n\n\n\npadding-left\n左內邊距\n\n\npadding-right\n右內邊距\n\n\npadding-top\n上內邊距\n\n\npadding-bottom\n下內邊距\n\n\n當給盒子指定padding值之後， 會發生2件事情：\n\n內容和邊框有了距離，添加了內邊距。\n盒子會變大了。\n\n多項值簡寫方法：\n\n\n\n值的個數\n表達意思\n\n\n\n1個值\npadding：上下左右內邊距;\n\n\n2個值\npadding: 上下內邊距    左右內邊距 ；\n\n\n3個值\npadding：上內邊距   左右內邊距   下內邊距；\n\n\n4個值\npadding: 上內邊距 右內邊距 下內邊距 左內邊距 ；\n\n\n4.3內盒尺寸計算（元素實際大小）\n寬度\nElement Height &#x3D; content height + padding + border （Height為內容高度）\n\n高度\n Element Width &#x3D; content width + padding + border （Width為內容寬度）\n\n盒子的實際的大小 &#x3D;   內容的寬度和高度 +  內邊距   +  邊框\n\n\n\n\n\n\n\n\n\n\n\n問：一個盒子寬度為100， padding為 10， 邊框為5圖元，問這個盒子實際的寬度的是（）\n\n \n(A) 130\n\n \n(B) 135 \n\n \n(C) 125\n\n \n(D) 115\n100 +  20 + 10\n\n\n\n\n\n\n\n\n\n\n\n問：關於根據下列代碼計算 盒子寬高下列說法正確的是（）\n123456789101112131415div &#123;    width: 200px;         height: 200px;    border: 1px solid #000000;    border-top: 5px solid blue;    padding: 50px;    padding-left: 100px;    &#125;\n\n\n (A) 寬度為200px 高度為200px\n (B) 寬度為352px 高度為306px\n (C) 寬度為302px 高度為307px\n (D) 寬度為302px 高度為252px\n\nw&#x3D;200 +   150   + 2   &#x3D;  352h&#x3D;   200 +  100 +  6   &#x3D;  306\n4.4 padding不影響盒子大小情況\n\n\n\n\n\n\n\n\n如果沒有給一個盒子指定寬度， 此時，如果給這個盒子指定padding， 則不會撐開盒子。\n5. 外邊距（margin）5.1 外邊距 margin屬性用於設置外邊距。  margin就是控制盒子和盒子之間的距離\n5.2 設置：\n\n\n屬性\n作用\n\n\n\nmargin-left\n左外邊距\n\n\nmargin-right\n右外邊距\n\n\nmargin-top\n上外邊距\n\n\nmargin-bottom\n下外邊距\n\n\nmargin值的簡寫 （複合寫法）代表意思  跟 padding 完全相同。\n5.3 塊級盒子水準居中\n可以讓一個塊級盒子實現水準居中必須：\n盒子必須指定了寬度（width）\n然後就給左右的外邊距都設置為auto，\n\n\n\n實際常用這種方式進行網頁佈局，示例代碼如下：\n1.header&#123; width:960px; margin:0 auto;&#125;\n\n常見的寫法，以下下三種都可以。\n\nmargin-left: auto;   margin-right: auto;\nmargin: auto;\nmargin: 0 auto;\n\n5.4 文字居中和盒子居中區別\n盒子內的文字水準居中是  text-align: center,  而且還可以讓 行內元素和行內塊居中對齊\n塊級盒子水準居中  左右margin 改為 auto\n\n12text-align: center;/*  文字 行內元素 行內塊元素水準居中 */margin: 10px auto; /* 塊級盒子水準居中 左右margin改為auto 上下margin都可以 */\n\n5.5 插入圖片和背景圖片區別\n插入圖片 我們用的最多，比如產品展示類、移動位置只能靠盒模型 padding margin\n背景圖片 我們一般用於小圖示背景，或者 超大背景圖片、背景圖片 只能通過  background-position\n\n1234567891011121314img &#123;     width: 200px;/* 插入圖片更改大小 width 和 height */   height: 210px;   margin-top: 30px;  /* 插入圖片更改位置 可以用margin 或padding  盒模型 */   margin-left: 50px; /* 插入當圖片也是一個盒子 */ &#125;div &#123;   width: 400px;   height: 400px;   border: 1px solid purple;   background: #fff url(images/sun.jpg) no-repeat;   background-position: 30px 50px; /* 背景圖片更改位置 我用 background-position */ &#125;\n\n5.6 清除元素的預設內外邊距(重要)為了更靈活方便地控制網頁中的元素，製作網頁時，我們需要將元素的預設內外邊距清除\n代碼： \n1234* &#123;   padding:0;         /* 清除內邊距 */   margin:0;          /* 清除外邊距 */&#125;\n\n注意：  \n\n行內元素為了照顧相容性， 儘量只設置左右內外邊距， 不要設置上下內外邊距。\n\n5.7 外邊距合併使用margin定義塊元素的垂直外邊距時，可能會出現外邊距的合併。\n(1). 相鄰塊元素垂直外邊距的合併\n當上下相鄰的兩個塊元素相遇時，如果上面的元素有下外邊距margin-bottom\n下面的元素有上外邊距margin-top，則他們之間的垂直間距不是margin-bottom與margin-top之和\n取兩個值中的較大者這種現象被稱為相鄰塊元素垂直外邊距的合併（也稱外邊距塌陷）。\n\n\n\n\n\n\n\n\n\n\n解決方案：儘量給只給一個盒子添加margin值。\n(2). 嵌套塊元素垂直外邊距的合併（塌陷）\n對於兩個嵌套關係的塊元素，如果父元素沒有上內邊距及邊框\n父元素的上外邊距會與子元素的上外邊距發生合併\n合併後的外邊距為兩者中的較大者\n\n\n\n\n\n\n\n\n\n\n解決方案：\n\n為父元素定義上邊框\n為父元素定義上內邊距\n為父元素添加overflow:hidden\n\n還有其他方法，比如浮動、固定、絕對定位的盒子不會有問題\n6. 盒子模型佈局穩定性\n什麼情況下用內邊距，什麼情況下用外邊距？\n\n大部分情況下是可以混用的。  就是說，你用內邊距也可以，用外邊距也可以。 覺得哪個方便，就用哪個。\n\n\n\n根據穩定性來分，建議如下：\n按照 優先使用  寬度 （width）  其次 使用內邊距（padding）    再次  外邊距（margin）。   \n1width &gt;  padding  &gt;   margin   \n\n\n原因：\nmargin 會有外邊距合併 還有 ie6下面margin 加倍的bug（討厭）所以最後使用。\npadding  會影響盒子大小， 需要進行加減計算（麻煩） 其次使用。\nwidth   沒有問題（嗨皮）我們經常使用寬度剩餘法 高度剩餘法來做。\n\n\n\n拓展@以下我們講的CSS3部分新屬性， 但是我們遵循的原則是，以下內容，不會影響我們頁面配置， 只是樣式更好看了而已。\n1.圓角邊框(CSS3)\n語法：\n\n1border-radius:length;  \n\n\n其中每一個值可以為 數值或百分比的形式。 \n\n技巧： 讓一個正方形  變成圓圈 \n1border-radius: 50%;\n\n2. 盒子陰影(CSS3)\n語法:\n\n1box-shadow:水準陰影 垂直陰影 模糊距離（虛實）  陰影尺寸（影子大小）  陰影顏色  內/外陰影；\n\n\n前兩個屬性是必須寫的。其餘的可以省略。\n外陰影 (outset) 是默認的 但是不能寫           \n想要內陰影可以寫  inset\n\n123456789div &#123;      width: 200px;      height: 200px;      border: 10px solid red;      /* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */      /* box-shadow:水準位置 垂直位置 模糊距離 陰影尺寸（影子大小） 陰影顏色  內/外陰影； */      box-shadow: 0 15px 30px  rgba(0, 0, 0, .4);      &#125;\n\n空格規範\n\n\n\n\n\n\n\n\n【強制】 選擇器 與 { 之間必須包含空格。\n示例： \n12.selector &#123;&#125;\n\n\n\n\n\n\n\n\n\n\n【強制】 屬性名 與之後的 : 之間不允許包含空格， : 與 屬性值 之間必須包含空格。\n示例：\n1font-size: 12px;\n\n選擇器規範\n\n\n\n\n\n\n\n\n【強制】 並集選擇器，每個選擇器聲明必須獨佔一行。\n示例：\n1234567891011/* good */.post,.page,.comment &#123;    line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123;    line-height: 1.5;&#125;\n\n\n\n\n\n\n\n\n\n\n【建議】 一般情況情況下，選擇器的嵌套層級應不大於 3 級，位置靠後的限定條件應盡可能精確。\n示例：\n1234567/* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login  input &#123;&#125;.comment div * &#123;&#125;\n\n屬性規範\n\n\n\n\n\n\n\n\n【強制】 屬性定義必須另起一行。\n示例：\n12345678/* good */.selector &#123;    margin: 0;    padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0; &#125;\n\n\n\n\n\n\n\n\n\n\n【強制】 屬性定義後必須以分號結尾。\n示例：\n123456789/* good */.selector &#123;    margin: 0;&#125;/* bad */.selector &#123;    margin: 0&#125;\n\n\n","slug":"2301-2 CSS 05 盒子模型+拓展規範","date":"2023-03-14T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"494b4979132be1c92e421450a897b835","title":"CSS 04-複合選擇器+三大特性","content":"1. CSS複合選擇器目標\n\n理解\n\n理解css複合選擇器分別的應用場景\n\n\n應用\n\n使用後代選擇器給元素添加樣式\n使用並集選擇器給元素添加樣式\n使用偽類別選取器\n\n\n\n為什麼要學習css複合選擇器\n\n目的是為了可以選擇更準確更精細的目標元素標籤。\n複合選擇器是由兩個或多個基礎選擇器，通過不同的方式組合而成的\n\n\n\n\n\n\n\n\n\n\nCSS選擇器分為 基礎選擇器 和 複合選擇器 ，但是基礎選擇器不能滿足我們實際開發中，快速高效的選擇標籤。\n1.1 後代選擇器（重點）\n概念：\n後代選擇器又稱為包含選擇器\n\n作用：\n用來選擇元素或元素組的子孫後代\n\n其寫法就是把外層標籤寫在前面，內層標籤寫在後面，中間用空格分隔，先寫父親爺爺，在寫兒子孫子。\n\n\n1父級 子級&#123;屬性:屬性值;屬性:屬性值;&#125;\n\n\n語法：\n\n1.class h3&#123;color:red;font-size:16px;&#125;\n\n\n當標籤發生嵌套時，內層標籤就成為外層標籤的後代。\n子孫後代都可以這麼選擇。 或者說，它能選擇任何包含在內的標籤。\n\n1.2 子元素選擇器\n作用：\n子元素選擇器只能選擇作為某元素子元素的元素。\n\n其寫法就是把父級標籤寫在前面，子級標籤寫在後面，中間跟一個 &gt; 進行連接\n\n語法：\n\n\n1.class&gt;h3&#123;color:red;font-size:14px;&#125;\n\n\n\n\n\n\n\n\n\n\n這裡的子 指的是 親兒子  不包含孫子 重孫子之類。\n123比如：  .demo &gt; h3 &#123;color: red;&#125;   說明  h3 一定是demo 親兒子。  demo 元素包含著h3。\n\n1.3 交集選擇器\n條件：\n交集選擇器由兩個選擇器構成，找到的標籤必須滿足：既有標籤一的特點，也有標籤二的特點。\n\n語法：\n\n其中第一個為標籤選擇器，第二個為class選擇器，兩個選擇器之間不能有空格\n\n如 h3.special。\n\n\n記憶技巧：\n交集選擇器 是 並且的意思。  即…又…的意思\n12比如： p.one   選擇的是： 類名為 .one  的 段落標籤。  \n\n用的相對來說比較少，不太建議使用。\n1.4 並集選擇器（重點）\n應用：\n\n如果某些選擇器定義的相同樣式，就可以利用並集選擇器，可以讓代碼更簡潔。\n\n\n並集選擇器（CSS選擇器分組）是各個選擇器通過,連接而成的，通常用於集體聲明。\n\n語法：\n\n任何形式的選擇器（包括標籤選擇器、class類別選取器id選擇器等），都可以作為並集選擇器的一部分。\n\n記憶技巧：\n並集選擇器通常用於集體聲明  ，逗號隔開的，所有選擇器都會執行後面樣式，逗號可以理解為 和的意思。\n\n\n123.one, p , #test &#123;color: #F00;&#125;表示.one 和 p  和 #test 這三個選擇器都會執行顏色為紅色。 通常用於集體聲明。  \n\n1.5  連結偽類別選取器（重點） 偽類別選取器：\n為了和類別選取器相區別，類別選取器是一個點 比如 .demo {}而偽類用 2個點就是冒號 比如  :link{} \n作用：\n用於向某些選擇器添加特殊的效果。比如給連結添加特殊效果， 比如可以選擇 第1個，第n個元素。因為偽類別選取器很多，比如連結偽類，結構偽類等等。\n12345連結偽類別選取器- a:link      /* 未訪問的連結 */- a:visited   /* 已訪問的連結 */- a:hover     /* 滑鼠移動到連結上 */- a:active    /* 選定的連結 */\n\n\n\n  注意\n\n寫的時候，他們的順序儘量不要顛倒，按照lvha 的順序。否則可能引起錯誤。  \n記憶法love   hate     \n因為叫連結偽類，所以都是 利用交集選擇器  a:link    a:hover  \n因為a連結流覽器具有預設樣式，所以我們實際工作中都需要給連結單獨指定樣式。\n實際工作開發中很少寫全四個狀態，一般寫法如下：\n\n12345678a &#123;   /* a是標籤選擇器  所有的連結 */      font-weight: 700;      font-size: 16px;      color: gray;&#125;a:hover &#123;   /* :hover 是連結偽類別選取器 滑鼠經過 */      color: red; /*  滑鼠經過的時候，由原來的 灰色 變成了紅色 */&#125;\n\n1.6 複合選擇器總結\n\n\n選擇器\n作用\n特徵\n使用情況\n隔開符號及用法\n\n\n\n後代選擇器\n用來選擇元素後代\n是選擇所有的子孫後代\n較多\n符號是空格 .nav a\n\n\n子代選擇器\n選擇 最近一級元素\n只選親兒子\n較少\n符號是&gt;   .nav&gt;p\n\n\n交集選擇器\n選擇兩個標籤交集的部分\n既是 又是\n較少\n沒有符號  p.one\n\n\n並集選擇器\n選擇某些相同樣式的選擇器\n可以用於集體聲明\n較多\n符號是逗號 .nav, .header\n\n\n連結偽類別選取器\n給連結更改狀態\n\n較多\n重點記住 a{} 和 a:hover  實際開發的寫法\n\n\n2. 標籤顯示模式（display）重點目標：\n\n理解\n標籤的三種顯示模式\n三種顯示模式的特點以及區別\n理解三種顯示模式的相互轉化\n\n\n應用\n實現三種顯示模式的相互轉化\n\n\n\n2.1 什麼是標籤顯示模式\n什麼是標籤的顯示模式？\n標籤以什麼方式進行顯示，比如div 自己占一行， 比如span 一行可以放很多個\n\n作用： \n我們網頁的標籤非常多，再不同地方會用到不同類型的標籤，以便更好的完成我們的網頁。\n\n標籤的類型(分類)\nHTML標籤一般分為塊標籤和行內標籤兩種類型，它們也稱塊元素和行內元素。\n\n\n2.2 塊級元素(block-level)12常見的塊元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;標籤是最典型的塊元素。\n\n\n塊級元素的特點\n\n（1）比較霸道，自己獨佔一行\n（2）高度，寬度、外邊距以及內邊距都可以控制。\n（3）寬度默認是容器（父級寬度）的100%\n（4）是一個容器及盒子，裡面可以放行內或者塊級元素。\n\n注意：\n只有文字才能組成段落，因此p裡面不能放塊級元素，特別是p 不能放div \n同理還有這些標籤h1,h2,h3,h4,h5,h6,dt，他們都是文字類塊級標籤，裡面不能放其他塊級元素。\n\n\n\n2.3 行內元素(inline-level)\n例：\n\n12常見的行內元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等其中&lt;span&gt;標籤為最典型的行內元素。有些地方也成內聯元素\n\n\n行內元素的特點：\n\n（1）相鄰行內元素在一行上，一行可以顯示多個。\n（2）高、寬直接設置是無效的。\n（3）預設寬度就是它本身內容的寬度。\n（4）行內元素只能容納文本或則其他行內元素。\n注意：\n\n連結裡面不能再放連結。\n特殊情況a裡面可以放塊級元素，但是給a轉換一下塊級模式最安全。\n\n2.4 行內塊元素（inline-block）\n例：\n\n12在行內元素中有幾個特殊的標籤——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以對它們設置寬高和對齊屬性，有些資料可能會稱它們為行內塊元素。\n\n\n行內塊元素的特點：\n（1）和相鄰行內元素（行內塊）在一行上,但是之間會有空白縫隙。一行可以顯示多個（2）預設寬度就是它本身內容的寬度。（3）高度，行高、外邊距以及內邊距都可以控制。\n\n\n2.5 三種模式總結區別\n\n\n元素模式\n元素排列\n設置樣式\n預設寬度\n包含\n\n\n\n塊級元素\n一行只能放一個塊級元素\n可以設置寬度高度\n容器的100%\n容器級可以包含任何標籤\n\n\n行內元素\n一行可以放多個行內元素\n不可以直接設置寬度高度\n它本身內容的寬度\n容納文本或則其他行內元素\n\n\n行內塊元素\n一行放多個行內塊元素\n可以設置寬度和高度\n它本身內容的寬度\n\n\n\n2.6 標籤顯示模式轉換 display\n塊轉行內：display:inline;\n行內轉塊：display:block;\n塊、行內元素轉換為行內塊： display: inline-block;\n\n此階段，我們只需關心這三個，其他的是後面的工作。\n3. 行高那些事（line-height）目標\n\n理解\n能說出 行高  和 高度  三種關係\n能簡單理解為什麼行高等於高度單行文字會垂直居中\n\n\n應用\n使用行高實現單行文字垂直居中\n能會測量行高\n\n\n\n3.1 行高測量\n行高的測量方法：\n行高 &#x3D; 基線與基線之間的距離\n\n\n\n3.2 單行文本垂直居中 行高我們利用最多的一個地方是： 可以讓單行文本在盒子中垂直居中對齊。\n\n\n\n\n\n\n\n\n\n文字的行高等於盒子的高度。\n\n行高   &#x3D;  上距離 +  內容高度  + 下距離\n\n上距離和下距離總是相等的，因此文字看上去是垂直居中的。\n行高和高度的三種關係\n\n如果行高等於高度，文字會垂直居中\n如果行高大於高度，文字會偏下 \n如果行高小於高度，文字會偏上\n\n4. CSS 背景(background)目標\n\n理解\n背景的作用\ncss背景圖片和插入圖片的區別\n\n\n應用\n通過css背景屬性，給頁面元素添加背景樣式\n能設置不同的背景圖片位置\n\n\n\n4.1 背景顏色(color)\n語法：\n1background-color:顏色值;   默認的值是 transparent  透明的\n\n4.2 背景圖片(image)\n語法：\n\n1background-image : none | url (url) \n\n\n\n\n參數\n作用\n\n\n\nnone\n無背景圖（默認的）\n\n\nurl\n使用絕對或相對位址指定背景圖像\n\n\n1background-image : url(images/demo.png);\n\n\n小技巧： 背景圖片後面的位址，url不要加引號。\n\n4.3 背景平鋪（repeat）\n語法：\n\n1background-repeat : repeat | no-repeat | repeat-x | repeat-y \n\n\n\n\n參數\n作用\n\n\n\nrepeat\n背景圖像在縱向和橫向上平鋪（默認的）\n\n\nno-repeat\n背景圖像不平鋪\n\n\nrepeat-x\n背景圖像在橫向上平鋪\n\n\nrepeat-y\n背景圖像在縱向平鋪\n\n\n4.4 背景位置(position) 重點\n語法：\n\n123background-position : length || lengthbackground-position : position || position \n\n\n\n\n參數\n值\n\n\n\nlength\n百分數 | 由浮點數位和單位識別字組成的長度值\n\n\nposition\ntop | center | bottom | left | center | right   方位名詞\n\n\n\n注意：\n必須先指定background-image屬性\nposition 後面是x座標和y座標。 可以使用方位名詞或者 精確單位。\n如果指定兩個值，兩個值都是方位名字，則兩個值前後順序無關，比如left  top和top  left效果一致\n如果只指定了一個方位名詞，另一個值默認居中對齊。\n如果position 後面是精確座標， 那麼第一個，肯定是 x  第二的一定是y\n如果只指定一個數值,那該數值一定是x座標，另一個默認垂直居中\n如果指定的兩個值是 精確單位和方位名字混合使用，則第一個值是x座標，第二個值是y座標\n\n\n\n實際用的最多，是背景圖片居中對齊了。\n4.5 背景附著\n背景附著就是解釋背景是滾動的還是固定的\n\n語法： \n1background-attachment : scroll | fixed \n\n\n\n\n參數\n作用\n\n\n\nscroll\n背景圖像是隨物件內容滾動\n\n\nfixed\n背景圖像固定\n\n\n4.6 背景簡寫\nbackground：屬性的值的書寫順序官方並沒有強制標準的。為了可讀性，建議大家如下寫：\nbackground: 背景顏色 背景圖片位址 背景平鋪 背景滾動 背景位置;\n語法：\n\n1background: transparent url(image.jpg) repeat-y  scroll center top ;\n\n\n4.7 背景透明(CSS3)\n語法：\n\n1background: rgba(0, 0, 0, 0.3);\n\n\n最後一個參數是alpha透明度  取值範圍 0~1之間\n習慣把0.3 的 0 省略掉  這樣寫  background: rgba(0, 0, 0, .3);\n注意：  背景半透明是指盒子背景半透明， 盒子裡面的內容不受影響\n因為是CSS3 ，所以 低於 ie9 的版本是不支持的。\n\n4.8 背景總結\n\n\n屬性\n作用\n值\n\n\n\nbackground-color\n背景顏色\n預定義的顏色值&#x2F;十六進位&#x2F;RGB代碼\n\n\nbackground-image\n背景圖片\nurl(圖片路徑)\n\n\nbackground-repeat\n是否平鋪\nrepeat&#x2F;no-repeat&#x2F;repeat-x&#x2F;repeat-y\n\n\nbackground-position\n背景位置\nlength&#x2F;position    分別是x  和 y座標， 切記 如果有 精確數值單位，則必須按照先X 後Y 的寫法\n\n\nbackground-attachment\n背景固定還是滾動\nscroll&#x2F;fixed\n\n\n背景簡寫\n更簡單\n背景顏色 背景圖片位址 背景平鋪 背景滾動 背景位置;  他們沒有順序\n\n\n背景透明\n讓盒子半透明\nbackground: rgba(0,0,0,0.3);   後面必須是 4個值\n\n\n5. CSS 三大特性目標：\n\n理解\n能說出css樣式衝突採取的原則\n能說出那些常見的樣式會有繼承\n\n\n應用\n能寫出CSS優先順序的演算法\n能會計算常見選擇器的疊加值\n\n\n\n5.1 CSS層疊性\n概念：\n所謂層疊性是指多種CSS樣式的疊加。\n是流覽器處理衝突的一個能力,如果一個屬性通過兩個相同選擇器設置到同一個元素上，那麼這個時候一個屬性就會將另一個屬性層疊掉\n\n原則：\n\n樣式衝突，遵循的原則是就近原則。 那個樣式離著結構近，就執行那個樣式。\n樣式不衝突，不會層疊\n\n\n\n1CSS層疊性最後的執行口訣：  長江後浪推前浪，前浪死在沙灘上。\n\n5.2 CSS繼承性\n概念：\n子標籤會繼承父標籤的某些樣式，如文本顏色和字型大小。\n 想要設置一個可繼承的屬性，只需將它應用于父元素即可。\n\n\n\n\n\n\n\n\n\n\n\n簡單的理解就是： 子承父業。\n\n注意：\n恰當地使用繼承可以簡化代碼，降低CSS樣式的複雜性。比如有很多子級孩子都需要某個樣式，可以給父級指定一個，這些孩子繼承過來就好了。\n子元素可以繼承父元素的樣式（text-，font-，line-這些元素開頭的可以繼承，以及color屬性）\n\n\n\n1CSS繼承性口訣：  龍生龍，鳳生鳳，老鼠生的孩子會打洞。\n5.3 CSS優先順序（重點）\n概念：\n定義CSS樣式時，經常出現兩個或更多規則應用在同一元素上，此時，\n\n選擇器相同，則執行層疊性\n選擇器不同，就會出現優先順序的問題。\n\n\n\n1). 權重計算公式關於CSS權重，需要一套計算公式來去計算，這個就是 CSS Specificity（特殊性）\n\n\n\n標籤選擇器\n計算權重公式\n\n\n\n繼承或者 *\n0,0,0,0\n\n\n每個元素（標籤選擇器）\n0,0,0,1\n\n\n每個類，偽類\n0,0,1,0\n\n\n每個ID\n0,1,0,0\n\n\n每個行內樣式 style&#x3D;””\n1,0,0,0\n\n\n每個!important  重要的\n∞ 無窮大\n\n\n\n值從左到右，左面的最大，一級大於一級，數位之間沒有進制，級別之間不可超越。 \n關於CSS權重，我們需要一套計算公式來去計算，這個就是 CSS Specificity（特殊性）123div &#123;     color: pink!important;   &#125;\n\n2). 權重疊加經常用交集選擇器，後代選擇器等，若有多個基礎選擇器組合而成，那麼此時，就會出現權重疊加。\n就是一個簡單的加法計算\n\ndiv ul  li   ——&gt;      0,0,0,3\n.nav ul li   ——&gt;      0,0,1,2\na:hover      —–—&gt;   0,0,1,1\n.nav a       ——&gt;      0,0,1,1\n\n注意： \n\n數位之間沒有進制 比如說： 0,0,0,5 + 0,0,0,5 &#x3D;0,0,0,10 而不是 0,0, 1, 0， 所以不會存在10個div能趕上一個類別選取器的情況。\n\n3). 繼承的權重是0這個不難，但是忽略很容易繞暈。其實，修改樣式，一定要看該標籤有沒有被選中。\n1） 如果選中了，那麼以上面的公式來計權重。誰大聽誰的。2） 如果沒有選中，那麼權重是0，因為繼承的權重為0.\n6. CSS注釋CSS注釋規則：\n12/*需要注釋的內容*/  ←注釋方式，即在需要注釋的內容前使用 /* 標記開始注釋，在內容的結尾使用 */ 結束。\n\n   例如：\n1234p &#123; /* 所有的字體是14圖元大小*/  font-size: 14px;                 &#125;\n\n","slug":"2301-2 CSS 04 複合選擇器+三大特性","date":"2023-03-13T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"d86c07d9a08e828d31cdbce6c02ea3bd","title":"CSS 03-文本樣式屬性調試工具","content":"\n應用\n使用css字體樣式完成對字體的設置\n使用css外觀屬性給頁面元素添加樣式\n使用常用的emment語法\n能夠使用開發人員工具代碼調試\n\n\n\n1.font字體1.1 font-size:大小\n作用：font-size屬性用於設置字型大小\n123p &#123;      font-size:20px; &#125;\n\n單位：\n\n可以使用相對長度單位，也可以使用絕對長度單位。\n相對長度單位比較常用，推薦使用圖元單位px，絕對長度單位使用較少。\n\n\n\n\n\n\n相對長度單位\n說明\n\n\n\nem\n相對於當前對象文本的字體尺寸\n\n\npx\n像素(最常用)\n\n\n\n\n\n絕對長度單位\n說明\n\n\n\nin\n英吋\n\n\ncm\n公分\n\n\nmm\n毫米\n\n\npt\n點\n\n\n注意：\n\n文字大小基本就用px了，其他單位很少使用\ngoogle流覽器預設的文字大小為16px\n但是不同流覽器可能預設顯示的字型大小大小不一致，需要儘量給一個明確值大小。\n\n1.2 font-family:字體\n作用：\nfont-family屬性用於設置哪一種字體。\n\n\n1p&#123; font-family:&quot;微軟雅黑&quot;;&#125;\n\n\n網頁中常用的字體有宋體、微軟雅黑、黑體等，例如將網頁中所有段落文本的字體設置為微軟雅黑\n可以同時指定多個字體，中間以逗號隔開，表示如果流覽器不支援第一個字體，則會嘗試下一個，直到找到合適的字體， 如果都沒有，則以我們電腦預設的字體為准。\n\n1p&#123;font-family: Arial,&quot;Microsoft Yahei&quot;, &quot;微軟雅黑&quot;;&#125;\n\n12341. 各種字體之間必須使用英文狀態下的逗號隔開。2. 中文字體需要加英文狀態下的引號，英文字體一般不需要加引號。當需要設置英文字體時，英文字體名必須位於中文字體名之前。3. 如果字體名中包含空格、#、$等符號，則該字體必須加英文狀態下的單引號或雙引號，例如font-family: &quot;Times New Roman&quot;;。4. 儘量使用系統預設字體，保證在任何使用者的流覽器中都能正確顯示。\n\nCSS Unicode字體\n為什麼使用 Unicode字體\n\n在 CSS 中設置字體名稱，直接寫中文是可以的。但是在檔編碼（GB2312、UTF-8 等）不匹配時會產生亂碼的錯誤。\n\n\n解決：\n\n方案一： 你可以使用英文來替代。 比如 font-family:&quot;Microsoft Yahei&quot;。\n\n方案二： 在 CSS 直接使用 Unicode 編碼來寫字體名稱可以避免這些錯誤。使用 Unicode 寫中文字體名稱，流覽器是可以正確的解析的。\n1font-family: &quot;\\5FAE\\8F6F\\96C5\\9ED1&quot;;   //表示設置字體為“微軟雅黑”。\n\n\n\n\n\n\n字體名稱\n英文名稱\nUnicode 編碼\n\n\n\n宋體\nSimSun\n\\5B8B\\4F53\n\n\n新宋體\nNSimSun\n\\65B0\\5B8B\\4F53\n\n\n黑體\nSimHei\n\\9ED1\\4F53\n\n\n微軟雅黑\nMicrosoft YaHei\n\\5FAE\\8F6F\\96C5\\9ED1\n\n\n楷體_GB2312\nKaiTi_GB2312\n\\6977\\4F53_GB2312\n\n\n隸書\nLiSu\n\\96B6\\4E66\n\n\n幼園\nYouYuan\n\\5E7C\\5706\n\n\n華文細黑\nSTXihei\n\\534E\\6587\\7EC6\\9ED1\n\n\n細明體\nMingLiU\n\\7EC6\\660E\\4F53\n\n\n新細明體\nPMingLiU\n\\65B0\\7EC6\\660E\\4F53\n\n\n為了照顧不同電腦的字體安裝問題，儘量只使用宋體和微軟雅黑中文字體\n1.3 font-weight:字體粗細\n在html中如何將字體加粗我們可以用標籤來實現\n使用b和strong標籤是文本加粗。\n\n\n可以使用CSS 來實現，但是CSS 是沒有語義的。\n\n\n\n\n屬性值\n描述\n\n\n\nnormal\n預設值（不加粗的）\n\n\nbold\n定義粗體（加粗的）\n\n\n100~900\n400 等同於 normal，而 700 等同於 bold  我們重點記住這句話\n\n\n提倡：  平時更喜歡用數字來表示加粗和不加粗。\n1.4 font-style:字體風格\n在html中如何將字體傾斜我們可以用標籤來實現\n字體傾斜除了用i和 em 標籤，\n\n\n可以使用CSS 來實現，但是CSS 是沒有語義的\n\nfont-style屬性用於定義字體風格，如設置斜體、傾斜或正常字體，其可用屬性值如下：\n\n\n\n屬性\n作用\n\n\n\nnormal\n預設值，流覽器會顯示標準的字體樣式  font-style: normal;\n\n\nitalic\n流覽器會顯示斜體的字體樣式。\n\n\n1平時我們很少給文字加斜體，反而喜歡給斜體標籤（em，i）改為普通模式。\n\n1.5 font:綜合設置字體樣式 (重點)font屬性用於對字體樣式進行綜合設置\n\n基本語法格式如下：\n\n1選擇器 &#123; font: font-style  font-weight  font-size/line-height  font-family;&#125;\n\n\n注意：\n使用font屬性時，必須按上面語法格式中的順序書寫，不能更換順序，各個屬性以空格隔開。\n其中不需要設置的屬性可以省略（取預設值），但必須保留font-size和font-family屬性，否則font屬性將不起作用。\n\n\n\n1.6 font總結\n\n\n屬性\n表示\n注意點\n\n\n\nfont-size\n字型大小\n我們通常用的單位是px 圖元，一定要跟上單位\n\n\nfont-family\n字體\n實際工作中按照團隊約定來寫字體\n\n\nfont-weight\n字體粗細\n加粗是 700 或者 bold  不加粗 是 normal 或者  400  記住數位不要跟單位\n\n\nfont-style\n字體樣式\n記住傾斜是 italic     不傾斜 是 normal  工作中我們最常用 normal\n\n\nfont\n字體連寫\n字體連寫是有順序的，不能隨意換位置，其中字型大小 和字體必須同時出現\n\n\n2. CSS外觀屬性2.1 color:文本顏色\n作用：\ncolor屬性用於定義文本的顏色，\n\n其取值方式有如下3種：\n\n\n\n\n\n表示表示\n屬性值\n\n\n\n預定義的顏色值\nred，green，blue\n\n\n十六進位\n#FF0000，#FF6600，#29D794\n\n\nRGB代碼\nrgb(255,0,0)或rgb(100%,0%,0%)\n\n\n\n注意實際工作中， 用 16進制的寫法是最多的，其中更喜歡簡寫方式比如  #f00 代表紅色\n\n2.2 text-align:文本水準對齊方式\n作用：\ntext-align屬性用於設置文本內容的水準對齊，相當於html中的align對齊屬性\n\n其可用屬性值如下：\n\n\n\n\n\n屬性\n解釋\n\n\n\nleft\n左對齊（預設值）\n\n\nright\n右對齊\n\n\ncenter\n居中對齊\n\n\n\n注意：\n是讓盒子裡面的內容水準居中， 而不是讓盒子居中對齊\n\n\n2.3 line-height:行間距\n作用：\nline-height屬性用於設置行間距，就是行與行之間的距離，即字元的垂直間距，一般稱為行高。\n\n單位：\n\nline-height常用的屬性值單位有三種，分別為圖元px，相對值em和百分比%，實際中使用最多的是圖元px\n\n\n技巧：\n\n\n12一般情況下，行距比字型大小大7.8圖元左右就可以了。line-height: 24px;\n\n2.4 text-indent:首行縮進\n作用：\ntext-indent屬性用於設置首行文本的縮進，\n\n屬性值\n\n其屬性值可為不同單位的數值、em字元寬度的倍數、或相對於流覽器視窗寬度的百分比%，允許使用負值,\n建議使用em作為設置單位。\n\n\n\n1em 就是一個字的寬度   如果是漢字的段落， 1em 就是一個漢字的寬度\n123456p &#123;      /*行間距*/      line-height: 25px;      /*首行縮進2個字  em  1個em 就是1個字的大小*/      text-indent: 2em;   &#125;\n\n2.5 text-decoration 文本的裝飾text-decoration   通常我們用於給連結修改裝飾效果\n\n\n\n值\n描述\n\n\n\nnone\n默認。定義標準的文本。 取消底線（最常用）\n\n\nunderline\n定義文本下的一條線。底線 也是我們連結自帶的（常用）\n\n\noverline\n定義文本上的一條線。（不用）\n\n\nline-through\n定義穿過文本下的一條線。（不常用）\n\n\n2.6 CSS外觀屬性總結\n\n\n屬性\n表示\n注意點\n\n\n\ncolor\n顏色\n我們通常用  十六進位   比如 而且是簡寫形式 #fff\n\n\nline-height\n行高\n控制行與行之間的距離\n\n\ntext-align\n水準對齊\n可以設定文字水準的對齊方式\n\n\ntext-indent\n首行縮進\n通常我們用於段落首行縮進2個字的距離   text-indent: 2em;\n\n\ntext-decoration\n文本修飾\n記住 添加 底線  underline  取消底線  none\n\n\n3.開發者工具（chrome）此工具是必備工具，以後代碼出了問題\n首先第一反應就是：\n\n“按F12”或者是 “shift+ctrl+i”   打開 開發者工具。\n菜單： 右擊網頁空白出—檢查↓\n通過開發人員工具小指標工具，查找頁面元素↓\n左側是html頁面結構，右側是css樣式\n\n\nctrl+滾輪 可以 放大開發者工具代碼大小。\n左邊是HTML元素結構   右邊是CSS樣式。\n右邊CSS樣式可以改動數值和顏色查看更改後效果。\nctrl + 0  復原流覽器大小\n\n4. sublime快捷操作emmet語法Emmet的前身是Zen coding,它使用縮寫,來提高html&#x2F;css的編寫速度。\n\n生成標籤 直接輸入標籤名 按tab鍵即可   比如  div   然後tab 鍵， 就可以生成 \n\n如果想要生成多個相同標籤  加上* 就可以了 比如   div*3  就可以快速生成3個div\n\n如果有父子級關係的標籤，可以用 &gt;  比如   ul &gt; li就可以了\n\n如果有兄弟關係的標籤，用  +  就可以了 比如 div+p  \n\n如果生成帶有類名或者id名字的，  直接寫  .demo  或者#two tab鍵就可以了\n\n如果生成的div 類名是有順序的， 可以用 自增符號 $   \n1234.demo$*3        &lt;div class=&quot;demo1&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo2&quot;&gt;&lt;/div&gt;&lt;div class=&quot;demo3&quot;&gt;&lt;/div&gt;\n如果想在生成的標籤内部寫内容，可以用&#123;&#125;表示\n\n\n5.拓展閱讀emment語法\n","slug":"2301-2 CSS 03 文本樣式屬性調試工具","date":"2023-03-12T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"fe80011ed56b79e3fb28c137c216c8eb","title":"CSS 02-基礎選擇器","content":"CSS選擇器\n\n\n\n\n\n\n\n\n找到特定的HTML頁面元素能夠使用基礎選擇器給頁面元素添加樣式\n1. CSS選擇器作用（重點）選擇器的作用css 只做兩件事 選人，做事 \n123h3 &#123;   color: red;&#125;\n\n這段代碼就是2件事， 把  h3選出來， 然後 把它變成了 紅色。 \n選擇器分為基礎選擇器和 複合選擇器，我們這裡先講解一下 基礎選擇器。\n2. CSS基礎選擇器2.1 標籤選擇器\n概念：\n標籤選擇器（元素選擇器）是指用HTML標籤名稱作為選擇器，按標籤名稱分類，為頁面中某一類標籤指定統一的CSS樣式。\n\n語法：\n\n\n1標籤名&#123;屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3; &#125; \n\n\n作用：標籤選擇器 可以把某一類標籤全部選擇出來  比如所有的div標籤  和 所有的 span標籤\n\n優點：是能快速為頁面中同類型的標籤統一樣式\n\n缺點：不能設計差異化樣式。\n\n\n總結 口訣：\n   標籤選擇器，   頁面同選起。   直接寫標籤，   全部不放棄。\n2.2 class選取器class選取器使用“.”（英文點號）進行標識，後面緊跟類名.\n\n語法：\n\n類名選擇器\n\n12345.類名  &#123;       屬性1:屬性值1;     屬性2:屬性值2;     屬性3:屬性值3;     &#125;\n\n\n標籤\n\n1&lt;p class=&#x27;類名&#x27;&gt;&lt;/p&gt;\n\n優點：\n\n可以為元素物件定義單獨或相同的樣式。 可以選擇一個或者多個標籤\n\n\n注意\n\n類別(class)選取器使用“.”（英文點號）進行標識，後面緊跟類名(自訂，我們自己命名的)\n長名稱或片語可以使用中橫線來為選擇器命名。\n不要純數位、中文等命名， 儘量使用英文字母來表示。\n\n\n\n命名規範：  見附件（Web前端開發規範手冊.doc）\n命名是我們通俗約定的，但是沒有規定必須用這些常用的命名。\n\n記憶口訣\n差異化選擇一個或多個上麵點定義類名別寫錯誰用誰調用class來做。\n嘿嘿，工作類最多。\n\n\n2.3 類別選取器特殊用法- 多類名我們可以給標籤指定多個類名，從而達到更多的選擇目的。\n\n\n\n\n\n\n\n\n\n....\n注意：\n\n各個類名中間用空格隔開。\n多類名選擇器在後期佈局比較複雜的情況下，還是較多使用的。\n\n1234&lt;div class=&quot;pink fontWeight font20&quot;&gt;亞瑟&lt;/div&gt;&lt;div class=&quot;font20&quot;&gt;劉備&lt;/div&gt;&lt;div class=&quot;font14 pink&quot;&gt;安其拉&lt;/div&gt;&lt;div class=&quot;font14&quot;&gt;貂蟬&lt;/div&gt;\n\n2.4 id選擇器id選擇器使用#進行標識，後面緊跟id名\n\n其基本語法格式如下：\n\nid選擇器\n1#id名 &#123;屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3; &#125;\n\n標籤\n1&lt;p id=&quot;id名&quot;&gt;&lt;/p&gt;\n\n\n元素的id值是唯一的，只能對應于文檔中某一個具體的元素。\n\n用法基本和類別選取器相同。\n\n\nid選擇器和class選取器區別\n在同一個頁面內，不允許有相同名字的id物件出現，但是允許相同名字的class。\n類別選取器（class） 好比人的名字，  是可以多次重複使用的， 比如  徐生  王生  李生  李生\nid選擇器     好比人的身份證號碼，  全國是唯一的， 不得重複。 只能使用一次。\n\n\n\nid選擇器和class選取器最大的不同在於 使用次數上。\n總結\n\nclass選取器我們在修改樣式中，用的最多。\nid選擇器一般用於頁面唯一性的元素身上，經常和我們後面學習的javascript 搭配使用。\n\n2.6 萬用字元選擇器\n概念\n萬用字元選擇器用*號表示，  *   就是 選擇所有的標籤      他是所有選擇器中作用範圍最廣的，能匹配頁面中所有的元素。\n\n其基本語法格式如下：\n\n\n1* &#123; 屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3; &#125;\n\n例如下面的代碼，使用萬用字元選擇器定義CSS樣式，清除所有HTML標記的預設邊距。\n1234* &#123;  margin: 0;                    /* 定義外邊距*/  padding: 0;                   /* 定義內邊距*/&#125;\n\n\n注意：\n  會匹配頁面所有的元素，降低頁面回應速度，不建議隨便使用\n\n\n2.7 基礎選擇器總結\n\n\n選擇器\n作用\n缺點\n使用情況\n用法\n\n\n\n標籤選擇器\n可以選出所有相同的標籤，比如p\n不能差異化選擇\n較多\np { color：red;}\n\n\n類別選取器\n可以選出1個或者多個標籤\n可以根據需求選擇\n非常多\n.nav { color: red; }\n\n\nid選擇器\n一次只能選擇器1個標籤\n只能使用一次\n不推薦使用\n#nav {color: red;}\n\n\n萬用字元選擇器\n選擇所有的標籤\n選擇的太多，有部分不需要\n不推薦使用\n* {color: red;}\n\n\n基礎選擇器我們一共學了4個，  每個都有自己的價值， 可能再某個地方都能用到。但是如果說，一定要找個最常用的，那麼，肯定是類別選取器。\n2.8 團隊約定選擇器\n\n儘量少用通用選擇器 *\n儘量少用 ID 選擇器\n不使用無具體語義定義的標籤選擇器 div span\n\n123456789/* 推薦 */.jdc &#123;&#125;li &#123;&#125;p&#123;&#125;/* 不推薦 */*&#123;&#125;#jdc &#123;&#125;div&#123;&#125;   因為div 沒有語義，我們儘量少用\n\n\n","slug":"2301-2 CSS 02 基礎選擇器","date":"2023-03-11T02:50:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"e201a2a619b1945f4ef64af1b2319404","title":"CSS 01-層疊樣式表","content":"學習目標\n理解\ncss的目的作用\ncss的三種引入方式\n\n\n應用\ncss三種引用方式的書寫\n通過樣式規則給標籤添加簡單的樣式\n\n\n\n1.HTML的局限性HTML非常單純， 只關注內容的語義， \n123比如:&lt;h1&gt;表明這是一個大標題，&lt;p&gt; 表明這是一個段落，&lt;img&gt; 表明這兒有一個圖片， &lt;a&gt; 表示此處有連結。\n\n以至於早期的網站雖然很多，但都有一個共同的特點醜但要改變高度或者變一個顏色，就需要大量重複操作\n總結：\n\nHTML滿足不了設計者的需求\n操作html屬性不方便\nHTML裡面添加樣式帶來的是無盡的臃腫和繁瑣\n\n2.CSS 網頁的美容師\n讓網頁更加豐富多彩，佈局更加靈活自如。   \nCSS的貢獻是:讓 HTML 從樣式中脫離，實現了HTML專注去做結構呈現，樣式交給css\n\n\n\n\n\n\n\n\n\n\n理想中的結果： 結構(html)與樣式(css)相分離  \n如果JavaScript是網頁的魔法師，那麼CSS它是我們網頁的美容師\n3.CSS初識\n概念：\n CSS(Cascading Style Sheets)  ，通常稱為CSS樣式表或層疊樣式表（階層式樣式表）\n\n作用：\n\n主要用於設置 HTML頁面中的文本內容（字體、大小、對齊方式等）、圖片的外形（寬高、邊框樣式、邊距等）以及版面的佈局和外觀顯示樣式。\nCSS以HTML為基礎，提供了豐富的功能，如字體、顏色、背景的控制及整體排版等，而且還可以針對不同的流覽器設置不同的樣式。\n\n\n\n4. 引入CSS樣式表（書寫位置）1要書寫css樣式，那css樣式書寫的位置在哪呢？\n\n4.1 行內式（內聯樣式）\n概念：\n 稱行內樣式、行間樣式.\n 是通過標籤的style屬性來設置元素的樣式\n\n其基本語法格式如下：\n\n\n123&lt;標籤名 style=&quot;屬性1:屬性值1; 屬性2:屬性值2; 屬性3:屬性值3;&quot;&gt;   內容 &lt;/標籤名&gt;\n\n實際上任何HTML標籤都擁有style屬性，用來設置行內式。\n\n案例：\n\n123&lt;div style=&quot;color: red; font-size: 12px;&quot;&gt;  青春不常在，抓緊談戀愛&lt;/div&gt;\n\n\n注意：\nstyle其實就是標籤的屬性\n樣式屬性和值中間是:\n多組屬性值之間用;隔開。\n只能控制當前的標籤和以及嵌套在其中的字標籤，造成代碼冗餘\n\n\n缺點：\n沒有實現樣式和結構相分離\n\n\n\n4.2 內部樣式表（內嵌樣式表）\n概念：\n 稱內嵌式\n 是將CSS代碼集中寫在HTML文檔的head頭部標籤中，並且用style標籤定義\n\n其基本語法格式如下：\n\n\n123456789&lt;head&gt;&lt;style type=&quot;text/CSS&quot;&gt;    選擇器（選擇的標籤） &#123;       屬性1: 屬性值1;      屬性2: 屬性值2;       屬性3: 屬性值3;    &#125;&lt;/style&gt;&lt;/head&gt;\n\n123456&lt;style&gt;   div &#123;    color: red;    font-size: 12px;   &#125;&lt;/style&gt;\n\n\n注意：\n\nstyle標籤一般位於head標籤中，當然理論上他可以放在HTML文檔的任何地方。\ntype&#x3D;”text&#x2F;css”  在html5中可以省略。\n只能控制當前的頁面\n\n\n缺點：\n  沒有徹底分離\n\n\n綜合案例1234567891011121314151617&lt;style&gt;   /*選擇器&#123;屬性:值；&#125;*/   p &#123;      color:#06C;       font-size:14px;      &#125;  /*文字的顏色是 藍色*/   h4 &#123;     color:#900;   &#125;   h1 &#123;     color:#090;      font-size:16px;     &#125;   body &#123;      background:url(bg2.jpg);   &#125;&lt;/style&gt;\n\n4.3 外部樣式表（外鏈式）\n概念：\n 稱鏈入式\n 是將所有的樣式放在一個或多個以**.CSS**為副檔名的外部樣式表檔中，\n 通過link標籤將外部樣式表檔連結到HTML文檔中\n\n其基本語法格式如下：\n\n\n123&lt;head&gt;  &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css檔路徑&quot;&gt;&lt;/head&gt;\n\n\n注意：  \nlink 是個單標籤\nlink標籤需要放在head頭部標籤中，並且指定link標籤的三個屬性\n\n\n\n\n\n\n屬性\n作用\n\n\n\nrel\n定義當前文檔與被連結文檔之間的關係，在這裡需要指定為“stylesheet”，表示被連結的文檔是一個樣式表檔。\n\n\ntype\n定義所連結文檔的類型，在這裡需要指定為“text&#x2F;CSS”，表示連結的外部檔為CSS樣式表。我們都可以省略\n\n\nhref\n定義所連結外部樣式表檔的URL，可以是相對路徑，也可以是絕對路徑。\n\n\n4.4 三種樣式表總結（位置）\n\n\n樣式表\n優點\n缺點\n使用情況\n控制範圍\n\n\n\n行內樣式表\n書寫方便，權重高\n沒有實現樣式和結構相分離\n較少\n控制一個標籤（少）\n\n\n內部樣式表\n部分結構和樣式相分離\n沒有徹底分離\n較多\n控制一個頁面（中）\n\n\n外部樣式表\n完全實現結構和樣式相分離\n需要引入\n最多，強烈推薦\n控制整個網站（多）\n\n\n團隊約定-代碼風格樣式書寫一般有兩種：\n\n一種是緊湊格式 (Compact)\n\n1h3 &#123; color: deeppink;font-size: 20px;&#125;\n\n\n一種是展開格式（推薦）\n\n1234h3 &#123;  color: deeppink;  font-size: 20px;    &#125;\n\n團隊約定-代碼大小寫樣式選擇器，屬性名，屬性值關鍵字全部使用小寫字母書寫，屬性字串允許使用大小寫。\n123456789/* 推薦 */h3&#123;  color: pink;&#125;  /* 不推薦 */H3&#123;  COLOR: PINK;&#125;\n\n\n5. 總結CSS樣式規則使用HTML時，需要遵從一定的規範。CSS亦如此，要想熟練地使用CSS對網頁進行修飾，首先需要瞭解CSS樣式規則，\n\n\n\n\n\n\n\n\n\n選擇器 {屬性:值;}\n總結：\n\n選擇器用於指定CSS樣式作用的HTML標籤，花括弧內是對該物件設置的具體樣式。\n屬性和屬性值以鍵值對的形式出現。\n屬性是對指定的物件設置的樣式屬性，例如字體大小、文本顏色等。\n屬性和屬性值之間用英文**:**連接。\n多個“鍵值對”之間用英文**;**進行區分。\n\n@拓展閱讀CSS的發展史\n","slug":"2301-2 CSS 01 層疊樣式表","date":"2023-03-10T02:00:27.000Z","categories_index":"CSS","tags_index":"CSS","author_index":"Hsu's Blog"},{"id":"c280a2edc22e967ceed619afcdbab7b6","title":"Html列表和表單","content":"1. 列表標籤（重點）學習目標\n理解\n無序列表的應用場景\n自訂列表的應用場景\n\n\n應用\n無序列表語法\n自訂清單語法\n\n\n\n\n\n\n\n\n\n\n\n\n容器裡面裝載著結構，樣式一致的文字或圖表的一種形式，叫列表\n\n特點：列表最大的特點就是  整齊 、整潔、 有序，跟表格類似，但是他可組合自由度會更高。\n\n1.1 無序列表 ul （重點）無序列表的各個清單項之間沒有順序級別之分，是並列的。其基本語法格式如下：\n123456&lt;ul&gt;  &lt;li&gt;列表項1&lt;/li&gt;  &lt;li&gt;列表項2&lt;/li&gt;  &lt;li&gt;列表項3&lt;/li&gt;  ......&lt;/ul&gt;\n\n腳下留心：\n1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;標籤中輸入其他標籤或者文字的做法是不被允許的。2. &lt;li&gt;與&lt;/li&gt;之間相當於一個容器，可以容納所有元素。3. 無序列表會帶有自己樣式屬性\n\n1.2  有序列表 ol （瞭解）有序列表即為有排列順序的清單，其各個清單項按照一定的順序排列定義，有序列表的基本語法格式如下：\n123456&lt;ol&gt;  &lt;li&gt;列表項1&lt;/li&gt;  &lt;li&gt;列表項2&lt;/li&gt;  &lt;li&gt;列表項3&lt;/li&gt;  ......&lt;/ol&gt;\n\n  所有特性基本與ul 一致。  但是實際中比 無序列表 用的少很多。\n1.3 自訂列表（理解）定義列表常用於對術語或名詞進行解釋和描述，定義列表的列表項前沒有任何專案符號。其基本語法如下：\n12345678910&lt;dl&gt;  &lt;dt&gt;名詞1&lt;/dt&gt;  &lt;dd&gt;名詞1解釋1&lt;/dd&gt;  &lt;dd&gt;名詞1解釋2&lt;/dd&gt;  ...  &lt;dt&gt;名詞2&lt;/dt&gt;  &lt;dd&gt;名詞2解釋1&lt;/dd&gt;  &lt;dd&gt;名詞2解釋2&lt;/dd&gt;  ...&lt;/dl&gt;\n\n1.4 列表總結\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;ul&gt;&lt;/ul&gt;\n無序標籤\n裡面只能包含li    沒有順序，我們以後佈局中最常用的列表\n\n\n&lt;ol&gt;&lt;/ol&gt;\n有序標籤\n裡面只能包含li    有順序， 使用情況較少\n\n\n&lt;dl&gt;&lt;/dl&gt;\n自訂列表\n裡面有2個兄弟， dt 和 dd\n\n\n\n\n\n\n\n\n\n\n\n\n學會什麼時候用無序列表， 學會什麼時候用自訂列表\n無序列表和自訂列表代碼怎麼寫？\n具體的我們剛才看的佈局，等我們學了css 在來全面佈局。\n\n2. 表單標籤(掌握)目標：\n\n能寫出最常用的註冊類表單\n能說出input表單常見屬性\n\n作用：\n使用表單的目的是收集使用者資訊。\n在網頁中，需要跟使用者進行交互，收集使用者資料，此時就需要表單。\n\n\n\n\n\n\n\n\n\n在HTML中，一個完整的表單通常由表單控制項（也稱為表單元素）、提示資訊和表單欄位元3個部分構成。\n  表單控制項：\n  包含了具體的表單功能項，如單行文本輸入框、密碼輸入框、核取方塊、提交按鈕、重新開機按鈕等。\n  提示資訊：\n  一個表單中通常還需要包含一些說明性的文字，提示使用者進行填寫和操作。\n  表單欄位（表單欄位）：  \n  他相當於一個容器，用來容納所有的表單控制項和提示資訊，可以通過他定義處理表單數據所用程式的url位址，以及資料提交到伺服器的方法。  如果不定義表單欄位，表單中的資料就無法傳送到後臺伺服器。\n2.1 input 控制項(重點)\n語法：\n1&lt;input type=&quot;屬性值&quot; value=&quot;你好&quot;&gt;\n\n\ninput 輸入的意思 \n&lt;input &#x2F;&gt;標籤為單標籤\ntype屬性設置不同的屬性值用來指定不同的控制項類型\n除了type屬性還有別的屬性\n\n\n常用屬性：\n\n\n\n\n\n屬性\n屬性值\n描述\n\n\n\ntype\ntext\n文本輸入框\n\n\n&#96;&#96;\npassword\n密碼輸入框\n\n\n&#96;&#96;\nradio\n單選按鈕\n\n\n&#96;&#96;\ncheckbox\n複選框\n\n\n&#96;&#96;\nbutton\n普通按鈕\n\n\n&#96;&#96;\nsubmit\n提交按鈕\n\n\n&#96;&#96;\nreset\n重置按鈕\n\n\n&#96;&#96;\nimage\n圖像型式按紐\n\n\n&#96;&#96;\nfile\n文件域\n\n\nname\n用戶自定義\n控制項名稱\n\n\nvalue\n用戶自定義\ninput默認文本值\n\n\nsize\n正整數\ninput默認顯示寬度\n\n\nchecked\nchecked\n默認被選重的項\n\n\nmaxlength\n正整數\n允許輸入最多字數\n\n\n1. type 屬性\n這個屬性通過改變值，可以決定了你屬於那種input表單。\n比如 type &#x3D; ‘text’  就表示 文字方塊 可以做 用戶名， 昵稱等。\n比如 type &#x3D; ‘password’  就是表示密碼框   使用者輸入的內容 是不可見的。\n\n12用戶名: &lt;input type=&quot;text&quot; /&gt; 密  碼：&lt;input type=&quot;password&quot; /&gt;\n\n2. value屬性   值1用戶名:&lt;input type=&quot;text&quot;  name=&quot;username&quot; value=&quot;請輸入用戶名&quot;&gt; \n\n\nvalue 預設的文本值。 有些表單想剛打開頁面就預設顯示幾個文字，就可以通過這個value 來設置。\n\n3. name屬性1用戶名:&lt;input type=&quot;text&quot;  name=“username” /&gt;  \n\nname表單的名字， 這樣，後臺可以通過這個name屬性找到這個表單。  頁面中的表單很多，name主要作用就是用於區別不同的表單。\n\n\n\n\n\n\n\n\n\nname屬性後面的值，是我們自己定義的。\n\nradio  如果是一組，我們必須給他們命名相同的名字 name   這樣就可以多個選其中的一個啦\n\n12&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt;女\n\n\n\n\n\n\n\n\n\n\nname屬性，我們現在用的較少， 但是，當我們學ajax 和後臺的時候，是必須的。\n4. checked屬性\n表示預設選中狀態。  較常見於 選項按鈕和複選按鈕。\n\n123性    別:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot; checked=&quot;checked&quot; /&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 \n\n上面這個，表示就默認選中了 男 這個選項按鈕\n5. input 屬性小結\n\n\n屬性\n說明\n作用\n\n\n\ntype\n表單類型\n用來指定不同的控制項類型\n\n\nvalue\n表單值\n表單裡面預設顯示的文本\n\n\nname\n表單名字\n頁面中的表單很多，name主要作用就是用於區別不同的表單。\n\n\nchecked\n默認選中\n表示那個單選或者複選按鈕一開始就被選中了\n\n\n2.2 label標籤(理解)目標：\nlabel標籤主要目的是為了提高使用者體驗。 為使用者提高最優秀的服務。\n概念：\nlabel 標籤為 input 元素定義標注（標籤）。\n作用： \n 用於綁定一個表單元素, 當點擊label標籤的時候, 被綁定的表單元素就會獲得輸入焦點。\n如何綁定元素呢？\n\n第一種用法就是用label直接包括input表單。\n\n1&lt;label&gt; 用戶名： &lt;input type=&quot;radio&quot; name=&quot;usename&quot; value=&quot;請輸入用戶名&quot;&gt;   &lt;/label&gt;\n\n   適合單個表單選擇\n\n第二種用法 for 屬性規定 label 與哪個表單元素綁定。\n\n12&lt;label for=&quot;sex&quot;&gt;男&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;  id=&quot;sex&quot;&gt;\n\n結論:\n\n\n\n\n\n\n\n\n\n 當我們滑鼠點擊 label標籤裡面的文字時， 遊標會定位到指定的表單裡面\n2.3 textarea控制項(文本域)\n語法：\n\n123&lt;textarea &gt;  文本內容&lt;/textarea&gt;\n\n\n作用：\n通過textarea控制項可以輕鬆地創建多行文本輸入框.\ncols&#x3D;”每行中的字元數” rows&#x3D;”顯示的行數”  我們實際開發不用\n\n\n文字方塊和文本域區別\n\n\n表單\n名稱\n區別\n預設值顯示\n用於場景\n\n\n\ninput type&#x3D;”text”\n文字方塊\n只能顯示一行文本\n單標籤，通過value顯示預設值\n用戶名、昵稱、密碼等\n\n\ntextarea\n文本域\n可以顯示多行文本\n雙標籤，預設值寫到標籤中間\n留言板\n\n\n2.4 select下拉清單目的：\n如果有多個選項讓使用者選擇，為了節約空間，我們可以使用select控制項定義下拉清單.\n語法：\n123456&lt;select&gt;  &lt;option&gt;選項1&lt;/option&gt;  &lt;option&gt;選項2&lt;/option&gt;  &lt;option&gt;選項3&lt;/option&gt;  ...&lt;/select&gt;\n\n\n注意：\n\n\n&lt;select&gt;  中至少包含一對 option \n在option 中定義selected &#x3D;” selected “時，當前項即為默認選中項。\n但是我們實際開發會用的比較少\n\n3. form表單欄位（表單欄位）\n收集的使用者資訊怎麼傳遞給伺服器？\n通過form表單欄位\n\n目的：\n在HTML中，form標籤被用於定義表單欄位，以實現使用者資訊的收集和傳遞，form中的所有內容都會被提交給伺服器。\n\n\n表單欄位是一個包含表單元素的區域。\n在 HTML 標籤中，&lt;form&gt; 標籤用於定義表單欄位，以實現使用者資訊的收集和傳遞。\n&lt;form&gt; 會把它範圍內的表單元素資訊提交給伺服器。\n語法:\n123&lt;form action=&quot;url位址&quot; method=&quot;提交方式&quot; name=&quot;表單欄位名稱&quot;&gt;    &lt;!-- 各種表單元素控制項 --&gt;&lt;/form&gt;\n\n常用屬性：\n\n\n\n屬性名\n屬性值\n作用\n\n\n\naction\nurl 位址\n用於指定接收並處理表單數據的伺服器程式的 url 位址\n\n\nmethod\nget &#x2F; post\n用於設置表單數據的提交方式，其取值為 get 或 post\n\n\nname\n名稱\n用於指定表單的名稱，以區分同一個頁面中的多個表單欄位\n\n\n注意：對於 HTML 基礎的學習來說，暫時不用考慮提交資料，只需寫上 form 標籤即可，後面學習服務端程式設計階段會重新講解。\nform 表單中 method 的 get 和 post 區別：\n\n\n\n\n\n\n\n\n\nmethod 方法規定如何發送表單數據（form-data）（表單數據會被發送到在 action 屬性中規定的頁面中）。\n表單數據可被作為 URL 變數的形式來發送（method&#x3D;”get”）或者作為 HTTP post 事務的形式來發送（method&#x3D;”post”）。\n關於 GET 的注釋：\n\n將表單數據以名稱&#x2F;值對的形式附加到 URL 中\nURL 的長度是有限的（大約 3000 字元）\n絕不要使用 GET 來發送敏感性資料！（在 URL 中是可見的，且流覽器會記錄 URL）\n對於使用者希望加入書簽的表單提交很有用（因為資訊記錄在 URL 中，直接保存 URL 即可）\nGET 更適用于非安全資料，比如在 Google 中查詢字串\n\n關於 POST 的注釋：\n\n將表單數據附加到 HTTP 請求的 body 內（資料不顯示在 URL 中）\n沒有長度限制\n通過 POST 提交的表單不能加入書簽注意:\n\n每個表單都應該有自己表單欄位。我們現在做頁面，不寫看不到效果，但是 如果後面學 ajax 後臺交互的時候，必須需要 form表單欄位元。\n2.6 團隊約定元素屬性\n元素屬性值使用雙引號語法\n元素屬性值可以寫上的都寫上\n\n推薦：\n12&lt;input type=&quot;text&quot; /&gt; &lt;input type=&quot;radio&quot; name=&quot;name&quot; checked=&quot;checked&quot; /&gt;\n\n不推薦：\n123&lt;input type=text  /&gt;  &lt;input type=&#x27;text&#x27; /&gt; &lt;input type=&quot;radio&quot; name=&quot;name&quot; checked /&gt;\n\n4. 文檔資源W3C :  http://www.w3school.com.cn/\nMDN: https://developer.mozilla.org/zh-CN/\n","slug":"2301-1 Html 05 列表和表單","date":"2023-03-09T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"9251ae9d685dc3ab72877b4e42919649","title":"Html表格","content":"為了讓我們頁面顯示的更加整齊，需要學習三個表（表格、表單、清單）\n表格 table(會使用)目標：\n\n理解：\n表格用來做什麼的\n表格的基本結構組成\n\n\n應用：\n寫出n行n列的表格\n簡單的合併儲存格\n\n\n\n表格作用：\n表格主要用於顯示、展示資料。因為它可以讓資料顯示得非常的規整，可讀性非常好。特別是後臺展示資料的時候，能夠熟練運用表格就顯得很重要。一個清爽簡約的表格能夠把繁雜的資料表現得很有條理（合理的使用表格也能夠有效提高 SEO）。\n表格不是用來佈局頁面的，而是用來展示資料的。\n\n\n\n\n\n\n\n\n\n表格常用於表單數據的 “佈局”。\n因為它可以讓資料顯示的非常的規整，可讀性非常好。\n特別是後臺展示資料的時候表格運用是否熟練就顯得很重要，一個清爽簡約的表格能夠把繁雜的資料表現得很有條理，雖然 div 佈局也可以做到，但是總沒有表格來得方便。\n1. 創建表格在HTML網頁中，要想創建表格，就需要使用表格相關的標籤。\n創建表格的基本語法：\n1234567&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;儲存格內的文字&lt;/td&gt;    ...  &lt;/tr&gt;  ...&lt;/table&gt;\n\n要深刻體會表格、行、儲存格他們的構成。\n在上面的語法中包含基本的三對HTML標籤，分別為 table、tr、td，他們是創建表格的基本標籤，缺一不可，下面對他們進行具體地解釋\n\n&lt;table&gt; &lt;/table&gt; 是用於定義表格的標籤\n&lt;tr&gt; &lt;/tr&gt; 用於定義表格中的行，必須嵌套在 &lt;table&gt; &lt;/table&gt; 標籤中\n&lt;td&gt; &lt;/td&gt; 用於定義表格中的儲存格，必須嵌套在 &lt;tr&gt; &lt;/tr&gt; 標籤中\n字母 td 指表格資料（table data），即：資料儲存格的內容\n儲存格 td 裡面可以放任何的元素\n\n總結:\n\n表格的主要目的是用來顯示特殊資料的\n一個完整的表格有表格標籤（table），行標籤（tr），儲存格標籤（td）組成\n\n\n&lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 類的儲存格\n&lt;td&gt;&lt;/td&gt;標籤，他就像一個容器，可以容納所有的元素\n\n2. 表格屬性表格有部分屬性我們不常用，重點記住 cellspacing 、 cellpadding。\n我們經常有個說法，是三參為0，平時開發的我們這三個參數border 、 cellpadding 、 cellspacing  為  0注意：表格標籤的屬性在實際開發中並不常用，而是通過後面的 CSS 來設置，這裡瞭解即可。\n以下屬性都寫在 table 開始標籤內，多個屬性之間用空格隔開。\n123&lt;table align=&quot;center&quot; border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; width=&quot;500&quot; height=&quot;240&quot;&gt;    ...&lt;/table&gt;\n\n\n\n\n屬性名\n屬性值\n描述\n\n\n\nalign\nleft、center、right\n規定表格相對周圍元素的對齊方式（預設 left），注意指的是整個表格的對齊方式（表格是在父盒子中默認往左靠，還是居中或是往右靠），而不是指儲存格內容的對齊方式（儲存格內容對齊可以通過：style=&quot;text-align: center;&quot; 設置）（瞭解）\n\n\nborder\n1 或 &quot;&quot;\n規定表格單元是否擁有邊框，預設為 “”，表示沒有邊框（瞭解）\n\n\ncellpadding\n圖元值\n規定單元邊沿與其內容之間的空白，預設 1 圖元（瞭解）\n\n\ncellspacing\n圖元值\n規定儲存格之間的空白，預設 2 圖元（瞭解）\n\n\nwidth\n圖元值 或 百分比\n規定表格的寬度（瞭解）\n\n\nheight\n圖元值 或 百分比\n規定表格的高度（瞭解）\n\n\n但是一般是通過css去控制\n12345678910111213141516171819202122232425table &#123;    width: 50%;    margin: 0 auto;    border: 1px black solid;    /* border-spacing：指定邊框之間的距離；邊框之間雖然沒有距離了，但是實際上是兩條邊框的和，看起來是變粗了 */    /* border-spacing: 0; */    /*border-collapse:collapse；設置邊框的合併；真正的將兩條邊框合併成一條邊框 */    border-collapse: collapse;        /* 預設情況下元素在td中是垂直居中的，可以通過vectical-align來修改 */    vertical-align: middle;    text-align: center;&#125;/* 如果表格中沒有使用tbody而是直接使用tr，那麼流覽器會自動創建一個tbody，並且將tr全都放到tbody中   所以說，tr不是table的子元素 */tbody tr:nth-child(odd) &#123;    background-color: rgb(211, 216, 188);&#125;td &#123;    border: 1px black solid;&#125;\n\n3. 表頭儲存格標籤th\n作用：\n突出重要性，表頭儲存格裡面的文本內容預設加粗居中顯示。\n一般表頭儲存格位元於表格的第一行或第一列，並且文本加粗居中\n\n\n語法：\n只需用表頭標籤&lt;th&gt;&lt;&#x2F;th&gt;替代相應的儲存格標籤&lt;td&gt;&lt;&#x2F;td&gt;即可。\n\n\n\n 代碼：\n1234567891011121314151617&lt;table width=&quot;500&quot; border=&quot;1&quot; align=&quot;center&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;    &lt;tr&gt;        &lt;th&gt;標題1&lt;/th&gt;       &lt;th&gt;標題2&lt;/th&gt;      &lt;th&gt;標題3&lt;/th&gt;    &lt;/tr&gt;        &lt;tr&gt;      &lt;td&gt;內文1&lt;/td&gt;      &lt;td&gt;內文2&lt;/td&gt;      &lt;td&gt;內文3&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;      &lt;td&gt;內文1-2&lt;/td&gt;      &lt;td&gt;內文2-2&lt;/td&gt;      &lt;td&gt;內文1-2&lt;/td&gt;    &lt;/tr&gt;   &lt;/table&gt;\n\n總結:\n\n\n\n\n\n\n\n\n\nth 也是一個儲存格   只不過和普通的 td儲存格不一樣，它會讓自己裡面的文字居中且加粗\n4. 表格標題caption定義和用法\n123&lt;table&gt;   &lt;caption&gt;我是表格標題&lt;/caption&gt;&lt;/table&gt;\n\n**注意： **\n\ncaption 元素定義表格標題，通常這個標題會被居中且顯示於表格之上。\ncaption 標籤必須緊隨 table 標籤之後。\n這個標籤只存在 表格裡面才有意義。\n\n5. 合併儲存格(難點)\n\n\n\n\n\n\n\n\n合併儲存格是我們比較常用的一個操作，但是不會合併的很複雜。\n5.1 合併儲存格2種方式\n跨行合併（上下合併）：rowspan=&quot;合併儲存格的個數&quot;\n跨列合併（左右合併）：colspan=&quot;合併儲存格的個數&quot;\n\n\n\n\n\n\n\n\n\n\n\n跨行：最上側儲存格為目標儲存格，與下側的合併\n跨列：最左側儲存格為目標儲存格，與右側的合併\n\n5.2 合併儲存格順序\n\n\n\n\n\n\n\n\n合併的順序我們按照先上、後下、先左、後右的順序\n跟以前學習漢字的書寫順序完全一致。\n5.3 合併儲存格三步曲\n先確定是跨行還是跨列合併\n根據 先上 後下   先左  後右的原則找到目標儲存格    然後寫上 合併方式=合併的儲存格數量  比如 ： &lt;td colspan=&quot;2&quot;&gt; &lt;/td&gt;\n刪除多餘的儲存格 儲存格\n\n6. 總結表格\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;table&gt;&lt;/table&gt;\n表格標籤\n就是一個四方的盒子\n\n\n&lt;tr&gt;&lt;/tr&gt;\n表格行標籤\n行標籤要再table標籤內部才有意義\n\n\n&lt;td&gt;&lt;/td&gt;\n儲存格標籤\n儲存格標籤是個容器級元素，可以放任何東西\n\n\n&lt;th&gt;&lt;/th&gt;\n表頭儲存格標籤\n它還是一個儲存格，但是裡面的文字會居中且加粗\n\n\n&lt;caption&gt;&lt;/caption&gt;\n表格標題標籤\n表格的標題，跟著表格一起走，和表格居中對齊\n\n\nclospan 和 rowspan\n合併屬性\n用來合併儲存格的\n\n\n\n表格提供了HTML 中定義表格式資料的方法。\n表格中由行中的儲存格組成。\n表格中沒有列元素，列的個數取決於行的儲存格個數。\n表格不要糾結於外觀，那是CSS 的作用。\n表格的學習要求：能手寫表格結構，並且能簡單合併儲存格。\n\n7. 拓展閱讀@表格劃分結構（瞭解）123對於比較複雜的表格，表格的結構也就相對的複雜了，所以又將表格分割成三個部分：題頭、正文和註腳。而這三部分分別用:thead,tbody,tfoot來標注，這樣更好的分清表格結構\n\n注意：\n\n&lt;thead&gt;&lt;/thead&gt;：用於定義表格的頭部。用來放標題之類的東西。&lt;thead&gt; 內部必須擁有 &lt;tr&gt; 標籤！\n&lt;tbody&gt;&lt;/tbody&gt;：用於定義表格的主體。放數據本體 。\n&lt;tfoot&gt;&lt;/tfoot&gt;放表格的註腳之類。\n以上標籤都是放到table標籤中。\n\n123456789101112131415161718192021&lt;table&gt;    &lt;!-- 頭部區域 --&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;            &lt;th&gt;性別&lt;/th&gt;            &lt;th&gt;年齡&lt;/th&gt;          ...      &lt;/tr&gt;    &lt;/thead&gt;    &lt;!-- 主體區域 --&gt;    &lt;tbody&gt;        &lt;tr&gt;            &lt;td&gt;周吉瑞&lt;/td&gt;            &lt;td&gt;男&lt;/td&gt;            &lt;td&gt;18&lt;/td&gt;            ...        &lt;/tr&gt;        ...    &lt;/tbody&gt;&lt;/table&gt;\n\n","slug":"2301-1 Html 04 表格","date":"2023-03-08T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"cbe5237b8ff5a57f8171e301da77c028","title":"HTML常用標籤","content":"學習目標\n理解：\n相對路徑三種形式\n\n\n應用\n排版標籤\n文本格式化標籤\n圖像標籤\n連結\n相對路徑，絕對路徑的使用\n\n\n\n1. HTML常用標籤 首先 HTML和CSS是兩種完全不同的語言，我們學的是結構，就只寫HTML標籤，認識標籤就可以了。 不會再給結構標籤指定樣式了。\n HTML標籤有很多，這裡我們學習最為常用的，後面有些較少用的，我們可以查下手冊就可以了。 \n1.1 排版標籤排版標籤主要和css搭配使用，顯示網頁結構的標籤，是網頁佈局最常用的標籤。\n1）標題標籤h (熟記) 單詞縮寫：  head   頭部. 標題       title  文檔標題\n為了使網頁更具有語義化，我們經常會在頁面中用到標題標籤，HTML提供了6個等級的標題，即\n標題標籤語義：  作為標題使用，並且依據重要性遞減\n其基本語法格式如下：\n123456&lt;h1&gt;   標題文本   &lt;/h1&gt;&lt;h2&gt;   標題文本   &lt;/h2&gt;&lt;h3&gt;   標題文本   &lt;/h3&gt;&lt;h4&gt;   標題文本   &lt;/h4&gt;&lt;h5&gt;   標題文本   &lt;/h5&gt;&lt;h6&gt;   標題文本   &lt;/h6&gt;\n\n小結 :\n\n加了標題的文字會變的加粗，字型大小也會依次變大\n一行是只能放一個標題的\n\n2）段落標籤p ( 熟記)單詞縮寫：  paragraph  段落  [ˈpærəgræf]    無須記這個單詞\n作用語義：\n可以把 HTML 文檔分割為若干段落\n 在網頁中要把文字有條理地顯示出來，離不開段落標籤，就如同我們平常寫文章一樣，整個網頁也可以分為若干個段落，而段落的標籤就是\n1&lt;p&gt;  文本內容  &lt;/p&gt;\n\n是HTML文檔中最常見的標籤，預設情況下，文本在一個段落中會根據流覽器視窗的大小自動換行。\n3）水準線標籤hr(認識)單詞縮寫：  horizontal  橫線    [ˌhɔrəˈzɑntl]    同上\n在網頁中常常看到一些水準線將段落與段落之間隔開，使得文檔結構清晰，層次分明。這些水準線可以通過插入圖片實現，也可以簡單地通過標籤來完成，就是創建橫跨網頁水準線的標籤。其基本語法格式如下：\n1&lt;hr /&gt;是單標籤\n\n 在網頁中顯示預設樣式的水準線。\n4）換行標籤br (熟記)單詞縮寫：  break   打斷 ,換行\n在HTML中，一個段落中的文字會從左到右依次排列，直到流覽器視窗的右端，然後自動換行。如果希望某段文本強制換行顯示，就需要使用換行標籤\n1&lt;br /&gt;\n\n5）div 和  span標籤(重點)div、span是沒有語義的，是我們網頁佈局主要的2個盒子css+div\ndiv 就是division  的縮寫，分割、分區的意思span就是跨度、跨距；範圍    \n語法格式：\n1&lt;div&gt; 這是頭部 &lt;/div&gt;    &lt;span&gt;今日價格&lt;/span&gt;\n\n他們兩個都是盒子，用來裝我們網頁元素的， 只不過他們有區別，現在我們主要記住使用方法和特點就好了\n\ndiv標籤  用來佈局的，但是現在一行只能放一個div\nspan標籤  用來佈局的，一行上可以放好多個span\n\n排版標籤總結\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;hx&gt;&lt;/hx&gt;\n標題標籤\n作為標題使用，並且依據重要性遞減\n\n\n&lt;p&gt;&lt;/p&gt;\n段落標籤\n可以把 HTML 文檔分割為若干段落\n\n\n&lt;hr /&gt;\n水準線標籤\n沒啥可說的，就是一條線\n\n\n&lt;br /&gt;\n換行標籤\n\n\n\n&lt;div&gt;&lt;/div&gt;\ndiv標籤\n用來佈局的，但是現在一行只能放一個div\n\n\n&lt;span&gt;&lt;/span&gt;\nspan標籤\n用來佈局的，一行上可以放好多個span\n\n\n1.2 文本格式化標籤(熟記)在網頁中，有時需要為文字設置粗體、斜體或底線效果，這時就需要用到HTML中的文本格式化標籤，使文字以特殊的方式顯示。\n區別：\n b  只是加粗 strong  除了可以加粗還有 強調的意思，  語義更強烈。\n1.3 標籤屬性所謂屬性就是外在特性  比如 手機的顏色 手機的尺寸 ，總結就是手機的。。\n\n手機的顏色是黑色   \n手機的尺寸是 8寸 \n水準線的長度是 200  \n圖片的寬度 是  300\n\n使用HTML製作網頁時，如果想讓HTML標籤提供更多的資訊，可以使用HTML標籤的屬性加以設置。其基本語法格式如下：\n12&lt;標籤名 屬性1=&quot;屬性值1&quot; 屬性2=&quot;屬性值2&quot; …&gt; 內容 &lt;/標籤名&gt;&lt;手機 顏色=&quot;紅色&quot; 大小=&quot;5寸&quot;&gt;  &lt;/手機&gt;\n\n1.4 圖像標籤img (重點)單詞縮寫：   image  圖像\n要想在網頁中顯示圖像就需要使用圖像標籤，接下來將詳細介紹圖像標籤以及和他相關的屬性。（它是一個單身狗）\n語法如下：\n1&lt;img src=&quot;圖像URL&quot; /&gt;\n\n該語法中src屬性用於指定影像檔的路徑和檔案名，他是img標籤的必需屬性。\nborder 後面我們會用css來做，這裡童鞋們就記住這個border 單詞就好了\n**注意: **\n\n標籤可以擁有多個屬性，必須寫在開始標籤中，位於標籤名後面。\n屬性之間不分先後順序，標籤名與屬性、屬性與屬性之間均以空格分開。\n採取  鍵值對 的格式   key&#x3D;”value”  的格式\n\n比如:  \n12345678正常的&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; /&gt;帶有邊框的&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; /&gt;有提示文本的&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; title=&quot;這是文字&quot; /&gt;有替換文本的&lt;img src=&quot;cz.jpg&quot; width=&quot;300&quot; height=&quot;300&quot; border=&quot;3&quot; alt=&quot;圖片不存在&quot; /&gt;\n\n1.5 連結標籤(重點)單詞縮寫：  anchor 的縮寫  [ˈæŋkə(r)] 。基本解釋 錨, 鐵錨 的\n在HTML中創建超連結非常簡單，只需用標籤把文字包括起來就好。\n語法格式：\n1&lt;a href=&quot;跳轉目標&quot; target=&quot;目標視窗的彈出方式&quot;&gt;文本或圖像&lt;/a&gt;\n\n\n\n\n屬性\n作用\n\n\n\nhref\n用於指定連結目標的url位址，（必須屬性）當為標籤應用href屬性時，它就具有了超連結的功能\n\n\ntarget\n用於指定連結頁面的打開方式，其取值有_self和_blank兩種，其中_self為預設值，__blank為在新視窗中打開方式。\n\n\n注意：\n\n外部連結 需要添加 http:&#x2F;&#x2F; www.google.com\n內部連結 直接連結內部頁面名稱即可 比如 &lt; a href&#x3D;”index.html”&gt; 首頁 \n如果當時沒有確定連結目標時，通常將連結標籤的href屬性值定義為 “#”(即href&#x3D;”#”)，表示該連結暫時為一個空連結。\n不僅可以創建文本超連結，在網頁中各種網頁元素，如圖像、表格、音訊、視頻等都可以添加超連結。\n\n1.6 注釋標籤在HTML中還有一種特殊的標籤——注釋標籤。如果需要在HTML文檔中添加一些便於閱讀和理解但又不需要顯示在頁面中的注釋文字，就需要使用注釋標籤。\n簡單解釋：\n注釋內容不會顯示在流覽器視窗中，但是作為HTML文檔內容的一部分，也會被下載到使用者的電腦上，查看原始程式碼時就可以看到。\n語法格式：\n12&lt;!-- 注釋語句 --&gt;快速鍵是：ctrl + / 或者 ctrl +shift + / \n\n\n\n\n\n\n\n\n\n\n注釋是給人看的，目的是為了更好的解釋這部分代碼是幹啥的， 程式是不執行這個代碼的\n團隊約定一般用於簡單的描述，如某些狀態描述、屬性描述等\n注釋內容前後各一個空格字元，注釋位於要注釋代碼的上面，單獨占一行\n推薦：\n12&lt;!-- Comment Text --&gt;&lt;div&gt;...&lt;/div&gt;\n\n不推薦：\n12345&lt;div&gt;...&lt;/div&gt;&lt;!-- Comment Text --&gt;   &lt;div&gt;&lt;!-- Comment Text --&gt;    ...&lt;/div&gt;\n\n2. 路徑(重點、難點)實際工作中，檔案不能隨便亂放，否則用起來很難快速的找到他們，因此需要一個資料夾來管理他們。\n目錄資料夾\n就是普通資料夾，裡面只不過存放了我們做頁面所需要的 相關素材，比如 html檔， 圖片 等等。\n根目錄  \n打開目錄資料夾的第一層  就是 根目錄 \n\n\n\n\n\n\n\n\n\n頁面中的圖片會非常多， 通常我們再新建一個資料夾專門用於存放影像檔（images），這時再插入圖像，就需要採用 “路徑” 的方式來指定影像檔的位置。路徑可以分為： 相對路徑和絕對路徑\n相對路徑以引用文件之網頁所在位置為參考基礎，而建立出的目錄路徑。因此，當保存於不同目錄的網頁引用同一個檔時，所使用的路徑將不相同，故稱之為相對路徑。\n\n\n\n路徑分類\n符號\n說明\n\n\n\n同一級路徑\n\n只需輸入影像檔的名稱即可，如&lt;img src&#x3D;”photo.gif” &#x2F;&gt;。\n\n\n下一級路徑\n“&#x2F;”\n影像檔位元於HTML檔同級資料夾下（例如資料夾名稱為：images）                         如&lt;img src&#x3D;”images&#x2F;photo.gif” &#x2F;&gt;。\n\n\n上一級路徑\n“..&#x2F;”\n在檔案名之前加入“..&#x2F;” ，如果是上兩級，則需要使用 “..&#x2F; ..&#x2F;”，以此類推，                    如&lt;img src&#x3D;”..&#x2F;photo.gif” &#x2F;&gt;。\n\n\n**結論： **\n\n\n\n\n\n\n\n\n\n相對路徑，是從代碼所在的這個檔出發， 去尋找我們的目的檔案的，而 我們所說的 上一級 下一級 同一級  簡單說，就是 圖片 位於 HTML 頁面的位置\n絕對路徑絕對路徑以Web網站根目錄為參考基礎的目錄路徑。之所以稱為絕對，意指當所有網頁引用同一個檔時，所使用的路徑都是一樣的。\n“D:\\web\\img\\logo.gif”，或完整的網路位址，例如“http://www.photo.com/images/logo.gif”。\n注意：\n絕對路徑用的較少，我們理解下就可以了。  但是要注意，它的寫法 特別是符號  \\  並不是 相對路徑的   /    \n3. @拓展閱讀3.1 錨點定位 （難點）通過創建錨點連結，使用者能夠快速定位到目標內容。\n創建錨點連結分為兩步：\n123451. 使用相應的id名標注跳轉目標的位置。 (找目標)  &lt;h3 id=&quot;two&quot;&gt;第2集&lt;/h3&gt; 2. 使用&lt;a href=&quot;#id名&quot;&gt;連結文本&lt;/a&gt;創建連結文本（被點擊的） （拉關係）  我也有一個姓畢的姥爺..  &lt;a href=&quot;#two&quot;&gt;   \n\n\n\n\n\n\n\n\n\n\n好比找個人辦事，  首先找到他，然後拉關係，最後看效果。\n3.2 base 標籤語法：\n1&lt;base target=&quot;_blank&quot; /&gt;\n\n**總結： **\n\nbase 可以設置整體連結的打開狀態   \nbase 寫到      之間\n把所有的連接 都默認添加 target&#x3D;”_blank”\n\n總結：\n\n\n\n\n\n\n\n\n\n全體連結~ 到 ~  全體集合  所有連結 以新視窗打開頁面  ~   是 \n3.3 預格式化文字pre標籤&lt;pre&gt; 標籤可定義預格式化的文本。\n被包圍在 &lt;pre&gt; 標籤 元素中的文本通常會保留空格和分行符號。而文本也會呈現為等寬字體。\n123456&lt;pre&gt;  此例演示如何使用 pre 標籤    對空行和 空格      進行控制&lt;/pre&gt;\n\n總結：\n\n\n\n\n\n\n\n\n\n所謂的預格式化文字就是 ，按照我們預先寫好的文字格式來顯示頁面， 保留空格和換行等。 \n有了這個標籤，裡面的文字，會按照我們書寫的模式顯示，不需要段落和換行標籤了。但是，比較少用，因為不好整體控制。\n","slug":"2301-1 Html 03 常用標籤","date":"2023-03-07T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"76dff37ffad444f9899a2462f98081d7","title":"Html認識HTML","content":"學習目標\n理解\nHTML的概念\nHTML標籤的分類\nHTML標籤的關係\nHTML標籤的語義化\n\n\n應用\nHTML骨架格式\nsublime基本使用\n\n\n\n1. HTML 初識\nHTML 指的是超文字標記語言 (Hyper Text Markup Language)是用來描述網頁的一種語言。\nHTML 不是一種程式設計語言，而是一種標記語言 (markup language)\n標記語言是一套標記標籤 (markup tag)\n\nhtml作用:\n\n\n\n\n\n\n\n\n\n網頁是由網頁元素組成的 ， 這些元素是利用html標籤描述出來，然後通過流覽器解析，就可以顯示給使用者了。\n所謂超文字，有2層含義： \n\n因為它可以加入圖片、聲音、動畫、多媒體等內容（**超越文本限制 **）\n不僅如此，它還可以從一個檔跳轉到另一個檔，與世界各地主機的檔連接（**超級連結文本 **）。\n\n1&lt;img src=&quot;timg.jpg&quot; /&gt;\n\nhtml 總結:\n\nhtml 是超文字標記(標籤)語言\n學習html 主要學習html標籤\n我們用html標籤描述網頁元素。 比如 圖片標籤 、文字標籤、連結標籤等等\n標籤有自己的語法規範，所有的html標籤都是用 &lt;&gt; 表示的\n\n1.1 HTML骨架標籤日常生活的書信，我們要遵循共同的約定。 \n同理：HTML 有自己的語言語法骨架格式：（要遵循，要專業） 要求務必非常流暢的默寫下來。。\n1234567&lt;html&gt;       &lt;head&gt;             &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;&lt;/html&gt;\nhtml骨架標籤總結\n\n\n標籤名\n定義\n說明\n\n\n\n&lt;html&gt;&lt;/html&gt;\nHTML標籤\n頁面中最大的標籤，我們成為  根標籤\n\n\n&lt;head&gt;&lt;/head&gt;\n文檔的頭部\n注意在head標籤中我們必須要設置的標籤是title\n\n\n&lt;titile&gt;&lt;/title&gt;\n文檔的標題\n讓頁面擁有一個屬於自己的網頁標題\n\n\n&lt;body&gt;&lt;/body&gt;\n文檔的主體\n元素包含文檔的所有內容，頁面內容 基本都是放到body裡面的\n\n\n團隊約定大小寫HTML標籤名、類名、標籤屬性和大部分屬性值統一用小寫\n推薦：\n123&lt;head&gt;             &lt;title&gt;我的第一個頁面&lt;/title&gt; &lt;/head&gt;\n\n不推薦：\n123&lt;HEAD&gt;             &lt;TITLE&gt;我的第一個頁面&lt;/TITLE&gt;&lt;/HEAD&gt;\n\n1.2 HTML元素標籤分類標籤：\n在HTML頁面中，帶有“&lt; &gt;”符號的元素被稱為HTML標籤，如上面提到的 &lt;html&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架結構標籤。\n分類：\n\n常規元素（雙標籤）\n\n1&lt;標籤名&gt; 內容 &lt;/標籤名&gt;   比如 &lt;body&gt;  我是文字  &lt;/body&gt;\n\n\n該語法中\n“&lt;標籤名&gt;”表示該標籤的作用開始，一般稱為“開始標籤（start tag）”\n“&lt;&#x2F;標籤名&gt;” 表示該標籤的作用結束，一般稱為“結束標籤（end tag）”\n\n\n和開始標籤相比，結束標籤只是在前面加了一個關閉符“&#x2F;”\n以後接觸的基本都是雙標籤\n\n\n空元素（單標籤）\n\n1&lt;標籤名 /&gt;  比如  &lt;br /&gt;\n\n\n空元素 用單標籤來表示， 簡單點說，就是裡面不需要包含內容， 只有一個開始標籤不需要關閉。\n這種單身狗標籤非常少，一共沒多少，我們多記憶就好\n\n聯想概括：\n\n\n\n\n\n\n\n\n\n世界上單身狗畢竟是少數的， 大部分還是喜歡成雙成對，不要拉下你的另外一半，對待一個雙標籤要有始有終。\n1.3 HTML標籤關係主要針對於雙標籤 的相互關係分為兩種：  請大家務必熟悉記住這種標籤關係，因為後面我們標籤嵌套特別多，很容易弄混他們的關係。\n\n嵌套關係\n\n123&lt;head&gt;    &lt;title&gt; &lt;/title&gt; &lt;/head&gt;\n\n2.並列關係\n12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;\n\n倡議： \n\n\n\n\n\n\n\n\n\n123如果兩個標籤之間的關係是嵌套關係，子元素最好縮進一個tab鍵的身位（一個tab是4個空格）。如果是並列關係，最好上下對齊。\n聯想概括：\n\n\n\n\n\n\n\n\n\nhtml雙標籤 可以分為一種是 父子級 包含關係的標籤一種是 兄弟級 並列關係的標籤\n2. 文檔類型&lt;!DOCTYPE&gt;用法：\n12&lt;!-- 當前頁面採用 HTML5 版本 --&gt;&lt;!DOCTYPE html&gt; \n\n作用：\n 聲明位於文檔中的最前面的位置，處於  標籤之前。此標籤可告知流覽器文檔使用哪種 HTML 或 XHTML 規範。\n&lt;!DOCTYPE html&gt;  就是告訴流覽器按照HTML5 規範解析頁面\n注意：\n\n&lt;!doctype&gt; 聲明位於文檔最前面的位置，處於 &lt;html&gt; 標籤之前\n&lt;!doctype&gt; 文檔型別宣告標籤，不屬於 HTML 標籤\n請默認統一指定 HTML5 版本 &lt;!doctype html&gt;\n\n3. 頁面語言lang1&lt;html lang=&quot;zh-TW&quot;&gt;  指定html 語言種類\n\n最常見的2個：\n\nen 定義語言為英語\nzh-TW 定義語言為繁體中文\n\n簡單來說：定義為 en 就是面向英文用戶的網頁，定義為 zh-TW 就是面向臺灣用戶的網頁。\n\n\n\n\n\n\n\n\n\nen-GB 英文（英國）\nen-US 英文（美國）\nzh-CN 中文（簡體，中國大陸）\nzh-SG 中文（簡體，新加坡）\nzh-HK 中文（繁體，香港）\nzh-MO 中文（繁體，澳門）\nzh-TW 中文（繁體，臺灣）\n12&lt;html lang=&quot;zh-CN&quot;&gt; &lt;/html&gt;\n\n\n\n\n\n\n\n\n\n\n語言的設置是為了方便 流覽器搜索推薦 以及觸發 流覽器翻譯功能，並不是說設置了某類主語言後網頁中就不能存在其他類型的語言了。\n團隊約定：\n\n\n\n\n\n\n\n\n\n1考慮流覽器和作業系統的相容性，目前仍然使用 zh-TW 屬性值\n@拓展閱讀：\n簡單來說，可能對於程式來說沒有太大的作用，但是它可以告訴流覽器，搜尋引擎，一些處理Html的程式對頁面語言內容來做一些對應的處理或者事情。比如可以\n\n根據根據lang屬性來設定不同語言的css樣式，或者字體\n告訴搜尋引擎做精確的識別\n讓語法檢查程式做語言識別\n幫助翻譯工具做識別\n説明網頁閱讀程式做識別\n\n4.字元編碼所有的資料在電腦中存儲時都是以二進位形式存儲的，文字也不例外。\n所以一段文字在存儲到記憶體中時，都需要轉換為二進位編碼當我們讀取這段文字時，電腦會將編碼轉換為字元，供我們閱讀\n4.1 編碼將字元轉換為二進位碼的過程稱為編碼\n4.2 解碼將二進位碼轉換為字元的過程稱為解碼\n4.3 字元集（charset）編碼和解碼所採用的規則稱為字元集（相當於密碼本）\n4.4 亂碼如果編碼和解碼所採用的字元集不同就會出現亂碼問題。\n可以通過meta標籤來設置網頁的字元集，避免亂碼問題\n1&lt;meta charset=&quot;utf-8&quot;&gt;\n\n5.字元集字元集：多個字元的集合，以便電腦能夠識別和儲存各種文字。\n5.1 ASCIIASCII(American Standard Code for Information Interchange)：美國資訊交換標準代碼\n在所有字元集中，最知名的可能要數被稱為ASCII的8位元字元了。美國資訊交換標準代碼是由美國國家標準學會(American National Standard Institute , ANSI )制定的，是一種標準的單字節字元編碼方案，用於基於文本的資料。它最初是美國國家標準，供不同電腦在相互通信時用作共同遵守的西文字元編碼標準，後來它被國際標準組織（International Organization for Standardization, ISO）定為國際標準，稱為ISO 646標準。適用於所有拉丁文字字母\nASCII 碼使用指定的7 位或8 位元二進位數字組合來表示128 或256 種可能的字元。標準ASCII 碼也叫基礎ASCII碼，使用7 位二進位數字（剩下的1位元二進位為0）來表示所有的大寫和小寫字母，數位0 到9、標點符號，以及在美式英語中使用的特殊控制字元\nASCII碼表：Ascii Table - ASCII character codes and html, octal, hex and decimal chart conversion\n5.2 ISO-8859-1ISO-8859-1編碼是單字節編碼，向下相容ASCII，其編碼範圍是0x00-0xFF，0x00-0x7F之間完全和ASCII一致，0x80-0x9F之間是控制字元，0xA0-0xFF之間是文字符號。\nISO碼表：HTML ISO-8859-1 參考手冊\n5.3 GB2312GB2312（資訊交換用漢字編碼字元集）是由中國國家標準總局1980年發佈。基本集共收入漢字6763個和非漢字圖形字元682個。GB 2312的出現，基本滿足了漢字的電腦處理需要，它所收錄的漢字已經覆蓋中國大陸99.75%的使用頻率。\n5.4 GBKGBK（即“國標”、“擴展”中文拼音的第一個字母），漢字編碼字元集。2000年已被GB18030-2000國家強制標準替代。 2005年GB18030-2005發佈，替代了GB18030-2000。\nGBK使用了雙位元組編碼方案，其編碼範圍從8140至FEFE（剔除xx7F），共23940個碼位，共收錄了21003個漢字，完全相容GB2312-80標準，支持國際標準ISO&#x2F;IEC10646-1和國家標準GB13000-1中的全部中日韓漢字，並包含了BIG5編碼中的所有漢字。\n5.5 Big5Big5，又稱為大五碼或五大碼，是使用繁體中文（正體中文）社區中最常用的電腦中文字元集標準，共收錄13,060個漢字。\nBig5雖普及於臺灣、香港與澳門等繁體中文通行區，但長期以來並非當地的國家&#x2F;地區標準或官方標準，而只是業界標準。倚天中文系統、Windows繁體中文版等主要系統的字元集都是以Big5為基準，但廠商又各自增加不同的造字與造字區，派生成多種不同版本。\n5.6 UTF-8UTF-8（8位元，Universal Character Set&#x2F;Unicode Transformation Format）是針對Unicode的一種可變長度字元編碼，也叫萬國碼、統一碼。它可以用來表示Unicode標準中的任何字元，而且其編碼中的第一個位元組仍與ASCII相容，使得原來處理ASCII字元的軟體無須或只進行少部分修改後，便可繼續使用。\n5.7 UTF-16UTF-16是Unicode的其中一個使用方式。UTF-16比起UTF-8，好處在於大部分字元都以固定長度的位元組（2位元組）儲存，但UTF-16卻無法相容於ASCII編碼。\n5.8 UnicodeUnicode只是一組字元設定或者說是從數位和字元之間的邏輯映射的概念編碼，但是它並沒有指定代碼點如何在電腦上存儲。UCS4、UTF-8、UTF-16（UTF後的數位代表編碼的最小單位，如UTF-8表示最小單位1位元組，所以它可以使用1、2、3位元組等進行編碼，UTF-16表示最小單位2位元組，所以它可以使用2、4位元組進行編碼）都是Unicode的編碼方案。UTF-8因可以相容ASCII而被廣泛使用。\n如果把各種文字編碼形容為各地的方言，那麼Unicode就是世界各國合作開發的一種語言。\n5.9 字元集使用在 &lt;head&gt; 標籤內，可以通過 &lt;meta&gt; 標籤的 charset 屬性來規定 HTML 文檔應該使用哪種字元編碼。\n1&lt;meta charset=&quot;UTF-8&quot;&gt;\n\ncharset 常用的值有：GB2312、BIG5、GBK、UTF-8，其中 UTF-8 也被稱為：萬國碼，基本包含了全世界所有國家需要用到的字元。\n團隊約定：\n\n\n\n\n\n\n\n\n\n1234字元設置是必須的一般情況下統一使用 &quot;UTF-8&quot; 編碼，請儘量統一寫成標準的 &quot;UTF-8&quot;，不要寫成 &quot;utf-8&quot; 或 &quot;utf8&quot; 或 &quot;UTF8&quot;。\n標準骨架：\n123456789101112&lt;!doctype html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;\n\n\n6. HTML標籤的語義化白話： 所謂標籤語義化，就是指標籤的含義。\n結論:\n\n\n\n\n\n\n\n\n\n根據標籤的語義，在合適的地方給一個最為合理的標籤，讓結構更清晰。\n\n方便代碼的閱讀和維護\n同時讓流覽器或是網路爬蟲可以很好地解析，從而更好分析其中的內容 \n使用語義化標籤會具有更好地搜尋引擎優化\n\n語義是否良好： 當去掉CSS之後，網頁結構依然組織有序，並且有良好的可讀性。\n遵循的原則：先確定語義的HTML ，再選合適的CSS。所以，接下來學習html標籤，要根據語義去記憶。 HTML網頁中任何元素的實現都要依靠HTML標籤。\n","slug":"2301-1 Html 02 認識Html","date":"2023-03-06T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"ea9f8724503553e7e983e98765f0c811","title":"Html認識WEB","content":"1. 認識網頁12網頁主要由文字、圖像和超連結等元素構成。當然，除了這些元素，網頁中還可以包含音訊、視頻以及Flash等。\n\n總結網頁有圖片、連結、文字等元素組成，就是要把這部分網頁元素用代碼寫出來，通常是 HTML 格式的檔（.htm 或 .html）必須通過流覽器來閱讀。\n2. 瀏覽器（顯示代碼）12瀏覽器是網頁顯示、運行的平臺，常用的五大瀏覽器有IE、火狐（Firefox）、google（Chrome）、Safari和Opera等。\n\n2.1 常見瀏覽器內核（瞭解）首先解釋一下瀏覽器內核是什麼東西。英文叫做：Rendering Engine，中文翻譯很多，排版引擎、解釋引擎、渲染引擎，現在流行稱為瀏覽器內核.\n1負責讀取網頁內容，整理訊息，計算網頁的顯示方式並顯示頁面.\n因為瀏覽器太多啦， 但是現在主要流行的就是下面幾個：\n\n\n\n瀏覽器\n內核\n備註\n\n\n\nGoogle Chrome\nBlink\n由Google開發，市佔率最高的瀏覽器之一，支援廣泛的瀏覽器外掛程式及擴充功能。\n\n\nMicrosoft Edge\nBlink\n由Microsoft開發，支援跨平臺使用，與Windows 10系統整合，支援多種瀏覽模式。\n\n\nApple Safari\nWebKit\n由Apple開發，預設瀏覽器於iOS及macOS系統中，內建多項輔助功能。\n\n\nMozilla Firefox\nGecko\n由Mozilla基金會開發，強調開放源碼及隱私保護，支援豐富的擴充功能。\n\n\nOpera\nBlink\n由Opera Software開發，提供許多獨特的功能如：內建VPN、廣告封鎖等。\n\n\n拓展閱讀：\n123456在 Android 手機中，除了 WebKit 內核之外，還有其他的內核選擇，例如 Google 開發的 Chrome 內核、Opera 開發的 Presto 內核以及穀歌為 Android 手機推出的 Blink 內核。目前 iOS 中的內置瀏覽器內核主要是基於 WebKit 開發的，但是它與 Android 上的 WebKit 並不完全相同，因為 Apple 在 WebKit 基礎上進行了大量的修改和優化。同時，Safari 在 iOS 和 macOS 上也是使用相同的內核。\n\n3. Web標準（重點）目標\n\n記憶\n網頁中 web 標準三層組成\n\n\n理解\n結合人來表述web標準三層\n\n\n\n拓展閱讀：\n\nWeb標準不是某一個標準，而是由W3C組織和其他標準化組織制定的一系列標準的集合。\nW3C 是一個非營利的國際組織，成立於1994年，其全稱為World Wide Web Consortium（萬維網聯盟）\nW3C 旨在開發萬維網相關技術的標準，進而促進網際網路的發展和普及。該組織負責管理並維護 HTML、CSS、XML 等網頁技術的標準，並制定其他網路技術的標準。\nW3C 發佈的標準僅是建議性的，並不是強制性的法規或規範。\n然而，許多互聯網技術和產品都基於 W3C 的標準來實現。\n\n3.1 為什麼要遵循WEB標準呢？ 通過以上瀏覽器不同內核不同，其顯示頁面或者排版就有些許差異。\n3.2 Web 標準的好處遵循web標準可以讓不同我們寫的頁面更標準更統一外，還有許多優點\n1、讓Web的發展前景更廣闊2、內容能被更廣泛的設備訪問3、更容易被搜尋引擎搜索4、降低網站流量費用5、使網站更易於維護6、提高頁面流覽速度\n3.3 Web 標準構成構成： 主要包括結構（Structure）、表現（Presentation）和行為（Behavior）三個方面。\n\n\n\n標準\n說明\n備註\n\n\n\n結構\n結構用於對網頁元素進行整理和分類\nHTML。\n\n\n表現\n表現用於設置網頁元素的版式、顏色、大小等外觀樣式\nCSS\n\n\n行為\n行為是指網頁模型的定義及交互的編寫\nJavascript\n\n\n 理想狀態我們的源碼： .HTML      .css      .js \n\nweb標準小結\nweb標準有三層結構，分別是結構（html）、表現（css）和行為（javascript）  \n結構類似人的身體， 表現類似人的著裝， 行為類似人的行為動作\n理想狀態下，他們三層都是獨立的， 放到不同的檔裡面\n\n4. 拓展@\n介紹一下你對瀏覽器內核的理解？\n\n\n\n\n\n\n\n\n\n瀏覽器內核包括兩部分，渲染引擎和js引擎。\n渲染引擎負責讀取網頁內容，整理訊息，計算網頁的顯示方式並顯示頁面\njs引擎是解析執行js獲取網頁的動態效果。 \n後來 JS 引擎越來越獨立，內核就傾向於只指渲染引擎。\n\n\n\n5.HTML語法規範5.1 基本語法概述HTML 標籤是由尖括弧包圍的關鍵字詞，例如：&lt;html&gt;。\nHTML 標籤通常是成對出現的，例如：&lt;html&gt; 和 &lt;/html&gt;，我們稱為雙標籤。標籤對中的第一個標籤是開始標籤，第二個標籤是結束標籤。\n有些特殊的標籤必須是單個標籤，例如：&lt;br /&gt;，我們稱為單標籤。注意：/ 之前有一個空格（Coding Style 編碼風格）。每個標籤原則上都應該有結束符，即： /。所以單標籤的最後要加 / 以表示結束，當然不加也是可以被流覽器正常解析的。\n\n\n\n\n\n\n\n\n\nHTML5 規範中明確說明單標籤 / 是可以忽略的，實際開發中建議不要給單標籤添加斜線。\n\n\n\n\n\n\n\n\n\n任何標籤都建議不要大寫，即便是 &lt;!doctype html&gt; 標籤。\n5.2 標籤關係\n包含關係\n\n123&lt;head&gt;    &lt;title&gt;&lt;/title&gt;&lt;/head&gt;\n\n\n並列關係\n\n1234&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;/body&gt;\n\n6.HTML5的基本結構1234567891011121314151617&lt;!-- 文檔聲明，聲明當前網頁的版本 --&gt;&lt;!doctype html&gt;&lt;!-- html的根標籤（元素），網頁中的所有內容都要寫根項目的裡邊 --&gt;&lt;html&gt;    &lt;!-- head是網頁的頭部，head中的內容不會在網頁中直接出現，主要用來幫助流覽器或搜尋引擎來解析網頁 --&gt;    &lt;head&gt;        &lt;!-- meta標籤用來設置網頁的中繼資料，這裡meta用來設置網頁的字元集，避免亂碼問題 --&gt;        &lt;meta charset=&quot;utf-8&quot;&gt;        &lt;!-- title中的內容會顯示在流覽器的標題列，搜尋引擎會主要根據title中的內容來判斷網頁的主要內容 --&gt;        &lt;title&gt;網頁的標題&lt;/title&gt;    &lt;/head&gt;    &lt;!-- body是htm1的子元素，表示網頁的主體，網頁中所有的可見內容都應該寫在body裡 --&gt;    &lt;body&gt;        &lt;!-- h1網頁的一級標題 --&gt;        &lt;h1&gt;網頁的大標題&lt;/h1&gt;    &lt;/body&gt;&lt;/html&gt;\n\n&lt;!doctype html&gt;文檔聲明用來標識當前頁面的html的版本該聲明用來告訴流覽器，當前的頁面是使用HTML5的標準編寫的&lt;html&gt;網頁的根標籤一個頁面中有且只有一個根標籤網頁中的所有內容都需要寫在html標籤的內部  \n&lt;head&gt;網頁的頭部  \n該標籤中的內容不會在網頁中直接顯示該標籤用於説明流覽器解析頁面子標籤&lt;title&gt;用來設置網頁的標題預設會在流覽器的標題列中顯示搜尋引擎檢索網頁時，會主要檢索title中的內容，它會影響到頁面在搜尋引擎中的排名&lt;meta&gt;用來設置網頁的中繼資料，比如網頁使用的字元集&lt;meta charset=&quot;utf-8&quot; /&gt;設置網頁的關鍵字&lt;meta name=&quot;keywords&quot; content=&quot;關鍵字,關鍵字,關鍵字,關鍵字&quot;/&gt;設置網頁的描述&lt;meta name=&quot;description&quot; content=&quot;網頁的描述&quot;/&gt;請求的重定向&lt;meta http-equiv=&quot;refresh&quot; content=&quot;秒數;url=地址&quot;  /&gt;  \n","slug":"2301-1 Html 01 前言及標準","date":"2023-03-05T02:31:01.000Z","categories_index":"HTML","tags_index":"HTML","author_index":"Hsu's Blog"},{"id":"71434f06eb628cf7a92f4f3d96cc0406","title":"前端之路","content":"歡迎來到 Hexo！這是您的第一篇文章。查看文件以取得更多資訊。如果您在使用Hexo 時遇到任何問題，可以在疑難排解中找到答案，也可以在GitHub上向我提問&#x2F;hexojs&#x2F;hexo&#x2F;issues）。\n快速入門ctrl+shift+r\n建立新文章1$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\n啟動伺服器1$ hexo server\n\nMore info: Server\n產生靜態檔案1$ hexo generate\n\nMore info: Generating\n部署到遠端網站1$ hexo deploy\n\nMore info: Deployment\n","slug":"2300 hello-world","date":"2022-12-31T16:00:00.000Z","categories_index":"Hexo","tags_index":"Hexo","author_index":"Hsu's Blog"}]